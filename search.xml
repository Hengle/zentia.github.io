<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[nginx]]></title>
    <url>%2F2019%2F03%2F15%2Fnginx%2F</url>
    <content type="text"><![CDATA[启动 /usr/sbin/nginx -c /etc/nginx/nginx.conf]]></content>
  </entry>
  <entry>
    <title><![CDATA[IL2CPP]]></title>
    <url>%2F2019%2F03%2F13%2FL2CPP%2F</url>
    <content type="text"><![CDATA[什么是IL2CPP从技术层面上来说，IL2CPP包含两个部分：一个进行预先编译（ahead-of-time，又叫AOT）的编译器；一个支持虚拟机的运行时库。 AOT编译器IL2CPP AOT编译器实际的执行文件是il2cpp.ext。在Windows平台你可以在Unity安装路径的Editor\Data\il2cpp目录下找到。il2cpp.exe这个工具是一个托管代码可执行文件，其完全由C#编码。在开发IL2CPP的过程中，我们同时使用.NET和Mono编译器对其进行编译。 il2cpp接受来自Unity自带的或者由Mono编译器产生的托管程序集，将这些程序集转换成C++代码。这些转化出的C++代码最终由部署目标平台的C++编译器进行编译。 你可以参照下图理解IL2CPP工具链的作用： 运行时库IL2CPP的另外一个部分就是对虚拟机提供支持的运行时库。我们基本上是用C++代码来实现整个运行时库的（其实里面还是有一些和平台相关的代码使用了程序集）。我们把运行时库称之为libli2cpp，它是作为一个静态库被连接到最终的游戏可行性文件中。这么做的一个主要的好处是可以使得整个IL2CPP技术是简单并且是可移植的。 AOT编译器将由.Net输出的中间语言IL代码生成C++代码。运行时库则提供诸如垃圾回收，与平台无关的线程，IO以及内部调用（C++原生代码直接访问托管代码结构）这样的服务层和抽象层。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图形学]]></title>
    <url>%2F2019%2F03%2F13%2Fgraphics%2F</url>
    <content type="text"><![CDATA[向量积模长：（在这里$\theta$表示两向量之间的夹角（共起点的前提下）（$0^。\le \theta \le 180^。$），它位于这两个矢量所定义的平面上。） $|\vec a \times \vec b| = |\vec a| \cdot |\vec b| \cdot sin\theta$ 方向：a向量与b向量的向量积的方向与这两个向量所在平面垂直，且遵守右手定则。（一个简单的确定满足“右手定则”的结果向量的方向的方法是这样的：若坐标系是满足右手定则的，当右手的四指从a以不超过180度的转角转向b时，竖起的大拇指指向的方向就是c的方向。） 复数把刑辱z=a+bi（a，b均为实数）的数成为复数，其中a称为实部，b称为虚部，i称为虚数单位。当虚部等于零时，这个复数可以视为实数；当z的虚部不等于零时，实部等于零时，常称z为纯虚数。 数集扩展到实数范围内，仍有些运算无法进行（比如对复数开偶数次方），为了使方程有解，我们将数集再次扩充。在实数域上定义二元有序对z=(a,b)，并规定有序对之间有运算”+”、”x”(记$z_{1}=(a,b),z){2}=(c,d)$):$z_{1}+z_{2}=(a+c,b+d)$$z_{1} \times z_{2}=(ac-db,bc+ad)$ 四元数四元数是简单的超复数。复数是由实数加上虚数单位i组成，其中i^2=-1。相似地，四元数都是由实数加上三个虚数单位i、j、k组成，而且它们有如下的关系：i^2=j^2=k^2=-1，i^0=j^0=k^0=1，每个四元数都是1、i、j和k的线性组合，既是四元数一般可表示为a+bi+cj+dk，其中a、b、c、d是实数。]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Light Reflect]]></title>
    <url>%2F2019%2F03%2F12%2FLight-Reflect%2F</url>
    <content type="text"><![CDATA[假设我们有一个发着光的太阳，太阳底下有一个“理想镜面”，如下图：这时候我们抽象成数学图来进行计算，如下图：这幅图可以看出，我们计算反射光线OB，则转换成了计算OP，这里OP是AO在法向量N上的投影，接下来我们推导投影向量的计算，如下图：我们根据点积计算出$cos\theta$，然后通过$OA’ = |OA| \cdot cos\theta \cdot n$(n是单位法向量)就能得到，向量的投影公式。这个时候我们在回过头来推导$OB = AO + 2OP$的结果，如下图：]]></content>
      <categories>
        <category>Unity Shader</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shader用到的三角函数]]></title>
    <url>%2F2019%2F03%2F09%2Ftrigonometric-function%2F</url>
    <content type="text"><![CDATA[正弦、余弦、正切 正弦、余弦曲线 正弦曲线公式可表示为$y = Asin({\omega}x+\phi)+k$A：振幅，最高和最低的距离（shader中理解为离圆心最近和最远的距离）W：角速度，用于控制周期（shader中理解为圈数）K：偏距，曲线整体上下偏移量（shader中理解为多边形整体大小） 余弦（正弦）曲线和圆的基本关系 根据余弦（或正弦）曲线与园的基本关系。${\omega}t={\omega}x=角度$]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Unity Shader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MathJax]]></title>
    <url>%2F2019%2F03%2F09%2FMathJax%2F</url>
    <content type="text"><![CDATA[希腊字母 显示 命令 显示 命令 $\alpha$ \alpha $\beta$ \beta $\gamma$ \gamma $\delta$ \delta $\epsilon$ \epsilon $\zeta$ \zeta $\eta$ \eta $\theta$ \theta $\upsilon$ \upsilon $\phi$ \phi $\omega$ \omega $\Omega$ \Omega 若需要大写希腊字母，将命令首字母大写即可。 \Omega 呈现为 $\Omega$ 需需要斜体希腊字母，将命令前面加上var。\varpi 呈现为 $\varPi$ 字母修饰上下标 上标：^ 下标：_ 举例：c_n^2呈现为$c_n^2$ 分数有两种方法来显示分数，一种是 \frac a b 显示$\frac a b$，另一种是用\over，如{a+1 \over b+1}显示${a+1 \over b+1}$ 积分\int \int_0^\infty{fxdx} 呈现为$\int_0^\infty{fxdx}$ 特殊符号和记号 \lt \gt \le \ge \neq 表示 $\lt \gt \le \ge \neq$，还可以在不等号上加\not，如\not\lt 表示 $\not\lt$ \times \div \pm \mp 表示 $\times \div \pm \mp$，点乘用\cdot表示，如 x \cdot y 表示 $x \cdot y$ 矢量\vec{a} \cdot \vec{b} = 0 显示 $\vec{a} \cdot \vec{b} = 0$]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity Shader:优化GPU代码，用step()代替if sele等条件语句]]></title>
    <url>%2F2019%2F03%2F09%2FUS-Step%2F</url>
    <content type="text"><![CDATA[普通的卡通着色Shader先看一个Shader，卡通着色。由于卡通着色需要对不同渲染区域进行判定，比较适合做案例。]]></content>
      <categories>
        <category>Unity Shader</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity Avatar]]></title>
    <url>%2F2019%2F03%2F08%2FUnity-Avatar%2F</url>
    <content type="text"></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity Reflection]]></title>
    <url>%2F2019%2F03%2F06%2FUnity-Reflection%2F</url>
    <content type="text"><![CDATA[概念反射是.NET中的重要机制，通过反射，可以在运行时获得程序或者程序集中每一个类型（包括类、结构、委托、接口和枚举等）的成员和成员的信息。另外还可以直接创建对象，即使这个对象的类型在编译时还不知道。 用途 使用Assembly定义和加载程序集，加载在程序集清单中列出模块，从此程序集中查找类型并创建并创建该类型的实例。 使用Module了解包含模块的程序集以及模块中的类等，还可以获取在模块上定义的所有全局方法或其他特定的非全局方法。 使用ConstructorInfo了解构造函数的名称，参数，访问修饰符（如public或private）和实现详细信息（如abstract或virtual）等。 使用MethodInfo了解方法的名称，返回类型，参数，访问修饰符（如public或private）和实现详细信息（如abstract或virtual）等。 使用FieldInfo了解字段的名称、访问修饰符（如public或private）和实现相信信息（如static）等，并获取或设置字段值。 使用EventInfo了解事件的名称、事件处理程序数据类型、自定义属性、声明类型和反射类型等，添加或移除事件处理程序。 使用PropertyInfo了解属性的名称、数据类型、声明类型、反射类型和只读或可写状态等，获取或设置属性值。 使用ParameterInfo了解参数的名称、数据类型、是输入参数还是输出参数，以及参数在方法签名中的位置等。 需要的namespaceSystem.Reflection; System.Type; System.Reflection.Assembly; 主要类System.Type // 通过这个类可以访问任何给定数据类型的信息 System.Reflection.Assembly; // 访问或者加载程序集的信息 System.TypeSystem.Type类对于反射起着核心的作用。它是一个抽象的基类，Type有与每种数据类型对应的派生类。1234567891011121314151617181920212223242526272829// 属性string Name &#123;get;&#125; // 数据类型名string FullName &#123;get;&#125; // 数据类型的完全限定名（包括命名空间）string Namespace; // 命名空间名bool IsAbstract; // 是否抽象bool IsArray; // 是否数组bool IsClass; // 是否类bool IsEnum; // 是否枚举bool IsInterface; // 是否接口bool IsPublic; // 是否是公有的类型bool IsSealed; // 是否是密封类bool IsValueType; // 是否是指类型// 方法// 用于取得该类的构造函数的信息public ConstructorInfo GetConstructor();// 同上public ConstructorInfo[] GetConstructors();// 取得该类的事件信息public EventInfo GetEvent();public EventInfo[] GetEvents();public FieldInfo GetField();public FieldInfo[] GetFields();public InterfaceInfo GetInterFace();public InterfaceInfo[] GetInterFaces();public MemberInfo GetMember();public MemberInfos GetMembers();public PropertyInfo GetProperty();public PropertyInfo[] GetProperties();// 调用上述成员，方式是调用Type的InvokeMember()方法，或者调用MethodInfo，PropertyInfo的Invoke方法 123456789101112// 查看类的构造方法NewClass nc = new NewClass();Type t = nc.GetType();ConstructorInfo[] ci = t.GetConstructors(); // 获取类的所有构造函数foreach (ConstructorInfo c in ci)&#123; ParamterInfo[] ps = c.GetParameters(); foreach (ParamterInfo pi in ps) &#123; Debug.Log("&#123;0&#125;\t&#123;1&#125;", pi.ParamterType.ToString(), pi.Name); &#125;&#125; 1234567891011// 用构造函数动态生成对象Type t = typeof(NewClass);Type[] pt = new Type[2];pt[0] = typeof(string);pt[1] = typeof(string);// 根据参数类型获取构造函数ConstructorInfo ci = t.GetConstructor(pt);// 构造Object数组，作为构造函数的输入参数object[] obj = new object[2]&#123;"Liyanfeng", "Hello World"&#125;;// 调用构造函数生成对象object o = ci.Invoke(obj); 1234// 用Activator生成对象Type t = typeof(NewClass);// 用Activator的CreateInstance静态方法，生成新对象object o = Activator.CreateInstance(t, "Liyanfeng", "Hello World"); 获取给定类型的Type引用有3中常用方式123456789101112// 使用typeof运算啊Type t = typeof(string);// 使用对象GetType()方法string s = "Liyanfeng";Type t = s.GetType();// 调用Type类的静态方法GetType()Type t = Type.GetType("System.String");foreach(MemberInfo mi in t.GetMembers())&#123; Debug.Log("&#123;0&#125;/t&#123;1&#125;", mi.MemberType, mi.Name);&#125;]]></content>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图形渲染及优化-Batch]]></title>
    <url>%2F2019%2F03%2F05%2FBatch%2F</url>
    <content type="text"><![CDATA[批处理（Batch）就是对某对象进行批量的处理，本文介绍一下Batch的基本概念、]]></content>
      <tags>
        <tag>图形</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# Job System]]></title>
    <url>%2F2019%2F03%2F05%2FCsharpJobSystem%2F</url>
    <content type="text"><![CDATA[Unity C＃ Job System允许用户编写与Unity其余部分良好交互的多线程代码，并使编写正确的代码变得更加容易。编写多线程代码可以提供高性能的好处。其中包括显着提高帧速率和延长移动设备的电池寿命。C＃ Job System的一个重要方面是它与Unity内部使用的集成（Unity的native jobsystem）。用户编写的代码和Unity共享工作线程。这种合作避免了导致争用CPU资源的问题，并且可以创建比CPU核心更多的线程。 多线程在单线程计算机系统中，一次只能进入一条指令，并且只能得出一个结果。加载和完成程序的时间取决于CPU需要完成的工作量。多线程是一种编程，它利用CPU在多个内核上同时处理多个线程的能力，它不是一个接一个地执行任务或指令，而是同时运行的。默认情况下，一个线程在程序的开头运行。这是“主线程”。主线程创建新线程来处理任务。这些新线程彼此并行运行，并且通常在完成后将其结果与主线程同步。如果您有一些运行很长时间的任务，这种多线程方法很有效。但是，游戏开发代码通常包含许多一次执行的小指令。如果为每个小指令创建一个线程，最终可能会有许多线程，每个线程的生命周期都很短。这可以推动CPU和操作系统处理能力的极限。通过拥有一个线程池可以缓解线程生存期的问题。但是，即使您使用线程池，也可能同时激活大量线程。线程数多于CPU核心导致线程相互争用CPU资源，导致频繁的上下文切换。上下文切换是通过执行保存线程状态的过程，然后处理另一个线程，然后重新构建第一个线程，以便继续处理它。上下文切换是资源密集型的，因此您应尽可能避免使用它。 Job SystemJob System通过创建Job而不是线程来管理多线程代码。Job System跨多个核心管理一组工作线程。它通常每个逻辑CPU核心有一个工作线程，以避免上下文切换（尽管它可能为操作系统或其他专用应用程序保留一些核心）。Job System将Job放入作业队列中用来执行。Job System中的工作线程从作业队列中获取Job并执行它们。作业系统管理依赖关系并确保作业以适当的顺序执行。 JobJob是完成一项特定任务的一小部分工作。Job接收参数并对数据进行操作，类似于方法调用的行为方式。Job可以是独立的，也可以是依赖的（需要等其他作业完成后，然后才能运行。） Job 依赖在复杂的系统中，如游戏开发所需的系统，每个工作都不可能是独立的。一项工作通常是为下一份工作准备数据。作业了解并支持依赖关系以使其发挥作用。如果jobA对jobB依赖，则Job System确保在完成jobA之前不会开始执行jobB。 安全系统编写多线程代码时，总是存在竞争条件的风险。当一个操作的输出取决于其控制之外的另一个过程的时间的时候，就会发生竞争条件。竞争条件并不总是一个bug，但是它不确定行为的来源，当竞争条件导致bug的时候，总是比较难以找到问题的根源。因为它取决于时间，因此你可能极少数情况下会复现问题。调试的时候可能会导致问题消失。因此调试和日志可能会改变bug的发生条件。竞争条件是编写多线程的时候面临的比较大的挑战。 为了更容易编写多线程代码，Job System可以检测所有潜在的竞争条件，并保护你免受可能导致的bug的影响。例如：如果Job System将主线程中代码中的数据引用发送到Job中，则无法验证作业在写入数据的时候同时读取数据，这种情况就会创建竞争条件。 Job System通过向每个作业发送它需要的操作的数据的副本来解决这个问题，而不是对主线程中的数据的引用，这种拷贝隔离了数据，从而消除了竞争条件。]]></content>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UnityHub破解]]></title>
    <url>%2F2019%2F03%2F03%2FUnity-Hub%2F</url>
    <content type="text"><![CDATA[退出UnityHub npm install -g asar cd C:\Program Files\Unity Hub\resources asar extract .\app.aser app rm -rf app.asar cd app/src/services/licenseService vim licenseClient.js 1234567getLicenseInfo(callback)&#123; // load license // get latest data from licenseCore //licenseInfo.activated = licenseCore.getLicenseToken().length &gt; 0; // 注释这行 licenseInfo.activated = true; // 新增这行 licenseInfo.flow = licenseCore.getLicenseKind();&#125; vim licenseCore.js 12345678verifyLicenseData(xml)&#123; return new Promise((resolve, reject)=&gt; resolve(true); //新增这行 if (xml === '')&#123; &#125; )&#125;]]></content>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO多路复用之select、poll、epoll详解]]></title>
    <url>%2F2019%2F03%2F02%2FNetSocket%2F</url>
    <content type="text"><![CDATA[目前支持I/O多路复用的系统调用有select,pselect,poll,epoll,I/O多路复用就是通过一种机制，一个进程可以监听多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），就能够通知程序进行相应的读写操作。但select,pselect,poll,epoll本质上都是同步I/O，因为他们都需要在读写时间就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。（这一步有性能开销）与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减少了系统的开销。 使用场景IO多路复用是指内核一旦发生进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合：1）当客户处理多个描述符时（一般是交互式输入和网络套接口），必须适用I/O复用。2）当一个客户同时处理多个套接口，这种情况是可能的，但很少出现。（貌似没见过）3）如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用I/O复用。（这是最常见的方式，貌似没有其他取代方式？）4）如果一个服务器既要处理TCP，又要处理UDP，一般要使用I/O复用。5）如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。 select、poll、epoll简介epoll跟select都能提供多路I/O复用的解决方案。在现在的Linux内核都支持，其中epoll是Linux所特有，而select则应该是POSIX规定。基本流程，如图所示：select目前几乎在所有的平台上支持，其良好的跨平台支持也是它的一个优点。select的一个缺点在与单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低。select本质上是通过设置或者检查存放fb标志位的数据结构来进行下一步处理。这样所带来的的缺点是：1.select最大的缺陷就是单个进程打开的DF是有一定限制的，它由FD_SETSIZE设置，默认值是1024。一般来说这个数目和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max查看。32位默认1024个，64位默认2048个。我查了一下自己的虚拟机Centos6.0 是95979，从数量上分析来看，对于游戏来说，select模型个人感觉这点可以忽视了。2.对socket进行扫描是线性扫描，即采用轮询的方法，效率较低。当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度，不管哪个Socket是活跃的，都遍历一遍。（这可太扯了）这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。3.需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销很大。 pollpoll是select的一种改良，最突出的改良有两点：1.文件描述符数量没有上限2.将输入输出参数进行分离，不用每次设定缺点：1.和select一样，poll返回后，需要轮询pollfd来获取就绪的描述符2.每次调用poll都需要大把大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。 epoll1.文件描述符没有上限，通过epoll_ctl()来注册一个文件描述符，内核中使用红黑树的数据结构来管理所有需要监控的文件描述符。2.基于时间就绪通知方式，一旦被监听的某个文件描述符就绪，内核会采用类似于callback的回调机制，迅速激活这个文件描述符，这样随着文件描述符数量的增加，也不会影响判定就绪的性能。3.维护就绪队列，当文件描述符就绪，就会被放到内核中的一个就绪队列中，这样调用epoll_wait获取就绪文件描述符的时候，只要取队列中的元素即可，操作的时间复杂度恒为O(1)。4.epoll内存映射机制，即内核将就绪队列通过mmap的方式映射到用户态，避免了拷贝内存这样的额外性能开销。]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F2019%2F02%2F25%2FQuickSort%2F</url>
    <content type="text"><![CDATA[快速排序快速排序(Quick Sort)使用分治法策略。它的基本思想是：选择一个基准数，通过一趟排序将要排序的数据分割成独立的两部分；其中一部分的所有数据都比另外一部分的所有数据都要小。然后，在按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 快速排序流程 从数列挑出一个基准值。 将所有比基准值小的摆放在基准前面，所有比基准值大的摆在基准的后面（相同的数可以到任一边）；在这个分区退出之后，该基准就处于数列的中间位置。 递归地把“基准值前面的子数列”和“基准值后面的子数列”进行排序。 归并排序基本思想归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分支（divide-and-conquer）策略（分治法将问题分(divide)成一些小问题然后在递归求解，而治(conquer)的阶段则将分的阶段得到的各答案“修补”在一起，即分而治之）。 可以看到这种结构很像一颗完全二叉树，本文的归并排序我们采用递归去实现，递归深度为$log_{2^n}$ 合并相邻有序子序列再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤。 复杂度归并排序比较占用内存，但却是一种高效且稳定的算法。时间复杂度：$O(n \cdot log^n)$空间复杂度：T(n) 二叉堆（binary heap）二叉堆是一种特殊的堆，二叉堆是完全二叉树（二叉树）或者近似完全二元树（二叉树）。二叉堆有两种：最小堆和最大堆。最大堆：父节点的键值总是大于或等于任何一个子节点的键值；最小堆：父结点的键值总是小于或等于任何一个子节点的键值。]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++]]></title>
    <url>%2F2019%2F02%2F25%2FC%2B%2B%2F</url>
    <content type="text"><![CDATA[虚函数 对于一个class，产生一堆指向virtual functions的指针，虚函数表指针通常放在对象实例的最前面的位置。编译报错的时候没有vtable，表示该纯虚函数没有实现。 每一个对象添加一个指针，指向相关的virtual table。这个指针被称作虚函数表指针。 C/C++中static关键字作用总结先来介绍它的第一条也是最重要的一条：隐藏。（static函数，static变量均可）当同事编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。举例来说明。同时编译两个源文件，一个是a.c，另一个是main.c。123456789101112131415//a.cchar a = 'A'; // global variablevoid msg()&#123; printf("Hello\n");&#125;// main.cint main()&#123; extern char a; // extern variable must be declared before use printf("%c", a); (void)msg(); return 0;&#125; 程序运行结果是：A Hello为什么在a.c中定义的全局变量a和函数msg能在main.c中使用？前面说过，所有未加static前缀的全局变量和函数都具有全局可见性，其它的源文件也能访问。此例中，a是全局变量，msg是函数，并且都没有加static前缀，因此对于另外的源文件main.c是可见的。如果加了static，就会对其它源文件隐藏。例如在a和msg的定义前加上了static，main.c就看不到它们了。利用这一特性可以再不同的文件中定义同名函数和同名变量，而不必担心命名冲突。static可以用作函数和变量的前缀，对于函数来讲，static的作用仅限于隐藏。 static的第二个作用是保持内容的持久。（static变量中的记忆功能和全局生存期）存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的，虽然这种用法不常见PS：如果作为static局部变量在函数内定义，它的生存期为整个源程序，但是其作用域仍与自动变量相同，只能定义该变量的函数内使用该变量。退出该函数后，尽管该变量还继续存在，但不能使用它。 程序举例：12345678910111213141516#include &lt;stdio.h&gt;int fun()&#123; static int count = 10; //在第一次进入这个函数的时候，变量a被初始化为10！并接着自减1，以后每次进入该函数，a就不会再次被初始化了，仅进行自减1的操作；在static发明前，要达到同样的功能，则只能使用全局变量； return count--;&#125;int count = 1;int main(void)&#123; printf("global\t\tlocal static\n"); for(;count&lt;=10;++count) &#123; printf("%d\t\t%d\n",count,fun()); &#125; return 0;&#125; 基于以上两点可以得出一个结论：把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。因此static这个说明符在不同的地方所起的作用是不同的。 static的第三个作用是默认初始化为0（static变量）其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。比如初始化一个稀疏举证，我们可以一个一个地把所有元素都置0，然后把不是0的几个元素赋值。如果定义成静态的，就省去了一开始置0的操作。再比如把一个字符数组当字符串来用，但又觉得每次在字符数组末尾加’\0’；太麻烦。如果把字符串定义成静态的，就省去了这个麻烦，因为那里本来就是’\0’; 最后对static的三条作用做一句话总结。首先static的最主要功能是隐藏，其次因为static变量存放在静态存储区，所以它具备持久性和默认值0。 static的第四个作用：C++中的类成员声明static（有些地方与以上作用重叠）在类中声明static变量或者函数时，初始化时使用作用域运算符来标明它所属类，因此，静态数据成员是类的成员，而不是对象的成员，这样就出现以下作用：（1）类的静态成员函数是属于整个类而非类的对象，所以它没有this指针，这就导致了它仅能访问类的静态数据和静态成员函数。（2）不能将静态成员函数定义为虚函数。（3）由于静态成员声明于类中，操作于其外，所以对其取地址操作，就多少有些特殊，变量地址是指向其数据类型的指针，函数地址类型是一个”nonmember函数指针”。（4）由于静态成员函数没有this指针，所以就差不多等同于nonmember函数，结果就产生了一个意想不到的好处：成为一个callback函数，使得我们得以将C++和C-based XWindow系统结合，同时也成功的应用于线程函数身上。（这条没遇见过）（5）static并没有增加程序的时空开销，相反它还缩短了子类对父类静态成员的访问时间，节省了子类的内存空间。（6）静态数据成员在&lt;定义或说明&gt;时前面加关键字static。（7）静态数据成员是静态存储的，所以必须对它进行初始化。（程序员手动初始化，否则编译时一般不会报错，但是Link时会报错误）（8）静态成员初始化与一般数据成员初始化不同：初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆；初始化时不加该成员的访问权限控制符private,public等；初始化时使用作用域来标明它所属类；所以我们得出静态数据成员初始化的格式：&lt;数据类型&gt; &lt;类名&gt;::&lt;静态数据成员名&gt;=&lt;值&gt;（9）为了防止父类的影响，可以在子类定一个与父类相同的静态变量，以屏蔽父类的影响。这里有一点需要注意：我们说静态成员为父类和子类共享，但我们有重复定义了静态成员，这会不会引起错误呢？不会，我们的编译器采用了一种绝妙的手法：name-mangling用以生成唯一的标志。 C++智能指针shared_ptrshared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。 weak_ptrweak_ptr没有共享资源，它的构造不会引起指针引用计数的增加 unique_ptr“唯一”拥有其所指对象，同一时刻只能有一个unique_ptr指向给定对象 虚函数通过一张虚函数表（Virtual Table）来实现sizeof不统计虚函数表 C/C++内存对齐什么是内存对齐32位系统下，int占4byte，char占1byte，那么将它们放到一个结构体中实际上占8byte，这就是内存对齐导致的。 inline什么是内联函数？内联函数是指那些定义在类体内部的成员函数，即该函数的函数体放在类体内。一般来说，inline适用的函数有两种，一种是类内定义的成员函数，另一种是类内声明，类外定义的成员函数，对于这两种情况inline的使用有一些不同； 内联函数的优缺点：优点：1.inline定义的类的内联函数，函数的代码被放入符号表中，在使用时直接进行替换，（像宏一样展开），没有了调用的开销，效率也很高。2.inline也是真正的函数，编辑器在调用一个内联函数时，会首先检查它的参数的类型，保证调用正确。然后进行一系列的相关检查，就像对待任何一个正在的函数一样。这样就消除了它的隐患和局限性。（宏替换不会检查参数类型，安全隐患较大）缺点：1.内联函数具有一定的局限性，inline函数的函数体一般来说不能太大，如果太大，一般的编译器会放弃内联方式，而采用普通的方式调用函数。（换句话说，你使用内联函数，只不过是向编译器提出一个申请，编译器可以拒绝你的申请），这样，内联和普通函数执行效率一样了。2.inline对编译器来说只是一种简易，编译器可以选择忽略这个建议。 注意事项1.内联函数不能宝库欧复杂的控制语句，如循环语句和switch语句； 接口（抽象类）接口描述了类的行为和功能，而不需要完成类的特定实现。 视C++为一个语言联邦 C语言 面向对象 C++模版 STL容器 尽量用const，enum，inline替换#define const的好处：define直接常量替换，出现编译错误不易定位（不知道常量是哪个变量，这个其实还好，工程规范点的都不存在这个问题）；define没有作用域，const有作用域提供了封装性（这个同上，不过这两点都是人为的避开了） enum的好处：提供了封装性，编译器肯定不会分配额外的内存空间（其实const也不会，难道define会？至于封装性，undef，所以这么多年了，虽然说避免，但是工程上用的还是比较多的） inline的好处：define宏函数容易造成误用 宏实现工厂设计模式 需要一个全局map用于存储类的信息以及创建实例的函数 需要调用全局对象的构造函数用于注册 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// ConsoleApplication1.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。//#include "pch.h"#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;typedef void *(*register_fun)();class CCFactory&#123;public: static void *NewInstance(string class_name) &#123; auto it = map_.find(class_name); if (it == map_.end()) &#123; return NULL; &#125; else &#123; return it-&gt;second(); &#125; &#125; static void Register(string class_name, register_fun func) &#123; map_[class_name] = func; &#125;private: static map&lt;string, register_fun&gt; map_;&#125;;map&lt;string, register_fun&gt; CCFactory::map_; // 体外初始化#define REGISTER_CLASS(class_name); \ CCFactory::Register(#class_name, []()-&gt;void *&#123;return (new class_name);&#125;);class Product&#123;public: virtual void Say() = 0;&#125;;class Register : public Product // 注册者，就是产品，虽然不喜欢设计模式这坨东西，但是研究起来还是挺好玩的&#123;public: void Say() &#123; std::cout &lt;&lt; "Say What?\n"; &#125;&#125;;void Init()&#123; REGISTER_CLASS(Register);&#125;void Release()&#123;&#125;int main()&#123; Init(); Register* a = (Register*)CCFactory::NewInstance("Register"); a-&gt;Say(); Release();&#125; 没写完，但是感觉做个池还是挺好玩的。 尽可能使用const const定义接口，防止误用 const成员函数，代表这个成员函数承诺不会改变对象值（const成员只能调用const成员函数(加-fpermissive编译选项就可以了)，非const成员可以调用所有成员函数） 确定对象使用前被初始化12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// ConsoleApplication1.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。//#include "pch.h"#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;typedef void *(*register_fun)();class CCFactory&#123;public: static void *NewInstance(string class_name) &#123; auto it = map_.find(class_name); if (it == map_.end()) &#123; return NULL; &#125; else &#123; return it-&gt;second(); &#125; &#125; static void Register(string class_name, register_fun func) &#123; map_[class_name] = func; &#125;private: static map&lt;string, register_fun&gt; map_;&#125;;map&lt;string, register_fun&gt; CCFactory::map_; // 体外初始化#define REGISTER_CLASS(class_name); \ CCFactory::Register(#class_name, []()-&gt;void *&#123;return (new class_name(#class_name));&#125;);class Product&#123;public: virtual void Say() = 0;&#125;;class Register : public Product // 注册者，就是产品，虽然不喜欢设计模式这坨东西，但是研究起来还是挺好玩的&#123;public: void Say() &#123; std::cout &lt;&lt; name.c_str() &lt;&lt; ": Say What?\n"; &#125; void Run() const // 表明这个函数不会对类对象的数据成员（准确地说是非静态数据成员）作任何改变 &#123; &#125; int b; const string name; // 必须在初始化的时候赋值 Register(string _y) : name(_y) &#123; &#125;&#125;;void Init()&#123; REGISTER_CLASS(Register);&#125;void Release()&#123;&#125;int main()&#123; Init(); Register* a = (Register*)CCFactory::NewInstance("Register"); a-&gt;Say(); Release();&#125; 构造、析构、赋值运算如果类中没有定义，程序却调用了，编译器会产生一些函数 一个default的构造函数 一个copy构造函数 一个copy assignment 操作符 一个析构函数(non virtual) 如果自己构造了带参数的构造函数，编译器不会产生default构造函数 base class如果把拷贝构造函数或者复制操作符设置为private，不会产生这两个函数 含有引用成员变量或者const成员变量不产生复制操作符 若不想使用编译器自动生成的函数，就该明确拒绝将默认生成的函数声明为private，或者C++ 11新特性”=delete”123456class UncopyTable&#123;private: UncopyTable(const UncopyTable&amp;); UncopyTable&amp; operator=(const UncopyTable&amp;);&#125;; 静态类型上下文无关，在编译时就可以确定其类型。 动态类型基类指针指向的对象在编译的时候无法确定 动态绑定与静态绑定静态绑定：编译时绑定，通过对象调用动态绑定：运行时绑定，通过地址实现 要触发动态绑定，需满足两个条件 只有虚函数才能惊醒动态绑定，非虚函数不能进行动态绑定 必须通过基类类型的引用或指针进行函数调用 为多态基类声明virtual析构函数 给多态基类应该主动声明virtual析构函数 非多态基类，没有virtual函数，不要声明virtual析构函数 复制对象时勿忘其每个成分 实现拷贝构造函数和赋值操作符的时候，调用base的相关函数 可以让拷贝构造函数和赋值操作符调用一个共同的函数，比如Init 资源管理以对象管理资源 为了防止资源泄漏，请使用RAII对象，在构造函数里面获得资源，在析构函数里面释放资源 shared_ptr，unique_lock都是RAII对象 在资源管理类小心copy行为 常见的RAII对象copy行为 禁止copy 引用计数 深度赋值 转移资源拥有权]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[序章]]></title>
    <url>%2F2018%2F12%2F09%2Ffiction%2F</url>
    <content type="text"><![CDATA[芩也不是一开始就知道这个世界是黑白的，是他的父亲告诉他的。父亲说，芩，你长大了，父亲要走了。芩问，父亲你去哪里？父亲说，我也不知道，我总觉得有人在召唤我，我该上路了。我们每个人都会上路的，包括你，芩。芩说，父亲，我可以陪你一起上路吗？父亲回答，我们每个人的路都是不一样的，你以后会有你自己的路走的，或许是明天，或许是明年，或许是更久。芩没说话，六岁的他不知道该说什么，也不太明白父亲对他说的话。她只知道，父亲要走了。要去很远的地方，一个她找不到的地方。而她，再也见不到父亲了。]]></content>
      <tags>
        <tag>混沌</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity Shader第三部分]]></title>
    <url>%2F2018%2F10%2F22%2FUnity-Shader-IntrodutionToTopic-2%2F</url>
    <content type="text"><![CDATA[透明效果为什么渲染顺序很重要Unity Shader的渲染顺序透明度测试透明度混合透明度混合的实现要比透明度测试复杂一些，这是因为我们在处理透明度测试时，实际上跟对待普通的不透明物体几乎是一样的，只是在片元着色器中增加了对透明度判断并裁剪片元的代码。而想要实现透明度混合就没这么简单了。我们回顾之前提到的透明度混合的原理。透明度混合：这种方法可以得到真正的半透明效果。它会使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲区种的颜色进行混合，得到新的颜色。但是，透明度混合需要关闭深度写入，这使得我们要非常小心物体的渲染顺序。为了进行混合，我们需要使用Unity提供的混合命令Blend。Blend是Unity提供的设置混合模式的命令。想要实现半透明的效果就需要把当前自身的颜色和已经存在于颜色缓冲区种的颜色值进行混合，混合时使用的函数就是由该指令决定的。 语义 描述 Blend Off 关闭混合 Blend SrcFactor DstFactor 开启混合，并设置混合因子。源颜色（该片元产生的颜色）会乘以SrcFactor，而目标颜色（已经存在于颜色缓存的颜色）会乘以DstFactor，然后把两者相加后在存入颜色缓冲中 Blend SrcFactor DstFactor, SrcFactorA DstFractorA 和上面一样，只是使用不同的因子来混合透明通道 BlendOp BlendOperation 并非是把源颜色和目标颜色简单相加后混合，而是使用BlendOperation对它们进行其他操作 我们介绍第二种语义，即Blend SrcFactor DstFactor来进行混合。需要注意的是，这个命令在设置混合因子的同时也开启了混合模式。这是因为，只有开启了混合之后，设置片元的透明通道才有意义，而Unity在我们使用Blend命令的时候就自动帮我们打开了。很多初学者抱怨为什么自己的模型没有任何透明效果，这往往是因为他们没有在Pass中使用Blend命令，一方面是没有设置混合因子，更重要的是没有打开混合模式。我们会把源颜色的混合因子SrcFactor设为SrcAlpha，而目标颜色的混合因子DstFactor设为OneMinusSrcAlpha。这意味着，经过混合后新的颜色是： DstColor_{new} = SrcAlpha*SrcColor+(1-SrcAlpha)*DstColor_{old}开启深度写入的半透明效果ShaderLab的混合命令混合等式和参数混合操作常见和混合类型双面渲染的透明效果透明度测试的双面渲染透明度混合的双面渲染渲染路径Rendering Path LightMode 描述 Always 不管使用哪种渲染路径，该Pass总是会被渲染，但不会计算任何光照 ForwardBase 用于前向渲染。该Pass会计算环境光、最重要的平行光、逐顶点/SH光源和Lightmaps ForwardAdd 用于前向渲染。该Pass会计算额外的逐像素光源，每个Pass对应一个光源 Deferred 用于延迟渲染。该Pass会渲染G缓冲（G-buffer） ShadowCaster 把物体的深度信息渲染到阴影映射纹理（shadowmap）或一张深度纹理中 PrepassBase 用于遗留的延迟渲染。该Pass会渲染法线和高光反射的指数部分 PrepassFinal 用于遗留的延迟渲染。该Pass通过合并纹理、光照和自发光来渲染得到最后的颜色 Vertex、VertexLMRGBM和VertexLX 用于遗留的顶点照明渲染 Unity在处理多光源的情况时为我们提供了三种模式；修改的地方在Edit-&gt;Project Settings—Player—Other Settings—Redering Path 顶点光Vertex Lit 方向性Forward(默认) 延迟照明 Deferred Lighting shader默认使用Forward 前向渲染路径每进行一次完整的前向渲染，需要渲染该对象的渲染图元，并计算两个缓冲区的信息：一个是颜色缓冲区，一个是深度缓冲区。利用深度缓冲区来决定一个片元是否可见，如果可见就更新颜色缓冲区的的颜色值。我们可以用下面的伪代码来描述前向渲染路径的大致过程： 12345678910111213141516171819Pass &#123; for (each primitive in this model) &#123; if (failed in depth test) &#123; // 如果没有通过深度测试，说明该片元是不可见的 discard; &#125; else &#123; // 如果该片元可见 // 就进行光照计算 float4 color = Shading(materialInfo, pos, normal, lightDir, viewDir); // 更新帧缓冲 writeFrameBuffer(fragment, color); &#125; &#125;&#125; 对于每个逐像素光源，我们都需要进行上面一次完整的渲染流程。如果一个物体在多个逐像素光源的影响区域内，那么该物体就需要执行多个Pass，每个Pass计算一个逐像素光源的光照结果，然后在帧缓冲中把这些光照结果混合起来得到最终的颜色值。假设，场景中有N个物体，每个物体物体受M个光源的影响，那么要渲染整个场景一共需要N*M个Pass。可以看出，如果有大量逐像素光照，那么需要执行的Pass数目也会很大。因此，渲染引擎通常会限制每个物体的逐像素光照的数目。 Unity中的前向渲染事实上，一个Pass不仅仅可以用来计算逐像素光照，它也可以用来计算逐顶点等其他光照。这取决于光照计算所处流水线阶段以及计算时使用的数学模型。当渲染一个物体时，Unity会计算哪些光源照亮了它，以及这些光源照亮该物体的方式。在Unity中，前向渲染路径有3种处理光照（即照亮物体）的方式：逐顶点处理、逐像素处理，球谐函数（Spherical Harmonics, SH）处理。 顶点照明渲染路径延迟渲染路径这是一种可以按照你的需求在场景中使用任意数目的光源的方法，而且这个方法还能同时保证性能仍然保持在一个合理的范围。它也不限制阴影的数量，如果场景中的对象实在光照范围之内的话，也不会增加额外的渲染批次（如果对象投影阴影的话则是例外）。 在游戏中的实时光照，一般有三种常用的方法 一遍渲染多个光源：所有光源都在一个着色器中进行。但一个着色器指令数量有限，所以这个技术只适用于光源数量较少的情况。 多遍渲染多光源 延迟渲染 菲涅尔反射在实时渲染中，经常会使用菲涅耳反射（Fresnelreflection）来根据视角方向控制反射程度。菲涅耳反射描述了一种光学现象，即当光线照射到物体表面上时，一部分发生反射，一部分进入物体内部，发生折射或散射。被反射的光和入射光之间存在一定的比率关系，这个比率关系可以通过菲涅耳等式进行计算。一个经常使用的例子是，当你站在湖边，直接低头看脚边的水面时，你会发现水几乎是透明的，你可以直接看到水底的小鱼和石子；但是，当你抬头看远处的水面时，会发现几乎看不到水下的情景，而只能看到水面反射的环境。这就是所谓的菲涅耳效果。事实上，不仅仅是水、玻璃这样的反光物体具有菲涅耳效果，几乎任何物体都或多或少包含了菲涅耳效果，这是基于物理的渲染中非常重要的一项高光反射计算因子。那么，如何计算菲涅耳反射呢？这就需要使用菲涅耳等式。真实世界的菲涅耳等式是非常复杂的，但在实时渲染中，通常会使用一些近似公式来计算。其中一个著名的近似公式就是Schlick 菲涅耳近似等式： $F_{Schlick}(v,n) = F_{0}+(1-F_{0})(1-v \cdot n)^5$ 其中，$F_{0}$是一个反射系数，用于控制菲涅耳反射的强度， v 是视角方向， n 是表面法线。另一个应用比较广泛的等式是Empricial菲涅耳近似等式： $F_{Empricial}(v,n) = max(0,min(1,bias+scale x (1-v \cdot n)^power))$ 其中，bias、scale和power是控制项。 使用上面的菲涅尔近似等式，可以在边界处模拟反射光强和折射光强/漫反射光强之间的变化。在许多车漆、水面等材质的渲染中，会经常用到菲涅尔反射来模拟更加真实的反射。 ### 广告牌 广告牌技术的本质就是构建旋转矩阵，而我们知道一个变换矩阵需要3个基向量。广告牌技术使用的基向量通常就是**表面法线（normal）、指向上的方向（up）以及指向右的方向（right）**。除此之外，我们还需要指定一个**锚点（anchor location）**，这个锚点在旋转过程中是固定不变的，以此来确定多边形在空间中的位置。 广告牌技术的难点在于，如何根据需求构建3个相互正交的基向量。计算过程通常是， CPU写法： 12345678public Vector3 Normal;Quaternion direction;void Start () &#123; direction = Quaternion.FromToRotation(new Vector3(0, 0, 1), Normal);&#125;void Update () &#123; transform.rotation = Camera.main.transform.rotation * direction;&#125; ## 屏幕后处理效果 ### 建立一个基本的屏幕后处理脚本系统 MonoBehaviour.OnRenderImage(RenderTexture src, RenderTexture dest); 当在脚本中声明该函数后，Unity会把当前渲染得到的图像存储在第一个参数对应的源渲染纹理中，把第二参数对应的渲染纹理显示到屏幕上。 public static void Blit(Texture src, RenderTexture dest); public static void Blit(Texture src, RenderTextrue dest, Material mat, int pass = -1); public static void Blit(Texture src, Material mat, int pass = -1); 参数pass的默认值胃-1，表示将会依次调用Shader内的所有Pass。否则，只会调用给定索引的Pass。 ### 边缘检测 #### 卷积 在图像处理中，卷积操作指的是使用一个卷积核（kernel）一张图像中的每个像素进行一些列操作。卷积核通常是一个四方形网格结构，该区域内每个方格都有一个权重值。当对图像中的某个像素进行卷积时，我们会把卷积核的中心放置于该像素上，翻转核之后再依次计算核中每个元素和其覆盖的图像像素值的乘积并求和，得到的结果就是该位置的新像素值。 这样的过程虽然简单，但可以实现很多常见的图像处理效果，例如图像模糊、边缘检测等。 #### 常见的边缘检测算子 卷积操作的神奇之处在于选择的卷积核。那么，用于边缘检测的卷积核（也被称为边缘检测算子）应该张什么样呢？再回答这个问题前，我们可以首先回想一下边到底是如何形成的。如果相邻像素之间存在差别明显的颜色、亮度、纹理等属性，我们就会认为它们之间应该有一条编辑。这种相邻像素之间的差值可以用**梯度（gradient）**来表示，可以想想得到，边缘处的梯度绝对值会比较大。基于这样的理解，有几种不同的边缘检测算子被先后提出来。 Roberts Gx{ -1,0, 0,1, } Gy{ 0,-1, 1, 0, } Prewitt Gx { -1,-1,-1, 0, 0, 0, 1, 1, 1, } Gy { -1, 0, 1, -1, 0, 1, -1, -, 1, } Sobel Gx { -1,-2,-1, 0, 0, 0, 1, 2, 1, } Gy { -1, 0, 1, -2, 0, 2, -1, 0, 1, } 3中常见的边缘检测算子，它们都包含了两个方向的卷积核，分别用于检测水平方向和竖直方向上的边缘信息。再进行边缘检测时，我们需要对每个像素分别进行一次卷积计算，得到两个方向上的梯度值Gx和Gy，而整体的梯度可按下面的公式计算而得： $$ G = \sqrt{G^2_x + G^2_y} $$ 由于上述符号包含了开根号操作，出于性能考虑，我们有时会使用绝对值操作来代替开根号操作： $$ G=|G_x|+|G_y| $$ 当得到梯度后，我们就可以据此来判断哪些像素对应了边缘（梯度值越大，越有可能是边缘点）。 ## 使用深度和法线纹理 ### 消融 噪声纹理+透明度测试，我们使用对噪声纹理采样的结果和某个控制消融程度的阀值比较，如果小于阀值，就使用clip函数把它对应的像素裁减掉。 1234567891011121314151617181920212223Shader &quot;Test&quot;&#123; Properties &#123; _BurnAmount(&quot;Burn Amount&quot;, Range(0.0, 1.0)) = 0.0 // 控制消融程度，0为正常，1完全消融 _LineWith(&quot;Burn Line Width&quot;, Range(0.0, 0.2)) = 0.1 // 模拟烧焦效果的线宽，值越大，火焰边缘的蔓延范围越宽 _MainText (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125; // 漫反射纹理 _BumpMap (&quot;Normal Map&quot;, 2D) = &quot;bump&quot; &#123;&#125; // 法线纹理 _BurnFirstColor(&quot;Burn First Color&quot;, Color) = (1,0,0,1) // 火焰边缘颜色 _BurnSecondColor(&quot;Burn Second Color&quot;, Color) = (1,0,0,1) // 火焰边缘颜色 _BurnMap(&quot;Burn Map&quot;, 2D) = &quot;white&quot; &#123;&#125; // 消融纹理 &#125; SubShader &#123; Pass &#123; CGPROGRAM #pragma vertex vert #pragma vertex frag ENDCG &#125; &#125; &#125; ### 水波效果 在模拟实时水面的过程中，往往也会使用噪声纹理。此时，噪声纹理通常会用作一个高度图，以不断修改水面的法线方向。为了模拟水不断流动的效果，我们会使用和时间相关的变量来对噪声纹理进行采样，当得到法线信息后，在进行正常的反射+折射计算，得到最后的水面波动效果。 1234SubShader &#123; Tags &#123;"Queue"="Transparent" "RenderType"="Opaque"&#125; GrabPass &#123;"_RefractionTex"&#125;&#125; 首先把SubShader的标签中渲染队列设置成Transparent，并把后面的RenderType设置为Opaque。把Queue设置成Transparent可以确保该物体渲染时，其他所有不透明的物体都已经被渲染到屏幕上了，否则就可能无法正确得到“透过水面看到的图像”。而设置RenderType则是为了在使用着色器替换（Shader Replacement）时，该物体可以在需要时被正确渲染。 ### 减少draw call数目 #### 动态批处理 基本原理：每一帧把可以进行批处理的模型网格进行合并，再把合并后的模型数据传递给GPU，然后使用同一个材质对其渲染。动态批处理的一个好处是实现方便，另一个好处是，经过批处理的物体仍然可以移动，这是由于在处理每帧时Unity都会重新合并一次网格。 条件限制： - 能够进行动态批处理的网格的顶点属性规模要小于900。例如，如果shader中需要使用顶点位置、发现和纹理坐标这3个顶点属性，那么要想让模型能够被动态批处理，它的顶点数目不能超过300。 - 多Pass的shader会中断批处理。在前向渲染中，我们有时需要使用额外的Pass来为模型添加更多的光照效果，但这样一来模型就不会被动态批处理了。 #### 静态批处理 #### 共享材质 #### 批处理的注意事项 ### 16.5 减少需要处理的顶点数目 #### 16.5.1 优化几何体 移除不必要的硬边以及纹理衔接，避免边界平滑和纹理分离。 #### 16.5.2 模型的LOD技术 #### 16.5.3 遮挡剔除技术 ### 16.6 减少需要处理的片元数目 #### 控制绘制顺序 #### 时刻警惕透明物体 #### 减少实时光照和阴影 ### 影响性能的因素 首先，在学习如何优化之前，我们得先了解影响游戏性能的因素有哪些。对于一个游戏来说，它主要需要使用两种计算资源：CPU和GPU。它们会互相合作，来让我们的游戏可以在预期的帧率和分辨率下工作。其中，CPU主要负责保证帧率，GPU主要负责分辨率相关的一些处理。 据此，可以把造成游戏性能瓶颈的主要原因分成以下几个方面。 （1）CPU - 过多的draw call - 复杂的脚本或者物理模拟 （2）GPU - 顶点处理 过多的顶点 过多的逐顶点计算 - 片元处理 过多的片元（既可能是由于分辨率造成的，也可能是由于overdraw造成的）。 过多的逐片元计算。 - 带宽 使用了尺寸很大且未压缩的纹理 分辨率过高的帧缓存 对于CPU来说，限制它的主要是每一帧draw call的数目。简单来说，就是CPU在每次通知GPU进行渲染之前，都需要提前准备好顶点数据（如位置、法线、颜色、纹理坐标等），然后调用一系列API把它们放到GPU可以访问到的指定位置，最后，调用一个绘制命令，来告诉GPU。而调用一次绘制命令的时候，就会产生一个draw call。过多的draw call会造成CPU的性能瓶颈，这是因为每次调用draw call时，CPU往往都需要改变很多渲染状态的设置，而这些操作是非常耗时的。如果一帧中需要的draw call数目过多的话，就会导致CPU把大部分时间都花费在提交draw call的工作上面了。当然，其他原因也可能造成CPU瓶颈，例如物理、布料模拟、蒙皮、粒子模拟等，这些都是计算量很大的操作。 而对于GPU来说，它负责整个渲染流水线。它从处理CPU传递过来的模拟数据开始，进行顶点着色器、片元着色器等一系列工作，最后输出屏幕上的每个像素。因此，GPU的性能瓶颈和需要处理的顶点数目、屏幕分辨率、显存等因素有关。而相关的优化策略可以减少处理的数据（包括顶点数目和片元数目） |信息名称|描述| |--|--| |每帧的时间和FPS|在Graphic的右侧显示，给出了处理和渲染一帧所需的时间，以及FPS数目| |Batches|一帧中需要进行的批处理数目| |Saved by batching|合并的批处理数目，这个数字表明了批处理为我们节省了多少的draw call| ### 节省带宽 #### 减少纹理大小 - 纹理的长宽比最好是正方形，长宽值最好是2的整数幂 - 多级渐远纹理技术（mipmapping）和纹理压缩。 #### 利用分辨率缩放 ### 减少计算复杂度 #### Shader的LOD技术 #### 代码方面的优化 #### 根据硬件进行缩放 ## 基于物理的渲染 ### 双向反射分布函数（BRDF） **辐射率（radiance）**是单位面积、单位方向上光源的辐射通量，通常用L表示，被认为是对单一光线的亮度和颜色评估。在渲染中，我们通常会基于表面的入射光线的入射辐射率 $ L_i $ 来计算出射辐射率 $L_{0}$ ，这个过程往往也称为**着色（shading）**过程。 而要得到出射辐射率$L_{o}$，我们需要知道物体表面一点是如何和光进行交互的。而这个过程就可以使用**BRDF（Bidirectional Reflectance Distribution Function，双向反射分布函数）**来定量分析。在大多数情况下，BRDF可以用$f(I,v)$来表示，其中I为入射方向和v为观察方向（双向的含义）。这种情况下，绕着表面法线旋转入射方向或观察方向并不会影响BRDF的结果，这种BRDF被称为是**各项同性（isotropic）**的BRDF。与之对应的则是**各项异性（anisotropic）**的BRDF。 ### 反射率方程 $L_{o}(p,w_{o}) = \int_\Omega(k_{d}{c \over \pi} + k_{s}{DGF \over 4(w_{o} \cdot n)(w_{i} \cdot n)})L_{i}(p,w_{i})(w_{i} \cdot n)dw_{i}$ 这是PBR的核心，也是主要的劝退点。翻译成自然语言，大概是这样的： $输出颜色 = \int_\Omega(漫反射比例{纹理颜色 \over \pi} + 镜面反射比例{镜面高光 x 几何遮蔽 x 菲涅尔效应 \over 4(view_{Dir} \cdot normal)(lightDir \cdot normal)})光源颜色(lightDir,normal)dw_{i}$ 先解释下这个公式遗留的部分。半球积分($\int_\Omega………dw_{i}$)]]></content>
      <categories>
        <category>Unity Shader</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity Shader第二部分]]></title>
    <url>%2F2018%2F10%2F21%2FUnity-Shader-IntroductionToTopic1%2F</url>
    <content type="text"><![CDATA[光源在光学里，我们使用辐照度（irradiance）来量化光。对于平行光来说，它的辐照度可通过计算在垂直于l的单位平面上的单位时间内穿过的能量来得到。 吸收和散射光线由光源发射出来后，就会与一些物体相交。通常，相交的结构有两个：散射（scattering）和吸收（absorption）。散射只改变光线的方向，但不改变光线的密度和颜色。而吸收只改变光线的密度和颜色，但不改变光线的方向。 BRDF光照模型我们已经了解了光线在和物体表面相交时会发生哪些现象。当已知光源位置和方向、视角方向时，我们就需要知道一个表面是和光照进行交互的。例如，当光线从某个方向照射到一个表面时，有多少光线被反射？反射的方向有哪些？而BRDF（Bidirectional Reflectance Distribution Function）就是用来回答这些问题的。当给定模型表面上的一个点时，BRDF包含了对该点外观的完整的描述。在图形学种，BRDF大多使用一个数学公式来表示，并且提供了一些参数来调整材质属性。通俗来讲，当给定入射光线的方向和辐照度后，BRDK可以给出某个出射方向上的光照能量分布。本章涉及的BRDF都是对真实场景进行理想化和简化后的模型，也就是说，它们并不能真实地反映物体和光线之间地交互，这些光照模型被成为是经验模型。尽管如此，这些经验模型仍然在实时渲染领域被应用了多年。 标准光照模型基本方法是，把进入到摄像机的光线分为4部分，每个部分使用一种方法来计算它的贡献度 自发光(emissive) 高光反射(specular) 漫反射(diffuse) 环境光(ambient) 环境光在标准光照模型中，使用一种被称为环境光的部分来近似模拟间接光照。环境光的计算非常简单，它通常是一个全局变量，即场景中的所有物体都使用这个环境光。下面的等式给出了计算环境光的部分： $c_{ambient}=g_{ambient}$ 自发光光线也可以直接由光源发射进入摄像机，而不需要经过任何物体的反射。标准光照模型使用自发光来计算这个部分的贡献度。它的计算也很简单，就是直接使用了该材质的自发光颜色： $c_{emissive}=m_{emissive}$ 通常在实时渲染中，自发光的表面往往并不会照亮周围的表面，也就是说，这个物体并不会被当成一个光源。 漫反射漫反射光照是用于对那些被物体表面随机散射到各个方向的辐射度进行建模的。在漫反射中，视角的位置是不重要的，因为反射是完全随机的，因此可以认为在任何反射方向上的分布都是一样的。但是，入射光线的角度很重要。漫反射光照符合兰伯特定律（Lambert’s law）：反射光线的强度与表面发现和光源方向之间夹角的余弦值成正比。因此，漫反射部分的计算如下： $c_{diffuse} = (c_{light} \cdot m_{diffuse})max(0, n \cdot I)$ 高光反射这里的高光反射是一种经验模型，也就是说，它并不完全符合真实世界中的高光反射现象。它可用于计算那些沿着完全镜面反射方向被反射的光线，这可以让物体看起来是有光泽的，例如金属材质。计算高光反射需要知道的信息比较多，如表面法线、视角方向、光源方向、反射方向等。反射计算公式：$r = 2(\vec{n} \cdot I)\vec{n} - I$推导公式见Light Reflect这样，我们就可以利用Phong模型来计算高光反射的部分： $c_{spscular} = (c_{light} \cdot m_{specular})max(0, \vec{v} \cdot r)^{m_{glass}}$其中，$m_{gloss}$是材质的光泽度（gloss），也被称为反光度（shinness）。它用于控制高光区域的“亮点”有多宽，$m_{gloss}$越大，亮点就越小。$m_{spscular}$是材质的高光反射颜色，它用于控制该材质对于高光反射的强度和颜色。$c_{light}则是光源的颜色和强度。$ 逐像素还是逐顶点总结单张纹理实践纹理的属性凹凸映射高度纹理法线纹理实践法线纹理类型渐变纹理遮罩纹理实践其他遮罩纹理]]></content>
      <categories>
        <category>Unity Shader</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity Shader第一部分]]></title>
    <url>%2F2018%2F10%2F20%2FUnity-Shader-IntroductionToTopic%2F</url>
    <content type="text"><![CDATA[像素光 Pixel LightUnity中将平行光称作为像素光，第一个像素光是基础平行光，以LightMode=ForwardBase标签修饰，每多一个像素光都以LightMode=ForwardAdd标签修饰。并不是所有的光源在运行时都会反射到物体上，而是根据Project的Quality中设置的像素光数量来渲染的。默认的像素光的数量应该是2，我们有更多的平行光照在物体上，就需要在Edit-&gt;Project Setting-&gt;Quality中去调节像素光的数量Pixel Light Count当场景中的实际像素光数量超过这个设定值的时候，Unity只会渲染最重要的光。 关于像素光的叠加原理片段着色器是要将mesh组件传递的信息最终计算为颜色(或者深度)存储在帧缓存(Frame Buffer)中。每个Pass之间输出的颜色通过一定的公式进行混合。在这里我们简单使用一比一的模式进行颜色混合，即混合指令为： Blend One One 第二个Pass的代码同样的也直接复制第一个Pass即可，相应的将Tags标签中LightMode=ForwardBase修改为LightMode=ForwordAdd。 12345Shader &quot;Custom/Multi-Light Diffuse&quot; &#123; Properties &#123; // 材料颜色默认为黑色， &#125;&#125; 渲染流水线渲染流水线的工作任务在于由一个三维场景触发、生成（或者说渲染）一张二维图像。换句话说，计算机需要从一系列的顶点数据、纹理等信息出发，把这些信息最终转换成一张人眼可以看到的图像。而这个工作通常是由CPU和GPU共同完成的。《Render-Time Rendering, Third Edition》将一个渲染流程分成3个阶段：应用阶段(Application Stage)、几何阶段(Geometry Stage)、光栅化阶段(Rasterizer Stage)。 应用阶段（CPU处理）这一阶段是由开发者主导的，在这一阶段中开发都有3个主要的任务：首先，需要准备好场景数据（摄像机位置，视锥体，模型和光源等）接着，还需要做粗粒度的剔除工作最后，需要设置好每个模型的渲染状态（使用的材质，使用的纹理，使用的Shader等）这一阶段最重要的输出是渲染所需的几何信息，即渲染图元，渲染图元可以是点，线，三角面等。 几何阶段（GPU处理）几何阶段主要用于处理所有和我们绘制的几何相关的事情。几何阶段负责和每个渲染图元打交道，进行逐顶点，逐多边形的操作。这个阶段可以进一步分成更小的流水线阶段。几何阶段的一个重要任务就是把顶点坐标变换到屏幕空间中，再交给光栅器进行处理。总结：输入的渲染图元-&gt;屏幕空间的二维顶点坐标、每个顶点对应深度、着色等信息 光栅化阶段（GPU处理）将会使用上一个阶段传递的数据来产生屏幕上的像素，并渲染出最终的图像。主要任务是决定每个渲染图元中的那些像素应该被绘制在屏幕上。顶点着色器（Vertex Shader）是完全可编程的，它通常用于实现顶点的空间变换、顶点着色等功能。曲面细分着色器（Tessellation Shader）是一个可选的着色器，几何着色器（Geometry Shader）同样是一个可选的着色器，它可以被用于执行逐图元（Per-Pimitive）的着色操作，或者被用于产生更多的图元。下一个流水线是裁剪（Clipping），这一阶段的目的是将那些不在摄像机视野内的顶点裁剪掉，并剔除某些三角图元的面片。这个阶段是可配置的。例如，我们可以使用自定义的裁剪平面来配置裁剪区域，也可以通过指令控制裁剪三角图元的正面还是背面。几何概念阶段的最后一个流水线阶段是屏幕映射（Screen Mapping）。这一阶段是不可配置和编程的，它负责把每个图元的坐标转换到屏幕坐标系中。光栅化概念阶段中的三角形设置（Triangle Setup）和三角形遍历（Triangle Traversal）阶段也都是固定函数（Fixed-Function）的阶段。接下来的片元着色器（Fragment Shader），则是完全可编程的，它用于实现逐片元（Per-Fragment）的着色操作。最后，逐片元操作（Per-Fragment Operations）阶段负责执行很多重要的操作，例如修改颜色、深度缓冲、进行混合等，它不是可编程，但具有很高的可配置型。Unity内置的DiffuseShader,也就是说我们创建一个Material出来时默认的Shader也是多光源的，所以这篇文章完成的Shader与默认的diffuse shader基本效果一致。 CPU与GPU之间的通信渲染流水线的起点是CPU，即应用阶段。应用阶段可以分为下面3个阶段： 把数据加载到显存中 设置渲染状态 调用Draw Call 数据加载到显存中基本步骤就是纹理、网格等数据从硬盘加载到系统内存在加载到显存中。数据记载到显存后系统内存中的数据就可以被移除了，但是对于一些数据来说CPU需要访问他们，例如用于碰撞检测用的网格数据，这些数据则会被保留。 设置渲染状态渲染状态指的是场景中的网格是如何被渲染的，例如使用哪个Vertex Shader或者哪个Fragment Shader、光源属性、材质等。 调用Draw CallDraw Call指的是一个命令，发起方为CPU，接收方为GPU。当给定了一个Draw Call时，GPU会根据渲染状态（例如材质、纹理、着色器等）和所有输入的顶点数据 从应用程序阶段模型数据给顶点着色器时支持的语义 语义 描述 POSITION 模型空间的顶点位置，通常是float4类型 NORMAL 顶点法线，通常是float3类型 TANGENT 顶点切线，通常是float4类型 TEXCOORDn,如TEXCOORD0、TEXCOORD1 该顶点的纹理坐标，TEXCOORD0表示第一组纹理坐标，依次类推，通常是float2或float4类型 其中TEXCOORDn中的数目是和Shader Model有关的，例如一般在Shader Model 2(即Unity默认编译到的Shader Model版本)和Shader Model 3中，n等于8，而在Shader Model 4 和Shader Model 5中，n等于16.通常情况下，一个模型的纹理坐标数组一般不超过2，即我们往往只只用TEXCOORD0和TEXCOORD1。在Unity内置的数据结构体appdata_full中，它最多使用了6个坐标纹理。 从顶点着色器传递数据给片元着色器时的语义 语义 描述 SV_POSITION 裁剪空间中的顶点坐标，结构体中必须包含一个用该语义修饰的变量。等同于Direct9中的POSITION，但最好使用SV_POSITION COLOR0 通常用于输出第一组顶点颜色，但不是必须的 COLOR1 通常用于输出第二组顶点颜色，但不是必须的 TEXCOORD0~TEXCOORD7 通常用于输出纹理坐标，但不是必须的 上面的语义中，除了SV_POSITION是有特别含意外，其他语义对变量的含义没有明确要求，也就是说，我们可以存储任意值到这些描述变量中。 片元着色器输出时Unity支持的常用语义 语义 描述 点和矢量的区别点是一个没有大小之分的空间中的位置，而矢量是一个有模和方向但是没有位置的量。 齐次坐标对于一个点，从三维坐标转换成齐次坐标是把w分量设为1，而对于方向矢量来说，需要把w分量设为0。 平移矩阵我们可以使用矩阵乘法来表示对一个点进行平移变换： $\begin{bmatrix}{1}&amp;{0}&amp;{0}&amp;{t_{x}}\\{0}&amp;{1}&amp;{0}&amp;{t_{y}}\\{0}&amp;{0}&amp;{1}&amp;{t_{z}}\\{0}&amp;{0}&amp;{0}&amp;{1}\\\end{bmatrix}\begin{bmatrix}{x}\\{y}\\{z}\\{1}\\\end{bmatrix} =\begin{bmatrix}{x+t_{x}}\\{y+t_{y}}\\{z+t_{z}}\\{1}\\\end{bmatrix}$ 从结果来看我们可以很容易看出为什么这个矩阵有平移的效果：点的x、y、z分量分别增加了一个位置偏移。在3D中的可视化效果是，把点$(x,y,z)$在空间中平移了$(t_{x},t_{y},t_{z})$。如果我们对一个方向矢量进行平移变换，结果如下： $\begin{bmatrix}{1}&amp;{0}&amp;{0}&amp;{t_{x}}\\{0}&amp;{1}&amp;{0}&amp;{t_{y}}\\{0}&amp;{0}&amp;{1}&amp;{t_{z}}\\{0}&amp;{0}&amp;{0}&amp;{1}\\\end{bmatrix}\begin{bmatrix}{x}\\{y}\\{z}\\{0}\\\end{bmatrix} =\begin{bmatrix}{x}\\{y}\\{z}\\{0}\\\end{bmatrix}$可以发现，平移变换不会对方向矢量产生任何影响。因为矢量没有位置属性，也就是说它可以位于空间中的任意一点，因此对位置的改变不应该对四维矢量产生影响。 缩放矩阵我们可以对一个模型沿空间的x轴、y轴和z轴进行缩放。 $\begin{bmatrix}{k_{x}}&amp;{0}&amp;{0}&amp;{0}\\{0}&amp;{k_{y}}&amp;{0}&amp;{0}\\{0}&amp;{0}&amp;{k_{z}}&amp;{0}\\{0}&amp;{0}&amp;{0}&amp;{1}\\\end{bmatrix}\begin{bmatrix}{x}\\{y}\\{z}\\{1}\\\end{bmatrix} =\begin{bmatrix}{k_{x}x}\\{k_{y}y}\\{k_{z}z}\\{1}\\\end{bmatrix}$ 如果缩放系数$k_{x}=k_{y}=k_{z}$，我们把这样的缩放称为统一缩放（uniform scale），否则称为非同一缩放（nonuniform scale）。从外观看，统一缩放是扩大整个模型，而非同一缩放会拉伸或挤压模型。更重要的是，统一缩放不会改变角度和比例信息。 复合变换在绝大多数情况下，我们约定变换的顺序就是先缩放，再旋转，最后平移。变换矩阵如下：(注意，矩阵是从右往左算的)$M_{translation}M_{rotation}M_{scale} =\begin{bmatrix}{1}&amp;{0}&amp;{0}&amp;{t_{x}}\\{0}&amp;{1}&amp;{0}&amp;{t_{y}}\\{0}&amp;{0}&amp;{1}&amp;{t_{z}}\\{0}&amp;{0}&amp;{0}&amp;{1}\\\end{bmatrix}$当我们直接给出$(\theta_{x}, \theta_{y}, \theta_{z})$这样的旋转角度时，需要定义一个旋转顺序。在Unity中，这个旋转顺序是zxy。 顶点的坐标空间变化在渲染流水线中，一个顶点要经过多个坐标空间的变换才能最终被画在屏幕上。一个顶点最开始是在模型空间中定义的，最后它将会变换到屏幕空间中，得到真正的屏幕像素坐标。 模型空间模型空间（model space），是和某个模型或者说是对象有关的。有时模型空间也被称为对象空间（object space）或局部空间（local space）。每个模型都有自己独立的坐标空间，当它移动或旋转的时候，模型空间也会跟着它移动和旋转。顶点变换的第一步，就是将顶点坐标从模型空间变换到世界空间中。这个变换通常叫做模型变换（model transform）。 世界空间顶点变换的第一步，就是将顶点坐标从模型空间变换到世界空间中。这个变换通常叫做模型变换（model transform）。变换矩阵如下：$M_{model} = \begin{bmatrix}{1}&amp;{0}&amp;{0}&amp;{t_{x}}\\{0}&amp;{1}&amp;{0}&amp;{t_{y}}\\{0}&amp;{0}&amp;{1}&amp;{t_{z}}\\{0}&amp;{0}&amp;{0}&amp;{1}\\\end{bmatrix}\begin{bmatrix}{cos\theta}&amp;{0}&amp;{sin\theta}&amp;{0}\\{0}&amp;{1}&amp;{0}&amp;{0}\\{-sin\theta}&amp;{0}&amp;{cos\theta}&amp;{0}\\{0}&amp;{0}&amp;{0}&amp;{1}\\\end{bmatrix}\begin{bmatrix}{k_{x}}&amp;{0}&amp;{0}&amp;{0}\\{0}&amp;{k_{y}}&amp;{0}&amp;{0}\\{0}&amp;{0}&amp;{k_{z}}&amp;{0}\\{0}&amp;{0}&amp;{0}&amp;{1}\\\end{bmatrix} =\begin{bmatrix}{k_{x}cos\theta}&amp;{0}&amp;{k_{z}sin\theta}&amp;{t_{x}}\\{0}&amp;{k_{y}}&amp;{0}&amp;{t_{y}}\\{-k_{x}sin\theta}&amp;{0}&amp;{k_{z}cos\theta}&amp;{-t_{z}}\\{0}&amp;{0}&amp;{0}&amp;{1}\\\end{bmatrix}$注意：上述变换顺序是不能互换的，即先进行缩放，在进行旋转，最后是平移。 观察空间观察空间（view space）也被称为摄像机空间（camera space）。顶点变换的第二步，就是将顶点坐标从世界空间变换到观察空间中。这个变换叫做观察变换（view transform）。 裁剪空间裁剪空间（clip space，也称齐次裁剪空间），这个用于变换的矩阵叫做裁剪矩阵（clip matrix），也称为投影矩阵（projection matrix）。裁剪空间的目标是能够方便地对渲染图元进行裁剪：完全位于这块空间内部的图元将会被保留，完全位于这块空间外部的图元将会被剔除，而与这块空间边界相交的图元就会被裁剪。这块空间是由视锥体来决定的。视锥体指的是空间中的一块区域，这块区域决定了摄像机可以看到的空间。视锥体由六个平面包围而成，这些平面也被称为裁剪平面（clip planes）。视锥体有两种类型，一种是正交投影（orthographic projection），一种是透视投影（perspective projection）。在视锥体的6块裁剪平面中，有两块裁剪平面比较特殊，它们分别被称为近裁剪平面（near clip plane）和远裁剪平面（far clip plane）。它们决定了摄像机可以看到的深度范围。 透视投影视锥体的意义在于定了场景中的一块三维空间。所有位于这块空间内的物体将会被渲染，否则就会被剔除或裁剪。这块区域是由6个裁剪平面组成，在Unity中，它们由Camera组件中的参数和Game视图中横纵比共同决定Camera组件的Field of View（简称FOV）属性来改变视锥体竖直方向的张开角度，而Clipping Planes中的Near和Far参数可以控制视锥体的近裁剪面和远裁剪面距离相机的远近。这样，我们可以求出视锥体近裁剪面和远裁剪面的高度 $nearClipPlaneHeight = 2 \cdot Near \cdot tan {FOV \over 2}$ $farClipPlaneHeight = 2 \cdot Far \cdot tan {FOV \over 2}$ 透视投影的横向信息，可以通过相机的横纵比得到。在Unity中，一个摄像机的横纵比由Game视图的横纵比和Viewport Rect中的W和H属性共同决定（实际上，Unity允许我们在脚本里通过Camera.aspect进行更改）。假设，当前相机的横纵比为Aspect，则： $Aspect = {nearClipPlaneWidth \over nerClipPlaneHeight}$ $Aspect = {farClipPlaneWidth \over farClipPlaneHeight}$ 现在，我们可以根据已知的Near、Far、FOV和Aspect的值来确定透视投影的投影矩阵。如下： $M_{frustum} = \begin{bmatrix}{cot{FOV \over 2} \over Aspect}&amp;{0}&amp;{0}&amp;{0}\\{0}&amp;{cot{FOV \over 2}}&amp;{0}&amp;{0}\\{0}&amp;{0}&amp;{-{Far+Near \over Far-Near}}&amp;{-{2 \cdot Far \cdot Near \over Far-Near}}\\{0}&amp;{0}&amp;{-1}&amp;{0}\\\end{bmatrix}$这里针对的是观察空间是右手坐标系，使用列矩阵在矩阵右侧相乘的，且变换后z分量范围在[-w,w]之间的情况。而一个顶点和上述投影矩阵相乘后，可以由观察空间变换到裁剪空间中，结果如下$P_{clip} = M_{frustum}P_{view} =\begin{bmatrix}{cot{FOV \over 2} \over Aspect}&amp;{0}&amp;{0}&amp;{0}\\{0}&amp;{cot{FOV \over 2}}&amp;{0}&amp;{0}\\{0}&amp;{0}&amp;{-{Far+Near \over Far-Near}}&amp;{-{2 \cdot Far \cdot Near \over Far-Near}}\\{0}&amp;{0}&amp;{-1}&amp;{0}\\\end{bmatrix}\begin{bmatrix}{x}\\{y}\\{z}\\{1}\\\end{bmatrix}=\begin{bmatrix}{x{cot{FOV \over 2} \over Aspect}}\\{y{cot{FOV \over 2}}}\\{-z{Far+Near \over Far-Near}-{2 \cdot Near \cdot Far \over Far-Near}}\\{-z}\\\end{bmatrix}$从这个结果来看，这个投影矩阵本质就是对x、y和z分量进行了不同程度的缩放（z分量还有一个平移），缩放的目的是为了方便裁剪。此时顶点的w分量不再是1，而是原先z分量的取反结果。现在，我们就可以按如下不等式来判断一个变换后的顶点是否位于视锥体内。如果一个顶点在视锥体内，那么它变换后的坐标必须满足：$-w \le x \le w$$-w \le y \le w$$-w \le z \le w$任何不满足上述条件的图元都需要被剔除或者裁剪。下图显示了经过上述投影矩阵后，视锥体的变化。从上图还可以注意到，裁剪矩阵会改变空间的旋向行；空间从右手坐标系变换到了左手坐标系。这意味着，离摄像机越远，z值将越大。 正交投影 正交投影的6个裁剪面和透视投影类似，在Unity中，它们也是由Camera组件中的参数和Game视图的横纵比共同决定。正交投影的视锥体是一个长方体，因此计算上相比透视投影来说更加简单。由图可以看出，我们可以通过Camera组件的Size属性来改变视锥体竖直方向上高度的一般，而Clipping Planes中的Near和Far参数可以控制视锥体的近裁剪面和远裁剪面距离相机的远近。这样，可以求出视锥体近裁剪面和远裁剪面的高度，也就是：$newClipPlaneHeight=2 \cdot Size$$farClipPlaneHeight=nearClipPlaneHeight$ 现在我们还缺乏横向的信息。同样，我们可以通过摄像机的横纵比得到。假设，当前摄像机的横纵比为Aspect，那么：$nearClipPlaneWidth=Aspect \cdot nearClipPlaneHeight$$farClipPlaneWidth=nearClipPlaneWidth$现在，我们可以根据已知的Near、Far、Size和Aspect的值来确定正交投影的裁剪矩阵。如下：$M_{prtho} =\begin{bmatrix}{1 \over Aspect \cdot Size}&amp;{0}&amp;{0}&amp;{0}\\{0}&amp;{1 \over Size}&amp;{0}&amp;{0}\\{0}&amp;{0}&amp;{-{2 \over Far-Near}}&amp;{-{Far+Near} \over {Far-Near}}\\{0}&amp;{0}&amp;{0}&amp;{1}\\\end{bmatrix}$ 屏幕空间经过投影矩阵的变换后，我们可以进行裁剪操作。当完成了所有的裁剪工作后，就需要进行真正的投影了，也就是说，我们需要把视锥体投影到屏幕空间（screen space）中。经过这一步变换，我们会得到真正的像素位置，而不是虚拟的三维坐标。屏幕空间是一个二维空间，因此，我们必须把顶点从裁剪空间投影到屏幕空间中，来生成对应的2D坐标。这个过程可理解成有两个步骤。首先，我们需要进行标准齐次除法（homogeneous division），也被称为透视除法（perspective division）。虽然这个步骤听起来很陌生，但是它实际上非常简单，就是用齐次坐标系的w分量去除以x、y、z分量。在OpenGL中，我们把这一步得到的坐标叫做归一化的设备坐标（Normalized Device Coordinates，NDC）。经过这一步，我们可以把坐标从齐次裁剪坐标空间转换到NDC中。经过透视投影变换后的裁剪空间，经过齐次除法会变换到一个立方体内。按照OpenGL的传统，这个立方体的x、y、z分量的范围都是[-1,1]。但在DirectX这样的API中，z分量的范围会是[0,1]。而Unity选择了OpenGL这样的齐次裁剪空间。 一个最简单的顶点/片元着色器顶点/片元着色器的基本结构Unity Shader的基本结构包含了Shader、Properties、SubShader、Fallback等语义块。顶点/片元着色器的结构与之大体类似，它的结构如下： 123456789101112131415161718192021222324252627282930Shader &quot;MyShaderName&quot; &#123; Properties &#123; // 属性 &#125; SubShader &#123; // 针对显卡A的SubShader Pass &#123; // 设置渲染状态和标签 // 开始CG代码片段 CGPROGRAM // 该片段的编译指令，例如: #pragma vertex vert #pragma fragment frag // CG代码写在这里 ENDCG // 其他设置 &#125; // 其他需要的Pass &#125; SubShader &#123; // 针对显卡B的SubShader &#125; // 上述SubShader都失败后用于回调的Unity Shader Fallback &quot;VertexLit&quot;&#125; 其中，最重要的部分是Pass语义块，我们绝大部分的代码都是写在这个语义块里面的。下面我们就来创建一个最简单的顶点/片元着色器。1234567891011121314151617Shader "Shader/Simple" &#123; SubShader &#123; Pass &#123; CGPROGRAM #pragma vertex vert #pragma fragment frag float4 vert(float4 v : POSITION) : SV_POSITION &#123; return UnityObjectToClipPos(v); &#125; fixed4 frag() : SV_Target&#123; return fixed4(1.0, 1.0, 1.0, 1.0); &#125; ENDCG &#125; &#125;&#125; 12345678910111213141516Shader "Shader/Simple1"&#123; SubShader&#123; Pass&#123; CGPROGRAM #pragma vertex vert #pargma fragment frag // 使用一个结构体来定义顶点着色器的输入 struct a2v &#123; // POSITION语义告诉Unity，用模型空间的顶点坐标填充vertex变量 float4 vertex : POSITION; &#125; ENDCG &#125; &#125;&#125; 模型数据从哪里来顶点着色器和片元着色器之间如何通信如何使用属性Unity提供的内置文件和变量内置的包含文件内置的变量Unity提供的CG/HLSL语义Unity支持的语义 语义 描述 POSITION 模型空间的顶点位置，通常是float4类型 NORMAL 顶点法线，通常是float3类型 TANGENT 顶点切线，通常是float4类型 $TEXCOORD_{n}$，如TEXCOORD0、TEXCOORD1 该顶点的纹理坐标，TEXCOORD0表示第一组纹理坐标，依此类推。通常是float2或float4类型 COLOR 顶点颜色，通常是fixed4或float4类型 如何定义复杂的变量类型使用假彩色图形float、half还是fixed在本书中，我们使用CG/HLSL来编写Unity Shader中的代码。而在CG/HLSL中，有3中精度的数值类型：float、half和fixed。这些精度将决定计算结果的数值范围。表5.8给出了这3中精度在通常情况下的数值范围。 CG/HLSL中3种精度的数值类型 类型 精度 float 最高精度的浮点值。通常使用32位来存储 half 中等精度的浮点值。通常用16位来存储，精度范围是-60000~+60000 fixed 最低精度的浮点值。通常使用11位来存储，精度方位是-2.0~+2.0]]></content>
      <categories>
        <category>Unity Shader</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity Shader Manual]]></title>
    <url>%2F2018%2F10%2F15%2FUnity-Shader-Manual%2F</url>
    <content type="text"><![CDATA[Properties123456789101112Shader &quot;ShaderLab Tutorials/TestShader&quot;&#123; Properties &#123; _Range (&quot;My Range&quot;, Range(0.02, 0.15)) = 0.07 // sliders _Color (&quot;My Color&quot;, Color) = (.34, .85, .92, 1) // color _2D (&quot;My Texture 2D&quot;, 2D) = &quot;&quot; &#123;&#125; // texture _Rect (&quot;My Rectangle&quot;, Rect) = &quot;name&quot; &#123;&#125; _Cube (&quot;My Cubemap&quot;, Cube) = &quot;name&quot; &#123;&#125; _Float (&quot;My Float&quot;, Float) = 1 _Vector (&quot;My Vector&quot;, Vector) = (1,2,3,4) &#125;&#125; Shader在Unity编辑器暴露给美术的参数，通过Properties来实现。 所有可能的参数如上所示。主要也就是Float、Vector和Texture这3类。 除了通过编辑器编辑Properties，脚本也可以通过Material的接口（比如SetFloat、SetTexture编辑） 之后的Shader程序通过[name]（固定管线）或者直接name（可编程Shader）访问这些属性。 在每一个Property前面也能类似C#那样添加Attribute，以达到额外UI功能。详见SemanticsSubShaderTags{“TagName1”=”Value1” “TagName2”=”Value2”}Tag的语法结构，通过Tags{}来表示需要添加的标识，大括号可以添加多组Tag（所以才叫Tags嘛），名称(TagName)和值（Value）是成对出现的，并且全部用字符串表示。 Queue渲染队列直接影响性能中的重复绘制，合理的队列可极大的提升渲染效率。渲染队列数目小于2500的对象都被认为是不透明的物体（从前往后渲染），高于2500的被任务是半透明物体（后后往前渲染）。“Queue”=”Geometry+1”可通过值后加数字的方式来改变队列。 Queue标签 解释 “Queue”=”Background” 值为1000，此队列的对象最先进行渲染 “Queue”=”Geometry” 默认值，值为2000，通常用于不透明对象，比如场景中的物体与角色等 “Queue”=”AlphaTest” 值为2450，要么完全透明要么完全不透明，多用于利用贴图来实现边缘透明的效果，也就是美术常说的透贴 “Queue”=”Transparent” 值为3000，常用于半透明对象，渲染时从后往前进行渲染，建议需要混合的对象放入此队列 “Queue”=”Overlay” 值为4000，此渲染队列用于叠加选过。最后渲染的东西应该放在这里（例如镜头光晕等） RenderType用来区分这个Shader要渲染的对象是属于什么类型的，你可以想象成事我们把不同的物体按我们需要的类型来进行分类一样。当然你也可以根据需要改成自定义的名称，这样并不会影响到Shader的选过。此Tag多用于摄像机的替换材质功能（Camera.SetReplacementShader）。 标签 释义 “RenderType”=”Opaque” 大多数不透明着色器 “RenderType”=”Transparent” 大多数半透明着色器，比如粒子、特效、字体等。 “RenderType”=”TransparentCutout” 透贴着色器，多用于植被等。 “RenderType”=”Background” 多用于天空盒着色器。 “RenderType”=”Overlay” GUI、光晕着色器等。 “RenderType”=”TreeOpaque” Terrain地形中的树干。 “RenderType”=”TreeTransparentCutout” Treeain地形中的树叶。 “RenderType”=”TreeBillboard” Terrain地形中的永对面树。 “RenderType”=”Grass” Terrain地形中的草。 “RenderType”=”GrassBillboard” Terrain地形中的用对面草。 指定RenderType的名称，主要是为了配合使用替代渲染的方法。 Camera.SetReplacementShader(&quot;shader&quot;, &quot;RenderType&quot;) DisableBatching在利用Shader在模型的定点本地坐标下做一些位移动画，而当此模型有批处理时会出现效果不正确的情况，这是因为批处理将所有模型转换为世界坐标空间，因为”本地坐标空间”将丢失。 批处理标签 解释 “DisableBatching”=”True” 禁止批处理 “DisableBatching”=”False” 不禁用批处理 Mathdot(a,b)点乘，a和b必须为三维向量或者四维向量，其计算结果是两个向量夹角的余弦值，相当于a.x*b.x+a.y*b.y+a.z*b.za和b的位置无所谓前后，结果都是一样的 Miscellaneousfloat3 objCenterPos = mul(unity_ObjectToWorld, float4(0,0,0,1)).xyz; 在Shader中获取当前模型的中心点，其实就是将(0,0,0)点从本地坐标转换到世界空间坐标下即可。 内置函数 Name Syntax 参数释义 Description abs abs(x) Absolute value (per component)(每个组件). acos acos(x) Returns the arccosine(反余弦) of each component of x. ceil ceil(x) Returns the smallest integer(最小整数) which is greater(大于) than or equal to x. clip clip(x) Discards(抛弃) the current pixel,if any component of x is less than zero. cross cross(x,y) x向量和y向量的向量积（差积） lerp lerp(x,y,s) Returns x + s(y-x) noise noise(x) Generates a random value using the Perlin-noise algorithm. pow pow(x,y) Returns $x^y$ saturate saturate(x) x: 为用于操作的标量或矢量，可以是float、float2、float3等类型。 把x截取在[0,1]范围内，如果x是一个矢量，那么会对它的每一个分量进行这样的操作。 smoothstep smoothstep(min,max,x) 如果x比min小，返回0；如果x比max大，返回1；如果x处于范围[min,max]中，则返回0和1之间的值（返回值在min和max间的比例）。 step step(a,b) Returns (b&gt;=a)?1:0 (一般用这个取代if else) tex2D tex2D(s, t) 2D texture lookup. reflect reflect(I,N) 根据入射光方向向量I，和顶点法向量N，计算反射光方向向量。其中I和N必须被归一化，需要非常注意的是，这个I是指向顶点的；函数只对三元向量有效]]></content>
      <categories>
        <category>Unity Shader</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TSF4G]]></title>
    <url>%2F2018%2F09%2F21%2FTSF4G%2F</url>
    <content type="text"><![CDATA[https://github.com/johnnyluo586/TSF4G.git Tbus简介Tbus是tsf4g(Tencent ServiceFramework for Game,腾讯游戏服务框架)中的基础组件之一，主要的目的是为上层业务提供统一的线程或进程间通信接口，屏蔽本地进程间通信以及远程进程通信的细节，让开发人员可以集中精力关注业务逻辑，是tsf4g重要组成部分。 Tbus原理 Tbus基于共享内存构建无锁双通循环消息队列，发送的双方通过专用的读写队列完成数据收发，实现本地进程或者远程进程间通信。通信双方使用的两个队列称之为tbus通道(channel)，每一组通讯的双方就需要有一个tbus通道。 进程A发送消息后，消息被存储到Host A的发送队列中，部署于Host A的tbusd发现队列中存在消息，则从队列中把消息取出，通过tcp发送到Host B上。Host B上的tbusd接收到消息后，把消息写入本地的接收队列，以供进程B读取。 为了能完成通信，Tbus还有以下几个特点： 通信双方具备全局唯一的tbus通信地址，该地址是一个点分十进制的字符串，与IP地址类型，总长度为32bit，分为4段，每段bit位数可以自定义，总长度不超过32bit。例如：128.1.100.1,5.0.200.1。 Tbus通道以及消息是存储在共享内存中，必须要使用相应的工具提前创建，进程才能绑定与使用。而当业务进程异常退出后，由于消息是存储在共享内存中，只要不主动清理共享内存、重启服务器或损坏共享内存，通道的消息就不会丢失。]]></content>
      <tags>
        <tag>Server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity-Lua-Manual]]></title>
    <url>%2F2018%2F09%2F18%2FUnity-Lua-Manual%2F</url>
    <content type="text"><![CDATA[GameObjectGO_namegameObject.GO_name = &quot;name&quot; 设置或者获取游戏对象的名字 GO_selfgameObject.GO_self 绑定到自己身上的Lua模块指针 GO_activegameObject.GO_active = true/false 设置游戏对象的显式或者隐藏 GO_parentgameObject.GO_parent = parent 设置游戏对象的父节点 GO_childCountgameObject.GO_childCount 获取游戏对象的子节点对象，不递归 GO_AddComponentgameObject:GO_AddComponent(“UILabel&quot;) 给游戏对象添加组件 GO_GetComponentgameObject:GO_GetComponent(&quot;UILabel&quot;) gameObject:GO_GetComponent(&quot;UILabel&quot;, &quot;Sprite/Label&quot;) 方法一：获取游戏对象的组件方法二：获取子节点上的组件，参数二表示相对于父节点的路径 GO_FindgameObject:GO_Find(&quot;Sprite/Label&quot;) 获取子节点对象 GO_AddChildgameObject:GO_AddChild(&quot;UI/ui_node&quot;) gameObject:GO_AddChild(ui_node) 方法一：通过相对于Resources下的路径来给游戏对象添加子节点方法二：通过实例对象来给游戏对象添加子节点如果是UI节点，请使用UI_AddChild UI_AddChildgameObject:UI_AddChild(&quot;UI/ui_node&quot;) gameObject:UI_AddChild(ui_node) 方法一：通过相对于Resources下的路径来给游戏对象添加子节点方法二：通过实例对象来给游戏对象添加子节点 GO_DelChildgameObject:GO_DelChild(idx) 删除游戏对象的子节点，idx是下标从0开始的索引（顺序是检视面板显示的顺序） GO_DestroySelfgameObject:GO_DestroySelf() 销毁自己 GO_RemoveAllChildrengameObject:GO_RemoveAllChildren() 销毁所有的子节点 GO_ShowAllChildrengameObject:GO_ShowAllChildren(ture/false) 显示或者隐藏自己所有的子节点 GO_GetLocalPositionlocal x,y,z = gameObject:GO_GetLocalPosition() 获取自己的localPosition GO_SetLocalPositiongameObject:GO_SetLocalPosition(x,y [,z]) 设置自己的localPosition,[] 表示可选参数,当未指定时表示使用之前的z GO_GetLocalRotationlocal x,y,z = gameObject:GO_GetLocalRotation() 获取自己的localRotation GO_SetLocalRotationgameObject:GO_SetLocalRotation(x,y [,z]) 设置自己的localRotation,[]表示可选参数,当未指定时表示使用之前的z GO_SetLocalScalegameObject:GO_SetLocalScale(x,y,z) 设置自己的localScale GO_UpdateAllAnchorsgameObject:GO_UpdateAllAnchors() 手动刷新自身的锚点 UI_activegameObject.UI_active = true/false 递归刷新自己和子节点的显示和隐藏，如无特殊要求请使用GO_active UI_onClickgameObject.UI_onClick = function() end 添加点击事件，游戏对象需要添加boxcollider2D UIToggle_onChangegameObject.UIToggle_onChange = function() end 添加Toggle状态改变的回调函数，游戏对象需要添加UIToggle UILabel_textgameObject.UILabel_text = &quot;Hello, World!&quot; 设置或者读取游戏对象的UILabel文本，游戏对象需要添加UILabel UILabel_colorgameObject.UILabel_color = Color.FromHex(&quot;C4C4C4FF&quot;) 设置或者读取文本颜色，返回值是Color UISprite_spriteNamegameObject.UISprite_spriteName = &quot;btn_blue&quot; 设置或者读取精灵的名字，游戏对象需要添加UISprite组件 UISprite_colorgameObject.UISprite_color = Color.FormHex(&quot;6f4f3fff&quot;) 设置或者读取精灵的颜色，游戏对象需要添加UISprite组件 UIToggle_valuegameObject.UIToggle_value = true/false 设置UIToggle的值 UIWidget_colorgameObject.UIWidget_color = Color.FormHex(&quot;6f4f3fff&quot;) 设置UIWidget或者继承他的子类（UILabel,UISprite)的颜色 UIWidget_widthgameObject.UIWidget_width = 100 设置UIWidget或者继承他的子类（UILabel,UISprite)的宽度 UIWidget_heightgameObject.UIWidget_height = 100 设置UIWidget或者继承他的子类的高度 UIGrid_RepositiongameObject:UIGrid_Reposition() 使Grid重新排序，一般给Grid添加了子节点后使用 Tween_PlaygameObject:Tween_Play() 播放Tween动画 MBMB.LogMB.Log(&quot;Hello,World!&quot;) 打印日志 MB.PCallMB.PCall(function() end) 安全的调用函数，当函数内部发生错误的时候，不会中断当前执行环境 MB.LoadModuleMB.LoadModule(&quot;ui_task&quot;) 加载一个lua模块 MB.ShowTheTipMB.ShowTheTip(&quot;Hello,World!&quot;, 2) 弹出Tips，第二个参数表示时长单位是秒 String.CSFormatString.CSFormat(&quot;id={0},name={1}&quot;,10,&quot;test&quot;) 调用C#的格式化函数 MB.GetStringXMB.GetStringX(bytes[], 10, &quot;test&quot;) 调用C#的格式化函数，第一个参数是byte数组，一般来说表格中的字段用它 MB.GetExcelListMB.GetExcelList(&quot;NewTaskResConf&quot;) 读取表格 MB.GO_GetResourceself.u_testSprite.atlas = MB.GO_GetResource(&quot;UI/01Common&quot;) 获取资源 参数表示相对于Resources的路径，返回的是GameObject UITextureSetTexturePathtexture:SetTexturePath(&quot;Texture/UI/Chapter1&quot;) 设置texture的资源路径，路径相对于Resources，texture是通过gameObject获取的组件 SetMattexture:SetMat(path) 设置texture的材质，path表示相对Resources路径 UILabletextlabel.text = &quot;Hello, World！&quot; 设置或者读取Label的文本 colorlabel.color = Color.FromHex(&quot;6F4F3FFF&quot;) 设置或者读取Label的颜色 effectColorlabel.effectColor = Color.FromHex(&quot;6F4F3FFF&quot;) 设置或者读取Label的效果颜色 fontSizelabel.fontSize = 20 设置或者读取字体的大小 UISpritespriteNamesprite.spriteName = &quot;btn_red&quot; 设置或者读取Sprite的名字（图集中的） widthsprite.width = 100 设置或者读取Sprite的宽度 heightsprite.height = 100 设置或者读取Sprite的高度 atlassprite.atlas = MB.GO_GetResource(&quot;UI/01Common&quot;) 设置或者读取图集 LuaEventC#中 LuaEvent.CallEvent((int)eLuaEvnet.eLuaEvent_PlayerTaskUpdate, param1, param2, param3); lua中 lua_event.InvokeEvent(lua_def.eLuaEvent_PlayerTaskUpdate, param1, param2, param3) lua_event.InsertEvent(lua_def.eLuaEvent_PlayerTaskUpdate, callback, name, 0) function callback(param1, param2, param3) end CallEvent表示C#事件通知LuaInvokeEvent表示Lua事件通知LuaLuaEvent.CallEvent中的第一个参数表示类型在obj_def.cs中定义，后面是需要传递给lua的参数 lua_netSendBinlua_net.SendBin(lua_def.CS_CMD_GET_TASK_LIST_REQ, {Page = 1, Type = 4}, callback) function callback(msg) end 发送二进制包，第一个参数是消息ID，第二个参数是相对于数据结构类型，callback是回调函数，可选类型回调函数中的msg表示一个json的xml中结构。 Sendlua_net.Send(lua_def.eCTS_UI_Task, {op = &quot;get&quot;}) 发送JSON包，第一个参数是cts_def.cs中定义的消息，第二个参数是lua table Registerlua_net.Register(lua_def.eSTC_UI_Task, OnUITaskHandle, signal, -1) function OnUITaskHandler(msg) end lua_net.Register(lua_def.CS_CMD_GET_TASK_LIST_RES, OnGetTaskListRes, signal, -1) function OnGetTaskListRes(msg) -- msg是xml生成的数据结构，传到lua里面是一个json table end 注册一个消息回调，signal表示一个回调的唯一句柄，-1表示调用该回调函数的顺序，默认是0 lua_timerlua_timer.Timer(self.gameObject, span, onTick, count, name) — 创建Timer对象— go : 指定挂到某个gameObject上— span : 时间间隔，毫秒— onTick : 回调函数(timer, dt)，回调的dt参数是超时的时间，一般也用不上— count : 重复次数，缺省是1，如果是-1则无限循环。— return : 返回一个lua table作为Timer]]></content>
  </entry>
  <entry>
    <title><![CDATA[luajit]]></title>
    <url>%2F2018%2F09%2F10%2Fluajit%2F</url>
    <content type="text"><![CDATA[JIT = Just In TimeIOS中禁止使用（不让自主申请内存） 解释执行： 效率低 代码暴露 静态编译 不够灵活，无法热更新 平台兼容性差 JIT： 效率：高于解释执行，低于静态编译。 安全性：一般都先转换成字节码 热更新：无论源码还是字节码本质都是自愿文件。 兼容性：虚拟机会处理平台差异，对用户透明。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Andorid NDK]]></title>
    <url>%2F2018%2F07%2F21%2FAndroid-NDK%2F</url>
    <content type="text"><![CDATA[JNIJNI的全称是Java Native Interface，Java原生接口。提供别的代码调用的一组函数。首先使用C++写出了一些函数，然后将这些函数在Java类中再声明一次（加上关键字native），这样Java类中的函数和C++中的函数就匹配到一起了，我们使用Java类中的函数，其实就是使用C++中的函数。这个在Java类中声明的函数就是一个JNI。 NDKNDK的全称是Native Development Kit，原生开发工具包。 交叉编译交叉编译就是在一个平台上生成另一个平台上的可执行代码。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidManifest.xml详解]]></title>
    <url>%2F2018%2F07%2F21%2FAndroidManifest%2F</url>
    <content type="text"><![CDATA[为应用的JAVA软件包命名。软件包名称充当应用的唯一标识符 描述应用的各个组件，包括构成应用的Activity、服务、广播接收器和内容提供程序。它还为实现每个组件的类命名并发布其功能，例如它们可以处理Intent消息。这些声明向Android系统告知有关组件以及可以启动这些组件的条件的信息。 确定托管应用组件的进程。 声明应用必须具备哪些权限才能访问API中受保护的部分并与其他应用交互。还声明其他应用与该应用组件交互所需具备的权限。 列出Instrumentation类，这些类可在应用运行时提供分析和其他信息。这些声明只会在应用处于开发阶段时出现在清单中，在应用发布之前会将移除。 声明应用所需的最低Android API级别。 列出应用必须链接到的库 元素首先，所有的xml都必须包含元素。这是文件的根节点。它必须要包含元素，并且指明xmlns:android和package属性。 xmlns:android这个属性定义了Android命名空间。必须设置成”http://schemas.android.com/apk/res/android&quot;。不要手动修改。 package这是一个完整的Java语言风格包名。包名由英文字母（大小写均可）、数字和下划线组成。每个独立的名字必须以字母开头。 构建APK的时候，构建系统使用这个属性来做两件事： 生成R.java类时用这个名字作为命名空间（用于访问APP的资源）比如：package被设置成net.pixelgame.unity3d android:name该属性以字符串形式指定了APP要用的硬件或软件功能。 android:required andorid:glEsVersion 元素 此元素描述了应用的配置。这是一个必备的元素，它包含了很多子元素来描述应用的组件，它的属性影响到所有的子组件。许多属性]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Protocol Buffer]]></title>
    <url>%2F2018%2F07%2F21%2FProtocol%2F</url>
    <content type="text"><![CDATA[高效的二进制方式存储Varint是一种紧凑的表示数字的方法。它用一个或多个字节来表示一个数字，值越少的数字使用越少的字节数。采用这种Key-Pair结构无需使用分隔符来分割不同的Field。 Type Meaning Used For 0 Varint int32,int64,uint32,uint64,sint32,sint64,bool,enum 1 64-bit fixed64 sfixed64,double 2 Length-delimi string,bytes,embedded messages,packed repeated fields 3 Start group Groups(deprecated) 4 End group Groups(deprecated) 5 32-bit fixed32,sfixed32,float 在计算机内，一个负数一般会被表示一个很大的整数，因为计算机定义负数的符号位为数字的最高位。如果采用Varint表示一个负数，那么一定需要5个byte。为此Google Protocol Buffer定义了sint32这种类型，采用zigzag编码。 Zigzag编码用无符号来表示有符号数字，正数和负数交错，这就是zigzag这个词的含义了。 使用zigzag编码，绝对值小的数字，无论正负都可以采用较少的byte来表示，充分利用了Varint这种技术。 其他的数据类型，比如字符串则采用类似数据库中的varchar的表示方法，即用一个varint表示长度，然后其余部分紧跟在这个长度部分之后即可。 封解包的速度首先来了解一下XML的封解包过程。XML需要从文件中读取字符串，再转换为XML文档对象结构模型。之后，再从XML文档对象结构模型中读取指定节点的字符串，最后再将这个字符串转换成指定类型的变量。这个过程非常复杂，其中将XML文件转换为文档对象结构模型的过程通常需要完成词法文法分析等大量消耗CPU的复杂计算。 反观Protobuf，它只需要简单地将一个二进制序列，按照指的格式读取到C++对应的结构类型中就可以了。从上一节的描述可以看到消息的decoding过程也可以通过几个位移操作组成的表达式计算即可完成。速度非常快。 T-L-V的数据存储方式Tag-Lenght-Value,标识-长度-字段值存储方式 标识-长度-字段值表示单个数据，最终将所有数据拼接成一个字节流，从而实现数据存储的功能 其中Length可选存储，如存储Varint编码数据就不需要存储Length]]></content>
  </entry>
  <entry>
    <title><![CDATA[CameraEditor]]></title>
    <url>%2F2018%2F07%2F11%2FCameraEditor%2F</url>
    <content type="text"><![CDATA[Floder:Editor\Mono\Inspector123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748// Unity C# reference source// Copyright (c) Unity Technologies. For terms of use, see// https://unity3d.com/legal/licenses/Unity_Reference_Only_Licenseusing System.Collections.Generic;using System.Text;using UnityEngine;using UnityEngine.Rendering;using AnimatedBool = UnityEditor.AnimatedValues.AnimBool;using UnityEngine.Scripting;using UnityEditor.Modules;namespace UnityEditor&#123; [CustomEditor(typeof(Camera))] [CanEditMultipleObjects] public class CameraEditor : Editor &#123; public sealed class Settings &#123; private SerializedObject m_SerializedObject; public Settings(SerializedObject so) &#123; m_SerializedObject = so; &#125; // Manually entered rendering path names/values, since we want to show them // in different order than they appear in the enum. private static readonly GUIContent[] kCameraRenderPaths = &#123; EditorGUIUtility.TrTextContent("Use Graphics Settings"), EditorGUIUtility.TrTextContent("Forward"), EditorGUIUtility.TrTextContent("Deferred"), EditorGUIUtility.TrTextContent("Legacy Vertex Lit"), EditorGUIUtility.TrTextContent("Legacy Deferred (light prepass)") &#125;; private static readonly int[] kCameraRenderPathValues = &#123; (int)RenderingPath.UsePlayerSettings, (int)RenderingPath.Forward, (int)RenderingPath.DeferredShading, (int)RenderingPath.VertexLit, (int)RenderingPath.DeferredLighting &#125;; public SerializedProperty clearFlags &#123; get; private set; &#125; public SerializedProperty backgroundColor &#123; get; private set; &#125; public SerializedProperty normalizedViewPortRect &#123; get; private set; &#125; public SerializedProperty fieldOfView &#123; get; private set; &#125; public SerializedProperty orthographic &#123; get; private set; &#125; public SerializedProperty orthographicSize &#123; get; private set; &#125; public SerializedProperty depth &#123; get; private set; &#125; public SerializedProperty cullingMask &#123; get; private set; &#125; public SerializedProperty renderingPath &#123; get; private set; &#125; public SerializedProperty occlusionCulling &#123; get; private set; &#125; public SerializedProperty targetTexture &#123; get; private set; &#125; public SerializedProperty HDR &#123; get; private set; &#125; public SerializedProperty allowMSAA &#123; get; private set; &#125; public SerializedProperty allowDynamicResolution &#123; get; private set; &#125; public SerializedProperty stereoConvergence &#123; get; private set; &#125; public SerializedProperty stereoSeparation &#123; get; private set; &#125; public SerializedProperty nearClippingPlane &#123; get; private set; &#125; public SerializedProperty farClippingPlane &#123; get; private set; &#125; public SerializedProperty targetDisplay &#123; get; private set; &#125; public SerializedProperty targetEye &#123; get; private set; &#125; private static readonly GUIContent[] kTargetEyes = &#123; EditorGUIUtility.TrTextContent("Both"), EditorGUIUtility.TrTextContent("Left"), EditorGUIUtility.TrTextContent("Right"), EditorGUIUtility.TrTextContent("None (Main Display)"), &#125;; private static readonly int[] kTargetEyeValues = &#123; (int)StereoTargetEyeMask.Both, (int)StereoTargetEyeMask.Left, (int)StereoTargetEyeMask.Right, (int)StereoTargetEyeMask.None &#125;; public void OnEnable() &#123; clearFlags = m_SerializedObject.FindProperty("m_ClearFlags"); backgroundColor = m_SerializedObject.FindProperty("m_BackGroundColor"); normalizedViewPortRect = m_SerializedObject.FindProperty("m_NormalizedViewPortRect"); nearClippingPlane = m_SerializedObject.FindProperty("near clip plane"); farClippingPlane = m_SerializedObject.FindProperty("far clip plane"); fieldOfView = m_SerializedObject.FindProperty("field of view"); orthographic = m_SerializedObject.FindProperty("orthographic"); orthographicSize = m_SerializedObject.FindProperty("orthographic size"); depth = m_SerializedObject.FindProperty("m_Depth"); cullingMask = m_SerializedObject.FindProperty("m_CullingMask"); renderingPath = m_SerializedObject.FindProperty("m_RenderingPath"); occlusionCulling = m_SerializedObject.FindProperty("m_OcclusionCulling"); targetTexture = m_SerializedObject.FindProperty("m_TargetTexture"); HDR = m_SerializedObject.FindProperty("m_HDR"); allowMSAA = m_SerializedObject.FindProperty("m_AllowMSAA"); allowDynamicResolution = m_SerializedObject.FindProperty("m_AllowDynamicResolution"); stereoConvergence = m_SerializedObject.FindProperty("m_StereoConvergence"); stereoSeparation = m_SerializedObject.FindProperty("m_StereoSeparation"); targetDisplay = m_SerializedObject.FindProperty("m_TargetDisplay"); targetEye = m_SerializedObject.FindProperty("m_TargetEye"); &#125; public void Update() &#123; m_SerializedObject.Update(); &#125; public void ApplyModifiedProperties() &#123; m_SerializedObject.ApplyModifiedProperties(); &#125; public void DrawClearFlags() &#123; EditorGUILayout.PropertyField(clearFlags, EditorGUIUtility.TextContent("Clear Flags|What to display in empty areas of this Camera's view.\n\nChoose Skybox to display a skybox in empty areas, defaulting to a background color if no skybox is found.\n\nChoose Solid Color to display a background color in empty areas.\n\nChoose Depth Only to display nothing in empty areas.\n\nChoose Don't Clear to display whatever was displayed in the previous frame in empty areas.")); &#125; public void DrawBackgroundColor() &#123; EditorGUILayout.PropertyField(backgroundColor, EditorGUIUtility.TextContent("Background|The Camera clears the screen to this color before rendering.")); &#125; public void DrawCullingMask() &#123; EditorGUILayout.PropertyField(cullingMask); &#125; public void DrawProjection() &#123; ProjectionType projectionType = orthographic.boolValue ? ProjectionType.Orthographic : ProjectionType.Perspective; EditorGUI.BeginChangeCheck(); EditorGUI.showMixedValue = orthographic.hasMultipleDifferentValues; projectionType = (ProjectionType)EditorGUILayout.EnumPopup(EditorGUIUtility.TextContent("Projection|How the Camera renders perspective.\n\nChoose Perspective to render objects with perspective.\n\nChoose Orthographic to render objects uniformly, with no sense of perspective."), projectionType); EditorGUI.showMixedValue = false; if (EditorGUI.EndChangeCheck()) orthographic.boolValue = (projectionType == ProjectionType.Orthographic); if (!orthographic.hasMultipleDifferentValues) &#123; if (projectionType == ProjectionType.Orthographic) EditorGUILayout.PropertyField(orthographicSize, new GUIContent("Size")); else EditorGUILayout.Slider(fieldOfView, 1f, 179f, EditorGUIUtility.TextContent("Field of View|The width of the Camera’s view angle, measured in degrees along the local Y axis.")); &#125; &#125; public void DrawClippingPlanes() &#123; EditorGUILayout.PropertiesField(EditorGUI.s_ClipingPlanesLabel, new[] &#123;nearClippingPlane, farClippingPlane&#125;, EditorGUI.s_NearAndFarLabels, EditorGUI.kNearFarLabelsWidth); &#125; public void DrawNormalizedViewPort() &#123; EditorGUILayout.PropertyField(normalizedViewPortRect, EditorGUIUtility.TextContent("Viewport Rect|Four values that indicate where on the screen this camera view will be drawn. Measured in Viewport Coordinates (values 0–1).")); &#125; public void DrawDepth() &#123; EditorGUILayout.PropertyField(depth); &#125; public void DrawRenderingPath() &#123; EditorGUILayout.IntPopup(renderingPath, kCameraRenderPaths, kCameraRenderPathValues, EditorGUIUtility.TempContent("Rendering Path")); &#125; public void DrawTargetTexture(bool deferred) &#123; EditorGUILayout.PropertyField(targetTexture); // show warning if we have deferred but manual MSAA set // only do this if the m_TargetTexture has the same values across all target cameras if (!targetTexture.hasMultipleDifferentValues) &#123; var targetTexture = this.targetTexture.objectReferenceValue as RenderTexture; if (targetTexture &amp;&amp; targetTexture.antiAliasing &gt; 1 &amp;&amp; deferred) &#123; EditorGUILayout.HelpBox("Manual MSAA target set with deferred rendering. This will lead to undefined behavior.", MessageType.Warning, true); &#125; &#125; &#125; public void DrawOcclusionCulling() &#123; EditorGUILayout.PropertyField(occlusionCulling); &#125; public void DrawHDR() &#123; EditorGUILayout.PropertyField(HDR, EditorGUIUtility.TempContent("Allow HDR")); &#125; public void DrawMSAA() &#123; EditorGUILayout.PropertyField(allowMSAA); &#125; public void DrawDynamicResolution() &#123; EditorGUILayout.PropertyField(allowDynamicResolution); &#125; public void DrawVR() &#123; if (PlayerSettings.virtualRealitySupported) &#123; EditorGUILayout.PropertyField(stereoSeparation); EditorGUILayout.PropertyField(stereoConvergence); &#125; &#125; public void DrawMultiDisplay() &#123; if (ModuleManager.ShouldShowMultiDisplayOption()) &#123; int prevDisplay = targetDisplay.intValue; EditorGUILayout.Space(); EditorGUILayout.IntPopup(targetDisplay, DisplayUtility.GetDisplayNames(), DisplayUtility.GetDisplayIndices(), EditorGUIUtility.TempContent("Target Display")); if (prevDisplay != targetDisplay.intValue) GameView.RepaintAll(); &#125; &#125; public void DrawTargetEye() &#123; EditorGUILayout.IntPopup(targetEye, kTargetEyes, kTargetEyeValues, EditorGUIUtility.TempContent("Target Eye")); &#125; &#125; private class Styles &#123; public static GUIContent iconRemove = EditorGUIUtility.IconContent("Toolbar Minus", "|Remove command buffer"); public static GUIStyle invisibleButton = "InvisibleButton"; &#125; readonly AnimatedBool m_ShowBGColorOptions = new AnimatedBool(); readonly AnimatedBool m_ShowOrthoOptions = new AnimatedBool(); readonly AnimatedBool m_ShowTargetEyeOption = new AnimatedBool(); private Camera camera &#123; get &#123; return target as Camera; &#125; &#125; private static bool IsDeferredRenderingPath(RenderingPath rp) &#123; return rp == RenderingPath.DeferredLighting || rp == RenderingPath.DeferredShading; &#125; private bool wantDeferredRendering &#123; get &#123; bool isCamDeferred = IsDeferredRenderingPath(camera.renderingPath); bool isTierDeferred = IsDeferredRenderingPath(Rendering.EditorGraphicsSettings.GetCurrentTierSettings().renderingPath); return isCamDeferred || (camera.renderingPath == RenderingPath.UsePlayerSettings &amp;&amp; isTierDeferred); &#125; &#125; enum ProjectionType &#123; Perspective, Orthographic &#125;; private Camera m_PreviewCamera; protected Camera previewCamera &#123; get &#123; if (m_PreviewCamera == null) m_PreviewCamera = EditorUtility.CreateGameObjectWithHideFlags("Preview Camera", HideFlags.HideAndDontSave, typeof(Camera), typeof(Skybox)).GetComponent&lt;Camera&gt;(); m_PreviewCamera.enabled = false; return m_PreviewCamera; &#125; &#125; private RenderTexture m_PreviewTexture; // should match color in GizmosDrawers.cpp private static readonly Color kGizmoCamera = new Color(233f / 255f, 233f / 255f, 233f / 255f, 128f / 255f); private const float kPreviewNormalizedSize = 0.2f; private bool m_CommandBuffersShown = true; private Settings m_Settings; protected Settings settings &#123; get &#123; if (m_Settings == null) m_Settings = new Settings(serializedObject); return m_Settings; &#125; &#125; bool clearFlagsHasMultipleValues &#123; get &#123; return settings.clearFlags.hasMultipleDifferentValues; &#125; &#125; bool orthographicHasMultipleValues &#123; get &#123; return settings.orthographic.hasMultipleDifferentValues; &#125; &#125; int targetEyeValue &#123; get &#123; return settings.targetEye.intValue; &#125; &#125; public void OnEnable() &#123; settings.OnEnable(); var c = (Camera)target; m_ShowBGColorOptions.value = !clearFlagsHasMultipleValues &amp;&amp; (c.clearFlags == CameraClearFlags.SolidColor || c.clearFlags == CameraClearFlags.Skybox); m_ShowOrthoOptions.value = c.orthographic; m_ShowTargetEyeOption.value = targetEyeValue != (int)StereoTargetEyeMask.Both || PlayerSettings.virtualRealitySupported; m_ShowBGColorOptions.valueChanged.AddListener(Repaint); m_ShowOrthoOptions.valueChanged.AddListener(Repaint); m_ShowTargetEyeOption.valueChanged.AddListener(Repaint); &#125; internal void OnDisable() &#123; m_ShowBGColorOptions.valueChanged.RemoveListener(Repaint); m_ShowOrthoOptions.valueChanged.RemoveListener(Repaint); m_ShowTargetEyeOption.valueChanged.RemoveListener(Repaint); &#125; public void OnDestroy() &#123; if (m_PreviewCamera != null) DestroyImmediate(m_PreviewCamera.gameObject, true); &#125; private void DepthTextureModeGUI() &#123; // Camera's depth texture mode is not serialized data, so can't get to it through // serialized property (hence no multi-edit). if (targets.Length != 1) return; var cam = target as Camera; if (cam == null || cam.depthTextureMode == DepthTextureMode.None) return; List&lt;string&gt; buffers = new List&lt;string&gt;(); if ((cam.depthTextureMode &amp; DepthTextureMode.Depth) != 0) buffers.Add("Depth"); if ((cam.depthTextureMode &amp; DepthTextureMode.DepthNormals) != 0) buffers.Add("DepthNormals"); if ((cam.depthTextureMode &amp; DepthTextureMode.MotionVectors) != 0) buffers.Add("MotionVectors"); if (buffers.Count == 0) return; StringBuilder sb = new StringBuilder("Info: renders "); for (int i = 0; i &lt; buffers.Count; ++i) &#123; if (i != 0) sb.Append(" &amp; "); sb.Append(buffers[i]); &#125; sb.Append(buffers.Count &gt; 1 ? " textures" : " texture"); EditorGUILayout.HelpBox(sb.ToString(), MessageType.None, true); &#125; static Rect GetRemoveButtonRect(Rect r) &#123; var buttonSize = Styles.invisibleButton.CalcSize(Styles.iconRemove); return new Rect(r.xMax - buttonSize.x, r.y + (int)(r.height / 2 - buttonSize.y / 2), buttonSize.x, buttonSize.y); &#125; /** * Draws the 2D bounds of the camera when in 2D mode. */ [DrawGizmo(GizmoType.NonSelected)] static void DrawCameraBound(Camera camera, GizmoType gizmoType) &#123; var sv = SceneView.currentDrawingSceneView; if (sv != null &amp;&amp; sv.in2DMode) &#123; if (camera == Camera.main &amp;&amp; camera.orthographic) CameraEditor.RenderGizmo(camera); &#125; &#125; private void CommandBufferGUI() &#123; // Command buffers are not serialized data, so can't get to them through // serialized property (hence no multi-edit). if (targets.Length != 1) return; var cam = target as Camera; if (cam == null) return; int count = cam.commandBufferCount; if (count == 0) return; m_CommandBuffersShown = GUILayout.Toggle(m_CommandBuffersShown, GUIContent.Temp(count + " command buffers"), EditorStyles.foldout); if (!m_CommandBuffersShown) return; EditorGUI.indentLevel++; foreach (CameraEvent ce in (CameraEvent[])System.Enum.GetValues(typeof(CameraEvent))) &#123; CommandBuffer[] cbs = cam.GetCommandBuffers(ce); foreach (CommandBuffer cb in cbs) &#123; using (new GUILayout.HorizontalScope()) &#123; // row with event &amp; command buffer information label Rect rowRect = GUILayoutUtility.GetRect(GUIContent.none, EditorStyles.miniLabel); rowRect.xMin += EditorGUI.indent; Rect minusRect = GetRemoveButtonRect(rowRect); rowRect.xMax = minusRect.x; GUI.Label(rowRect, string.Format("&#123;0&#125;: &#123;1&#125; (&#123;2&#125;)", ce, cb.name, EditorUtility.FormatBytes(cb.sizeInBytes)), EditorStyles.miniLabel); // and a button to remove it if (GUI.Button(minusRect, Styles.iconRemove, Styles.invisibleButton)) &#123; cam.RemoveCommandBuffer(ce, cb); SceneView.RepaintAll(); GameView.RepaintAll(); GUIUtility.ExitGUI(); &#125; &#125; &#125; &#125; // "remove all" button using (new GUILayout.HorizontalScope()) &#123; GUILayout.FlexibleSpace(); if (GUILayout.Button("Remove all", EditorStyles.miniButton)) &#123; cam.RemoveAllCommandBuffers(); SceneView.RepaintAll(); GameView.RepaintAll(); &#125; &#125; EditorGUI.indentLevel--; &#125; public override void OnInspectorGUI() &#123; settings.Update(); var c = (Camera)target; m_ShowBGColorOptions.target = !clearFlagsHasMultipleValues &amp;&amp; (c.clearFlags == CameraClearFlags.SolidColor || c.clearFlags == CameraClearFlags.Skybox); m_ShowOrthoOptions.target = !orthographicHasMultipleValues &amp;&amp; c.orthographic; m_ShowTargetEyeOption.target = targetEyeValue != (int)StereoTargetEyeMask.Both || PlayerSettings.virtualRealitySupported; settings.DrawClearFlags(); if (EditorGUILayout.BeginFadeGroup(m_ShowBGColorOptions.faded)) settings.DrawBackgroundColor(); EditorGUILayout.EndFadeGroup(); settings.DrawCullingMask(); EditorGUILayout.Space(); settings.DrawProjection(); settings.DrawClippingPlanes(); settings.DrawNormalizedViewPort(); EditorGUILayout.Space(); settings.DrawDepth(); settings.DrawRenderingPath(); if (m_ShowOrthoOptions.target &amp;&amp; wantDeferredRendering) EditorGUILayout.HelpBox("Deferred rendering does not work with Orthographic camera, will use Forward.", MessageType.Warning, true); settings.DrawTargetTexture(wantDeferredRendering); settings.DrawOcclusionCulling(); settings.DrawHDR(); settings.DrawMSAA(); settings.DrawDynamicResolution(); DisplayCameraWarnings(); settings.DrawVR(); settings.DrawMultiDisplay(); if (EditorGUILayout.BeginFadeGroup(m_ShowTargetEyeOption.faded)) settings.DrawTargetEye(); EditorGUILayout.EndFadeGroup(); DepthTextureModeGUI(); CommandBufferGUI(); serializedObject.ApplyModifiedProperties(); &#125; private void DisplayCameraWarnings() &#123; Camera camera = target as Camera; if (camera != null) &#123; string[] warnings = camera.GetCameraBufferWarnings(); if (warnings.Length &gt; 0) EditorGUILayout.HelpBox(string.Join("\n\n", warnings), MessageType.Warning, true); &#125; &#125; public virtual void OnOverlayGUI(Object target, SceneView sceneView) &#123; if (target == null) return; // cache some deep values var c = (Camera)target; Vector2 previewSize = GameView.GetMainGameViewTargetSize(); if (previewSize.x &lt; 0f) &#123; // Fallback to Scene View of not a valid game view size previewSize.x = sceneView.position.width; previewSize.y = sceneView.position.height; &#125; // Apply normalizedviewport rect of camera Rect normalizedViewPortRect = c.rect; previewSize.x *= Mathf.Max(normalizedViewPortRect.width, 0f); previewSize.y *= Mathf.Max(normalizedViewPortRect.height, 0f); // Prevent using invalid previewSize if (previewSize.x &lt;= 0f || previewSize.y &lt;= 0f) return; float aspect = previewSize.x / previewSize.y; // Scale down (fit to scene view) previewSize.y = kPreviewNormalizedSize * sceneView.position.height; previewSize.x = previewSize.y * aspect; if (previewSize.y &gt; sceneView.position.height * 0.5f) &#123; previewSize.y = sceneView.position.height * 0.5f; previewSize.x = previewSize.y * aspect; &#125; if (previewSize.x &gt; sceneView.position.width * 0.5f) &#123; previewSize.x = sceneView.position.width * 0.5f; previewSize.y = previewSize.x / aspect; &#125; // Get and reserve rect Rect cameraRect = GUILayoutUtility.GetRect(previewSize.x, previewSize.y); if (Event.current.type == EventType.Repaint) &#123; // setup camera and render previewCamera.CopyFrom(c); // also make sure to sync any Skybox component on the preview camera var dstSkybox = previewCamera.GetComponent&lt;Skybox&gt;(); if (dstSkybox) &#123; var srcSkybox = c.GetComponent&lt;Skybox&gt;(); if (srcSkybox &amp;&amp; srcSkybox.enabled) &#123; dstSkybox.enabled = true; dstSkybox.material = srcSkybox.material; &#125; else &#123; dstSkybox.enabled = false; &#125; &#125; var previewTexture = GetPreviewTextureWithSize((int)cameraRect.width, (int)cameraRect.height); previewTexture.antiAliasing = Mathf.Max(1, QualitySettings.antiAliasing); previewCamera.targetTexture = previewTexture; previewCamera.pixelRect = new Rect(0, 0, cameraRect.width, cameraRect.height); Handles.EmitGUIGeometryForCamera(c, previewCamera); GL.sRGBWrite = QualitySettings.activeColorSpace == ColorSpace.Linear; previewCamera.Render(); GL.sRGBWrite = false; Graphics.DrawTexture(cameraRect, previewTexture, new Rect(0, 0, 1, 1), 0, 0, 0, 0, GUI.color, EditorGUIUtility.GUITextureBlit2SRGBMaterial); &#125; &#125; private RenderTexture GetPreviewTextureWithSize(int width, int height) &#123; if (m_PreviewTexture == null || m_PreviewTexture.width != width || m_PreviewTexture.height != height) &#123; m_PreviewTexture = new RenderTexture(width, height, 24, RenderTextureFormat.Default, RenderTextureReadWrite.Linear); &#125; return m_PreviewTexture; &#125; [RequiredByNativeCode] static float GetGameViewAspectRatio() &#123; Vector2 gameViewSize = GameView.GetMainGameViewTargetSize(); if (gameViewSize.x &lt; 0f) &#123; // Fallback to Scene View of not a valid game view size gameViewSize.x = Screen.width; gameViewSize.y = Screen.height; &#125; return gameViewSize.x / gameViewSize.y; &#125; static float GetFrustumAspectRatio(Camera camera) &#123; Rect normalizedViewPortRect = camera.rect; if (normalizedViewPortRect.width &lt;= 0f || normalizedViewPortRect.height &lt;= 0f) return -1f; float viewportAspect = normalizedViewPortRect.width / normalizedViewPortRect.height; return GetGameViewAspectRatio() * viewportAspect; &#125; // Returns near- and far-corners in this order: leftBottom, leftTop, rightTop, rightBottom // Assumes input arrays are of length 4 (if allocated) static bool GetFrustum(Camera camera, Vector3[] near, Vector3[] far, out float frustumAspect) &#123; frustumAspect = GetFrustumAspectRatio(camera); if (frustumAspect &lt; 0) return false; if (far != null) &#123; far[0] = new Vector3(0, 0, camera.farClipPlane); // leftBottomFar far[1] = new Vector3(0, 1, camera.farClipPlane); // leftTopFar far[2] = new Vector3(1, 1, camera.farClipPlane); // rightTopFar far[3] = new Vector3(1, 0, camera.farClipPlane); // rightBottomFar for (int i = 0; i &lt; 4; ++i) far[i] = camera.ViewportToWorldPoint(far[i]); &#125; if (near != null) &#123; near[0] = new Vector3(0, 0, camera.nearClipPlane); // leftBottomNear near[1] = new Vector3(0, 1, camera.nearClipPlane); // leftTopNear near[2] = new Vector3(1, 1, camera.nearClipPlane); // rightTopNear near[3] = new Vector3(1, 0, camera.nearClipPlane); // rightBottomNear for (int i = 0; i &lt; 4; ++i) near[i] = camera.ViewportToWorldPoint(near[i]); &#125; return true; &#125; // Called from C++ when we need to render a Camera's gizmo internal static void RenderGizmo(Camera camera) &#123; var near = new Vector3[4]; var far = new Vector3[4]; float frustumAspect; if (GetFrustum(camera, near, far, out frustumAspect)) &#123; Color orgColor = Handles.color; Handles.color = kGizmoCamera; for (int i = 0; i &lt; 4; ++i) &#123; Handles.DrawLine(near[i], near[(i + 1) % 4]); Handles.DrawLine(far[i], far[(i + 1) % 4]); Handles.DrawLine(near[i], far[i]); &#125; Handles.color = orgColor; &#125; &#125; static bool IsViewPortRectValidToRender(Rect normalizedViewPortRect) &#123; if (normalizedViewPortRect.width &lt;= 0f || normalizedViewPortRect.height &lt;= 0f) return false; if (normalizedViewPortRect.x &gt;= 1f || normalizedViewPortRect.xMax &lt;= 0f) return false; if (normalizedViewPortRect.y &gt;= 1f || normalizedViewPortRect.yMax &lt;= 0f) return false; return true; &#125; public virtual void OnSceneGUI() &#123; var c = (Camera)target; if (!IsViewPortRectValidToRender(c.rect)) return; SceneViewOverlay.Window(EditorGUIUtility.TrTextContent("Camera Preview"), OnOverlayGUI, (int)SceneViewOverlay.Ordering.Camera, target, SceneViewOverlay.WindowDisplayOption.OneWindowPerTarget); Color orgHandlesColor = Handles.color; Color slidersColor = kGizmoCamera; slidersColor.a *= 2f; Handles.color = slidersColor; // get the corners of the far clip plane in world space var far = new Vector3[4]; float frustumAspect; if (!GetFrustum(c, null, far, out frustumAspect)) return; Vector3 leftBottomFar = far[0]; Vector3 leftTopFar = far[1]; Vector3 rightTopFar = far[2]; Vector3 rightBottomFar = far[3]; // manage our own gui changed state, so we can use it for individual slider changes bool guiChanged = GUI.changed; // FOV handles Vector3 farMid = Vector3.Lerp(leftBottomFar, rightTopFar, 0.5f); // Top and bottom handles float halfHeight = -1.0f; Vector3 changedPosition = MidPointPositionSlider(leftTopFar, rightTopFar, c.transform.up); if (!GUI.changed) changedPosition = MidPointPositionSlider(leftBottomFar, rightBottomFar, -c.transform.up); if (GUI.changed) halfHeight = (changedPosition - farMid).magnitude; // Left and right handles GUI.changed = false; changedPosition = MidPointPositionSlider(rightBottomFar, rightTopFar, c.transform.right); if (!GUI.changed) changedPosition = MidPointPositionSlider(leftBottomFar, leftTopFar, -c.transform.right); if (GUI.changed) halfHeight = (changedPosition - farMid).magnitude / frustumAspect; // Update camera settings if changed if (halfHeight &gt;= 0.0f) &#123; Undo.RecordObject(c, "Adjust Camera"); if (c.orthographic) &#123; c.orthographicSize = halfHeight; &#125; else &#123; Vector3 pos = farMid + c.transform.up * halfHeight; c.fieldOfView = Vector3.Angle(c.transform.forward, (pos - c.transform.position)) * 2f; &#125; guiChanged = true; &#125; GUI.changed = guiChanged; Handles.color = orgHandlesColor; &#125; private static Vector3 MidPointPositionSlider(Vector3 position1, Vector3 position2, Vector3 direction) &#123; Vector3 midPoint = Vector3.Lerp(position1, position2, 0.5f); return Handles.Slider(midPoint, direction, HandleUtility.GetHandleSize(midPoint) * 0.03f, Handles.DotHandleCap, 0f); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>UnityCsReference</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[arithmetic]]></title>
    <url>%2F2018%2F07%2F09%2Farithmetic%2F</url>
    <content type="text"><![CDATA[快排通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都要小，然后再按此方法对这两部分分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 背包问题]]></content>
      <tags>
        <tag>arithmetic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++11]]></title>
    <url>%2F2018%2F07%2F09%2FC%2B%2B11%2F</url>
    <content type="text"><![CDATA[虚函数 对于一个class，产生一堆指向virtual functions的指针，虚函数表指针通常放在对象实例的最前面的位置。 每一个对象添加一个指针，指向相关的virtual table。这个指针被称作虚函数表指针。]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LoadingPerformance_Texture]]></title>
    <url>%2F2018%2F07%2F05%2FLoadingPerformance_Texture%2F</url>
    <content type="text"><![CDATA[资源加载资源加载是加载模块中最为耗时的部分，其CPU开销在Unity引擎中主要体现在Loading.UpdatePreloading和Loading.ReadObject两项中。 Loading.UpdatePreloading，这一项尽在调用类似LoadLevel(Async)的接口处出现，主要负责卸载当前场景的资源]]></content>
      <tags>
        <tag>uwa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[presentandsync]]></title>
    <url>%2F2018%2F07%2F05%2Fpresentandsync%2F</url>
    <content type="text"><![CDATA[WaitForTargetFPS该参数一般出现在CPU开销过低，且通过设定了目标帧率地情况下(Application.targetFrameRate)。当上一帧产生一个WaitForTargetFPS地空闲等待消耗时，以维持目标帧率。 解析：该项在Unity引擎地主循环中其实是最早执行地，即引擎实际上是根据上一帧地CPU耗时，在当前帧通过增补WaitForTargetFPS的方式来将运行FPS维持到目标值。比如，目标帧率为30帧/秒，上一帧耗时15ms，那么当前帧中WaitForTargetFPS将会是18（33-15）ms，但是这一帧中其他耗时为28ms，那么在Profiler中这一帧的总耗时就变成了46（18+28）ms。因此，由该值造成了Profiler开销较高的现象，其实是耗时的“假象”，在优化过程中，你对它可以“视而不见”。 Gfx.WaitForPresend &amp;&amp; Graphics.PresentAndSync这两个参数在Profiler中经常出现CPU占用较高的情况，且仅在发布版本中可以看到。究其原因，其实是CPU和GPU之间垂直同步（VSync）导致的，之所以会有两种参数，主要是与项目是否开启多线程渲染有关。当项目开启多线程渲染时，你看到的是Gfx.WaitForPresent；当项目未开启多线程渲染时，看到的则是Graphics.PresentAndSync。 Graphics.PresentAndSync是指主线程进行Present时的等待时间和等待垂直同步的时间。 Gfx.WaitForPresent其字面意思同样也是进行Present时需要等待的时间，但这里其实省略了很多的内容，其真实的意思应该是为了在渲染子线程（Rendering Thread）中进行Presend，当前主线程（MainThread）需要等待的时间。]]></content>
      <tags>
        <tag>uwa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[optimzation_memory_1]]></title>
    <url>%2F2018%2F07%2F05%2Foptimzation-memory-1%2F</url>
    <content type="text"><![CDATA[内存开销： 资源内存占用在一个较为复杂的大中型项目中，资源的内存占用往往占据了总体内存的70%以上。因此，资源使用是否恰当直接决定了项目的内存占用情况。一般来说，一款游戏项目的资源主要可分为如下几种：纹理（Texture）、网格（Mesh）、动画片段（AnimationClip）、音频片段（AudioClip）、材质（Material）、着色器（Shader）、字体资源（Font）以及文本资源（Text Asset）等等。其中，纹理、网格、动画片段和音频片段则是最容易造成较大内存开销的资源。 一、纹理纹理资源可以说是几乎所有游戏项目中占据最大内存开销的资源。一个6万面片的场景，网格资源最大才不过10MB，但一个2048x2048的纹理，可能直接就达到16MB。因此，项目中纹理资源的使用是否得当会极大地影响项目地内存占用。 纹理格式纹理格式是研发团队最需要关注的纹理属性。因为它不仅影响着纹理的内存占用，同时还决定了纹理的加载效率。在使用硬件支持的纹理格式时，你可能会遇到以下几个问题： 色阶问题 由于ETX、PVRTC等格式均为有损压缩，因此，当纹理色查范围跨度较大时，均不可避免地造成不同程度地“阶梯”状的色阶问题。因此，很多研发团队使用RGBA32/ARGB32格式来实现更好的效果。但是，这种做法将造成很大的内存占用。比如，同样一张1024x1024的纹理，如果不开启Mipmap，并且PVRTC格式，则其内存占用为512KB，而如果转换为RGBA32位，则很可能占用达到4MB。 ETC1不支持透明通道问题 在Andorid平台上，对于使用OpenGL ES 2.0的设备，其纹理格式仅能支持ETC1格式，该格式有个较为严重的问题，即不支持Alpha透明通道，使得透明贴图无法直接通过ETC1格式来进行储存。对此，我们建议研发团队将透明贴图尽可能拆分成两张，即一张RGB24位纹理记录原始纹理的颜色部分和一张Alpha8纹理记录原始纹理的透明通道部分。然后，将这两张贴图分别转化为ETC1格式的纹理，并通过特定的Shader来进行渲染，从而达到支持透明贴图的效果。这种方法极大程度伤毕竟RGBA透明贴图的渲染效果，同时降低纹理的内存占用。 纹理尺寸一般来说，纹理尺寸越大，则内存占用越大。所以，尽可能降低纹理尺寸，如果512x512的纹理对于显示效果已经够用，那么就不要使用1024x1024的纹理，因为后者的内存占用时前者的4倍。 Mipmap功能Mipmap旨在有效降低渲染带宽的压力，提升游戏的渲染效率。但是，开启Mipmap会将纹理内存提升1.33倍。对于具有较大纵深感的3D游戏来说，3D场景模型和角色我们一般是建议开启Mipmap功能的，而绝大多数UI均是渲染在屏幕最上层，开启Mipmap并不会提升渲染效率，反倒会增加无谓的内存占用。 Read &amp; Write一般情况下，纹理资源的”Read &amp; Write”功能在Unity引擎中默认是关闭的。开启该选项将会使纹理内存增大一倍。 二、网格Normal、Color和TangentMesh资源的数据中经常会含有大量的Color数据、Normal数据和Tangent数据。这些数据的存在将大幅度增加Mesh资源的文件提及和内存占用。其中，Color数据和Normal数据主要为3DMax、Maya等建模软件导出时设置所生成，而Tangent一般为导入引擎的生成。 更为麻烦的是，如果项目对Mesh进行Draw Call Batching操作的话，那么将很有可能进一步增大总体内存的占用。比如，100个Mesh进行拼合，其中99个Mesh均没有Color、Tangent等属性，剩下一个则包含有Color、Normal和Tangent属性，那么Mesh拼合后，CombinedMesh中将为每个Mesh来添加上此三个顶点属性，进而造成很大的内存开销。 引擎模块自身内存占用引擎自身中存在内存开销的部分纷繁复杂，可以说是由巨量“微小”内存所积累起来的，比如GameObject及其各种Component（量最大的Component应该算是Transform）了、ParticleSystem、MonoScript以及各种各样的模块Manager（SceneManager、CanvasManager、PersistentManager）等。 一般情况下，上面所指出的引擎各组成部分的内存开销均比较小，真正占据较大内存开销的这两处：WebStream和SerializedFile。其绝大部分的内存分配则是由AssetBundle加载资源所致。当使用new WWW或CreateFromMemory来加载AssetBundle时，Unity引擎会加载原始数据到内存中并对其进行解压，而WebStream的大小则是AssetBundle原始文件大小+解压后的数据大小+DecompressionBuffer(0.5MB)。同时，由于Unity5.3版本之前的AssetBundle文件为LZMA压缩，其压缩比类似于Zip(20%-50%)，所以对于1MB的原始AssetBundle文件，其加载后WebStream的大小则可能时5~6MB，因此，当项目中通过new WWW加载多个AssetBundle文件，且AssetBundle又无法即时释放时，WebStream的内存可能会很大。 对于SerilizedFile，则是当你使用LoadFromCacheOrDownload、CreateFromFile或new WWW本地AssetBundle文件时产生的序列化文件。 对于WebStream和SerializedFile，需要关注两点： 是否存在AssetBundle没有被清理干净的情况。可以通过Unity Profiler直接查看其具体的使用情况，并确定Take Sample时AssetBundle的存在是否合理； 对于占用WebStream较大的AssetBundle文件（如UI Atlas相关的AssetBundle文件等），建议使用LoadFromCacheOrDownLoad或CreateFromFile来替换，即将解压后的AssetBundle数据存储与本地Cache中进行使用。这种做法非常适合于内存特别吃紧的项目，即通过本地的磁盘控件来存储内存空间。 托管堆内存占用对于目前绝大多数基于Unity引擎开发的项目而言，其托管堆是由Mono分配和管理的。“托管”的本意是Mono可以自动地改变堆地大小来适应你所需要的内存，并且适当地调用垃圾回收（Garbage Collection操作来释放已经不需要地内存，从而降低开发人员再代码内存管理方面的门槛。 目前Unity所使用的Mono版本存在一个严重的问题，即：Mono的堆内存一旦分配就不会返还给系统。这意味着Mono的堆内存是只升不降的。举个粒子，项目运行时，再场景A中开辟了60MB的托管堆内存，而到下一个场景B时，只需要使用20MB的托管堆内存，那么Mono中将会存在40MB空闲的堆内存，且不会返还给系统。 高频率地New Class/Container/Array等。不要再Update、FixUpdate或较高调用频率地函数中开辟堆内存。 项目中较为合理地内存分配： 纹理资源：50MB 网格资源：20MB 动画片段：15MB 音频片段：15MB Mono堆内存：40MB 其它：10MB]]></content>
      <tags>
        <tag>uwa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[optimzation_memory_2]]></title>
    <url>%2F2018%2F07%2F05%2Foptimzation_memory_2%2F</url>
    <content type="text"><![CDATA[内存泄漏]]></content>
      <tags>
        <tag>uwa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity3D手游游戏]]></title>
    <url>%2F2018%2F07%2F01%2FUnity3D_Game_Design%2F</url>
    <content type="text"><![CDATA[Unity3D美工命名 模型命名 Max文件中角色模型命名为skin@sk_001武器模型命名为skin@wq_001 颜色贴图skin@st_001.png 高光贴图skin@st_001_ctr.png 导入导出能够从3DsMax导入Unity3D的资源 所有节点的位移、旋转、锁方、轴心和命名都将导入 网格模型包含顶点颜色、法线，一到两个UV通道 材质包含贴图以及漫反射颜色，以及单个网格的多维材质 动画（物体移动、旋转、缩放） 骨骼动画（角色动画） 角色模型制作规范模型 选人界面模型面数约4500-5000左右 游戏内主角模型面数2500-3000左右 Boss模型面数根据体型大小3000-5000左右 Npc模型面数900-1200造型简单面数没下限 武器模型面数250-500 造型简单面数没下限 模型在不是非常废面的情况下，转折的地方做出厚度，厚度适当夸张。 地面部分制作成双面或是封闭，小布条类模型做成双面模型 角色结构整体均衡 比如眼睛部分不需要细致刻画 贴图主角 512*512 pngBoss 512*512 pngNpc 256*256 png 武器体积较大的使用256*256 体积较小 128*128 png 尺寸设定制作模型前必须先确保模型尺寸，统一将显示单位与系统单位改为公尺。 注意正反面关系每个模型都包含正面和反面，一般来说引擎只会显示模型的正面，如要反面也一起显示需透过shader来实现，但增加反面显示时会降低性能，因此尽量让模型单面显示就好，而在制作模型时必须确保要显示的模型面是正面即可。 不要存在破面和迭面制作模型时注意顶点是否焊接好，未焊接的顶点可能会导致模型有破面的情形，另外模型面与面之间最好保持距离，不然会发生迭面的情况。 不要存在多余的顶点和T点删除一些没用的顶点，并且避免出现T点。 删除看不到的面制作模型时有些面可能在低下或是在模型里面，都是在场景进行中看不到的面，这些面可以删除，以减少模型面数提高效能。 物体的轴心每个物体都有一个坐标轴心，宜据物体属性设计好物体轴心位置，一般来说轴心都会放置在中心的位置，其他情况如门的轴心可能会在低下角落的位置。 使用简单几何体来制作复杂对象当遇到比较复杂的对象，且对象比较小，左乘模型反而增加了模型的面数，因此可以使用简单的平面模型结合透空贴图来实现复杂的造型，可以将图片存成PSD、PNG、TGA这种带有透明通道属性的贴图档。 重置模型（ResetXForm）制作模型时可能使用了缩放功能或镜像功能，这些指令会使得模型比例错乱以及出现负数轴向的情形，因此在模型制作完毕时最好进行ResetXForm指令，让模型回归最基本的状态。 制作虚拟碰撞体可以为模型制作简单的几何体来当作物体的碰撞体，可以依据物体的重要性与精确性来设计几何体外观。 材质贴图和UVUnity3D支持的Max材质Unity3D支持3dsmax的Standard(标准材质)与Muti/Sub-Object(多维/子物体材质)。 模型汇入Unity后没有贴图？当模型汇入Unity前，可以先创建一个Texture文件夹，并事先将贴图导入，这样模型汇入后就会自动读取到贴图。 模型塌陷制作模型时，建议将模型以一栋建筑进行塌陷，接着对模型进行UV拆解，这样可以将一个模型使用一张贴图来完成。 避免拉伸UV调整UV前先将材质球使用棋格 (checkter) 贴图来观看UV比例，调整UV时尽量让棋格维持正方形的形状。 贴图尺寸贴图必须是2的N词放（8、16、32、64、128、256），建议贴图不要超过1024*1024大小。 绘制UV出血绘制材质时绘制出血边缘，可避免出现明显接缝线。 透空贴图在Unity里的使用透空贴图毛边处理技巧透空贴图毛边处理技巧（进阶）材质与贴图命名烘培贴图教学3dsMax LightMap 烘培贴图3dsMax CompleteMap 烘培贴图Unity烘培贴图Unity3D地形制作地形编辑器基本功能介绍水系统介绍天空盒系统介绍第一人称导览3dsMax角色动画导入与基本控制单个角色动画导入多个角色动画导入角色基本控制第三人称角色控制角色阴影树木与粒子系统树木制作粒子系统-繁星粒子效果粒子系统-雪花粒子效果粒子系统-火焰粒子效果编辑界面介绍创建工程打开工程Project视图Hierarchy视图Inspector视图Scene视图视图介绍移动视图移动模型旋转模型缩放模型场景工具Sence视图控制条Game视图Game视图控制条工程的打包导出与导入游戏案例1Android和iOS版本发布Unity3D脚本概述Unity3D脚本概述Unity3D的基本语法访问其他组件访问其他游戏对象向量成员变量与全局变量实例化协同程序与中断创建游戏对象获取游戏对象添加组件与修改组件脚本组件克隆游戏对象时间1234567void OnGUI()&#123; GUILayout.Label("当前游戏时间：" + Time.time); GUILayout.Label("上一帧所消耗的时间：" + Time.deltaTime); GUILayout.Label("固定增量时间：" + Time.fixedTime); GUILayout.Label("上一帧所消耗的固定时间：" + Time.fixedDeltaTime);&#125; 随机数四元数Unity3D GUI界面设计（GUI&amp;NGUI&amp;UGUI）GUI常用控件GUI TextGUI Texture (LazyTexture)Label控件Button控件TextFieldToolBarSliderScrollView控件群组视图窗口NGUI Panel &amp; UGUI Canvas图集制作(TexturePacket)UITween动画顶点动画GUI Skin自定义风格组件Unity3D输入与控制键盘事件键盘按下事件键盘抬起事件键盘长按事件触摸事件触摸按下事件触摸抬起事件触摸长按事件鼠标事件鼠标按下事件鼠标抬起事件鼠标长按事件自定义事件输入管理器（InputHelper）自定义按键事件自定义按键轴实例练习角色模型与动画（Animation&amp;Animator）模型的载入设置角色动画播放3D动画动画裁切动画的帧Tween多媒体音频视频]]></content>
      <tags>
        <tag>Unity3D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阴影映射的原理和实现]]></title>
    <url>%2F2018%2F06%2F30%2FShadow_Mapping%2F</url>
    <content type="text"><![CDATA[阴影贴图 (Shadwom mapping)像素与以纹理形式保存的光照深度缓冲区或者深度图像比较，通过这种方式计算像素是否处于光源照射范围之内，从而生成阴影。 原理阴影贴图是一种使用深度纹理来为渲染阴影提供解决方法的多通道计算。它的关键是，就是用投影光源代替最终视口来观察场景。通过移动视口到光源位置，可以观察到这个位置每个东西都是明亮的，因为从光的角度来看是没有阴影的。]]></content>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity3D优化专题]]></title>
    <url>%2F2018%2F06%2F26%2FUnity3D-Optimize%2F</url>
    <content type="text"><![CDATA[一 遮挡剔除OcclusionCulling遮挡剔除(Occlusion Culling)功能可在对象因被其他物体遮挡，当前在相机中无法看到时，禁用对象渲染。该功能不会在三维计算机图形中自动开启，因为在大部分情况下，离相机最远的对象最先渲染，离相机的对象覆盖先前的物体（该步骤称之为“重复渲染(overdraw)”）。遮挡剔除(Occlusion Culling)与视锥体剔除(Frustum Culling)不同。视锥体剔除(Frustum Culling)只禁用相机视野外的对象渲染，不禁用视野中被遮挡的任何物体的渲染。注意，使用遮挡剔除(Occlusion Culling)功能时，仍将受益于视锥体剔除(Frustum Culling)。当场景中包含大量模型时，势必会造成渲染效率的降低。如果使用遮挡剔除技术，可以使用那些被阻挡的物体不被渲染，从而达到提高渲染效率的目的。 遮挡剔除的基本原理是在场景中创建一个遮挡区域，该遮挡区域由单元格组成；每个单元格构成整个场景遮挡区域的一部分，这些单元格会把整个场景拆分为多个部分。当摄像机能够看到该单元格时，单元格中的物体会被渲染出来，而被其他单元格挡住的不被摄像机看到的物体不会被渲染。 下面，我们来做遮挡剔除的案例 二 层级消隐如果场景中存在大量的小物体，则可以使用层消隐优化场景。层消隐就是在比较远的距离将小物体剔除，减少绘制调用的次数。例如，在比较远的距离，大型建筑物依然可见，但是小型的石块和碎片隐藏掉。可以将小物件单独放入一个层，并且使用Camera.main.layerCullDistance函数设置层的消隐距离。调整摄像机位置进行测试即可。只有在摄像机距离这些物体小于10M的时候，地面上的这些物体才能显示出来。 1234567public class SeperateControl : MonoBehaviour &#123; void Start() &#123; float[] distance = new float[32]; distances[8] = 10; Camera.main.layerCullDistances = distances; // 如果main == null,则设置camera的tag为mainCamera &#125;&#125; 三 层级细节LOD层级细节LOD全称为LevelOfDetail,它是根据物体在游戏画面中锁占据的百分比来调用不同复杂度的模型的。简单理解就是当一个物体距离摄像机比较远的时候，使用复杂度低的模型，比较近的时候，使用复杂度高的模型。 在建模软件中，制作好各个层级的模型，并且根据复杂程度自高向低命名为：模型名称_LOD0,模型名称_LOD1,模型名称_LOD2，数字越低，复杂程度越高。 我们新建一个场景，构造最简单的LOD模型示例。 准备3个Unity基本游戏对象，添加必要的材质。 定义一个空对象，命名为_LOD,添加LODGroup组件 分别将以上三个基本对象拖拽到LODGroup的各个级别上 首先添加LOD0的对象，当然中间需要修改父节点，点击确定即可 在Scene视图中，拖动摄像机分别近距离与远距离观察模型的变化。 四 DrawCall讲解一个DrawCall，表示U3D使用这个材质/纹理，来进行一次渲染，那么这次渲染假设有3个对象，那么当3个对象都使用这一个材质/纹理的时候，就会产生一次DrawCall，可以理解为一次将纹理输送到屏幕上的过程，（实际上引擎大多会使用如双缓冲，缓存这类的手段来优化这个过程，但在这里我们只需要这样认识就可以了），假设3个对象使用不同的材质/纹理，那么无疑会产生3个DrawCall。 批处理动态物体需要在每个顶点上进行一定的开销，所以动态批处理仅支持小于900顶点的网格物体，如果你的着色器使用顶点位置，法线和UV值三种属性，那么你只能批处理300顶点一下的物体；请注意：属性数量的限制可能会在将来进行改变。 相同的物体采取相同的材质，修改其缩放比例，观察DrawCall的变化。 功能描述如下：Static Batching是将标明为Static的静态物件，如果在使用相同材质球的条件下，Unity会自动帮你把这两个物体合并成一个Batch，送往GPU来处理。 Static Batching可以让引擎降低任何尺寸网格的Draw Call，如下图所示： Profile 工具使用性能分析工具可以给我们提供游戏性能表现的详细信息。如果我们的游戏存在性能问题，如低帧率或者高内存占用，性能分析工具可以帮助我们法线问题的起因，并协助我们解决问题。 Profiler布局 在我们使用Profiler收集游戏数据之前，先打开它熟悉下界面布局。从菜单Window-&gt;Profiler打开。 在窗口左侧，可以看到一列profilers，每个profiler显示我们游戏的一个方面的信息，分别为cpu使用情况，gpu使用情况，渲染，内存使用情况，声音，物理和网络。 当开始录制时，窗口上部的每个profiler会随着时间显示数据。性能是随着时间变化的，所以随着时间变化的信息是比仅仅一帧的信息有用的多的。有些性能问题是持续性的，有些问题是仅仅在一帧中出现的，还有一些性能问题是随着时间逐渐显现的。]]></content>
      <tags>
        <tag>Unity3D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于物理的着色：BRDF]]></title>
    <url>%2F2018%2F06%2F09%2FBRDF%2F</url>
    <content type="text"><![CDATA[在计算机图形学领域，着色（Shading）是指根据表面或者多边形相对光源和相机的角度和距离来计算它的颜色的过程。不同的用户可以使用不同的着色算法，CAD等追求相应速度的交互式图形领域可以使用简单快速的着色算法，卡通油画等艺术效果使用非真实感（Nonphotorealistic）着色算法，而追求真实感的CG电影或游戏则可以使用基于物理建模的着色算法。本文关注基于物理着色的BRDF模型，希望能将BRDF的来龙去脉将清楚，并分析Cook-TorranceBRDF公式的推倒过程。要模拟真实光照，我们先要弄清楚光照的现象。 光照现象光由光子组成，光子即具有粒子的特性，又表现出波的特性。从波的角度看，光是电磁波的一种，不同频率（波长）的光波能量不同，频率越高（波长越短），能量越高，频率越低（波长越长），能量越低，其中波长在380nm-780nm范围内的光波能被认类的视网膜感知到，这个范围的光波成为可见光，不同频率的可见光被人感知为不同的颜色，频率越高的光偏蓝，频率较低的光则偏红。]]></content>
  </entry>
  <entry>
    <title><![CDATA[3D美术人员Technical Artist（TA技术美术）的学习之旅（1）]]></title>
    <url>%2F2018%2F06%2F03%2FTA-1%2F</url>
    <content type="text"><![CDATA[文章针对于有一定3D美术基础，并了解次时代游戏制作流程的开发者，需要具备以下知识基础：了解3D建模，以及拓扑流程，贴图制作。相关软件3DMAX,ZB,substancepainte,ps等。TA是美术和程序之间沟通的桥梁。美术同学需要一些更加方便，可视化更强的工具，例如拓扑的工具，各位都知道MAX里有一个石墨工具是可以用于拓扑的，但是操作石墨工具拓扑是一件很痛苦的事，这时候有一个插件工具能给解决这个问题，例如wrapit的拓扑插件。正因为有了这个插件工具，我们就不用把模型导入Topogun在再次进行二次操作，而编写这个插件就可以算作TA人员所要去做的一件事。]]></content>
      <tags>
        <tag>-TA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity ShaderLab]]></title>
    <url>%2F2018%2F05%2F19%2FUnity3D-ShaderLab%2F</url>
    <content type="text"><![CDATA[CG类型 Type Description float 32位浮点数据 half 16位浮点数据 int 32位整形数据 fixed 12位定点数 bool 布尔数据 sampler 纹理对象的句柄，分为sampler、sampler1D、sampler2D、sampler3D、samplerCUBE和samplerRECT。 float2x4 matrix // 表示2x4阶矩阵，包含8个float类型数据 使用技巧： 精度够用就好 颜色和单位向量，使用fixed 其他情况，尽量使用half（即范围在[-6万，） 内置数据类型：基于基础数据类型，如float3，表示float3类型的三维向量；同理，bool2表示布尔类型的二维向量。 向量最长不能超过四元，如float5 vector; //编译错误 Swizzle操作符：它可以将一个向量的成员取出组成一个新的向量。对于坐标或者角度等其它多维向量，Swizzle操作符(.)后接x、y、z、w分别表示原始向量的第一个、第二个、第三个和第四个元素；同样，对于颜色可以后接r、g、b和a来表示同样的索引。例如： float4(a,b,c,d).xwz 等价于 float4(a,d,c) float4(a,b,c,d).xxy 等价于 float4(a,a,b) Swizzle操作符只能对结构体和向量使用，不能对数组使用。]]></content>
      <categories>
        <category>Unity Shader</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何系统地进行性能优化？]]></title>
    <url>%2F2018%2F05%2F17%2FHow-to-systematically-optimize-performance%2F</url>
    <content type="text"><![CDATA[项目做到一定阶段之后，要开始性能优化了。目前比较没有头绪地是，如何系统地开始？比如是否先要列一份清单，逐项去检查，用什么工具？这里想请教的是一套方法，或者说是一套工作流，能够系统地定位性能问题。谢邀。这是个好问题，也是个大问题。我想UWA团队在做深度优化地时候应该算是一个系统地性能优化，所以请@xin他们来回答可能更合适。我就仅仅从我个人的经验角度来回答一下，抛砖引玉。 1.是否需要性能优化？知乎老惯例，“先问有没有，再问为什么”。所以第一步是确定产品有没有性能问题，需不需要性能优化？虽然通常来说，绝大部分项目都需要关注性能的部分，但是就像我在UWA Day上分享所说的，我个人的感觉是性能优化最终要直接或者间接的反馈到游戏体验上。如果你的游戏再高中低配置对应的设备上都很流畅，对于发热和耗电也没有特别明显的问题，那我觉得可以调低一些性能优化的优先级。所以是否需要性能优化这个问题，我的回答是是否有影响游戏体验的表现，比如设备达不到目标帧率、卡顿、发热等等问题。 2.如何定位问题原因？有问题才有优化的具体目标，那接下来就是根据问题来进行原因的排查。排查的过程根据问题不同项目不同有各自的方法和过程，我这里提供一些常规问题的排查方法。 从抓大放小的角度，我们进行优化通常采用先检查常规消耗，再检查峰值消耗的思路来进行，即首先保证运行时的平均帧率，再减少卡顿，然后关注内存，最后考虑发热。这几部分其实也有很多的相关性，比如减少卡顿可能会使用缓存/预加载的策略，这时候对于内存可能会有影响，而提升了平均帧率再限制帧率设备上可以减少发热和耗电等。 2.1平时运行帧率低低配机器上运行帧率比较低是常见问题。a)首先是做分类，把通常的问题归类到几种瓶颈下来做讨论：GPU Bound、CPU Bound、Bandwidth Bound，还有Memory。这种分类方式基本是按照硬件资源的方式来进行的。b)GPU Bound是一种目前手游中比较常见的瓶颈，降低分辨率如果对帧率有非常明显的提升的话，非常大的可能就是GPU Bound。c)CPU Bound,降低分辨率的方式如果并不能提高帧率，那么可能是CPU Bound。CPU通常和Draw Call祥光，或者和复杂的游戏逻辑相关，通过Unity的Profiler工具可以比较明确看出是否是CPU Bound，以及这些计算时间都消耗在了哪里。TimeLine可以比较明确的看到瓶颈（5.3.8没有，暂时不研究）d)Bandwith Bound 在手游中也比较常见，一种比较简单的判断方式是使用NVIDIA Tegra Graphics Debugger这个工具（对于Tegra硬件更友好，但是比较难找。。。）中将所有贴图替换成2 * 2的大小，如果帧率有明显提升可能是Bandwidth瓶颈。当然也可以自己协代码所图来确认，比如使用Unity的Quality Setting里的Texture Quality。e)内存就用Unity地Profiler来看吧，不过这个对于帧率没什么影响。 2.2 卡顿]]></content>
  </entry>
  <entry>
    <title><![CDATA[3D数学基础：图形与游戏开发]]></title>
    <url>%2F2018%2F05%2F16%2F3d-math-base-graph-game-develop%2F</url>
    <content type="text"><![CDATA[9.4.1 4D齐次空间4.1.3节曾提到，4D向量有4个分量，前3个是标准的x,y和z分量，第四个是w，有时称作齐次坐标。 为了理解标准3D坐标是怎样扩展到4D坐标的，让我们先看一下2D中的齐次坐标，它的形式为(x,y,w)。想象在3D中w=1处的标准2D平面，实际的2D点(x,y)用齐次坐标表示(x,y,1)，对于哪些不在w=1平面的点，则将它们投影到w=1平面上。所以齐次坐标(x,y,w)映射的实际2D点为(x/w,y/w)。如图9.2所示。 因此，给定一个2D点(x,y)，齐次空间中有无数多个点与之对应。所有点的形式都为(kx,ky,k),k≠0。这些点构成一条穿过齐次原点的直线。 当w=0时，除法未定义，因此不存在实际的2D点。然而，可以将2D齐次点(x,y,0)解释为“位于无穷远的点”，它描述了一个方向而不是一个位置。在下节中会有关于该点的更多讨论。 4D坐标的基本思想相同。实际的3D点能被认为是在4D中w=1“平面”上。4D点的形式为(x,y,z,w)，将4D点投影到这个“平面”上得到相应的实际3D点(x/w,y/w,z/w)。w=0时4D点表示“无限远点”，它描述了一个方向而不是一个位置。 齐次坐标和通过除以w来投影时很有趣的，那我们为什么要使用4D坐标呢？有两个基本原因使得我们要使用4D向量和4X4矩阵。第一个原因实际上就是因为它是一种方便的记法，这也是下一节将要讨论的。 9.4.2 4X4平移矩阵回忆8.8.1节，3X3变换矩阵表示的是线性变换，不包含平移。因为矩阵乘法的性质，零向量总是变换成零向量，因此，任何能用矩阵乘法表达的变换都不包含平移。这很不幸，因为矩阵乘法和它的逆是一种非常方便的工具，不仅可以用来复用复杂的变换组合成简单的单一变换，还可以操纵嵌入式坐标系间的关系。如果能找到一种方法将3X3变换矩阵进行扩展，使它能处理平移，这将是]]></content>
  </entry>
  <entry>
    <title><![CDATA[PBR_Guide_Vol1]]></title>
    <url>%2F2018%2F05%2F14%2FPBR-Guide-Vol1%2F</url>
    <content type="text"><![CDATA[光与物质光与物质：基于物理的渲染与着色理论光是一种复杂的现象，它同时展现出波与粒子两种特性。于是，为了描述光的表现特性，人们建立了各种模型。作为材质艺术家，我们感兴趣的是光线模型（Light Ray Model）因为它描述了光与物质的交互作用。对我们来说，理解光线如何与物质表面交互非常重要，因为我们的工作是创作描述物体表面的材质。我们创作出的纹理与材质再虚拟世界中与光交互，对光线表现特效理解的越多，创作出的材质就会更好。再这篇指南中，我们会讨论物理理论，而基于物理的渲染(physically-based rendering)(PBR)模型正是建立在其上的。我们从光线开始，逐步讲解PBR中的关键点。 光线光线模型阐明，光线在均匀透明介质（如空气）中的轨迹为直线。光线模型同时也阐明，当光传播遇到表面是，例如遇到不透明物体或穿过不同介质如从空气折射入水中，光的表现是可预测的。这样，当光从一个起点传播到某点最终转换为其他形式例如热时，我们可以将它的轨迹视觉化。击中一个表面的光线成为入射光，而它击中的角度称为入射角，如图01所示。一条光线射入两个不同介质间的平面交界面。]]></content>
  </entry>
  <entry>
    <title><![CDATA[d3d11]]></title>
    <url>%2F2018%2F05%2F14%2Fd3d11%2F</url>
    <content type="text"><![CDATA[点积(dot product)计算结果是标量值；也叫标量积(scalar product)。等于两个向量对应分量的乘积之和。 $\mathbf{u \cdot v} = u_xv_x+u_yv_y+u_zv_z$ 4.1 准备工作4.1.4 交换链和页面翻转为了避免在动画中出现闪烁，最好的做法是在一个离屏（off-screen）纹理中执行所有的动画帧绘制工作，这个离屏纹理成为后台缓存区(back buffer)。当我们在后台缓冲区中完成给定帧的绘制工作后，便可以将后台缓冲区作为一个作为一个完整的帧显示在屏幕上；使用这种方法，用户不会感觉到帧的绘制过程，只会看到完整的帧。从理论上讲，将一帧显示到屏幕上所消耗的时间小于屏幕的垂直刷新时间。硬件会自动维护两个内置的纹理缓冲区来实现这一功能，这两个缓冲区分别成为前台缓冲区(front buffer)和后台缓冲区。前台缓冲区存储了当前显示在屏幕上的图像数据，而动画的下一帧会在后台缓冲区中执行绘制。当后台缓冲区的绘制工作完成之后，前后两个缓冲区的做哟个会发生翻转；后台缓冲区会变为前台huan’ch 4.1.5 深度缓冲区深度缓冲区(depth buffer)是一个不包含图像数据的纹理对象。在一定程度上，深度信息可以被认为是一种特殊的像素。常见的深度值范围在0.0到1.0之间，其中0.0表示离观察者最近的物体，1.0表示离观察者最远的物体。深度缓冲区中的每个元素与后台缓冲区中的每个像素一一对那个（即，后台缓冲区的第ij个元素对应于深度缓冲区第ij个元素）。所以，当后台缓冲区的分辨率为1280x1024时，在深度缓冲区中有1280x1024个深度元素。 4.1.6 纹理资源视图纹理可以被绑定到渲染管线（rendering pipeline）的不同阶段(stage);例如，比较常见的情况是将纹理作为渲染目标（即，Direct3D渲染到纹理）或着色器资源（即，在着色器中对纹理进行采样）。当创建用于这两种目的的纹理资源时，应使用绑定标记值： D3D11_BIND_RENDER_TARGET|D3D10_BIND_SHADER_RESOURCE指定纹理所要绑定的两个管线阶段。其实，资源不能被直接绑定到一个管线阶段；我们只能把与资源关联的资源试图绑定到不同的管线阶段。无论以哪种方式使用纹理，Direct3D始终要求我们在初始化时为纹理创建相关的资源视图(resource view)。这样有助于提供运行效率，正如SDK文档指出的那样：“运行时环境与驱动程序可以在视图创建执行相应的验证和映射，减少绑定时的类型检查”。所以，当把纹理作为一个渲染目标和着色器资源时，我们要为它创建两种试图：渲染目标试图 (ID3D11RenderTargetView)和着色器资源视图 (ID3D11ShaderResourceView)。资源视图主要有两个功能：（1）告诉Direct3D如何使用资源（即，指定资源所要绑定的管线阶段）； 4.1.7 多重采样因为计算机显示器上的像素分辨率有限，所以当我们绘制一条任意直线时，该直线很难精确地显示在屏幕上。当无法提高显示器的分辨率，缩小像素尺寸，也可以有效地缓解这一问题，使阶梯效应明显降低。当无法提高显示器分辨率或分辨率不够高时，我们可以使用抗锯齿 (antialiasing)技术。其中的一种技术叫做超级采样（supersampling），它把后台缓冲和深度缓冲的大小提高到屏幕分辨率的4倍。 4.1.8 Direct3D中的多重采样4.2 对Direct3D进行初始化 ID3D11Device接口用于检测显示适配器功能和分配资源。 ID3D11DeviceContext接口用于设置管线状态、将资源绑定到图形管线和生成渲染命令。 4.2.2 检测4X多重采样质量支持创建了设备后，我们就可以检查4X多重采样质量等级了。所有支持Direct3D 11的设备都支持所有渲染目标格式的4X MSAA（支持的质量等级可能并不相同）。123UINT m4xMsaaQuality;HR(md3dDevice-&gt;CheckMultisampleQualityLevels(DXGI_FORMAT_R8G8B8AB_UNORM, 4, &amp;m4xMassQuality));assert(m4xMsaaQuality&gt;0); 因为4X MSAA总是被支持的，所以返回的质量等级总是大于0。 4.2.3 描述交换链下一步是创建交换链，首先需要填充一个DXGI_SWAP_CHAIN_DESC结构体来描述我们将要创建的交换链的特性。该结构体的定义如下：12345678910typedef struct DXGI_SWAP_CHAIN_DESC&#123; DXGI_MODE_DESC BufferDesc; DXGI_SAMPLE_DESC SampleDesc; DXGI_USAGE BufferUsage; UINT BufferCount; HWND OutputWindow; BOOL Windowed; DXGI_SWAP_EFFECT SwapEffect; UINT Flags;&#125;DXGI_SWAP_CHAIN_DESC; DXGI_MODE_DESC类型是另一个结构体，其定义如下：12345678typedef struct DXGI_MODE_DESC&#123; UINT Width; // 后台缓冲区宽度 UINT Height; // 后台缓冲区高度 DXGI_RATIONAL RefreshRate; // 显示刷新率 DXGI_MODE_SCANLINE_ORDER ScanlineOrdering; // display scanline mode DXGI_MODE_SCALING Scaling; // display scaling mode &#125; 注意：在下面的数据成员描述中，我们只覆盖了一些常用的标记值和选项，它们对于初学者来说非常重要。对于其他标志值和选项的描述，请参阅SDK文档。 BufferDesc:该结构体描述了我们所要创建的后台缓冲区的属性。我们主要关注的属性有：宽度、高度和像素骼时；其他属性的详情请参阅SDK文档。 SampleDesc:]]></content>
  </entry>
  <entry>
    <title><![CDATA[Liyanfeng-Notes]]></title>
    <url>%2F2018%2F04%2F26%2FLiyanfeng-Notes%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Shader模板缓冲和模板测试]]></title>
    <url>%2F2018%2F04%2F26%2FUnity-Stencil-Buffer-Stencil-Test%2F</url>
    <content type="text"><![CDATA[在图形学种一个像素会有如下缓存： 颜色缓存color buffer/pixel buffer : 存储该点即将显示地颜色，RGBA值 深度缓存depth buffer/z buffer:存储该点地深度，z 模板缓存stencil buffer： 通常用作限制渲染区域。更高级用法需结合深度缓冲，例如某像素地模板缓冲值会随着其是否通过深度缓冲测试而改变。 累计缓存Accumulation Buffer:与颜色缓存类似，同样储存一个RGBA值。累计缓存是为合成多幅图像而设计地，累计缓存提供了一种在保持好地颜色分辨率下实现在场景中”多重曝光(multiple exposures”地方法。使用累计缓存可以产生许多图像效果来提高图像的真实性，其中包括：反走样，运动模糊，软阴影，深度域（景深）和卷积。要产生这些效果，必须将图像渲染多次，对场景位置（或所选的物体）进行微小的、渐增的改变，然后累计结果。 stencil与颜色缓冲区和深度缓存区类似，模板缓存区可以为屏幕上的每个像素点保存一个无符号整数值（通常是个八位整数）。这个值的具体意义视程序的具体应用而定。在渲染的过程中，可以用这个值与一个预先设定的参考值相比较，根据比较的结果来决定是否更新相应的像素点的颜色值。这个比较的过程成为模板测试Stencil Test。模板测试发生在透明度测试(alpha test)之后。如果模板测试通过，则相应的像素点更新，否则不更新。图形渲染管线中，基于单个像素的测试操作的顺序如下图]]></content>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity Lerp]]></title>
    <url>%2F2018%2F04%2F26%2FUnity-Lerp%2F</url>
    <content type="text"><![CDATA[有时，我们在做游戏时会发现有些跟随动作不够圆滑或者需要一个缓冲的效果，这时，一般会考虑到插值。（比如摄像机跟随主角） 插值是数学上的一个概念，公式： from + (to - from) * t;from是起始地位置，to是目标位置，按照数字t在from到to之间插值。]]></content>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CG-Input-Output-And-Semantic-Bind]]></title>
    <url>%2F2018%2F04%2F21%2FCG-Input-Output-And-Semantic-Bind%2F</url>
    <content type="text"><![CDATA[先复习一下GPU的工作流程，第三章从CPU运行原理和数据流程的角度阐述了顶点着色器程序和片段着色程序的输入输出，即，应用程序(宿主程序)将图元信息(顶点位置、法向量、纹理坐标等)传递给顶点着色程序；顶点着色程序基于图元信息进行坐标空间变换，运算得到的数据传递到片段着色程序中；片段着色程序还可以接受从应用程序中传递的纹理信息，将这些信息综合起来计算每个片段的颜色值，最后将这些颜色值输送到帧缓冲区(或颜色缓冲区)中。这一章中，我们将讲解Cg语言通过何种机制确定数据类型和传递形式。三个问题：1、从应用程序传递到GPU的数据，分为图元信息数据(在GPU处理的基本数据如顶点位置信息等)和其他的离散数据(在GPU运行流程中不会发生变化，如材质对光的反射、折射信息)，这两种输入数据如何区分？2、从应用程序传递到GPU中的图元信息如何区分类型，即，顶点程序怎么知道一个数据是位置数据，而不是法线量数据？3、顶点着色程序与片段着色程序之间的数据传递如何进行？cg关键字不但用于指定输入图元的数据含义(是位置信息，还是法向量信息),本质也则对应着这些图元数据存放的硬件资源(寄存器或者纹理)，称之为语义词(Semantics),通常也根据其用法称之为绑定语义词(binging semantics)。 除语义词外，Cg中还提供了三个关键字，int、out、inout，用于表示函数的输入参数的传递方式，称为输入/输出关键字，这组关键字可以和语义词合用表达硬件上不同的存储位置，即同一个语义词，使用in关键字修饰和out关键词修饰，表示的图形硬件上不同的寄存器。 Cg语言还提供两个修饰符：uniform,用于指定变量的数据初始化方式；const关键字的含义与C/C++中相同，表示被修饰变量为常量变量。 uniformCg语言将输入输出数据流分为两类： Varying inputs,即数据流输入图元信息的各种组成要素。从应用程序输入到GPU的数据除了顶点位置数据，还有顶点的法向量数据，纹理坐标数据等。 Uniform inputs,表示一些与三维渲染有关的离散信息数据，这些数据通常由应用程序传入，并通常不会随着图元信息的变化而变化，如材质对光的反射信息、运动矩阵等。Uniform修饰一个参数，表示该参数的值由外部应用程序初始化并传入。使用Uniform修饰的变量，除了数据来源不同外，与其他变量是完全一样的。需要注意的一点是：uniform修辞的变量是从外部传入的，所以在Cg程序(顶点程序和片段程序)中通常所有uniform参数修辞函数形参，不容许声明一个uniform修辞的局部变量！ Cg语言中参数传递方式同样分为”值传递”和”引用传递”，但指针机制并不被GPU硬件支持，所以Cg语言采用不同的语法修辞符来区别”值传递”和”引用传递”.这些修辞符分别为： in :修辞一个形参只是用于输入，进入函数体时被初始化，且该形参值的改变不会影响实参值，这是典型的值传递方式。 out :修辞一个形参只是用于输出的，进入函数体时并没有被初始化，这种类型的形参一般是一个函数的运行结果； inout:修辞一个形参即用于输入也用于输出，这是典型的引用传递。例如： void myFunction(float x); //等价于in float x，这种用法和C/C++完全一致语义词(Semantic)与语义绑定(Binding semantics) 语义词，表示输入图元的数据含义(是位置信息，还是法向量信息)，也表明这些图元数据存放的硬件资源(寄存器或者纹理缓存区)。顶点着色程序和片段着色程序中Varying inputs类型的输入，必须和一个语义词相绑定，这称之为绑定语义(binding semantics)。 记住这一点：语义，是两个处理阶段(顶点程序、片段程序)之间的输入/输出数据和寄存器之间的桥梁，同时语义通常也表示数据的含义，如POSITION一般表示参数存放的数据是顶点位置。 语义，只对两个处理阶段的输入/输出数据有意义，也就是说，语义只有在入口函数中才有效，在内部函数(一个阶段的内部处理函数，和下一个阶段没有数据传递关系)无效，被忽略。 顶点着色程序必须声明一个输出变量，并绑定POSITION语义词，该变量中的数据将被用于且至被用于光栅化！ 为了保持顶点程序输出语义和片段程序输入语义的一致性，通常使用相同的struct类型数据作为两者之间的传递，这是一种非常方便的写法，推荐使用。 注意：当使用struct结构中成员变量绑定语义时，需要主要到顶点着色程序中使用的POSITION语义词，是不会被片段程序所使用的。 都要记住vertex program中的绑定语义(POSITION除外)的输出形参中的数据会传递到fragment program中绑定相同语义的输入形参中。 片段着色器的输出语义词较少，通常是COLOR。这是因为片段着色程序运行完毕后，就基本到了GPU流水线的末端了。片段程序必须声明一个out向量(三元或四元),绑定语义词COLOR，这个值将被用作该片段的最终颜色值。 语义绑定方法绑定语义放在函数的参数列表的参数声明后面中： [const][int|out|inout]&lt;type&gt;&lt;identifier&gt;[:&lt;binding-semantic&gt;][=&lt;initializer&gt;] 绑定语义可以放在结构体(struct)的成员变量后面： 1234struct &lt;struct-tag&gt;&#123; &lt;type&gt;&lt;identifier&gt; [:&lt;binding-semantic&gt;];&#125;; 绑定语义词可以放在函数声明的后面，其形式为：1234&lt;type&gt; &lt;identifier&gt;(&lt;parameter-list&gt;)[:&lt;binding-semantic&gt;]&#123; &lt;body&gt;&#125; 最后一种语义绑定的方法是，将绑定语义词放在全局非静态变量的声明后面。其形式为： &lt;type&gt; &lt;identifer&gt;[:&lt;binding-semantic&gt;][=&lt;initializer&gt;];]]></content>
      <tags>
        <tag>CG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity Mesh]]></title>
    <url>%2F2018%2F04%2F21%2FUnity-Mesh%2F</url>
    <content type="text"><![CDATA[Mesh是Unity内的一个组件，成为网格组件。 Mesh网格 MeshFilter网格过滤器 Mesh Renderer 网格渲染器 Mesh: 是指模型的网格，建模就是建网格。Mesh的主要属性内容包括顶点坐标，法线，纹理坐标，三角形绘制序列等其他有用属性和功能。因此建网格，就是画三角形；画三角形就是定位三个点。Mesh Filter: 内包含一个Mesh组件，可以根据MeshFilter获得网格的组件，也可以为MeshFilter设置Mesh内容。Mesh Renderer: 是用于把网格渲染出来的组件。MeshFilter的作用就是把Mesh扔给MeshRender将模型或者是几何体绘制显示出来。 它们之间的关系大概就是GameObject挂MeshFilter组件，该组件有Mesh属性，该属性存顶点坐标，法线等属性，然后用Mesh Renderer(SkinMeshRenderer)才能将此网格渲染出来。 Mesh属性 顶点坐标(vertex) 顶点坐标数组存放Mesh的每个顶点空间坐标，假设某mesh有n个顶点，则vertex的size为n 法线(normal) 法线数组存放mesh每个顶点的法线，大小与顶点坐标对应，normal[i]对应vector[i]的法线 纹理坐标(uv) 它定义了图片上每个点的位置的信息，这些点与3D模型是互相联系的，以决定表面纹理贴图的位置，UV就是将图像上每个点精确对应到模型物体的表面uv[i]对应vectex[i] 三角形序列(triangle) 每个mesh都由若干个三角形组成，而三角形的三个点就是顶点坐标里的点，三角形的数组的size - 三角形个数 * 3 例如：某mesh有四个顶点0,1,2,3v0( 1, 1, 0)v1(-1, 1, 0)V2( 1,-1, 0)V3(-1,-1, 0)那么它们可以组成这样的一个网格tri[0] = v0,v3,v1, tri[1] = v0, v2, v3 注意：三角形的顶点顺序必须是顺时针，顺时针表示正面，逆时针表示背面，而Unity3D在渲染默认只渲染正面，背面是看不见的。(双面渲染一般用于头发等材质的处理)那么该三角形可以表示: tri = new int[2 * 3]{0,3,1, 0, 2, 3}; 如何要获取第N个三角形对应的三个顶点坐标，则:V1 = tri[N 3+0],v2 = tri[N 3 + 1], v3 = tri[N * 3 + 2] 实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748using UnityEngine;using System.Collections;//注意Unity是左手坐标系！！！，Unity默认是不渲染背面的public class CreateMesh : MonoBehaviour &#123; private MeshFilter filter; private Mesh mesh; void Start () &#123; filter = GetComponent&lt;MeshFilter&gt;(); mesh = new Mesh(); filter.mesh = mesh; InitMesh(); &#125; void InitMesh() &#123; mesh.name = "MyMesh"; Vector3[] vertics = new Vector3[8]&#123; new Vector3(1,1,0), new Vector3(-1, 1, 0), new Vector3(1,-1,0), new Vector3(-1,-1,0), new Vector3(1,1,1), new Vector3(-1, 1, 1), new Vector3(1,-1,1), new Vector3(-1,-1,1) &#125;; mesh.vertices = vertics; int[] triangles = new int[12 * 3]&#123; 0, 3, 1, 0, 2, 3, 4, 7, 5, 4, 6, 7, 0, 1, 5, 0, 5, 4, 2, 3, 7, 2, 7, 6, 0, 4, 6, 0, 6, 2, 1, 3, 7, 1, 7, 5, &#125;; mesh.triangles = triangles; /*Vector2[] uv = new Vector2[4]&#123; new Vector2(1,1), new Vector2(0,1), new Vector2(1,0), new Vector2(0,0) &#125;; mesh.uv = uv;*/ &#125;&#125; 效果如下(一定要加Mesh Renderer因为这玩意是负责渲染的,Unity这货材质缺失就是显示粉色的) 网格已经生成了，接下来就是给网格贴图了，uv属性会直接控制贴显示贴图的哪一部分，以及如何显示贴图uv中的每一项和vertices的每一项都是一一对应的，unity在贴图的时候，会把uv中的每一个点和vertices中对应的索引的顶点一一关联起来，这样可以实现贴图任意形状实现最终效果 shared在源对象上修改属性，非shared每次修改属性会从新生成一个对象。在编辑器下非运行期如果使用shared会修改本地文件，如果使用非shared会提示内存泄漏。]]></content>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cocos2d]]></title>
    <url>%2F2018%2F04%2F20%2Fcocos2d%2F</url>
    <content type="text"></content>
      <tags>
        <tag>Cocos2D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity3D MMORPG客户端游戏设计]]></title>
    <url>%2F2018%2F04%2F20%2Fxxsy-client-framework%2F</url>
    <content type="text"><![CDATA[资源模块UI模块更新模块网络模块Lua模块Lua 注册1234567891011121314151617181920212223242526272829303132[MonoInvokeCallbackAttribute(typeof(LuaCSFunction))]static int call(System.IntPtr L)&#123; int upidx = LuaDLL.lua_upvalueindex(1); int fnidx = (int)LuaDLL.lua_touserdata(L, upidx); if (fnidx &lt;= || fnidx &gt; m_count) &#123; LuaDLL.luaL_error(L, "SafeCallApi : bad function index " + fnidx); return 0; &#125; var info = m_infos[fnidx - 1]; try &#123; if (L != LuaMgr.m_L) &#123; using (new GuardL &#123; L = LuaMgr.m_L&#125;) &#123; LuaMgr.m_L = L; int v = info.function(); return v; &#125; &#125; int r = info.function(); return r; &#125; catch (System.Exception err) &#123; LuaDLL.lua_pushstring(L, "SafeCallApi : exception \n" + err.ToString()); &#125; LuaDll.lua_error(L); return 0;&#125; 技能模块角色模块动画模块状态模块CD模块状态模块场景模块子物体模块同屏系统每个场景里一般都有很多对象，对其中一个对象而言，它一般只关注自己周围一定范围内的其它对象。同屏系统的主要工作就是将对象周围一定范围内的其它对象精确且高效的统计，为客户端的表现以及其它系统提供服务。 我们采取的思想是每个对象维护了一个同屏信息，同屏信息主要包括同屏对象列表和同屏玩家列表。 导致同屏信息表改变的原因主要有三个：新对象进入场景，对象位置改变，对象离开场景。针对以上三种原因我们采取了两种实现机制：定时更新机制，立刻更新机制。立刻更新机制： 主要针对对象离开场景的情况。 实现步骤主要是根据离开对象记录的同屏信息，再相关联对象和自己的同屏信息内相互去掉。定时更新机制： 主要针对对象进入场景和对象位置改变两个原因。 针对对象进入场景原因实现主要是对象进入场景时，设置新对象标记。然后通过定时更新实现同屏信息变化。 针对对象位置改变原因实现步骤主要是对象位置改变，设置位置变更标记。然后通过定时更新实现同屏信息变化。 定时更新机制是每个tick对场景内所有本tick进行过位置变化或者新进入的对象进行同屏信息更新。更新的主要逻辑是再同屏信息内的对象若离开同屏则进行清除和未在同屏信息内的玩家若满足进入同屏则加入。 由于定时更新使用频繁且实现复杂，因此采取了搞笑的实现方法来实现这个功能。由于定时更新需要检测哪些对象进入同屏，如果整个检测整个场景内的对象，比较费，由此提出了单元格概念(CellSpace)，就是把场景划分N*N的格子，每个各自作为一个单元格，单元格内维护对象列表。然后再根据玩家的同屏距离，首先获得所在的单元戈，再判断对应单元格的对象是否进入对象同屏，减少判断数量。 游戏专用子系统武器、道具、游戏专用渲染地形渲染、水体模拟及渲染玩家机制状态机及动画、相对摄像机的操控（HID）、碰撞流行、移动游戏摄像机固定设想、脚本/动画摄像机、跟踪玩家摄像机、调试用飞行摄像机人工智能目标及决策、动作（引擎接口）、视线追踪及感知、路径搜寻（A*）前端平视显示器（HUD）、全动视频（FMV）、游戏内置电影（IGC）、游戏内置GUI、游戏内置菜单、包裹/吸引模式视觉效果光照贴图及动态阴影、高动态光照、PRT光照此表面散射、粒子及贴花系统、后处理效果、环境贴图场景图/剔除优化空间部分（BSP树）、遮挡及潜在可见集、纹理及表面管理、调试绘图（直线等）、图形设备接口性能剖析及调试录影及回放、内存及性能统计、游戏内菜单或控制台游戏性基础高层次的游戏流程系统/FSM脚本系统静态世界元素、动态游戏对象模型、实时基于代理人模拟、时间/信息系统、世界载入/串流骨骼动画动画状态树及蹭、反向动力学（IK）层阶式物体依附、游戏专用的后期处理、线性插值、动画播放、子骨骼播放、动画解压、骨骼网格渲染、布娃娃物理在线多人安排比赛及游戏管理、对象管辖权策略、游戏状态复制音频DSP/效果、三维音频模型、音频播放/管理低阶渲染器材质及着色器、静态及动态光源、摄像机、文本及字体、几何图元提交、视区及虚拟屏幕、纹理及表面管理、调试绘图（直线等）、图形设备接口碰撞及物理力及约束、光线/形状投影（查询）、刚体、Phantom、形状/可碰撞体、物理/碰撞世界人体学接口设备（HID）游戏专用接口、物理设备I/O资源（游戏资产）三维模型资源、纹理资源、材质资源、字体资源、骨骼资源、碰撞资源、物理参数、游戏世界/地图、其他核心系统模块启动及终止、断言、单元测试、内存分配、数学库、字符串及散列字符串标识符、调试用打印及日志、本地化服务、影片播放器、语法分析器（CSV、XML等）、性能剖析/统计采集、引擎配置（INI文件等）、随机数生成器、曲线及曲圆库、RITI/反射/序列化、对象句柄/唯一标识符、异步文件I/O平台独立层平台检测、原子数据类型、集合及迭代器、文件系统、网络传播层（UDP/TCP）、高分辨率时钟、线程库、图形包裹类、物理/碰撞包裹类第三方软件开发包DirectX\OpenGL、Boost、STL/STLPort]]></content>
      <tags>
        <tag>Unity3D</tag>
        <tag>MMORPG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[.Net .Net Framework mono]]></title>
    <url>%2F2018%2F04%2F18%2FNet-Net-Framework-mono%2F</url>
    <content type="text"><![CDATA[.net从一个抽象上来说其实是一个理念，使多种语言编写的程序能够通过一个通用的Runtime运行在不同的操作系统及硬件平台上。比如.net framework是在windows上实现的.net platform,mono是一个跨平台的.net platform一个.net platform想到达到.net的目标，就需要一些组件，比如CLR(Common Language Runtime),比如FCL基础类库，比如各种语言编译器，编译器编译出来的东西想要在CLR中运行，那也需要遵循一定的标准，这就是CLI和CIL，CIL规定了编译输出的规则，而CLI规定了编译器输入语言的规则，只有符合这种标准的语言才能编译成CIL语言运行在CLR中。好了现在有CIL和CLR，可以用符合CLI的语言比如C#编写程序了，然后将其编译成CIL，最后在CLR中运行Unity能跨平台的原因就是实现了各个平台的”即时编译器”(C#代码-&gt;中间语言-&gt;各个平台的原生代码)]]></content>
  </entry>
  <entry>
    <title><![CDATA[减少装箱(Boxing)和拆箱(UnBoxing)操作]]></title>
    <url>%2F2018%2F04%2F17%2FC-0%2F</url>
    <content type="text"><![CDATA[.Net的类型分值类型和引用类型，这两个类型的本质区别，值类型数据是分配在栈中，而引用类型数据分配在堆上，那么如果要把一个值类型数据放到堆上，就需要装箱操作；反之，把一个放在堆上的值类型数据取出来，则需要拆箱操作。减少装箱和拆箱操作的好处 对于堆的操作效率比较低 堆上分配的内存资源，需要GC来回收，从而降低程序效率 格式化操作有较多的装箱拆箱操作，比如String.Format, Console.WriteLine之类的语句， Console.WriteLine(&quot;Number list:{0}, {1}, {2}&quot;, 1.ToString(), t.2ToString(), 3.ToString()) 由于1.ToString()的结果是String类型，属于引用类型，因此不涉及装箱拆箱操作；]]></content>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity ECS Readme]]></title>
    <url>%2F2018%2F04%2F17%2FUnity-ECS-README%2F</url>
    <content type="text"><![CDATA[Entitas - The Entity Component System Framework for C# and UnityEntitas is a super fast Entity Component System Framework (ECS) specifically made for C# and Unity. Internal caching and blazing fast component access makes it second to none. Several design decisions have been made to work optimal in a garbage collected environment and to go easy on the garbage collector. Entitas comes with an optional code generator which radically reduces the amount of code you have to write and makes your code read like well written prose. » Download» Documentation» Ask a question» Wiki and example projects» #madeWithEntitas Video Tutorials &amp; Unity Unite Talks Entitas ECS Unity Tutorial Entitas ECS Unity Tutorial Entity system architecture with Unity ECS architecture with Unity by example Setup &amp; Basics Git &amp; Unit Tests » Open the slides on SlideShare: Unite Europe 2015 » Open the slides on SlideShare: Unite Europe 2016 First glimpseThe optional code generator lets you write code that is super fast, safe and literally screams its intent. 123456789public static GameEntity CreateRedGem(this GameContext context, Vector3 position) &#123; var entity = context.CreateEntity(); entity.isGameBoardElement = true; entity.isMovable = true; entity.AddPosition(position); entity.AddAsset("RedGem"); entity.isInteractive = true; return entity;&#125; 123456var entities = context.GetEntities(Matcher&lt;GameEntity&gt;.AllOf(GameMatcher.Position, GameMatcher.Velocity));foreach(var e in entities) &#123; var pos = e.position; var vel = e.velocity; e.ReplacePosition(pos.value + vel.value);&#125; OverviewEntitas is fast, light and gets rid of unnecessary complexity. There are less than a handful classes you have to know to rocket start your game or application: Entity Context Group Entity Collector Read more… Code GeneratorThe Code Generator generates classes and methods for you, so you can focus on getting the job done. It radically reduces the amount of code you have to write and improves readability by a huge magnitude. It makes your code less error-prone while ensuring best performance. I strongly recommend using it! Read more… Unity integrationThe optional Unity module integrates Entitas nicely into Unity and provides powerful editor extensions to inspect and debug contexts, groups, entities, components and systems. Read more… Entitas deep diveRead the wiki or checkout the example projects to see Entitas in action. These example projects illustrate how systems, groups, collectors and entities all play together seamlessly. Download EntitasEach release is published with zip files containing all source files you need. Show releases Thanks toBig shout out to @mzaks, @cloudjubei and @devboy for endless hours of discussion and helping making Entitas awesome! Maintainer(s) @sschmid | @s_schmid | @entitas_csharp Different language?Entitas is available in C# Swift C++ Objective-C Java Python Scala Go F# TypeScript Kotlin Haskell Erlang Clojure]]></content>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity ECS]]></title>
    <url>%2F2018%2F04%2F16%2FUnity-Coroutine%2F</url>
    <content type="text"><![CDATA[CoroutinesWaitForENdOffFrame 帧末尾执行 yield return null 表示暂缓一帧，在下一帧接着往下处理，于yield return 0 或 yield return 1一样的功能 yield return new WaitForSeconds 协程的真正用途是分布做一个比较耗时的事情，比如游戏里面的加载资源 多线程应用程序运行过程中，开辟一个新的、独立于主线程的运行片段；这可以推动CPU和操作系统处理事务的极限。通过拥有一个线程池可以缓解线程生存期的问题。但是，即使使用线程池也有可能激活大量线程，线程数如果多余CPU核心数将会互相争夺CPU资源，导致频繁切换上下文。切换上下文要先保存当前线程状态，在处理下一个线程，然后重新构建第一个线程，以便继续处理它。上下文切换是资源密集型的，因此尽可能避免切换上下文。 Job SystemJob System是通过创建Job而不是线程来管理多线程的。Job System跨多个核心管理一组线程。它通常每个CPU有一个工作线程，以避免频繁切换上下文。 Unity面对的问题 面向对象的编程方式（曾经的圣典，已经跟不上时代，OOP最大的问题是数据和逻辑混在一起，而现在我们要数据驱动模型） 由Mono编译的非最优机器码 GC机制 单线程开发]]></content>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity Manual]]></title>
    <url>%2F2018%2F04%2F16%2FUnity-Manual%2F</url>
    <content type="text"><![CDATA[YieldInstruction 中断指令所有yield指令的基类参考WaitForSeconds, WaitForFixedUpdate, Coroutine and MonoBehaviour,StartCoroutine WaitForSeconds 等待几秒Namespace: UnityEngineInherits from: YieldInstruction 在给定的秒数内，暂停协同程序的执行。WaitForSeconds只能用在协同程序中的yield声明。 RequireComponent当你添加了一个用了RequireComponent组件的脚本，需要的组件将会自动被添加到GameObject上。这个可以有效避免组装错误。在新建类的前面加 [RequireComponent(typeof(LineRenderer))] AssetDatabase.ImportAssetstatic function ImportAsset(path : string, options : ImportAssetOptions = ImportAssetOptions.Default):void 导入指定路径的资源所有路径都是相对于工程目录文件，例如”Assets/MyTexture/hello.png” AssetImporter.GetAtPathstatic function GetAtPath(path: string):AssetImporter 通过指定路径来导入资源 TextureWrapMode在进行纹理贴图时，图像会出现在物体表面(u,v)位置上，而这些值在[0.0,1.0]范围内。但是，如果超出这个范围，会发生什么情况呢，这由纹理的映射函数来决定.常见有下面几种： 重复(REPEAT):图像在表面上重复出现。在算法上，忽略纹理坐标的整数部分，并将纹理图的拷贝粘贴在物体表面上。对于大多数复制纹理的使用，在纹理顶部的纹理单元应于底部的纹理单元相匹配，在纹理左侧的纹理单元也应于右侧的纹理单元相匹配。 截取(CLAMP): 将大于1.0的数值设置为1.0，将小于0.0的数值设置为0.0，即将超出[0.0,1.0]范围的数值截取到[0.0,1.0]范围内，这样会导致纹理边缘的重复。 镜像重复(MIRRORED_REPEAT_ARB) 边界截取(CLAMP_TO_BORDER_ARB) 边缘截取(CLAMP_TO_EDGE) CameraClearFlag12345678public enum CameraClearFlags&#123; Skybox = 1, // 这是默认设置，在屏幕上空的部分显示当前相机的天空盒。如果当前相机没有设置天空盒，它会默认使用Edit-&gt;Render Settings里)中选择天空盒。然后它将退回使用背景颜色，另外天空盒组件可以添加到相机上。 SolidColor = 2, // 屏幕上的任何空的部分显示当前相机的背景颜色 Color = 2, Depth = 3, // 该深度的东西永远都不会被裁剪 Nothing = 4, // 什么事情都不做&#125; ProjectornearClipPlane 近裁剪面的距离 farClipPlane 远裁剪面的距离 fieldOfView 该投影的视野，以度为单位 aspectRatio 投影的宽高比 orthographic 投射是正交还是透视 orthographicSize 在正交模式下投射的一半尺寸 ignoreLayers 哪个物体层被这个投射器忽略 material 要投射到每个物体的材质 MeshMesh.RecalculateBounds在修改完顶点后你应该用这个函数以确保包围体是恰当的。赋值三角形将自动重新计算包围体。 Mesh.RecalculateNormals重新计算网格的法线在修改完定点后，通常会更新发现来反映新的变化。发现是根据共享的顶点计算出来的。导入到网格有时不共享所有顶点。例如：一个顶点在一个纹理坐标的接缝处将会被分为两个顶点。因此这个RecalculateNormals函数将会在纹理坐标接缝处创建一个不光滑的法线。RecalculateNormals不会自动产生切线，因此bumpmap着色器在调用RecalculateNormals之后不会工作。然而你可以提取你自己的切线。 惯性坐标系因为在进行物体到世界坐标系的转换时候，即需要平移同时也需要进行旋转，为了简化这种变化，在其中假如惯性坐标系，其中惯性坐标系的原点与本地坐标系的原点重合其轴和世界坐标系平英。那么本地坐标系到惯性坐标系只需要旋转操作（之前也得缩放）再到世界坐标系只需要进行平移。]]></content>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity优化]]></title>
    <url>%2F2018%2F04%2F12%2FUnity-Optimize%2F</url>
    <content type="text"><![CDATA[更新不透明贴图的压缩格式为ETC 4bit，因为android市场的手机中的GPU有多种，每家的GPU支持不同的压缩格式，但他们都兼容ETC格式。 对于透明贴图，我们只能选择RGBA 16bit 或者RGBA 32bit。 减少FPS，在ProjectSetting-&gt; Quality中的VSync Count 参数会影响你的FPS，EveryVBlank相当于FPS=60，EverySecondVBlank = 30；这两种情况都不符合游戏的FPS的话，我们需要手动调整FPS，首先关闭垂直同步这个功能，然后在代码的Awake方法里手动设置FPS（Application.targetFrameRate = 45;）降低FPS的好处：1）省电，减少手机发热的情况；2）能都稳定游戏FPS，减少出现卡顿的情况。 当我们设置了FPS后，再调整下Fixed timestep这个参数，这个参数在ProjectSetting-&gt;Time中，目的是减少物理计算的次数，来提高游戏性能。 尽量少使用Update LateUpdate FixedUpdate，这样也可以提升性能和节省电量。多使用事件（不是SendMessage，使用自己写的，或者C#中的事件委托）。 待机时，调整游戏的FPS为1，节省电量。 图集大小最好不要高于1024，否则游戏安装之后、低端机直接崩溃、原因是手机系统版本低于2.2、超过1000的图集无法读取、导致。2.2 以上没有遇见这个情况。注意手机的RAM 与 ROM、小于 512M的手机、直接放弃机型适配。 VSCount 垂直同步Unity3D中新建一个空场景的时候，帧速率（FPS总是很低），大概在60~70之间。在Unity3D中当运行场景打开Profiler的时候，我们会看到VSync 这一项占了很大的比重。这个是什么呢，这个就是垂直同步。我们可以关闭VSync来提高帧速率，选择edit-&gt;project settings-&gt;Quality。在右侧面板中可以找到VSync Count,把它选成Don’t Sync。这就关闭了VSync(垂直同步)，现在在运行场景看看，帧速率是不是提高很多。现在来说说什么是垂直同步，要知道什么是垂直同步，必须要先明白显示器的工作原理，显示器上的所有图像都是一线一线的扫描上去的，无论是隔行扫描还是逐行扫描，显示器都有两种同步参数——水平同步和垂直同步。 什么叫水平同步？什么叫垂直同步？垂直和水平是CRT中两个基本的同步信号，水平同步信号决定了CRT画出一条横越屏幕线的时间，垂直同步信号决定了CRT从屏幕顶部画到底部，再返回原始位置的时间，而恰恰是垂直同步代表着CRT显示器的刷新率水平。 为什么关闭垂直同步信号会影响游戏中的FPS数值？如果我们选择等待垂直同步信号（也就是我们平时所说的垂直同步打开），那么在游戏中或许强劲的显卡迅速的绘制完一屏的图像，但是没有垂直同步信号的到达，显卡无法绘制下一屏，只有等85单位的信号到达，才可以绘制。这样FPS自然要受到操作系统刷新率运行值的制约。 而如果我们选择不等待垂直同步信号（也就是我们平时所说的关闭垂直同步），那么游戏中作完一屏画面，显卡和显示器无需等待垂直同步信号就可以开始下一屏图像的绘制，自然可以完全发挥显卡的实力。但是不要忘记，正是因为垂直同步的存在，才能使得游戏进程和显示器刷新率同步，使得画面更加平滑和稳定。取消了垂直同步信号，固然可以换来更快的速度，但是在图像的连续性上势必打折扣。这也正是很多朋友抱怨关闭垂直后发现画面不连续的理论原因。 合并材质球Unity3D中每导入一次模型就多一个材质球，可我的这些模型都是共用一张贴图的就想共用一个材质球，所以每次都要删除再附上，很麻烦。怎么才能合并这些材质球？采用TexturePacking吧 遍历gameobject，取出material，并根据shader来将material分类； 调用Unity自带的PackTextures函数来合并每个shader分类中的material所对应的textures（PackTextures函数有缺陷，不过可以将就用）； 根据合并的大的texture来更新原有模型的texture、material已经uv坐标值。 需要注意的是：需要合并的纹理应该是物体在场景中距离相近的，如果物体在场景中的距离较远，则不建议合并纹理，因为这样做很有可能非但起不到优化的作用，反而降低了运行效率。 mesh合并分为2种方式合并 自带的合并必须勾选静态。 所有被勾选了“Static”的GameObject，其中的Mesh Filter中的mesh都会被合并到 “Combined Mesha (root: scene)” 中 也可以用脚本来合并mesh 。 12345678910111213141516171819202122using UnityEngine;using System.Collections; public class MyClass : MonoBehaviour&#123; void Start () &#123; MeshFilter [] meshFilters = GetComponentsInChildren&lt;MeshFilter&gt; (); CombineInstance[] combine = new CombineInstance[meshFilters.Length]; for(int i = 0; i &lt; meshFilters.Length; i++) &#123; combine[i].mesh = meshFilters[i].sharedMesh; combine[i].transform = meshFilters[i].transform.localToWorldMatrix; meshFilters[i].gameObject.active = false; &#125; transform.GetComponent&lt;MeshFilter&gt;().mesh = new Mesh (); transform.GetComponent&lt;MeshFilter&gt;().mesh.CombineMeshes (combine); transform.gameObject.active = true; &#125;&#125; 先在 Unity 中建立空物件 ( Empty ) 再创建2个 Cube 方块，并放入空物件底下 (可以改成你自己的模型) 把 MyClass 代码丟进空物件上 。 (可选) 建立一个 Material 材质，并且丢进空物件上 执行 角色Material数量2-3个，骨骼数量小于30个，面片数量300-1500，一般角色应该没有IK结点这是因为角色的动作大多数都是事先设定好的，并不需要经过IK操作来进行实时计算（Rogdoll除外），所以在模型导入时，不要将IK结点一起导入。 静态实体不要附加Animation Component在静态实体上附加Animation部件虽然对结果没有影响，但却会增加一定的CPU开销来调用这一组件，所以尽量去掉该组件。网格顶点数小于500；UV值范围尽量不要超过（0, 1）区间；尽量保证UV值不越界，这对于将来的纹理拼合优化很有帮助。 地形地形的分辨率大小长宽均尽量小于257。这是因为地形太大，会造成大量顶点数据，给你的内存带宽造成一定的影响，在目前的ios设备中，内存带宽是非常有限的，需要尽量节省。同时，如果用Unity自带的地形，一定也要使用Occlusion Culling，因为Unity的刷地形工具虽然方便，但却是framekiller，刷过之后，你会发现drawcall增加的非常多。混合纹理数量不要超过4。地形的混合操作是很耗时的，应该尽量避免。能合并的纹理尽量合并。 纹理 纹理格式建议png或tga。不用转成ios硬件支持的PVRTC格式，因为Unity在发布时会帮你自动转的。 纹理尺寸长宽小于1024。同时应该尽可能地小，够用就好，以保证纹理对内存带宽的影响达到最小。 支持Mipmap（UI不需要转，不然会增大内存）建议生成Mipmap。虽然这种做法会增加一些应用程序的大小，但在游戏运行时，系统会根据需求应用Mipmap来渲染，从而减少内存带宽。 检查Alpha值如果纹理的alpha通道均为1，则用RGB的24位纹理来代替RGBA的32位纹理。（据说Unity内部会进行自动检测） 光源光源“Important”个数建议1个，一般为方向光。“Important”个数应该越小越少。个数越多，drawcall越多。Pixel Light数目1-2个。 粒子特效屏幕上的最大粒子数建议小于200个粒子。每个粒子发射器发射的最大粒子数建议不超过50个。粒子大小如果可以的话，粒子的size应该尽可能地小。因为Unity的粒子系统的shader无论是alpha test还是alpha blending都是一笔不小的开销。同时，对于非常小的粒子，建议粒子纹理去掉alpha通道。尽量不要开启粒子的碰撞功能。非常耗时。 音频游戏中播放时间较长的音乐（如背景音乐）使用.ogg或.mp3的压缩格式。较短音乐（如枪声）使用.wav和.aif的未压缩音频格式。 相机裁剪平面将远平面设置成合适的距离。远平面过大会将一些不必要的物体加入渲染，降低效率。根据不同的物体设置不同的远裁剪平面Unity提供了可以根据不同的layer来设置不同的view distance，所以我们可以实现将物体进行分层，大物体层设置的可视距离大些，而小物体层可以设置地小些，另外，一些开销比较大的实体（如粒子系统）可以设置得更小些等等。 碰撞尽量不用MeshCollider如果可以的话，尽量不用MeshCollider，以节省不必要的开销。如果不能避免的话，尽量用减少Mesh的面片数，或用较少面片的代理体来代替。 其他Drawcall尽可能地减少Drawcall的数量。IOS设备上建议不超过100。减少的方法主要有如下几种：Frustum Culling，Occlusion Culling，Texture Packing。Frustum Culling是Unity内建的，我们需要做的就是寻求一个合适的远裁剪平面；Occlusion Culling，遮挡剔除，Unity内嵌了Umbra，一个非常好OC库。但Occlusion Culling也并不是放之四海而皆准的，有时候进行OC反而比不进行还要慢，建议在OC之前先确定自己的场景是否适合利用OC来优化；Texture Packing，或者叫Texture Atlasing，是将同种shader的纹理进行拼合，根据Unity的static batching的特性来减少draw call。建议使用，但也有弊端，那就是一定要将场景中距离相近的实体纹理进行拼合，否则，拼合后很可能会增加每帧渲染所需的纹理大小，加大内存带宽的负担。这也就是为什么会出现“DrawCall降了，渲染速度也变慢了”的原因。 非运动物体尽量打上Static标签Unity在运行时会对static物体进行自动优化处理，所以应该尽可能将非运行实体勾上static标签。 场景中尽可能地使用prefab尽可能地使用prefab的实例化物体，以降低内存带宽的负担。检查实体的PrefabType，尽量将其变成PrefabInstance，而不是ModelPrefabInstance。 移动平台相对于PC机，具有体积小，计算弱，带宽少的特点。 因此做手机游戏的开发，优化的方向，与力度对比PC游戏都有所区别。 必须要做到优化流程，合理利用资源。目前在手机上面，还不能够像PC游戏那样追求高质量渲染效果，为了让手机不那么容易发烫，还要控制cpu，gpu，不能让他们全速运算。 材质方面：纹理方面，建议使用压缩纹理， Android上面使用ETC1，苹果上面使用PVRTC。UV坐标控制在0到1之间，人物模型面数控制在1500内，骨骼控制在30个以内。场景中使用一个主光（不能再多了）。尽量减少alphaTest和alphaBlend材质的使用。在手机上，这是很杀效率的。骨骼动画方面：在动画方面可以考虑不使用插值，固定的帧率的动画。 如果要做插值，考虑使用四元数（表示旋转）和向量（表示位移）来做插值。 四元数做插值速度比矩阵来的快，Slerp提供了平滑插值。 优化的常规技巧剖析你的游戏。不要花费时间来优化那些晦涩的代码或者缩减图形文件的大小，除非这是你游戏的瓶颈。第一次剖析你的游戏将会使你发现你游戏的瓶颈。Apple’s Shark是一个很好的用来剖析基于OpenGL的程序的工具。再次剖析你的游戏。优化之后不要忘记再剖析一次你的游戏，这样可以检查你所做的优化是否达到了预期的效果。当然，这样做也可能会使你发现更多的瓶颈。流程第一、性能第二。花费时间来使你游戏的创建尽可能地流畅。尽可能快地修正游戏中的错误将会使你后期更容易优化你的游戏。在Scene View中测试场景。这样做将会使你清楚了解这个场景中的物体或者附加在物体上的脚本是否降低了游戏性能。如果Scene View反应迟钝，那么有可能是图形方面的原因，如果Scene View反应不迟钝，那么瓶颈可能出在脚本或者物理系统上。禁用指定游戏物体。在play模式下，尝试禁用并启用游戏物体来排查出游戏慢的原因。 网格如果可能的话，把相邻的物体（网格）合并为一个只有一个材质的物体（网格）。比如，你的游戏中包含一个桌子，上面有一堆东西，你完全可以在3D程序中将它们合并在一起（这可能也需要你将这些物体的纹理合并为一个大的纹理集）。减少需要渲染的物体的数量可以极大地提高游戏性能。 不要有不必要的网格。如果你的游戏场景中有一个人物，那么他应该是一个网格。如果你有一个船，那么它也应该只是一个网格。每一个网格只用一种材质。使用极少的面数的网格（比如500个多边形以下）。最好把你人物的三角面数量控制在1500-2000个之间。这个数量可以说是游戏质量和性能之间一个均衡值。如果你的模型有四边形，那么在导入模型的时候，引擎将会把每个四边形变为两个三角形。 光照像素光。像素光可以让你的游戏看起来效果很牛逼，但是不要使用过多的像素光。在你的游戏中可以使用质量管理器来调节像素光的数量来取得一个性能和质量的均衡点. 性能占用顺序：聚光灯&gt;点光源&gt;平行光。一个好的点亮场景的方法就是先得到你想要的效果，然后看看哪些光更重要；在保持光效的前提下看看哪些光可以去掉。 点光源和聚光灯只影响它们范围内的网格。如果一个网格处于点光源或者聚光灯的照射范围之外，并且光源的attenuate开关是打开的，那么这个网格将不会被光源所影响，这样就可以节省性能开销。这样做理论上来讲可以使用很多小的点光源而且依然能有一个好的性能，因为这些光源只影响一小部分物体。一个网格在有8个以上光源影响的时候，只响应前8个最亮的光源。 贴图在外观不变的前提下，贴图大小越小越好。如果你的显卡的显存不够大的话，你游戏中的贴图将会被转存到系统内存中，在显卡调用它们的时候再传到显卡中。对于比较新的电脑来说，内存和显卡之间有足够的带宽来达到一个很好的性能；如果你很无耻地用了巨多的大图片的话，在低显存的电脑上运行你的游戏的时候，你的游戏必然会挂掉。倒是没有必要在图形编辑软件中调整贴图的大小。你可以在unity导入贴图的时候进行调整。 不要使用低质量的图片。在小播放界面的游戏中使用低质量的jpeg图片或者低色彩的png图片亦或是gif图片没什么问题。在发布游戏的时候，引擎会自动压缩这些图片，多重压缩和解压将会降低图片的质量，所以最好保持贴图文件的分辨率为原始分辨率。这样就会减少多重压缩和解压所导致的图片失真现象。 Shaders多重效果的shader就比看起来样式很单一的shader要更耗费资源。同样在一个拥有贴图和光反射的物体上，使用VertexLit Diffuse shader无疑是最省资源的。 在美术制作场景的过程中，会使用到大量的粒子系统。比如场景中的火把。在我们的一个地下城场景中，美术们放置了大量的火把。整个场景中的各个地方，有100来个火把。 unity中，在摄像机范围外的粒子系统虽然不会被绘制。但是update是一直持续的。这也就意味着，这100多个火把，不论是否可见都在更新。 这个设计应该是很不合理的，在我看过的其他引擎中，都会有一个开关，来控制不可见的粒子系统是否需要update。有的粒子系统在不可见的时候需要更新,比如爆炸。有的不需要更新，比如火堆火把。 为了避免不必要的update开销，尤其是最后游戏是要发布到页游平台（web player只能使用一个cpu的核）。于是写了一个脚本，控制不可见的粒子系统就不更新。 该脚本主要是用到了2个MonoBehaviour的函数。OnBecameInvisible() 当变为不可见 和 OnBecameVisible() 当变成可见。 要这2个函数起作用的前提是，该GameObject绑定了MeshRender组件。所以，我们要在粒子系统的GameObject放置在一个GameObject 下，且给该GameObject绑定一个MeshRender 与 MeshFilter。MeshFilter中的mesh可以随便找个cube。 在Start（） 的时候，把最GameObject的scale设置为很小，以保证该cube不被看见。其实遍历所有的child，把active设置为false。 在OnBecameVisible 中 遍历所有child，把active设置为true。在OnBecameInvisible中 遍历所有child，把active设置为false。 Unity 性能优化 Draw Call Unity（或者说基本所有图形引擎）生成一帧画面的处理过程大致可以这样简化描述：引擎首先经过简单的可见性测试，确定摄像机可以看到的物体，然后把这些物体的顶点（包括本地位置、法线、UV等），索引（顶点如何组成三角形），变换（就是物体的位置、旋转、缩放、以及摄像机位置等），相关光源，纹理，渲染方式（由材质/Shader决定）等数据准备好，然后通知图形API——或者就简单地看作是通知GPU——开始绘制，GPU基于这些数据，经过一系列运算，在屏幕上画出成千上万的三角形，最终构成一幅图像。 在Unity中，每次引擎准备数据并通知GPU的过程称为一次Draw Call。这一过程是逐个物体进行的，对于每个物体，不只GPU的渲染，引擎重新设置材质Shader也是一项非常耗时的操作。因此每帧的Draw Call次数是一项非常重要的性能指标，对于iOS来说应尽量控制在20次以内，这个值可以在编辑器的Statistic窗口看到。 Unity内置了Draw Call Batching技术，从名字就可以看出，它的主要目标就是在一次Draw Call中批量处理多个物体。只要物体的变换和材质相同，GPU就可以按完全相同的方式进行处理，即可以把它们放在一个Draw Call中。Draw Call Batching技术的核心就是在可见性测试之后，检查所有要绘制的物体的材质，把相同材质的分为一组（一个Batch），然后把它们组合成一个物体（统一变换），这样就可以在一个Draw Call中处理多个物体了（实际上是组合后的一个物体）。 但Draw Call Batching存在一个缺陷，就是它需要把一个Batch中的所有物体组合到一起，相当于创建了一个与这些物体加起来一样大的物体，与此同时就需要分配相应大小的内存。这不仅会消耗更多内存，还需要消耗CPU时间。特别是对于移动的物体，每一帧都得重新进行组合，这就需要进行一些权衡，否则得不偿失。但对于静止不动的物体来说，只需要进行一次组合，之后就可以一直使用，效率要高得多。 Unity提供了Dynamic Batching和Static Batching两种方式。Dynamic Batching是完全自动进行的，不需要也无法进行任何干预，对于顶点数在300以内的可移动物体，只要使用相同的材质，就会组成Batch。Static Batching则需要把静止的物体标记为Static，然后无论大小，都会组成Batch。如前文所说，Static Batching显然比Dynamic Batching要高效得多 要有效利用Draw Call Batching，首先是尽量减少场景中使用的材质数量，即尽量共享材质，对于仅纹理不同的材质可以把纹理组合到一张更大的纹理中（称为Texture Atlasing）。然后是把不会移动的物体标记为Static。此外还可以通过CombineChildren脚本（Standard Assets/Scripts/Unity Scripts/CombineChildren）手动把物体组合在一起，但这个脚本会影响可见性测试，因为组合在一起的物体始终会被看作一个物体，从而会增加GPU要处理的几何体数量，因此要小心使用。 对于复杂的静态场景，还可以考虑自行设计遮挡剔除算法，减少可见的物体数量同时也可以减少Draw Call。 总之，理解Draw Call和Draw Call Batching原理，根据场景特点设计相应的方案来尽量减少Draw Call次数才是王道，其它方面亦然。 Draw Call Batching （绘制调用批处理） To draw an object on the screen, the engine has to issue a draw call to the graphics API (OpenGL ES in the case of iOS). Every single draw call requires a significant amount of work on the part of the graphics API, causing significant performance overhead on the CPU side.在屏幕上渲染物体，引擎需要发出一个绘制调用来访问图形API（iOS系统中为OpenGL ES）。每个绘制调用需要进行大量的工作来访问图形API，从而导致了CPU方面显著的性能开销。 Unity combines a number of objects at runtime and draws them together with a single draw call. This operation is called “batching”. The more objects Unity can batch together, the better rendering performance you will get.Unity在运行时可以将一些物体进行合并，从而用一个绘制调用来渲染他们。这一操作，我们称之为“批处理”。一般来说，Unity批处理的物体越多，你就会得到越好的渲染性能。 Built-in batching support in Unity has significant benefit over simply combining geometry in the modeling tool (or using theCombineChildren script from the Standard Assets package). Batching in Unity happensafter visibility determination step. The engine does culling on each object individually, and the amount of rendered geometry is going to be the same as without batching. Combining geometry in the modeling tool, on the other hand, prevents effecient culling and results in much higher amount of geometry being rendered.Unity中内建的批处理机制所达到的效果要明显强于使用几何建模工具（或使用Standard Assets包中的CombineChildren脚本）的批处理效果。这是因为，Unity引擎的批处理操作是在物体的可视裁剪操作之后进行的。Unity先对每个物体进行裁剪，然后再进行批处理，这样可以使渲染的几何总量在批处理前后保持不变。但是，使用几何建模工具来拼合物体，会妨碍引擎对其进行有效的裁剪操作，从而导致引擎需要渲染更多的几何面片。 Materials材质Only objects sharing the same material can be batched together. Therefore, if you want to achieve good batching, you need to share as many materials among different objects as possible.只有拥有相同材质的物体才可以进行批处理。因此，如果你想要得到良好的批处理效果，你需要在程序中尽可能地复用材质和物体。 If you have two identical materials which differ only in textures, you can combine those textures into a single big texture - a process often calledtexture atlasing. Once textures are in the same atlas, you can use single material instead.如果你的两个材质仅仅是纹理不同，那么你可以通过纹理拼合操作来将这两张纹理拼合成一张大的纹理。一旦纹理拼合在一起，你就可以使用这个单一材质来替代之前的两个材质了。 If you need to access shared material properties from the scripts, then it is important to note that modifyingRenderer.material will create a copy of the material. Instead, you should useRenderer.sharedMaterial to keep material shared.如果你需要通过脚本来访问复用材质属性，那么值得注意的是改变Renderer.material将会造成一份材质的拷贝。因此，你应该使用Renderer.sharedMaterial来保证材质的共享状态。 Dynamic Batching动态批处理Unity can automatically batch moving objects into the same draw call if they share the same material.如果动态物体共用着相同的材质，那么Unity会自动对这些物体进行批处理。 Dynamic batching is done automatically and does not require any additional effort on your side.动态批处理操作是自动完成的，并不需要你进行额外的操作。 Tips:提醒：1、Batching dynamic objects has certain overheadper vertex, so batching is applied only to meshes containing less than900 vertex attributes in total.批处理动态物体需要在每个顶点上进行一定的开销，所以动态批处理仅支持小于900顶点的网格物体。 2、If your shader is using Vertex Position, Normal and single UV, then you can batch up to 300 verts and if your shader is using Vertex Position, Normal, UV0, UV1 and Tangent, then only 180 verts.Please note: attribute count limit might be changed in future如果你的着色器使用顶点位置，法线和UV值三种属性，那么你只能批处理300顶点以下的物体；如果你的着色器需要使用顶点位置，法线，UV0，UV1和切向量，那你只能批处理180顶点以下的物体。请注意：属性数量的限制可能会在将来进行改变。 4、Don’t use scale. Objects with scale (1,1,1) and (2,2,2) won’t batch.不要使用缩放尺度（scale）。分别拥有缩放尺度(1,1,1)和(2,2,2)的两个物体将不会进行批处理。 5、Uniformly scaled objects won’t be batched with non-uniformly scaled ones.统一缩放尺度的物体不会与非统一缩放尺度的物体进行批处理。Objects with scale (1,1,1) and (1,2,1) won’t be batched. On the other hand (1,2,1) and (1,3,1) will be.使用缩放尺度(1,1,1)和 (1,2,1)的两个物体将不会进行批处理，但是使用缩放尺度(1,2,1)和(1,3,1)的两个物体将可以进行批处理。 6、Using different material instances will cause batching to fail.使用不同材质的实例化物体（instance）将会导致批处理失败。 7、Objects with lightmaps have additional (hidden) material parameter: offset/scale in lightmap, so lightmapped objects won’t be batched (unless they point to same portions of lightmap)拥有lightmap的物体含有额外（隐藏）的材质属性，比如：lightmap的偏移和缩放系数等。所以，拥有lightmap的物体将不会进行批处理（除非他们指向lightmap的同一部分）。 8、Multi-pass shaders will break batching. E.g. Almost all unity shaders supports several lights in forward rendering, effectively doing additional pass for them多通道的shader会妨碍批处理操作。比如，几乎unity中所有的着色器在前向渲染中都支持多个光源，并为它们有效地开辟多个通道。 9、Using instances of a prefab automatically are using the same mesh and material.预设体的实例会自动地使用相同的网格模型和材质。 Static Batching静态批处理 Static batching, on the other hand, allows the engine to reduce draw calls for geometry of any size (provided it does not move and shares the same material). Static batching is significantly more efficient than dynamic batching. You should choose static batching as it will require less CPU power.相对而言，静态批处理操作允许引擎对任意大小的几何物体进行批处理操作来降低绘制调用（只要这些物体不移动，并且拥有相同的材质）。因此，静态批处理比动态批处理更加有效，你应该尽量低使用它，因为它需要更少的CPU开销。 In order to take advantage of static batching, you need explicitly specify that certain objects are static and willnot move, rotate or scale in the game. To do so, you can mark objects as static using the Static checkbox in the Inspector:为了更好地使用静态批处理，你需要明确指出哪些物体是静止的，并且在游戏中永远不会移动、旋转和缩放。想完成这一步，你只需要在检测器（Inspector）中将Static复选框打勾即可；Using static batching will require additional memory for storing the combined geometry. If several objects shared the same geometry before static batching, then a copy of geometry will be created for each object, either in the Editor or at runtime. This might not always be a good idea - sometimes you will have to sacrifice rendering performance by avoiding static batching for some objects to keep a smaller memory footprint. For example, marking trees as static in a dense forest level can have serious memory impact.使用静态批处理操作需要额外的内存开销来储存合并后的几何数据。在静态批处理之前，如果一些物体共用了同样的几何数据，那么引擎会在编辑以及运行状态对每个物体创建一个几何数据的备份。这并不总是一个好的想法，因为有时候，你将不得不牺牲一点渲染性能来防止一些物体的静态批处理，从而保持较少的内存开销。比如，将浓密森里中树设为Static，会导致严重的内存开销。 Static batching is only available in Unity iOS Advanced.静态批处理目前只支持Unity iOS Advanced。 备注：最近一直在研究Unity3D的性能优化问题，这段时间可能会多翻译这方面的文章。 前两天，MadFinger，就是当今iOS与Android上画质最牛逼闪闪的游戏之一——ShadowGun的开发商，令人惊异地放出了一个ShadowGun的样例关卡以及若干可免费使用的Shader，国外同行们的分享精神真的是令人赞叹不已。原文在这里，以下是我的一些摘录和笔记。 首先是一些优化常识。针对图形方面的优化主要包括三角形数量，纹理所占内存，以及Shader，前两项基本没什么好讲的，针对设备机能的限制制定相应的指标即可，所以Shader就成为了图形性能优化的关键。 Alpha blending 在Unity官方文档中讲，由于硬件原因，在iOS设备上使用alpha-test会造成很大的性能开销，应尽量使用alpha-blend代替。这里提到，在同屏使用alpha-blend的面数，尤其是这些面所占屏幕面积的大小，对性能也会造成很大影响。原因是使用alpha-blend的面会造成overdraw的增加，这尤其对低性能设备的影响很大。不过没有购买Pro版，没有Occlusion Culling功能的话，就不必顾虑这一问题了，反正overdraw是必然的。 复杂的Per-pixel shader Per-pixel shader即Fragment shader，顾名思义是要对每个渲染到屏幕上的像素做处理的shader，如果per-pixel shader比较复杂且需要处理的像素很多时，也就是使用该shader的面占屏幕面积很大时，对性能的影响甚至要超过alpha blending。因此复杂的per-pixel shader只适用于小物体。 下面是对几个Shader的逐一讲解： Environment specular maps(Shader Virtual Gloss Per Vertex Additive)Specular map通常都是利用贴图的alpha通道来定义物体表面的光滑程度（反光度），这个shader的特点是per-vertex计算反光度的，有着相当不错的效果的同时比per-pixel的shader性能要高得多。这个shader很适用于关卡环境等占很大区域的模型。 经过优化的动态角色光照和阴影(Light probes和BRDF Shader)传统的Lightmaps无法支持动态物体，对此Unity提供了Light probes技术，预先把动态物体的光照信息保存在代理对象(即Light probes)中，运行时动态物体从距离最近的Probe中获取光照信息。 Unity本身还提供了一个效果非常棒的专为移动设备优化过的角色Shader，支持Diffuse、Specular和Normal maps，并通过一个特殊的脚本生成贴图用于模仿BRDF光照效果。最终产生的效果堪比次时代大作中的角色光影效果。 雾和体积光(Shader Blinking Godrays)目前在移动设备上要开启真正的雾效基本不可行，ShadowGun的方案是通过简单的网格＋透明贴图(称为雾面)来模拟雾效。在玩家靠近时，雾面逐渐变淡，同时fog plane的顶点也会移开(即使完全透明的alpha面也会消耗很多渲染时间)。 使用这个Shader的网格需要经过处理： 顶点的alpha值用于决定顶点是否可以移动(在例子中0为不可动，1为可动)。顶点法线决定移动的方向然后Shader通过计算与观察者的距离来控制雾面的淡入/淡出。这个Shader还可以用来做体积光和其它一些alpha效果。 飞机坠毁的浓烟效果(Shader Scroll 2 Layers Sine Alpha-blended)通过粒子产生浓烟的代价太高，所以ShadowGun中使用了网格＋贴图动画来制作这个效果。通过混合两层贴图并让它们交错移动来产生动画效果。其中顶点alpha值用于让网格的边缘看起来比较柔和，同时使用顶点颜色来模拟从火焰到烟雾的过渡效果。 带动态效果的天空盒(Shader Scroll 2 Layers Multiplicative)通过两张贴图的混合和移动产生云的动态效果。 旗帜和衣服的飘动效果(Shader Lightmap + Wind)同样利用顶点alpha值决定哪些顶点可以移动，然后shader的参数用于调整摆动的方向和速度。 一、程序方面 1. 务必删除脚本中为空或不需要的默认方法； 2. 只在一个脚本中使用OnGUI方法；（最好不要加） 3. 避免在OnGUI中对变量、方法进行更新、赋值，输出变量建议在Update内； 4. 同一脚本中频繁使用的变量建议声明其为全局变量，脚本之间频繁调用的变量或方法建议声明为全局静态变量或方法； 5. 不要去频繁获取组件，将其声明为全局变量； 6. 数组、集合类元素优先使用Array，其次是List； 7. 脚本在不使用时脚本禁用之，需要时再启用； 8. 可以使用Ray来代替OnMouseXXX类方法； 9. 需要隐藏/显示或实例化来回切换的对象，尽量不要使用SetActiveRecursively或active，而使用将对象远远移出相机范围和移回原位的做法； 10. 尽量少用模运算和除法运算，比如a/5f，一定要写成a * 0.2f。 11. 对于不经常调用或更改的变量或方法建议使用Coroutines &amp; Yield； 12. 尽量直接声明脚本变量，而不使用GetComponent来获取脚本；iPhone 13. 尽量使用整数数字，因为iPhone的浮点数计算能力很差； 14. 不要使用原生的GUI方法； 15. 不要实例化（Instantiate）对象，事先建好对象池，并使用Translate“生成”对象；二、模型方面 1. 合并使用同贴图的材质球，合并使用相同材质球的Mesh； 2. 角色的贴图和材质球只要一个，若必须多个则将模型离分离为多个部分； 2. 骨骼系统不要使用太多； 3. 当使用多角色时，将动画单独分离出来； 4. 使用层距离来控制模型的显示距离； 5. 阴影其实包含两方面阴暗和影子，建议使用实时影子时把阴暗效果烘焙出来，不要使用灯光来调节光线阴暗。 6. 少用像素灯和使用像素灯的Shader； 7. 如果硬阴影可以解决问题就不要用软阴影，并且使用不影响效果的低分辨率阴影； 08、实时阴影很耗性能，尽量减小产生阴影的距离； 09、允许的话在大场景中使用线性雾，这样可以使远距离对象或阴影不易察觉，因此可以通过减小相机和阴影距离来提高性能； 10、使用圆滑组来尽量减少模型的面数； 11、项目中如果没有灯光或对象在移动那么就不要使用实时灯光； 12、水面、镜子等实时反射/折射的效果单独放在Water图层中，并且根据其实时反射/折射的范围来调整； 13、碰撞对效率的影响很小，但碰撞还是建议使用Box、Sphere碰撞体； 14、建材质球时尽量考虑使用Substance； 15、尽量将所有的实时反射/折射（如水面、镜子、地板等等）都集合成一个面； 16、假反射/折射没有必要使用过大分辨率，一般6464就可以，不建议超过256256； 17、需要更改的材质球，建议实例化一个，而不是使用公共的材质球； 18、将不须射线或碰撞事件的对象置于IgnoreRaycast图层； 19、将水面或类似效果置于Water图层 20、将透明通道的对象置于TransparentFX图层； 21、养成良好的标签（Tags）、层次（Hieratchy）和图层（Layer）的条理化习惯，将不同的对象置于不同的标签或图层，三者有效的结合将很方便的按名称、类别和属性来查找； 22、通过Stats和Profile查看对效率影响最大的方面或对象，或者使用禁用部分模型的方式查看问题到底在哪儿； 23、使用遮挡剔除（Occlusion Culling）处理大场景，一种较原生的类LOD技术，并且能够“分割”作为整体的一个模型。 三、其它 场景中如果没有使用灯光和像素灯，就不要使用法线贴图，因为法线效果只有在有光源（Direct Light/Point Light/Angle Light/Pixel Light）的情况下才有效果。]]></content>
      <tags>
        <tag>Unity3D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# 线程同步]]></title>
    <url>%2F2018%2F04%2F12%2FC-Thread-Sync%2F</url>
    <content type="text"><![CDATA[线程同步的方式线程同步有：临界区、互斥区、事件、信号量四种方式 临界区(Critical Section)：临界区：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。在任意时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占。 互斥量(Mutex)：采用互斥对象机制。 只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问。互斥不仅能实现同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享 信号量(Semaphore)：它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目 事件(Event)：通过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作 lock 关键字lock 关键字将语句块标记为临界区，方法是获取给定对象的互斥锁，执行语句，然后释放该锁。lock 确保当一个线程位于代码的临界区时，另一个线程不进入临界区。如果其他线程试图进入锁定的代码，则它将一直等待（即被阻止），直到该对象被释放。 同步事件和等待句柄使用锁或监视器对于防止同时执行区分线程的代码块很有用，但是这些构造不允许一个线程向另一个线程传达事件。这需要“同步事件”，它是有两个状态（终止和非终止）的对象，可以用来激活和挂起线程。让线程等待非终止的同步事件可以将线程挂起，将事件状态更改为终止可以将线程激活。如果线程试图等待已经终止的事件，则线程将继续执行，而不会延迟。 同步事件有两种：AutoResetEvent 和 ManualResetEvent。它们之间唯一的不同在于，无论何时，只要 AutoResetEvent 激活线程，它的状态将自动从终止变为非终止。相反，ManualResetEvent 允许它的终止状态激活任意多个线程，只有当它的 Reset 方法被调用时才还原到非终止状态。 等待句柄，可以通过调用一种等待方法，如WaitOne、WaitAny 或 WaitAll，让线程等待事件。System.Threading.WaitHandle.WaitOne使线程一直等待，直到单个事件变为终止状态；System.Threading.WaitHandle.WaitAny 阻止线程，直到一个或多个指示的事件变为终止状态；System.Threading.WaitHandle.WaitAll 阻止线程，直到所有指示的事件都变为终止状态。当调用事件的 Set 方法时，事件将变为终止状态。 AutoResetEvent 允许线程通过发信号互相通信。 通常，当线程需要独占访问资源时使用该类。线程通过调用 AutoResetEvent 上的 WaitOne 来等待信号。 如果 AutoResetEvent 为非终止状态，则线程会被阻止，并等待当前控制资源的线程通过调用 Set 来通知资源可用。调用 Set 向 AutoResetEvent 发信号以释放等待线程。 AutoResetEvent 将保持终止状态，直到一个正在等待的线程被释放，然后自动返回非终止状态。 如果没有任何线程在等待，则状态将无限期地保持为终止状态。如果当 AutoResetEvent 为终止状态时线程调用 WaitOne，则线程不会被阻止。 AutoResetEvent 将立即释放线程并返回到非终止状态。可以通过将一个布尔值传递给构造函数来控制 AutoResetEvent 的初始状态：如果初始状态为终止状态，则为 true；否则为 false。AutoResetEvent 也可以同 staticWaitAll 和 WaitAny 方法一起使用。 WaitHandle.WaitOne()阻止当前线程，直到当前的 WaitHandle 收到信号为止 EventWaitHandle.Set()将事件状态设置为有信号，从而允许一个或多个等待线程继续执行。]]></content>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[托管代码和非托管代码]]></title>
    <url>%2F2018%2F04%2F11%2Fmanaged-code-unmanaged-code%2F</url>
    <content type="text"><![CDATA[托管代码是-Microsoft的中间语言(IL)，他主要作用是在.Net FRAMEWORK的公共语言运行库(CLR)执行代码前去编译源代码，也就是说托管代码充当着翻译的作用，源代码在运行时分为两个阶段： 源代码编译为托管代码，(所以源代码可以有很多种，如VB,C#,J#) 托管代码编译为Microsoft的平台专用语言 编译器把代码编译成中间语言(IL),而不是能在你的电脑上运行的机器码。中间语言被封装在一个叫程序集(Assembly)的文件中，程序集中包含了描述你所创建的类，方法和属性(例如安全需求)的所有元数据。你可以拷贝这个程序集到另一台服务器上部署它。 托管代码在公共语言运行库(CLR)中运行。这个运行库给你的运行代码提供各种各样的服务，通常来说，他会加载和验证程序集，以此来保证中间语言的正确性 托管代码是一种中间语言，运行在CLR上；非托管代码被编译为机器码，运行在机器上 托管代码独立于平台和语言，能更好的实现不同语言平台之间的兼容；非托管代码依赖于平台和语言。 托管代码可享受CLR提供的服务（如安全检测，垃圾回收），不需要自己完成这些操作非托管代码需要自己提供安全检测、垃圾回收等操作。]]></content>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity加载和内存管理]]></title>
    <url>%2F2018%2F04%2F11%2FAssetBundle%2F</url>
    <content type="text"><![CDATA[Unity有两种动态加载机制：Resources.Load和AssetBundle，二者本质并无区别。Resources.Load就是从一个缺省打进程程序包的AssetBundle(Resourece)里加载资源，而一般AssetBundle文件需要你自己创建，运行时加载。 AssetBundle加载基础通过AssetBunlde加载资源，分为两步，第一步是获取AssetBundle对象，第二步是通过该对象加载需要的资源。而第一步又分为两种方式，下文中将结合常用的API进行详细地描述。 第一步，获取AssetBundle对象常用地API方式一，先获取WWW对象，再通过WWW.assetBundle获取AssetBundle对象：public WWW(string uri); 加载Bundle文件并获取WWW对象，完成后会在内存中创建较大地WebStream(解压后的内容，通常为原Bundle文件的4~5倍大小，纹理资源比例可能更大),因此后续的AssetBundle.Load可以直接在内存中进行。 public static WWW LoadFromCacheOrDownload(string uri, int version, unit crc = 0); 加载Bundle文件并获取WWW对象，同时将解压形式的Bundle内容存入磁盘中作为缓存（如果该Bundle已在缓存中，则省去这一步），完成后只会在内存中创建较小的SerializedFile，而后续的AssetBundle.Load需要通过IO从磁盘中的缓存获取。 public AssetBundle assetBundle; 通过之前两个接口获取WWW对象后，即可通过WWW.assetBundle获取AssetBundle对象。 方式二，直接获取AssetBundle:public static AssetBundle LoadFromFile(string path); public static AssetBundle LoadFromFileAsync(string path); 通过未压缩的Bundle文件，同步创建AssetBundle对象，这是最快的方式。创建完成后只会在内存中创建较小的SerializedFile，而后续的AssetBundle.Load需要通过IO从磁盘中获取。如果AssetBundle是未压缩，或者是数据块形式（LZ4算法压缩）的，LoadFromFile将从磁盘中直接加载它。如果AssetBundle是高度压缩(LZMA算法压缩)的，再将它加载进入内存前，会首先将它解压。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667void LoadAssetBundles(string baseDir)&#123; if (assetBundleInfos != null) &#123; for (int i = 0; i &lt; assetBundleInfos.Length; i++) &#123; var bInfo = assetBundleInfos[i]; if (bInfo.assetBundle != null) &#123; bInfo.assetBundle.Unload(false); &#125; &#125; assetBundleInfos = null; &#125; var abInfos = new List&lt;AssetBundleInfo&gt;(50); var files = Directory.GetFiles(m_dir_update, "*.bytes"); for (int i = 0; i &lt; files.Length; i++) &#123; string f = files[i]; string n = Path.GetFileName(f); if (!CheckABName(abInfos, n)) contine; abInfos.Add(new AssetBundleInfo&#123;name = n, uri = f&#125;); &#125; if (baseDir != null) &#123; files = Directory.GetFiles(baseDir, "*.bytes"); for (int i = 0; i &lt; files.Length; i++) &#123; string f = files[i]; string n = Path.GetFileName(f); if (!CheckABName(abInfos, n)) continue; abInfos.Add(new AssetBundleInfo&#123;name = n, uri = f&#125;); &#125; &#125; files = LoadConfigLines("res_idx"); for (int i = 0; i &lt; files.Length; i++) &#123; string n = files[i].Trim(); if (!CheckABName(abInfos, n)) continue; string f = streamAssetsPath + n; abInfos.Add(new AssetBundleInfo&#123;name = n, uri = f&#125;); &#125; if (abInfos.Count == 0) return; string prefix = "assets/res/"; int cprefix = prefix.Length; for (int i = 0; i &lt; abInfos.Count;) &#123; var abInfo = abInfos[i]; var ab = AssetBundle.LoadFromFile(abInfo.uri); if (ab == null) &#123; abInfos.RemoveAt(i); sbError.Append("\nfail ab : "); sbError.Append(abInfo) &#125; &#125;&#125; public static AssetBundle LoadFromMemory(byte[] binary) 通过Bundle的二进制数据，异步创建AssetBundle对象，完成后会在内存中创建较大的WebStream。调用时，Bundle的解压是异步进行的，因此对于未压缩的Bundle文件，该接口于LoadFromMemoryAsync是等价的。 public static AssetBundle LoadFromMemoryAsync 该接口是 CreateFromMemory 的同步版本，这个方法的参数是包含了AssetBundle数据的字节数组。如果需要的话，你还可以传入一个CRC(循环冗余校验码)参数。如果AssetBundle使用了LZMA算法压缩，那么AssetBundle在加载的时候会被解压。如果AssetBundle使用了LZ4算法压缩，它将直接以压缩形式被加载。 12345678IEnumerator LoadFromMemoryAsync(string path)&#123; AssetBundleCreateRequest createRequest = AssetBundle.LoadFromMemoryAsync(File.ReadAllBytes(path)); yield return createRequest; AssetBundle bundle = createRequest.assetBundle; var prefab = bundle.LoadAsset&lt;GameObject&gt;("MyObject"); Instantiate(prefab);&#125; 第二步，从AssetBundle加载资源的常用APIpublic Object Load(string name, Type type); 通过给定的名字和资源类型，加载资源。加载时会自动加载其依赖的资源，即Load一个Prefab时，会自动Load其引用的Texture资源。 public Object[] LoadAll(Type type); public AssetBundleRequest LoadAllAssetsAsync(); 一次性加载Bundle中给定资源类型的所有资源 public AssetBundleRequest LoadAsync(string name, Type type) 2.3 AssetBundle的压缩类型Unity3D引擎为我们提供了三种压缩策略来处理AssetBundle的压缩，即： LZMA格式 LZ4格式 不压缩 LAMZ格式在默认情况下，打包生成的AssetBundle都会被压缩。在U3D中，AssetBundle的标准压缩格式便是LZMA（LZMA是一种序列化流文件），因此在默认情况下，打出的AssetBundle包处于LZMA格式的压缩状态， LZ4格式Unity 5.3之后的版本增加了LZ4格式压缩，由于LZ4的压缩比一般，因此经过压缩之后的AssetBundle包体的体积较大（该算法基于chunk）。但是，使用LZ4格式的好处在于解压缩的时间相对要短。 使用LZ4格式压缩，需要打包设置 BuildPipeline.BuildAssetBundles(Application.streamingAssetPath, BuildAssetBundleOptions.ChunkBasedCompression); 不压缩当然，我们也可以不对AssetBundle进行压缩。没有经过压缩的胞体系最大，但是访问速度最快。 若要使用不压缩的策略，只需要在打包的时候开启 BuildPipeline.BuildAsetBundles(Application.streamingAssetPath, BuildAssetBundleOptions.UncompressedAssetBundle); 五 AssetBundle原理分析5.2 AssetBundle及Assets的卸载在AssetBundle的下载和加载过程中，以及Assets加载和实例化过程中，AssetBundle以及加载的Assets都会占用内存。 AssetBundle的卸载采用Assetbundle.Unload(bool)接口。 Assets的卸载有两种方式: AssetBundle.Unload(true); // 这会强制卸载掉所有从AssetBundle加载的Assets。 Resource.UnloadUnusedAssets()和Resources.UnloadAsset。这会卸载掉所有没有用到的Assets。需要注意的是，该接口作用于整个系统，而不仅仅是当前的AssetBundle，而且不会卸载从当前AssetBundle文件中加载并仍在使用的Assets。 对于实例化出来的对象，可以使用GameObject.Destroy活GameObject.DestroyImmediate。注意的是：官方说法是这样的，如果使用GameObject.Destroy接口，Unity会将真正的删除操作延后到一个合适的时机统一进行处理，但会在渲染之前。 对于WWW对象，可以使用www=null或www.dispose。这两者是由区别的，www=null不会立即释放内存，而是系统自动回收机制启动时回收。www.dispose则会立即调用系统的回收机制来释放内存。当WWW对象被释放后，其对于Web Stream数据的引用计数也会相应减1。 对于Web Stream数据，它所占用的内存会在其引用计数为0时，被系统自动回收。例如：当上图中的AssetBundle对象和WWW对象被释放后，Web Stream数据所占内存也会被系统自动回收。 六 AssetBundle依赖加载如果一个或者多个UnityEngine.Objects引用了其他AssetBundle中的UnityEngine.Object，那么AssetBundle之间就产生了依赖关系了。如果UnityEngine.ObjectA所引用的UnityEngine.ObjectB不是其他的AssetBundle中的，那么依赖就不会产生。如果产生依赖，被依赖对象(UnityEngine.ObjectB)将被拷贝进你创建的AssetBundle(指包含UnityEngine.ObjectA的AssetBundle) 更进一步，如果有多个对象(UnityEngine.ObjectA1、UnityEngine.ObjectA2、UnityEngine.ObjectA3…)引用了同一个被依赖对象(UnityEngine.ObjectB)，那么被依赖对象将被拷贝多份，打包进各个对象各自的AssetBundle。 如果一个AssetBundle存在依赖性，那么要注意的是，那些包含了被依赖对象的AssetBundles，需要在你想要实例化的对象的加载之前加载。Unity不会自动帮你加载这些依赖。 想想看下面的例子，Bundle1中的一个材质(Material)引用了Bundle2中的一个纹理(Texture)在这个例子中，在从Bundle1中加载材质前，你需要先将Bundle2加载到内存中。你按照声明顺序加载Bundle1和Bundle2并不重要，重要的是，想从Bundle1中加载材质前，你需要先加载Bundle2。]]></content>
      <tags>
        <tag>Unity3D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity3D笔记]]></title>
    <url>%2F2018%2F04%2F11%2FUnity-Note%2F</url>
    <content type="text"><![CDATA[在Update中使用Time.deltaTime，获取到的是这一帧的时间，如果游戏卡，帧率低，那这个值就大。如果游戏流畅，帧率高，这个值就小，Time.deltaTime=1.0f/帧率 1、MonoBehaviour.Update 更新渲染帧当MonoBehaviour启用时，其Update在每一帧被调用。 2、MonoBehaviour.FixedUpdate 固定更新逻辑帧当MonoBehaviour启用时，其 FixedUpdate在每一帧被调用。处理Rigidbody时，需要用FixedUpdate代替Update。例如：给刚体加一个作用力时，你必须应用作用力在FixedUpdate里的固定帧，而不是Update中的帧(两者帧长不同)。 3、MonoBehaviour.LateUpdate 晚于更新渲染帧末尾当Behaviour启用时，其LateUpdate在每一帧被调用。LateUpdate是在所有Update函数调用后被调用。这可用于调整脚本执行顺序。例如:当物体在Update里移动时，跟随物体的相机可以在LateUpdate里实现。 Update和FixedUpdate的区别：Update跟当前平台的帧数有关，而FixedUpdate是CPU tick 的时间，所以处理物理逻辑的时候要把代码放在FixedUpdate而不是Update。Update是在每次渲染新的一帧的时候才会调用，也就是说，这个函数的更新频率和设备的性能有关以及被渲染的物体（可以认为是三角形的数量）。在性能好的机器上可能fps 30，差的可能小些。这会导致同一个游戏在不同的机器上效果不一致，有的快有的慢。因为Update的执行间隔不一样了。而FixedUpdate，是在固定的时间间隔执行，不受游戏帧率的影响。有点像Tick。所以处理Rigidbody的时候最好用FixedUpdate。 FixedUpdate的时间间隔可以在项目设置中更改，Edit-&gt;ProjectSetting-&gt;time 找到Fixedtimestep。就可以修改了。 Update和LateUpdate的区别：LateUpdate是在所有Update函数调用后被调用。这可用于调整脚本执行顺序。例如：当物体在Update里移动时，跟随物体的相机可以在LateUpdate里实现。LateUpdate是晚于所有Update执行的。例如：游戏中有2个脚步，脚步1含有Update和LateUpdate，脚步2含有Update，那么当游戏执行时，每一帧都是把2个脚步中的Update执行完后才执行LateUpdate 。虽然是在同一帧中执行的，但是Update（渲染帧）会先执行，LateUpdate（渲染帧末尾）会晚执行。现在假设有2个不同的脚本同时在Update中控制一个物体，那么当其中一个脚本改变物体方位、旋转或者其他参数时，另一个脚步也在改变这些东西，那么这个物体的方位、旋转就会出现一定的反复。如果还有个物体在Update中跟随这个物体移动、旋转的话，那跟随的物体就会出现抖动。 如果是在LateUpdate中跟随的话就会只跟随所有Update执行完后的最后位置、旋转，这样就防止了抖动。 IOS: Application.dataPath Application/xxxxxxxxx/xxx.app/DataApplication.streamAssetsPath Application/xxxxxxxxx/xxx.app/Data/RawApplication.persistentDataPath Application/xxxxxxxxx/xxx.app/DocumentsApplication.temporaryCachePath Application/xxxxxxxxx/xxx.app/Library/Caches Android: Application.dataPath /data/app/xxx.xxx.xxx.apkApplication.streamAssetsPath jar:file:///data/app/xxx.xxx.xxx.apk/!/assetsApplication.persistentDataPath /data/data/xxx.xxx.xxx/filesApplication.temporaryCachePath /data/data/xxx.xxx.xxx/cache Windows: Application.dataPath /AssetsApplication.streamAssetsPath /Assets/StreamingAssetsApplication.persistentDataPath C:/Users/xxxx/AppData/LocalLow/CompanyName/ProductNameApplication.temporaryCachePath C:/Users/xxxx/AppData/Local/Temp/CompanyName/ProductName Max: Application.dataPath /AssetsApplication.streamAssetsPath /Assets/StreamingAssetsApplication.persistentDataPath /Users/xxxx/Library/Caches/CompanyName/Product NameApplication.temporaryCachePath /var/folders/57/6b4_9w8113x2fsmzx_yhrhvh0000gn/T/CompanyName/Product 影响渲染顺序因素地总结 Camrea Depth 相机组件上设置的相机深度，深度越大越靠后渲染。 Sorting Layer 在Tags &amp; Layers设置中可见。 Order In Layer 相当于Sorting Layer的子排序，用这个值做比较时只有都在同一层时才有效。 RenderQueue Shader中对Tags设置的”Queue” Camera Depth永远最高。Camera Depth小的一定先进渲染管线。当Sorting Layer和Order in Layer相同时RenderQueue小的先进渲染管线。 当Sorting Layer和Order In Layer不相同时！当两个材质使用了不同的RenderQueue,且这两个RenderQueue都在[0~2500]或[2501~5000]时，SortingLayer和OrderInLayer的排序生效。当两个材质使用了不同的RenderQueue,且这两个RenderQueue分别再[0~2500]或[2501~5000]时，则一定会按照RenderQueue绘制，无视SortingLayer,OrderInLayer的排序。]]></content>
      <tags>
        <tag>Unity3D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[约束]]></title>
    <url>%2F2018%2F04%2F11%2Fconstraint%2F</url>
    <content type="text"><![CDATA[T:struct 类型参数必须是值类型。可以指定除Nullable以外的任何值类型。 T:class 类型参数必须是引用类型，包括任何类、接口、委托或数组类型。 T:new() 类型参数必须具有无参数的公共构造函数。当与其他约束一起使用时，new()约束必须最后指定。 T:&lt;接口名称&gt; 类型参数必须是指定的接口或实现指定的接口。可以指定多个接口约束。约束接口也可以是泛型的。 T:U 为T提供的类型参数必须是为U提供的参数或派生自为U提供的参数。这称为螺类型约束。 public class MyGenericClass&lt;T&gt; where T:IComparable {} class MyClassy&lt;T, U&gt; where T : class where U : struct {} public class MyGenericClass&lt;T&gt; where T: IComparable, new() { T item = new T(); } 12345678910interface MyI &#123;&#125;class Dictionary&lt;TKey, TVal&gt;where TKey: IComparable, IEnumerablewhere TVal: MyI&#123; public void Add(Tkey key, TVal val) &#123; &#125;&#125; public bool MyMethod&lt;T&gt; (T t) where T: IMyInterface {} 1234567class List&lt;T&gt;&#123; void Add&lt;U&gt;(List&lt;U&gt; items) where U: T &#123; &#125;&#125; default 之所以会用到default关键字，是因为需要在不知道类型参数为值类型还是引用类型的情况下，为对象实例赋初值。 ```class TestDefault{ public T foo() { return default(T); }}]]></content>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[23种设计模式]]></title>
    <url>%2F2018%2F04%2F11%2F23-Design-Patterns%2F</url>
    <content type="text"><![CDATA[设计模式分为三大类：创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。结构性模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介模式、解释器模式。其实还有两类：并发型模式和线程池模式。 设计模式六大原则：总原则-开闭原则对扩展开放，对修改封闭。在程序需要进行扩展的时候，不能去修改原有的代码，而是扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，外面需要使用接口和抽象类等，后面的具体设计中我们会提到这点。 1、单一职责原则不要存在多余一个导致类变更的原因，也就是说每个类应该实现单一的职责，否则就应该把类拆分。 2.里氏替换原则(Liskov Substitution Principle)任何积累可以出现的地方，子类一定可以出现 6.合成复用原则(Composite Reuse Principle)尽量首先使用合成/聚合的方式，而不是使用继承。 单线程单例模式12345678910111213141516171819public sealed class Singleton // 密封防止继承&#123; private static Singleton uniqueInstance; // 唯一的实例 // 私有构造函数外部无法创建实例 private Singleton() &#123; &#125; // 全局唯一访问点 public static Singleton GetInstance() &#123; if (uniqueInstance == null) &#123; uniqueInstance = new Singleton(); &#125; return uniqueInstance; &#125;&#125; 单线程单例模式的几个要点： Singleton模式的实例构造器可以设置为protected以允许子类派生。 Singleton模式一般不要ICloneable接口，因为这可能会导致多个对象实例，与Singleton模式的初衷违背。 Singleton模式一般不要支持序列化，因为这也有可能导致多个对象实例，同样与Singleton模式的初衷违背。 Singleton模式只考虑到了对象创建的工作，没有考虑到对象效果的工作。全局静态的放到托管堆中还可以接受？ 不能应对多线程环境，在多线程环境下，使用Singleton模式仍然有可能得到Singleton类的多个实例对象。 工厂设计模式简单工厂设计模式123456789101112131415161718192021222324252627282930313233343536373839404142434445public enum FruitKind&#123; Apple, Pear,&#125;public interface Fruit&#123; void WhatIm();&#125;public class Apple : Fruit&#123; public void WhatIm() &#123; Console.WriteLine("I am Apple"); &#125;&#125;public class Pear : Fruit&#123; public void WhatIm() &#123; Console.WriteLine("I am pear"); &#125;&#125;public class FruitFactory&#123; public static Fruit CreateFruit(FruitKind type) &#123; switch(type) &#123; case FruitKind.Apple: return new Apple(); case FruitKind.Pear: return new Pear(); &#125; return null; &#125;&#125;class Program&#123; static void Main(string[] args) &#123; Fruit a = FruitFactory.CreateFruit(FruitKind.Pear); a.WhatIm(); &#125;&#125; 不太喜欢损失性能和不容易看到内部的逻辑，所以上述不太喜欢。上述存在一个问题，产品内部随便折腾没啥问题，但是做一个新的产品就蛋疼了。 工厂方法设计模式 抽象产品类 具体产品类 抽象工厂类 具体工厂类12345678910111213141516171819202122232425262728293031323334public enum FruitKind&#123; Apple, Pear,&#125;public interface Fruit&#123; void WhatIm();&#125;public class Apple : Fruit&#123; public void WhatIm() &#123; Console.WriteLine("I am Apple"); &#125;&#125;public class Pear : Fruit&#123; public void WhatIm() &#123; Console.WriteLine("I am pear"); &#125;&#125;public interface FruitFactory&#123; Fruit CreateFruit();&#125;public class PearFactory : FruitFactory&#123; public Fruit CreateFruit() &#123; return new Apple(); &#125;&#125; 上述代码解耦了，]]></content>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试1]]></title>
    <url>%2F2018%2F04%2F11%2FInterface%2F</url>
    <content type="text"><![CDATA[接口(Interface)是一种规划，为你定义了一系列的规则和任务，但不去实现它类和结构体可以继承多个接口抽象类表示该类中可能已经有一些的具体定义生成的库在这里：Temp\StagingArea\libs\armeabi-v7a\libil2cpp.so 符号表在这里，需要把扩展名弄成.so，才能被bugly的符号工具转换。Temp\StagingArea\libs\armeabi-v7a\libil2cpp.so.debug C++代码生成到这里，最好保存这个目录，以便对应看调用栈：Temp\StagingArea\Il2Cpp\il2cppOutput ArrayList会把所有插入其中的数据都当成了object类型来处理。弊端：1、不是类型安全的；2、存在装箱拆箱操作 Add() //向数组中添加一个元素Remove() //删除数组中的一个元素RemoveAt(int i);////不是骨骼动画,可以用animator,///骨骼动画 animator只能用一个,Reverse()//反转数组的元素Sort()//从小到大排序数组的元素Clone()//复制一个数组//List//可通过索引访问在决定使用List还是使用ArrayList 类(两者具有类似的功能)时,记住List类在大多数情况下执行的更好并且是类型安全的,如果对List类型T使用值类型,则需要考虑实现和装箱问题如果对类型T实用值类型,则编译器将特别针对该值类型生成List类的实现,这意味着不必对再提醒一下，模板容器里不要使用枚举。比如Dictionary之类的，枚举会boxing，产生无用的GC就用int替代吧 1.请描述游戏动画有哪几种，以及其原理。答:主要有关节动画,单一网络模型动画(关键帧动画),骨骼动画.关节动画把角色分为若干独立部分,一个部分对应一个网络模型,部分的动画连接成一个整体的动画,角色比较灵活Quake2中实用了这种动画.单一网络模型动画由一个完整的网络模型构成,在动画序列的关键帧里记录各个顶点的原位置及其改变量,然后插值运算实现动画效果,角色动画较真实.骨骼动画,广泛应用的动画方式,集成了以上两个方式的优点,骨骼按角色特点组成一定的层次结构,由关节相连,可做相对运动,皮肤作为单一网络蒙在骨骼之外,决定角色的外观,皮肤网络每一个顶点都会收到骨骼的影响,从而实现完美的动画. alpha blend 工作原理alpha blend用于做半透明效果.Color=(源颜色 源系数)OP(目标颜色 目标系数);其中OP(混合方式)有加,减,反减,取最小,取最大 OpenGL Alpha混合假设一种不透明的东西的颜色是A，另一种透明的东西颜色是B，那么透过B看A，看上去的颜色C就是B和A的混合颜色，可以用以下公式来模拟，设B物体的透明度为alpha（取值为0-1，0为完全透明，1为完全不透明） R(C)=alpha*R(B)+(1-alpha)R(A) G(C)=alpha*G(B)+(1-alpha)G(A) B(C)=alpha*B(B)+(1-alpha)G(A) 3.写光照计算中的diffuse的计算公式答:漫反射光(diffuse)计算公式为:ldiffuse = DintensityDcolorN.L;(Dintensity)表示漫反射强度,Dcolor表示漫反射光颜色,N为该点的法向量,L为光源向量其他,3D渲染中,物体表面的光照计算公式为:I = 环境关(lambient) + 漫反射光(ldiffuse) + 镜面高光(lspecular);其中,环境光(ambient)计算公式为: lambient = Aintensity*Acolor;(Aintensity)表示环境光强度,Acolor表示环境光颜色 镜面高光(specular)计算公式为:lspecular = SintensityScolor(R.V)n;(Sintensity)表示镜面光照强度,Scolor表示镜面光颜色,R为光的反射向量,V为观察者向量4.lod是什么，优缺点是什么答:LOD技术即为Levels of Detail的简称,意为多细节层次.LOD技术根据模型的节点在显示环境中所处的位置和重要度,决定物体渲染的资源分配,降低非重要物体的面数和细节度,从而得到高效率的渲染运算5.两种阴影判断的方法工作原理6.MipMap是什么？作用？答:在三维计算机图形的贴图渲染中有一个常用的技术成为Mipmapping,为了加快渲染速度和减少图像锯齿,贴图被处理成由一系列被预先计算和优化过的图片组成的文件,这样的贴图被称为MIP map或者mipmap7.用u3d实现2d游戏，有几种方式？答：一种用UI实现(GUI,NGUI…)，一种是采用3d实体对象（plane），绘制在3d对象上，调节摄像机，采用平行投影模式或则固定视角。8.u3d中碰撞器和触发器的区别？答：触发器只是碰撞器身上的一个属性，碰撞器是触发器的载体。9.物体发生碰撞的必要条件答：需要检测碰撞的物体身上存在刚体组件（或被检测物体），也要碰撞器collider10.CharacterController和Rigidbody的区别11.物体发生碰撞时，有几个阶段，分别对应的函数答：排除触发，有3种，OnCollisionEnter(),OnCollisionStay(); OnCollisionExit()12.u3d中，几种施加力的方式，描述出来。答：a)爆炸力（AddExplosionForce(force : float, forcePos : Vector3，radius : float, upwards : float, mode : ForceMode)），应用一个力到刚体来模拟爆炸效果,就是在爆炸力中心坐标position,搜索在radius范围内的刚体，对其释放力作用，超出radius范围的刚体不受力作用，爆炸力将随着刚体的距离线性减弱。b)力AddForce(force : Vector3, mode : ForceMode),主要施力给一个刚，使其移动。c)位置力AddForceAtPosition(force : Vector3, position : Vector3, mode : ForceMode), 在position施加一个力，施力的主体将会受到一个力和力矩。d)相对力AddRelativeForce(force : Vector3, mode : ForceMode),类似于AddForce；13.什么叫做链条关节答:Hinge Joint ,他可以模拟两个物体见14.物体自旋转使用的函数叫什么答：transform.Rotate(eulerAngles : Vector3, relativeTo : Space = Space.self);15.物体绕某点旋转使用函数叫什么答：transform.RotateAround(point : Vector3, axis : Vector3, angles : float)16.u3d提供了一个用于保存读取数据的类，（playerPrefs），请列出保存读取整形数据的函数答：PlayerPrefs.GetInt(key : string, defaultValue : int = 0);17.unity3d提供了几种光源，分别是什么答：平行光,点光源，聚光灯，环境光18.unity3d从唤醒到销毁有一段生命周期，请列出系统自己调用的几个重要方法。答：void Awake(),void Start(), void Update(), void FixedUpdate(),void LateUpdate(), void OnGUI() ，void Reset(), OnDisable(), void OnDestroy()19.物理更新一般在哪个系统函数里？答：void FixedUpdate()20.移动相机动作在哪个函数里，为什么在这个函数里。答：void LateUpdate(),因为这个函数是在Update执行完毕才执行的，不然的话就有可能出现摄像机里面什么都看到的情况。21.当游戏中需要频繁创建一个物体对象时，我们需要怎么做来节省内存。Unity里有两种动态加载机制:一个是Resources.Load,另外一个通过AssetBundle,其实两者区别不大,Resources.Load就是从一个缺省打进程序包里的AssetBundle里加载资源,而一般AssetBundle文件需要你自己创建,运行时动态加载AssetBundle运行时加载AssetBundle.Unload(flase)是释放AssetBundle文件22.一个场景放置多个camera并同时处于活动状态，会发生什么23.简述prefab的用处和环境24.如何销毁一个UnityEngine.Object以及其子类25.为什么u3d会出现组件上数据丢失的情况26.u3d下如何安全的在不同工程迁移asset数据DrawCall优化一 Mesh Renderer二 Skinned Mesh Renderer三 合并要求对比四 总结五 场景制作建议DrawCall优化合并,即DrawCall Batching.通过减少Draw call数和对显卡性能的消耗来提高性能一 Mesh Renderer分为Dynamic Batching 和 Static BatchingDynamic Batching不需要任何操作,只要共享材质(即使是不同的Mesh模型也可以)Unity中的内存种类实际上Unity游戏使用的内存一共有三种:程序代码,托管堆(Managed Heap)以及本机堆(Native Heap)程序代码包括了所有的Unity引擎,使用的库,以及你所写的所有的游戏代码,在编译后,得到的运行文件将会被加载到设备中执行,并占用一定内存.这部分内存实际上是没有办法去”管理的” 法线贴图一: 法线贴图的原理光照效果很大程度上是由垂直于物体表面的法线决定的,因为法线影响反射光的方向,均匀垂直的法线是镜面贴图但是有时候我们会给一个平面使用砖墙贴图,砖墙应该是凹凸不平的,而如果让砖墙使用该平面的法线的话,画面就很假,神马?一面墙像镜子一样反光而如果按真实砖墙去做模型的话,即做高精度模型,一方面制作麻烦,另一方面运行时对性能的损耗很大.法线贴图就是来解决这个问题的.法线贴图就是把法线信息存储在一张图里.使用发现贴图时,通常顶点数和三角形面数只有高精度模型的十分之一不到.二: 法线贴图的实现将材质贴图对应的法线绘制在一张贴图上,将贴图对应点的单位法线向量信息float3(x,y,z)存储在途中对应的颜色里压缩法线贴图的好处:压缩后的法线贴图,大小只有原来的1/4左右,故可以使用更大或者更多的贴图来提升画面品质.Unity3D的法线贴图Unity3D使用的压缩法线贴图是DXT5nm格式的,有A和G两个通道,对于法线(x,y,z) A对应x,G对应y对压缩法线贴图的采样依然是如下函数 float4 packedNormal = tex2D(_NormalMap, IN.uv_MainTex); packedNormal.w对应A通道,既法线的xpackedNormal.y对应G通道,既法线的yUnity3D热更新全书-加载(一)从AssetBundle说起Unity3D动态加载下载资源,有没有解,有,AssetBundle就是通用解,任何一本书都会花大幅篇章来介绍AssetBundle我们也来说说AssetBundle我们试全面分析一下Unity3D提供的资源加载机制1.Resourecs//内嵌资源,使用方法Resources.Load,可以加载任意种类的资源,不能动态修改,卒2.StreamingAssets//随包资源,使用方法IO或WWW.Load,WWW.Load可以加载任意种类资源,IO仅限bytes和text3.WWW从网络下载并加载4.WWW从网络加载AssetBundle一和二显然不具有热更新的效果,这里就不做讨论3 4都是从网络加载的,他们有什么区别呢首先说3,这是没有缓冲的,我们显然不想让用户重复的浪费流量,不可取然后是4,assetbundle提供了一个版本号来做缓冲对比,可以比较好的起到更新的目标assetbundle原来就是Unity3D为我们准备的方案,难怪每本书都会大篇介绍AssetBundle,后文简称AB每本书都告诉你,AB很强大,AB帮你解决了跨平台问题,帮你解决了依赖关系.而这个系列,不打算只讲别人讲的东西,还有告诉你一些小秘密AssetBundle是天使还是恶魔首先AB的确很好很强大,他能收纳Unity自己的所有资源种类,贴图,材质,shader预设然后可以每平台支持,这就是第一个陷进,注意是每平台都支持,不是多平台支持每个平台都要单独导出,而每个平台到底差了些什么呢?nothing而最大的质量差异,源自贴图有些平台贴图不压缩,有些平台贴图要压缩,而且根据不通的平台特性,套用不通的压缩算法,先压过再存到包里这就是AB帮你干的最主要的事情听起来很贴心呢,等等,你是不是忘了一个特定的命题,这个命题叫做UI压缩的图片会有质量损失,UI贴图我们通常是不压缩的然后UI还会触及到AB的另一个问题以NGUI为例,NGUI的资源关系比较复杂,有贴图-&gt;图集-&gt;布局不同的布局经常交叉应用贴图如果用AB想把每个界面分开打包,给用户最小的资源更新量,这个任务可以用来灾难来形容最终热更新推送给用户的东西是以文件为单位的,而AB在小粒度文件并且之间有较为复杂的应用关系这种需求的下的使用是一场灾难AB对每个平台的差异编译不是可选的,而是强制的,假如你有web,ios,android,三个平台,无论如何你都要导出三次没了AssetBundle,我们怎么办把碎片文件下载回来,并且组装对于UI这个情景,是完全可行的,把布局和图集保存为文本形式,把文本和贴图下载回来,然后组装对于其他场景片段,在有动画和贴图需要压缩的情况下,AB依然是唯一的选择unity没有提供在运行时压缩压缩贴图的手段,动画也不容易存储,只能运行时压缩DXT,只有pc和wp8支持对于各种各样的资源加载回特别凌乱么,不会其实本质上可以统一成bytes的处理texture可以从bytes加载字符串可以从bytes加载AB可以从bytes加载自定义二进制存储,本身就是bytesUnity3D热更新全书-加载(二)如何在不用AssetBundle的前提下动态加载预设Unity3D的主要构成大家都知道,首先是场景图,场景图上的节点构成一棵树每个节点对应一个GameObject对象然后每个GameObject有若干个组件有一些组件会与资源产生关系,比如MeshRenderer会关联材质,材质回关联shader和贴图场景图的一部分回保存为一个预设,prefab有时候我们会需要预设去复用,而预设的加载似乎只能通过AB去打包,其实不然,这里我们有一个开源的库就可以解决这个问题为什么不使用AB,可以见上一篇,加载(一),不使用AB一份资源全平台同意,也没有痛苦的打包时间,资源依赖也很容易处置Unity3d从唤醒到销毁有一段声明周期,调用的几个重要方法为Awake-&gt;OnEnable-&gt;Start-&gt;Update-&gt;FixedUpdate-&gt;LateUpdate-&gt;OnGUI-&gt;Reset-&gt;OnDisable-&gt;OnDestroy物理更新一般在FixedUpdate里,每固定帧绘制时执行一次,和update不同的是FixedUpdate是渲染帧执行,如果你的渲染效率低下的时候FixedUpdate调用次数就会跟着下降,FixedUpdate比较适用于物理引擎的计算,因为是跟每帧渲染有关,Update就比较适合做控制.移动相机动作在LateUpdate函数,当所有Update结束才调用,比较适合用于命令脚本的执行,当游戏中需要频繁创建一个物体对象时,做一个pool,游戏开始时预先实例化足够的数量,用的时候取,不用的时候回收.1.什么是渲染管道?是指在显示器上为了显示出图像而经过的一系列必要操作渲染管道中有很多步骤,都要将几何体从一个坐标系中变换到另一个坐标系中.本地坐标-&gt;视图坐标-&gt;背面裁剪-&gt;光照-&gt;裁剪-&gt;投影-&gt;视图变换-&gt;光栅化优化内存:1.自带压缩类库2.将暂时不用的以后还需要实用的物体隐藏起来而不是直接Destroy掉3.释放AssetBundle占用的资源4.降低模型的片面数,降低模型的骨骼数量,降低贴图的大小5.使用光照贴图,使用多层次细节(LOD),使用着色器(Shader),使用预设(Prefab)资源加载:1.Resources.Load();2.AssetBundlelocalPosition:自身位置,相对于父级的变换位置,Position:在世界坐标transform的位置静态构造函数不允许访问修饰符,也不接受任何参数碰撞器(Collider)有碰撞效果,IsTrigger=false,可以调用OnCollisionEnter/Stay/Exit函数触发器(Trigger)没有碰撞效果,IsTrigger=true,可以调用OnTriggerEnter/Stay/Exit函数2.物体发生碰撞的必要条件?必须带有collider碰撞起和rigibody刚体属性或者人物控制器其实人物控制器就包含了前两者,另外一个也要带有Collider,Collider分类:网格碰撞器,盒子碰撞器,胶囊碰撞器,球型碰撞器,地形碰撞器3.CharacterController和Rigidbody的区别?Rigidbody具有完全真是物理的特性,而CharacterController可以说是受限的Rigidbody,具有一定的物理效果但不是完全真实的.4.物体发生碰撞时,几种施加力的方式,描述出来?rigidbody.AddForce/AddForceAtPosition,都是rigidbody的成员函数5.物体发生碰撞时,有几个阶段,分别对应的函数三个阶段,OnCollsionEnter/Stay/Exit函数6.Unity3d提供了几种光源,分别是什么共4中,DirectrionaLight,PointLight,SpotLight,AreaLight(用于烘培)7.什么是协同程序?在主线程运行时间同时开启另一段逻辑处理,来协助当前程序的执行,换句话说,开启协程就是开启一个线程,可以用来控制运动,序列以及对象的行为.8.使用Unity3d实现2d游戏,有几种方式?(1).使用本身GUI(2).把相机的Projection(投影)值调位Orthographic(正交投影),不考虑z轴;(3).使用2d插件,如:2DTollKit9.下列代码在运行中回产生几个临时对象?string a = new string(“abc”);a = (a.ToUpper() + “123”).SubString(0, 2);答:其实在C#第一行是会出错的(Java中倒是可行),应该这样初始化string b = new string(new char[]{‘a’, ‘b’, ‘c’}}10.请简述关键字Sealed用在类声明和函数声明时的作用答:类声明时可防止其他类继承此类,在方法中声明则可防止派生类重写此方法11.简述四元数的作用,四元数对欧拉角的优点?答:四元数用于表示旋转相对于欧拉角的优点:(1).能进行增量旋转(2).避免方向锁(3)给定方位的表达方式有两种,互为负(欧拉角有无数种表达方式)12.如何安全的在不用工程间安全的迁移asset数据,三种方法答(1).将Assets目录和Library目录一起迁移(2)导出包(3)用unity自带的assert server功能13.当一个细小的高速物体碰撞另一个较大的物体时,会出现什么情况?如何避免?穿透(碰撞检测失败)14.MipMap是什么?作用?在三维计算机图形的贴图渲染中有一个常用的技术被成为Mipmapping,为了加快渲染速度和减少图像锯齿,贴图被处理成为 反射审查元数据并手机关于它的类型信息的能力实现原理：在运行时根据程序集和其中的类型得到元数据实现步骤: 导入 using System.Reflection Assembly.Load(“程序集”)加载一个程序集，返回类型是一个Assembly 得到程序集中所有类的名称 foreach(Type type in assembly.GetType()) { stromh t = type.name; } Type type = assembly.GetType(“程序集.类名”); //获取当前类的类型 Activator.CreateInstance(type); // 创建此类型实例 MethodInfo mInfo = type.GetMethod(“方法名”);//获取当前方法 m.Info.Invok(null, 方法参数);]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unity-nature-review]]></title>
    <url>%2F2018%2F04%2F10%2Funity-nature-review%2F</url>
    <content type="text"><![CDATA[是否有多维子材质：多维子材质材质测试，三个子材质，50个物体，使用多维子材质12帧，330个dc，343面。拆开之后20帧，154dc，134面。多维子材质Unity无法动态合并。叠加模式贴图，可以不用Alpha通道特效粒子贴图是否合并是否有些粒子能使用序列帧，不过和视角有关，去掉alpha贴图合并。动画boneweight,没有特殊需要的情况下受两个骨骼影响就够了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[大端模式与小端模式]]></title>
    <url>%2F2018%2F04%2F02%2FUnix%2F</url>
    <content type="text"><![CDATA[字节序 Little-Endian 低位字节放在内存的低地址端，高位字节放在内存的高地址端。 Big-Endian 高位字节放在内存的高地址端，低位字节放在内存的低地址端。 Network byte order TPC/IP各层协议将字节序定义为Big-Endian，因此TCP/IP协议中使用的字节序通常称之为网络字节序。 高/低地址端首先要知道C程序中内存的空间布局情况：在《C专家编程》和《Unix环境高级编程》中关于内存空间布局情况的说明，大致如下图： ——————————————— 最高内存地址 0xffffffff栈底栈栈顶NULL（空洞）堆未初始化的数据正文段（代码段——————————————— 最高内存地址 0x00000000 在内存分布中，栈是向下增长的，而堆是向上增长的。 加入在栈分配unisgned char buf[4]，他在栈上分布如下栈底（高地址）buf[3]buf[2]buf[1]buf[0]栈顶（低地址） 高/低位字节在十进制中靠左边的是高位，靠右边的地址，在其它进制也是如此 unisgned int value = 0x12345678; Big-Endian:低地址存放高位栈底（高地址）buf[3] (0x78)buf[2] (0x56)buf[1] (0x34)buf[0] (0x12)栈顶（低地址） Litter-Endian:高地址存高位栈顶（高地址）buf[0] (0x78)buf[1] (0x56)buf[2] (0x34)buf[3] (0x12)栈底（低地址） 主机序（Host Order）就是遵循Little-Endian规则。所以当两台主机之间通过TCP/IP协议进行通信的时候就需要调用相应的函数进行主机序（Little-Endian）和网络（Big-Endian）的转换。 Big-Endian和Little-Endian优缺点Big-Endian 优点： 靠首先提取高位字节，总是可以在偏移位置为0的字节来确定这个数字是正数还是负数。 数值打印是按顺序存放的 Litter-Endian 优点： 数学计算，精度处理。]]></content>
      <tags>
        <tag>Unix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua refer manual]]></title>
    <url>%2F2018%2F04%2F02%2FLua-5-1-refer-manual%2F</url>
    <content type="text"><![CDATA[Lua 是一个扩展式程序设计语言，它被设计成支持通用的过程式编程，并有相关数据描述的设施。 Lua 也能对面向对象编程，函数式编程，数据驱动式编程提供很好的支持。 它可以作为一个强大、轻量的脚本语言，供任何需要的程序使用。 Lua 以一个用 clean C 写成的库形式提供。（所谓 Clean C ，指的 ANSI C 和 C++ 中共通的一个子集）作为一个扩展式语言，Lua 没有 “main” 程序的概念：它只能 嵌入 一个宿主程序中工作，这个宿主程序被称作 embedding program 或简称为 host 。 宿主程序可以通过调用函数执行一小段 Lua 代码，可以读写 Lua 变量，可以注入 C 函数让 Lua 代码调用。 这些扩展的 C 函数，可以大大的扩展了 Lua 可以处理事务的领域，这样就可以订制出各种语言， 而它们共享一个统一的句法格式的框架。 Lua 的官方发布版就包含了一个叫做 lua 的简单的宿主程序，它用 Lua 库提供了一个保证独立的 Lua 解释器。Lua 是一个自由软件，它的使用许可决定了对它的使用过程一般没有任何保证。 这份手册中描述的东西的实现，可以在 Lua 的官方网站 www.lua.org 找到，跟其它的许多参考手册一样，这份文档有些地方比较枯燥。 关于 Lua 的设计想法的探讨，可以看看 Lua 网站上提供的技术论文。 有关用 Lua 编程的细节介绍，可以读一下 Roberto 的书，Programming in Lua (Second Edition) 。 这一节从词法、语法、句法上描述 Lua 。 换句话说，这一节描述了哪些 token （符记）是有效的，它们如何被组合起来，这些组合方式有什么含义。关于语言的构成概念将用常见的扩展 BNF 表达式写出。也就是这个样子： {a} 意思是 0 或多个 a ， [a] 意思是一个可选的 a 。 非最终的符号会保留原来的样子，关键字则看起来像这样 kword ， 其它最终的符号则写成 `=´ 。 完整的 Lua 语法可以在本手册最后找到。 Lua 中用到的 名字（也称作 标识符）可以是任何非数字开头的字母、数字、下划线组成的字符串。 这符合几乎所有编程语言中关于名字的定义。 （字母的定义依赖于当前环境：系统环境中定义的字母表中的字母都可以被用于标识符。） 标识符用来命名变量，或作为表的域名。 下面的关键字是保留的，不能用作名字： and break do else elseif end false for function if in local nil not or repeat return then true until while Lua 是一个大小写敏感的语言： and 是一个保留字，但是 And 和 AND 则是两个不同的合法的名字。 一般约定，以下划线开头连接一串大写字母的名字（比如 _VERSION）被保留用于 Lua 内部全局变量。 下面这些是其它的 token ： + - * / % ^ # == ~= &lt;= &gt;= &lt; &gt; = ( ) { } [ ] ; : , . .. ... 字符串既可以用一对单引号引起，也可以是双引号，里面还可以包含类似 C 的转义符： ‘\a’ （响铃）， ‘\b’ （退格）， ‘\f’ （表单）， ‘\n’ （换行）， ‘\r’ （回车）， ‘\t’ （横向制表）， ‘\v’ （纵向制表）， ‘\\’ （反斜杠）， ‘\”‘ （双引号）， 以及 ‘\’’ （单引号)。 而且，如果在一个反斜杠后跟了一个真正的换行符，其结果就是在字符串中产生一个换行符。 我们还可以用反斜杠加数字的形式 \ddd 来描述一个字符。这里， ddd 是一串最多三位的十进制数字。（注意，如果需要在这种描述方法后接一个是数字的字符， 那么反斜杠后必须写满三个数字。）Lua 中的字符串可以包含任何 8 位的值。包括用 ‘\0’ 表示的零。只有在你需要把不同的引号、换行、反斜杠、或是零结束符这些字符置入字符串时， 你才必须使用转义符。别的任何字符都可以直接写在文本里。（一些控制符可以会影响文件系统造成某些问题， 但是不会引起 Lua 的任何问题。）字符串还可以用一种长括号括起来的方式定义。 我们把两个正的方括号间插入 n 个等号定义为第 n 级正长括号。 就是说，0 级正的长括号写作 [[ ， 一级正的长括号写作 [=[ ，如此等等。 反的长扩展也作类似定义； 举个例子，4 级反的长括号写作 ]====] 。 一个长字符串可以由任何一级的正的长括号开始，而由第一个碰到的同级反的长括号结束。 整个词法分析过程将不受分行限制，不处理任何转意符，并且忽略掉任何不同级别的长括号。 这种方式描述的字符串可以包含任何东西，当然特定级别的反长括号除外。另一个约定是，当正的长括号后面立即跟了一个换行符， 这个换行符就不包含在这个字符串内。 举个例子，假设一个系统使用 ASCII 码 （这时，’a’ 编码为 97 ，换行符编码为 10 ，’1’ 编码为 49 ）， 下面五种方式描述了完全相同的字符串： a = &#39;alo\n123&quot;&#39; a = &quot;alo\n123\&quot;&quot; a = &#39;\97lo\10\04923&quot;&#39; a = [[alo 123&quot;]] a = [==[ alo 123&quot;]==] 数字常量可以分两部分写，十进制底数部分和十进制的指数部分。指数部分是可选的。 Lua 也支持十六进制整数常量，只需要在前面加上前缀 0x 。 下面是一些合法的数字常量的例子： 3 3.0 3.1416 314.16e-2 0.31416E1 0xff 0x56 注释可以在除字符串内的任何地方是以两横 (—) 开始。 如果跟在两横后面的不是一个长括号，这就是一个短注释，它的作用范围直到行末； 否则就是一个长注释，其作用范围直到遇到反的长括号。 长注释通常被用来临时屏蔽代码块。Lua 是一种 动态类型语言。 这意味着变量没有类型，只有值才有类型。 语言中不存在类型定义。而所有的值本身携带它们自己的类型信息。Lua 中的所有值都是一致 (first-class) 的。 这意味着所有的值都可以被放在变量里，当作参数传递到另一个函数中，并被函数作为结果返回。Lua 中有八种基本类型： nil, boolean, number, string, function, userdata, thread, and table. Nil 类型只有一种值 nil ，它的主要用途用于标表识和别的任何值的差异； 通常，当需要描述一个无意义的值时会用到它。 Boolean 类型只有两种值：false 和 true。 nil 和 false 都能导致条件为假；而另外所有的值都被当作真。 Number 表示实数（双精度浮点数）。 （编译一个其它内部数字类型的 Lua 解释器是件很容易的事；比如把内部数字类型改作 单精度浮点数或长整型。参见文件 luaconf.h 。） String 表示一串字符的数组。 Lua 是 8-bit clean 的： 字符串可以包含任何 8 位字符， 包括零结束符 (‘\0’) （参见 §2.1）。Lua 可以调用（和处理）用 Lua 写的函数以及用 C 写的函数userdata 类型用来将任意 C 数据保存在 Lua 变量中。 这个类型相当于一块原生的内存，除了赋值和相同性判断，Lua 没有为之预定义任何操作。 然而，通过使用 metatable （元表） ，程序员可以为 userdata 自定义一组操作。 userdata 不能在 Lua 中创建出来，也不能在 Lua 中修改。这样的操作只能通过 C API。 这一点保证了宿主程序完全掌管其中的数据。thread 类型用来区别独立的执行线程，它被用来实现 coroutine （协同例程）。 不要把 Lua 线程跟操作系统的线程搞混。 Lua 可以在所有的系统上提供对 coroutine 的支持，即使系统并不支持线程。table 类型实现了一个关联数组。也就是说， 数组可以用任何东西（除了nil）做索引，而不限于数字。 table 可以以不同类型的值构成；它可以包含所有的类型的值（除 nil 外）。 table 是 lua 中唯一的一种数据结构；它可以用来描述原始的数组、符号表、集合、 记录、图、树、等等。 用于表述记录时，lua 使用域名作为索引。 语言本身采用一种语法糖，支持以 a.name 的形式表示 a[“name”]。 有很多形式用于在 lua 中创建一个 table （参见 §2.5.7）。跟索引一样， table 每个域中的值也可以是任何类型（除 nil外）。 特别的，因为函数本身也是值，所以 table 的域中也可以放函数。 这样 table 中就可以有一些 methods 了 。table， function ，thread ，和 (full) userdata 这些类型的值是所谓的对象： 变量本身并不会真正的存放它们的值，而只是放了一个对对象的引用。 赋值，参数传递，函数返回，都是对这些对象的引用进行操作； 这些操作不会做暗地里做任何性质的拷贝。库函数 type 可以返回一个描述给定值的类型的字符串。Lua 提供运行时字符串到数字的自动转换。 任何对字符串的数学运算操作都会尝试用一般的转换规则把这个字符串转换成一个数字。 相反，无论何时，一个数字需要作为字符串来使用时，数字都会以合理的格式转换为字符串。 需要完全控制数字怎样转换为字符串，可以使用字符串库中的 format 函数 （参见 string.format）。写上变量的地方意味着当以其保存的值来替代之。 Lua 中有三类变量：全局变量，局部变量，还有 table 的域。一个单一的名字可以表示一个全局变量，也可以表示一个局部变量 （或者是一个函数的参数，这是一种特殊形式的局部变量）： var ::= Name Name 就是所定义的标识符。任何变量都被假定为全局变量，除非显式的以 local 修饰定义。 局部变量有其作用范围： 局部变量可以被定义在它作用范围中的函数自由使用。在变量的首次赋值之前，变量的值均为 nil。方括号被用来对 table 作索引： var ::= prefixexp `[´ exp `]´ 对全局变量以及 table 域之访问的含义可以通过 metatable 来改变。 以取一个变量下标指向的量 t[i] 等价于调用 gettable_event(t,i)。 （参见 §2.8 ，有一份完整的关于 gettable_event 函数的说明。 这个函数并没有在 lua 中定义出来，也不能在 lua 中调用。 这里我们把它列出来只是方便说明。） var.Name 这种语法只是一个语法糖，用来表示 var[“Name”]： var ::= prefixexp `.´ Name 所有的全局变量都是放在一个特定 lua table 的诸个域中，这个特定的 table 叫作 environment （环境）table 或者简称为 环境 （参见 §2.9）。 每个函数都有对一个环境的引用， 所以一个函数中可见的所有全局变量都放在这个函数所引用的环境表（environment table）中。 当一个函数被创建出来，它会从创建它的函数中继承其环境，你可以调用 getfenv 取得其环境。 如果想改变环境，可以调用 setfenv。 （对于 C 函数，你只能通过 debug 库来改变其环境； 参见 §5.9）。 对一个全局变量 x 的访问 等价于 _env.x，而这又可以等价于 gettable_event(_env, &quot;x&quot;) 这里，_env 是当前运行的函数的环境。 （函数 gettable_event 的完整说明参见 §2.8。 这个函数并没有在 lua 中定义出来，也不能调用。 当然，_env 这个变量也同样没有在 Lua 中定义出来。 我们在这里使用它们，仅仅只是方便解释而已。） 2.4 - 语句段（Statement）Lua 支持惯例形式的语句段，它和 Pascal 或是 C 很相象。 这个集合包括赋值，控制结构，函数调用，还有变量声明。 2.4.1 - Chunk（语句组）Lua 的一个执行单元被称作 chunk。 一个 chunk 就是一串语句段，它们会被循序的执行。 每个语句段可以以一个分号结束： chunk ::= {stat [`;´]} 这儿不允许有空的语句段，所以 ‘;;’ 是非法的。 lua 把一个 chunk 当作一个拥有不定参数的匿名函数 （参见 §2.5.9）处理。 正是这样，chunk 内可以定义局部变量，接收参数，并且返回值。 chunk 可以被保存在一个文件中，也可以保存在宿主程序的一个字符串中。 当一个 chunk 被执行，首先它会被预编译成虚拟机中的指令序列， 然后被虚拟机解释运行这些指令。 chunk 也可以被预编译成二进制形式；细节参考程序 luac。 用源码形式提供的程序和被编译过的二进制形式的程序是可以相互替换的； Lua 会自动识别文件类型并做正确的处理。 语句块是一列语句段；从语法上来说，一个语句块跟一个 chunk 相同： block ::= chunk 一个语句块可以被显式的写成一个单独的语句段： stat ::= do block end 显式的语句块对于控制变量的作用范围很有用。 有时候，显式的语句块被用来在另一个语句块中插入 return 或是 break （参见 §2.4.4）。 Lua 允许多重赋值。 因此，赋值的语法定义是等号左边放一系列变量， 而等号右边放一系列的表达式。 两边的元素都用逗号间开： stat ::= varlist1 `=´ explist1 varlist1 ::= var {`,´ var} explist1 ::= exp {`,´ exp} 在作赋值操作之前， 那一系列的右值会被对齐到左边变量需要的个数。 如果右值比需要的更多的话，多余的值就被扔掉。 如果右值的数量不够需求， 将会按所需扩展若干个 nil。 如果表达式列表以一个函数调用结束， 这个函数所返回的所有值都会在对齐操作之前被置入右值序列中。 （除非这个函数调用被用括号括了起来；参见 §2.5）。 赋值段首先会做运算完所有的表达式，然后仅仅做赋值操作。 因此，下面这段代码 i = 3 i, a[i] = i+1, 20 会把 a[3] 设置为 20，而不会影响到 a[4] 。 这是因为 a[i] 中的 i 在被赋值为 4 之前就被拿出来了（那时是 3 ）。 简单说 ，这样一行 x, y = y, x 可以用来交换 x 和 y 中的值。 对全局变量以及 table 中的域的赋值操作的含义可以通过 metatable 来改变。 对变量下标指向的赋值，即 t[i] = val 等价于 settable_event(t,i,val)。 （关于函数 settable_event 的详细说明，参见 §2.8。 这个函数并没有在 Lua 中定义出来，也不可以被调用。 这里我们列出来，仅仅出于方便解释的目的） 对于全局变量的赋值 x = val 等价于 _env.x = val，这个又可以等价于 settable_event(_env, &quot;x&quot;, val) 这里，_env 指的是正在运行中的函数的环境。 （变量 _env 并没有在 Lua 中定义出来。 我们仅仅出于解释的目的在这里写出来。） if、 while、以及 repeat 这些控制结构符合通常的意义，而且也有类似的语法： stat ::= while exp do block end stat ::= repeat block until exp stat ::= if exp then block {elseif exp then block} [else block] end Lua 也有一个 for 语句，它有两种形式。控制结构中的条件表达式可以返回任何值。 false 和 nil 两者都被认为是假条件。 所有不同于 nil 和 false 的其它值都被认为是真 （特别需要注意的是，数字 0 和空字符串也被认为是真）。在 repeat–until 循环中， 内部语句块的结束点不是在 until 这个关键字处， 它还包括了其后的条件表达式。 因此，条件表达式中可以使用循环内部语句块中的定义的局部变量。return 被用于从函数或是 chunk（其实它就是一个函数）中 返回值。 函数和 chunk 可以返回不只一个值， 所以 return 的语法为 stat ::= return [explist1] break 被用来结束 while、 repeat、或 for 循环， 它将忽略掉循环中下面的语句段的运行： stat ::= break break 跳出最内层的循环。return 和 break 只能被写在一个语句块的最后一句。 如果你真的需要从语句块的中间 return 或是 break ， 你可以使用显式的声名一个内部语句块。 一般写作 do return end 或是 do break end， 可以这样写是因为现在 return 或 break 都成了一个语句块的最后一句了。 for 有两种形式：一种是数字形式，另一种是一般形式。 数字形式的 for 循环，通过一个数学运算不断的运行内部的代码块。 下面是它的语法： stat ::= for Name `=´ exp `,´ exp [`,´ exp] do block end block 将把 name 作循环变量。从第一个 exp 开始起，直到第二个 exp 的值为止，其步长为 第三个 exp 。 更确切的说，一个 for 循环看起来是这个样子 for v = e1, e2, e3 do block end 这等价于代码： do local var, limit, step = tonumber(e1), tonumber(e2), tonumber(e3) if not (var and limit and step) then error() end while (step &gt; 0 and var &lt;= limit) or (step &lt;= 0 and var &gt;= limit) do local v = var block var = var + step end end 注意下面这几点： 所有三个控制表达式都只被运算一次，表达式的计算在循环开始之前。 这些表达式的结果必须是数字。var 、limit 、以及 step 都是一些不可见的变量。 这里给它们起的名字都仅仅用于解释方便。如果第三个表达式（步长）没有给出，会把步长设为 1 。你可以用 break 来退出 for 循环。循环变量 v 是一个循环内部的局部变量； 当 for 循环结束后，你就不能在使用它。 如果你需要这个值，在退出循环前把它赋给另一个变量。一般形式的 for 通过一个叫作迭代器（iterators）的函数工作。 每次迭代，迭代器函数都会被调用以产生一个新的值， 当这个值为 nil 时，循环停止。 一般形式的 for 循环的语法如下： stat ::= for namelist in explist1 do block end namelist ::= Name {`,´ Name} for 语句好似这样 for var_1, ···, var_n in explist do block end 它等价于这样一段代码： do local f, s, var = explist while true do local var_1, ···, var_n = f(s, var) var = var_1 if var == nil then break end block end end 注意以下几点： explist 只会被计算一次。 它返回三个值， 一个迭代器函数，一个状态，一个迭代器的初始值。f、 s、 以及 var 都是不可见的变量。 这里给它们起的名字都只是为了解说方便。你可以使用 break 来跳出 for 循环。循环变量 var_i 对于循环来说是一个局部变量； 你不可以在 for 循环结束后继续使用。 如果你需要保留这些值，那么就在循环结束前赋值到别的变量里去。2.4.6 - 把函数调用作为语句段为了允许使用可能的副作用， 函数调用可以被作为一个语句段执行： stat ::= functioncall 在这种情况下，所有的返回值都被舍弃。 函数调用在 §2.5.8 中解释。 2.4.7 - 局部变量声名局部变量可以在语句块中任何地方声名。 声名可以包含一个初始化赋值操作： stat ::= local namelist [`=´ explist1] 如果有的话，初始化赋值操作的行为等同于赋值操作（参见 §2.4.3）。 否则，所有的变量将被初始化为 nil。 一个 chunk 同时也是一个语句块（参见 §2.4.1）， 所以局部变量可以放在 chunk 中那些显式注明的语句块之外。 这些局部变量的作用范围从声明起一直延伸到 chunk 末尾。 局部变量的可见规则在 §2.6 中解释。 2.5 - 表达式Lua 中有这些基本表达式： exp ::= prefixexp exp ::= nil | false | true exp ::= Number exp ::= String exp ::= function exp ::= tableconstructor exp ::= `...´ exp ::= exp binop exp exp ::= unop exp prefixexp ::= var | functioncall | `(´ exp `)´ 数字和字符串在 §2.1 中解释； 变量在 §2.3 中解释； 函数定义在 §2.5.9 中解释； 函数调用在 §2.5.8 中解释； table 的构造在 §2.5.7 中解释； 可变参数的表达式写作三个点 (‘…’) ，它只能被用在有可变参数的函数中； 这些在 §2.5.9 中解释。 二元操作符包含有数学运算操作符（参见 §2.5.1）， 比较操作符（参见 §2.5.2），逻辑操作符（参见 §2.5.3）， 以及连接操作符（参见 §2.5.4）。 一元操作符包括负号（参见see §2.5.1）， 取反 not（参见 §2.5.3）， 和取长度操作符（参见 §2.5.5）。 函数调用和可变参数表达式都可以放在多重返回值中。 如果表达式作为一个独立语句段出现（参见 §2.4.6） （这只能是一个函数调用）， 它们的返回列表将被对齐到零个元素，也就是忽略所有返回值。 如果表达式用于表达式列表的最后（或者是唯一）的元素， 就不会有任何的对齐操作（除非函数调用用括号括起来）。 在任何其它的情况下，Lua 将把表达式结果看成单一元素， 忽略除第一个之外的任何值。 这里有一些例子： f() -- 调整到 0 个结果 g(f(), x) -- f() 被调整到一个结果 g(x, f()) -- g 被传入 x 加上所有 f() 的返回值 a,b,c = f(), x -- f() 被调整到一个结果 （ c 在这里被赋为 nil ） a,b = ... -- a 被赋值为可变参数中的第一个， -- b 被赋值为第二个 （如果可变参数中并没有对应的值， -- 这里 a 和 b 都有可能被赋为 nil） a,b,c = x, f() -- f() 被调整为两个结果 a,b,c = f() -- f() 被调整为三个结果 return f() -- 返回 f() 返回的所有结果 return ... -- 返回所有从可变参数中接收来的值 return x,y,f() -- 返回 x, y, 以及所有 f() 的返回值 {f()} -- 用 f() 的所有返回值创建一个列表 {...} -- 用可变参数中的所有值创建一个列表 {f(), nil} -- f() 被调整为一个结果 被括号括起来的表达式永远被当作一个值。所以， (f(x,y,z)) 即使 f 返回多个值，这个表达式永远是一个单一值。 （(f(x,y,z)) 的值是 f 返回的第一个值。如果 f 不返回值的话，那么它的值就是 nil 。） 2.5.1 - 数学运算操作符Lua 支持常见的数学运算操作符： 二元操作 + （加法）， - （减法），* （乘法）， / （除法）， % （取模），以及 ^ （幂）； 和一元操作 - （取负）。 如果对数字操作，或是可以转换为数字的字符串（参见 §2.2.1）， 所有这些操作都依赖它通常的含义。 幂操作可以对任何幂值都正常工作。比如， x^(-0.5) 将计算出 x 平方根的倒数。 取模操作被定义为 a % b == a - math.floor(a/b)*b 这就是说，其结果是商相对负无穷圆整后的余数。（译注：负数对正数取模的结果为正数） 2.5.2 - 比较操作符Lua 中的比较操作符有 == ~= &lt; &gt; &lt;= &gt;= 这些操作的结果不是 false 就是 true。 等于操作 (==) 首先比较操作数的类型。 如果类型不同，结果就是 false。 否则，继续比较值。 数字和字符串都用常规的方式比较。 对象 （table ，userdata ，thread ，以及函数）以引用的形式比较： 两个对象只有在它们指向同一个东西时才认为相等。 每次你创建一个新对象（一个 table 或是 userdata ，thread 函数）， 它们都各不相同，即不同于上次创建的东西。 你可以改变 Lua 比较 table 和 userdata 的方式，这需要使用 “eq” 这个原方法 （参见 §2.8）。 §2.2.1 中提及的转换规则并不作用于比较操作。 所以， “0”==0 等于 false， 而且 t[0] 和 t[“0”] 描述的是 table 中不同的域。 操作符 ~= 完全等价于 (==) 操作的反值。 大小比较操作以以下方式进行。 如果参数都是数字，那么就直接做数字比较。 否则，如果参数都是字符串，就用字符串比较的方式进行。 再则，Lua 就试着调用 “lt” 或是 “le” 元方法 （参见 §2.8）。 2.5.3 - 逻辑操作符Lua 中的逻辑操作符有 and, or, 以及 not。 和控制结构（参见 §2.4.4）一样， 所有的逻辑操作符把 false 和 nil 都作为假， 而其它的一切都当作真。 取反操作 not 总是返回 false 或 true 中的一个。 与操作符 and 在第一个参数为 false 或 nil 时 返回这第一个参数； 否则，and 返回第二个参数。 或操作符 or 在第一个参数不为 nil 也不为 false 时， 返回这第一个参数，否则返回第二个参数。 and 和 or 都遵循短路规则； 也就是说，第二个操作数只在需要的时候去求值。 这里有一些例子： 10 or 20 --&gt; 10 10 or error() --&gt; 10 nil or &quot;a&quot; --&gt; &quot;a&quot; nil and 10 --&gt; nil false and error() --&gt; false false and nil --&gt; false false or nil --&gt; nil 10 and 20 --&gt; 20 （在这本手册中， —&gt; 指前面表达式的结果。） 2.5.4 - 连接符Lua 中字符串的连接操作符写作两个点 (‘..’)。 如果两个操作数都是字符串或都是数字，连接操作将以 §2.2.1 中提到的规则把其转换为字符串。 否则，会取调用元方法 “concat” （参见 §2.8）。 2.5.5 - 取长度操作符取长度操作符写作一元操作 #。 字符串的长度是它的字节数（就是以一个字符一个字节计算的字符串长度）。 table t 的长度被定义成一个整数下标 n 。 它满足 t[n] 不是 nil 而 t[n+1] 为 nil； 此外，如果 t[1] 为 nil ，n 就可能是零。 对于常规的数组，里面从 1 到 n 放着一些非空的值的时候， 它的长度就精确的为 n，即最后一个值的下标。 如果数组有一个“空洞” （就是说，nil 值被夹在非空值之间）， 那么 #t 可能是指向任何一个是 nil 值的前一个位置的下标 （就是说，任何一个 nil 值都有可能被当成数组的结束）。 2.5.6 - 优先级Lua 中操作符的优先级写在下表中，从低到高优先级排序： or and &lt; &gt; &lt;= &gt;= ~= == .. + - * / % not # - (unary) ^ 通常，你可以用括号来改变运算次序。 连接操作符 (‘..’) 和幂操作 (‘^’) 是从右至左的。 其它所有的操作都是从左至右。 2.5.7 - Table 构造table 构造子是一个构造 table 的表达式。 每次构造子被执行，都会构造出一个新的 table 。 构造子可以被用来构造一个空的 table， 也可以用来构造一个 table 并初始化其中的一些域。 一般的构造子的语法如下 tableconstructor ::= `{´ [fieldlist] `}´ fieldlist ::= field {fieldsep field} [fieldsep] field ::= `[´ exp `]´ `=´ exp | Name `=´ exp | exp fieldsep ::= `,´ | `;´ 每个形如 [exp1] = exp2 的域向 table 中增加新的一项， 其键值为 exp1 而值为 exp2。 形如 name = exp 的域等价于 [“name”] = exp。 最后，形如 exp 的域等价于 [i] = exp ， 这里的 i 是一个从 1 开始不断增长的数字。 这这个格式中的其它域不会破坏其记数。 举个例子： a = { [f(1)] = g; &quot;x&quot;, &quot;y&quot;; x = 1, f(x), [30] = 23; 45 } 等价于 do local t = {} t[f(1)] = g t[1] = &quot;x&quot; -- 1st exp t[2] = &quot;y&quot; -- 2nd exp t.x = 1 -- t[&quot;x&quot;] = 1 t[3] = f(x) -- 3rd exp t[30] = 23 t[4] = 45 -- 4th exp a = t end 如果表单中最后一个域的形式是 exp ， 而且其表达式是一个函数调用或者是一个可变参数， 那么这个表达式所有的返回值将连续的进入列表 （参见 §2.5.8）。 为了避免这一点，你可以用括号把函数调用（或是可变参数）括起来 （参见 §2.5）。 初始化域表可以在最后多一个分割符， 这样设计可以方便由机器生成代码。 2.5.8 - 函数调用Lua 中的函数调用的语法如下： functioncall ::= prefixexp args 函数调用时，第一步，prefixexp 和 args 先被求值。 如果 prefixexp 的值的类型是 function， 那么这个函数就被用给出的参数调用。 否则 prefixexp 的元方法 “call” 就被调用， 第一个参数就是 prefixexp 的值，跟下来的是原来的调用参数 （参见 §2.8）。 这样的形式 functioncall ::= prefixexp `:´ Name args 可以用来调用 “方法”。 这是 Lua 支持的一种语法糖。像 v:name(args) 这个样子，被解释成 v.name(v,args)， 这里 v 只会被求值一次。 参数的语法如下： args ::= `(´ [explist1] `)´ args ::= tableconstructor args ::= String 所有参数的表达式求值都在函数调用之前。 这样的调用形式 f{fields} 是一种语法糖用于表示 f({fields})； 这里指参数列表是一个单一的新创建出来的列表。 而这样的形式 f’string’ （或是 f”string” 亦或是 f[[string]]） 也是一种语法糖，用于表示 f(‘string’)； 这里指参数列表是一个单独的字符串。 因为表达式语法在 Lua 中比较自由， 所以你不能在函数调用的 ‘(‘ 前换行。 这个限制可以避免语言中的一些歧义。 比如你这样写 a = f (g).x(a) Lua 将把它当作一个单一语句段， a = f(g).x(a) 。 因此，如果你真的想作为成两个语句段，你必须在它们之间写上一个分号。 如果你真的想调用 f， 你必须从 (g) 前移去换行。 这样一种调用形式：return functioncall 将触发一个尾调用。 Lua 实现了适当的尾部调用（或是适当的尾递归）： 在尾调用中， 被调用的函数重用调用它的函数的堆栈项。 因此，对于程序执行的嵌套尾调用的层数是没有限制的。 然而，尾调用将删除调用它的函数的任何调试信息。 注意，尾调用只发生在特定的语法下， 这时， return 只有单一函数调用作为参数； 这种语法使得调用函数的结果可以精确返回。 因此，下面这些例子都不是尾调用： return (f(x)) -- 返回值被调整为一个 return 2 * f(x) return x, f(x) -- 最加若干返回值 f(x); return -- 无返回值 return x or f(x) -- 返回值被调整为一个 2.5.9 - 函数定义函数定义的语法如下： function ::= function funcbody funcbody ::= `(´ [parlist1] `)´ block end 另外定义了一些语法糖简化函数定义的写法： stat ::= function funcname funcbody stat ::= local function Name funcbody funcname ::= Name {`.´ Name} [`:´ Name] 这样的写法： function f () body end 被转换成 f = function () body end 这样的写法： function t.a.b.c.f () body end 被转换成 t.a.b.c.f = function () body end 这样的写法： local function f () body end 被转换成 local f; f = function () body end 注意，并不是转换成 local f = function () body end （这个差别只在函数体内需要引用 f 时才有。） 一个函数定义是一个可执行的表达式， 执行结果是一个类型为 function 的值。 当 Lua 预编译一个 chunk 的时候， chunk 作为一个函数，整个函数体也就被预编译了。 那么，无论何时 Lua 执行了函数定义， 这个函数本身就被实例化了（或者说是关闭了）。 这个函数的实例（或者说是 closure（闭包）） 是表达式的最终值。 相同函数的不同实例有可能引用不同的外部局部变量， 也可能拥有不同的环境表。 形参（函数定义需要的参数）是一些由实参（实际传入参数）的值初始化的局部变量： parlist1 ::= namelist [`,´ `...´] | `...´ 当一个函数被调用， 如果函数没有被定义为接收不定长参数，即在形参列表的末尾注明三个点 (‘…’)， 那么实参列表就会被调整到形参列表的长度， 变长参数函数不会调整实参列表； 取而代之的是，它将把所有额外的参数放在一起通过变长参数表达式传递给函数， 其写法依旧是三个点。 这个表达式的值是一串实参值的列表，看起来就跟一个可以返回多个结果的函数一样。 如果一个变长参数表达式放在另一个表达式中使用，或是放在另一串表达式的中间， 那么它的返回值就会被调整为单个值。 若这个表达式放在了一系列表达式的最后一个，就不会做调整了（除非用括号给括了起来）。 我们先做如下定义，然后再来看一个例子： function f(a, b) end function g(a, b, ...) end function r() return 1,2,3 end 下面看看实参到形参数以及可变长参数的映射关系： CALL PARAMETERS f(3) a=3, b=nil f(3, 4) a=3, b=4 f(3, 4, 5) a=3, b=4 f(r(), 10) a=1, b=10 f(r()) a=1, b=2 g(3) a=3, b=nil, ... --&gt; (nothing) g(3, 4) a=3, b=4, ... --&gt; (nothing) g(3, 4, 5, 8) a=3, b=4, ... --&gt; 5 8 g(5, r()) a=5, b=1, ... --&gt; 2 3 结果由 return 来返回（参见 §2.4.4）。 如果执行到函数末尾依旧没有遇到任何 return 语句， 函数就不会返回任何结果。 冒号语法可以用来定义方法， 就是说，函数可以有一个隐式的形参 self。 因此，如下写法： function t.a.b.c:f (params) body end 是这样一种写法的语法糖： t.a.b.c.f = function (self, params) body end 2.6 - 可视规则Lua 是一个有词法作用范围的语言。 变量的作用范围开始于声明它们之后的第一个语句段， 结束于包含这个声明的最内层语句块的结束点。 看下面这些例子： x = 10 -- 全局变量 do -- 新的语句块 local x = x -- 新的一个 &#39;x&#39;, 它的值现在是 10 print(x) --&gt; 10 x = x+1 do -- 另一个语句块 local x = x+1 -- 又一个 &#39;x&#39; print(x) --&gt; 12 end print(x) --&gt; 11 end print(x) --&gt; 10 （取到的是全局的那一个） 注意这里，类似 local x = x 这样的声明， 新的 x 正在被声明，但是还没有进入它的作用范围， 所以第二个 x 指向的是外面一层的变量。 因为有这样一个词法作用范围的规则， 所以可以在函数内部自由的定义局部变量并使用它们。 当一个局部变量被更内层的函数中使用的时候， 它被内层函数称作 upvalue（上值），或是 外部局部变量。 注意，每次执行到一个 local 语句都会定义出一个新的局部变量。 看看这样一个例子： a = {} local x = 20 for i=1,10 do local y = 0 a[i] = function () y=y+1; return x+y end end 这个循环创建了十个 closure（这指十个匿名函数的实例）。 这些 closure 中的每一个都使用了不同的 y 变量， 而它们又共享了同一份 x。 errorerror(message[, level]) Level = 1[默认]：为调用error位置(文件+行号) Level = 2：指出哪个调用error的函数的函数 Level = 0：不添加错误位置信息因为 Lua 是一个嵌入式的扩展语言， 所有的 Lua 动作都是从宿主程序的 C 代码调用 Lua 库 （参见 lua_pcall）中的一个函数开始的。 在 Lua 编译或运行的任何时候发生了错误，控制权都会交还给 C ， 而 C 可以来做一些恰当的措施（比如打印出一条错误信息）。Lua 代码可以显式的调用 error 函数来产生一条错误。 如果你需要在 Lua 中捕获发生的错误， 你可以使用 pcall 函数。 MetatableLua 中的每个值都可以用一个 metatable。 这个 metatable 就是一个原始的 Lua table ， 它用来定义原始值在特定操作下的行为。 你可以通过在 metatable 中的特定域设一些值来改变拥有这个 metatable 的值 的指定操作之行为。 举例来说，当一个非数字的值作加法操作的时候， Lua 会检查它的 metatable 中 “__add” 域中的是否有一个函数。 如果有这么一个函数的话，Lua 调用这个函数来执行一次加法。我们叫 metatable 中的键名为 事件 (event) ，把其中的值叫作 元方法 (metamethod)。 在上个例子中，事件是 “add” 而元方法就是那个执行加法操作的函数。你可以通过 getmetatable 函数来查询到任何一个值的 metatable。你可以通过 setmetatable 函数来替换掉 table 的 metatable 。 你不能从 Lua 中改变其它任何类型的值的 metatable （使用 debug 库例外）； 要这样做的话必须使用 C API 。每个 table 和 userdata 拥有独立的 metatable （当然多个 table 和 userdata 可以共享一个相同的表作它们的 metatable）； 其它所有类型的值，每种类型都分别共享唯一的一个 metatable。 因此，所有的数字一起只有一个 metatable ，所有的字符串也是，等等。一个 metatable 可以控制一个对象做数学运算操作、比较操作、连接操作、取长度操作、取下标操作时的行为， metatable 中还可以定义一个函数，让 userdata 作垃圾收集时调用它。 对于这些操作，Lua 都将其关联上一个被称作事件的指定健。 当 Lua 需要对一个值发起这些操作中的一个时， 它会去检查值中 metatable 中是否有对应事件。 如果有的话，键名对应的值（元方法）将控制 Lua 怎样做这个操作。metatable 可以控制的操作已在下面列出来。 每个操作都用相应的名字区分。 每个操作的键名都是用操作名字加上两个下划线 ‘‘ 前缀的字符串； 举例来说，”add” 操作的键名就是字符串 “add”。 这些操作的语义用一个 Lua 函数来描述解释器如何执行更为恰当。这里展示的用 Lua 写的代码仅作解说用； 实际的行为已经硬编码在解释器中，其执行效率要远高于这些模拟代码。 这些用于描述的的代码中用到的函数 （ rawget ， tonumber ，等等。） 都可以在 §5.1 中找到。 特别注意，我们使用这样一个表达式来从给定对象中提取元方法 metatable(obj)[event] 这个应该被解读作 rawget(getmetatable(obj) or {}, event) 这就是说，访问一个元方法不再会触发任何的元方法， 而且访问一个没有 metatable 的对象也不会失败（而只是简单返回 nil）。 “add”: + 操作。下面这个 getbinhandler 函数定义了 Lua 怎样选择一个处理器来作二元操作。 首先，Lua 尝试第一个操作数。 如果这个东西的类型没有定义这个操作的处理器，然后 Lua 会尝试第二个操作数。 function getbinhandler (op1, op2, event) return metatable(op1)[event] or metatable(op2)[event] end 通过这个函数， op1 + op2 的行为就是 function add_event (op1, op2) local o1, o2 = tonumber(op1), tonumber(op2) if o1 and o2 then -- 两个操作数都是数字？ return o1 + o2 -- 这里的 &#39;+&#39; 是原生的 &#39;add&#39; else -- 至少一个操作数不是数字时 local h = getbinhandler(op1, op2, &quot;__add&quot;) if h then -- 以两个操作数来调用处理器 return h(op1, op2) else -- 没有处理器：缺省行为 error(···) end end end &quot;sub&quot;: - 操作。 其行为类似于 &quot;add&quot; 操作。 &quot;mul&quot;: * 操作。 其行为类似于 &quot;add&quot; 操作。 &quot;div&quot;: / 操作。 其行为类似于 &quot;add&quot; 操作。 &quot;mod&quot;: % 操作。 其行为类似于 &quot;add&quot; 操作， 它的原生操作是这样的 o1 - floor(o1/o2)*o2 &quot;pow&quot;: ^ （幂）操作。 其行为类似于 &quot;add&quot; 操作， 它的原生操作是调用 pow 函数（通过 C math 库）。 &quot;unm&quot;: 一元 - 操作。 function unm_event (op) local o = tonumber(op) if o then -- 操作数是数字？ return -o -- 这里的 &#39;-&#39; 是一个原生的 &#39;unm&#39; else -- 操作数不是数字。 -- 尝试从操作数中得到处理器 local h = metatable(op).__unm if h then -- 以操作数为参数调用处理器 return h(op) else -- 没有处理器：缺省行为 error(···) end end end &quot;concat&quot;: .. （连接）操作， function concat_event (op1, op2) if (type(op1) == &quot;string&quot; or type(op1) == &quot;number&quot;) and (type(op2) == &quot;string&quot; or type(op2) == &quot;number&quot;) then return op1 .. op2 -- 原生字符串连接 else local h = getbinhandler(op1, op2, &quot;__concat&quot;) if h then return h(op1, op2) else error(···) end end end &quot;len&quot;: # 操作。 function len_event (op) if type(op) == &quot;string&quot; then return strlen(op) -- 原生的取字符串长度 elseif type(op) == &quot;table&quot; then return #op -- 原生的取 table 长度 else local h = metatable(op).__len if h then -- 调用操作数的处理器 return h(op) else -- 没有处理器：缺省行为 error(···) end end end 关于 table 的长度参见 §2.5.5 。 “eq”: == 操作。 函数 getcomphandler 定义了 Lua 怎样选择一个处理器来作比较操作。 元方法仅仅在参于比较的两个对象类型相同且有对应操作相同的元方法时才起效。 function getcomphandler (op1, op2, event) if type(op1) ~= type(op2) then return nil end local mm1 = metatable(op1)[event] local mm2 = metatable(op2)[event] if mm1 == mm2 then return mm1 else return nil end end“eq” 事件按如下方式定义： function eq_event (op1, op2) if type(op1) ~= type(op2) then -- 不同的类型？ return false -- 不同的对象 end if op1 == op2 then -- 原生的相等比较结果？ return true -- 对象相等 end -- 尝试使用元方法 local h = getcomphandler(op1, op2, &quot;__eq&quot;) if h then return h(op1, op2) else return false end end a ~= b 等价于 not (a == b) 。 &quot;lt&quot;: &lt; 操作。 function lt_event (op1, op2) if type(op1) == &quot;number&quot; and type(op2) == &quot;number&quot; then return op1 &lt; op2 -- 数字比较 elseif type(op1) == &quot;string&quot; and type(op2) == &quot;string&quot; then return op1 &lt; op2 -- 字符串按逐字符比较 else local h = getcomphandler(op1, op2, &quot;__lt&quot;) if h then return h(op1, op2) else error(···); end end end a &gt; b 等价于 b &lt; a. &quot;le&quot;: &lt;= 操作。 function le_event (op1, op2) if type(op1) == &quot;number&quot; and type(op2) == &quot;number&quot; then return op1 &lt;= op2 -- 数字比较 elseif type(op1) == &quot;string&quot; and type(op2) == &quot;string&quot; then return op1 &lt;= op2 -- 字符串按逐字符比较 else local h = getcomphandler(op1, op2, &quot;__le&quot;) if h then return h(op1, op2) else h = getcomphandler(op1, op2, &quot;__lt&quot;) if h then return not h(op2, op1) else error(···); end end end end a &gt;= b 等价于 b &lt;= a 。 注意，如果元方法 “le” 没有提供，Lua 就尝试 “lt” ， 它假定 a &lt;= b 等价于 not (b &lt; a) 。 “index”: 取下标操作用于访问 table[key] 。12345678910111213141516171819function gettable_event (table, key) local h if type(table) == "table" then local v = rawget(table, key) if v ~= nil then return v end h = metatable(table).__index if h == nil then return nil end else h = metatable(table).__index if h == nil then error(···); end end if type(h) == "function" then return h(table, key) -- 调用处理器 else return h[key] -- 或是重复上述操作 endend newindex赋值给指定下标 table[key] = value 12345678910111213141516171819202122232425function settable_event (table, key, value) local h if type(table) == "table" then local v = rawget(table, key) if v ~= nil then rawset(table, key, value) return end h = metatable(table).__newindex if h == nil then rawset(table, key, value) return end else h = metatable(table).__newindex if h == nil then error(···) end end if type(h) == "function" then return h(table, key,value) -- 调用处理器 else h[key] = value -- 或是重复上述操作 endend “call”: 当 Lua 调用一个值时调用。123456789101112function function_event (func, ...) if type(func) == "function" then return func(...) -- 原生的调用 else local h = metatable(func).__call if h then return h(func, ...) else error(···) end endend 2.9 - 环境类型为 thread ，function ，以及 userdata 的对象，除了 metatable 外还可以用另外一个与之关联的被称作 它们的环境的一个表， 像 metatable 一样，环境也是一个常规的 table ，多个对象可以共享 同一个环境。userdata 的环境在 Lua 中没有意义。 这个东西只是为了在程序员想把一个表关联到一个 userdata 上时提供便利。关联在线程上的环境被称作全局环境。 全局环境被用作它其中的线程以及线程创建的非嵌套函数 （通过 loadfile ， loadstring 或是 load ）的缺省环境。 而且它可以被 C 代码直接访问（参见 §3.3）。关联在 C 函数上的环境可以直接被 C 代码访问（参见 §3.3）。 它们会作为这个 C 函数中创建的其它函数的缺省环境。关联在 Lua 函数上的环境用来接管在函数内对全局变量（参见 §2.3）的所有访问。 它们也会作为这个函数内创建的其它函数的缺省环境。你可以通过调用 setfenv 来改变一个 Lua 函数 或是正在运行中的线程的环境。 而想操控其它对象（userdata、C 函数、其它线程）的环境的话，就必须使用 C API 。 2.10 - 垃圾收集Lua 提供了一个自动的内存管理。 这就是说你不需要关心创建新对象的分配内存操作，也不需要在这些对象不再需要时的主动释放内存。 Lua 通过运行一个垃圾收集器来自动管理内存，以此一遍又一遍的回收死掉的对象 （这是指 Lua 中不再访问的到的对象）占用的内存。 Lua 中所有对象都被自动管理，包括： table, userdata、 函数、线程、和字符串。Lua 实现了一个增量标记清除的收集器。 它用两个数字来控制垃圾收集周期： garbage-collector pause 和 garbage-collector step multiplier 。garbage-collector pause 控制了收集器在开始一个新的收集周期之前要等待多久。 随着数字的增大就导致收集器工作工作的不那么主动。 小于 1 的值意味着收集器在新的周期开始时不再等待。 当值为 2 的时候意味着在总使用内存数量达到原来的两倍时再开启新的周期。step multiplier 控制了收集器相对内存分配的速度。 更大的数字将导致收集器工作的更主动的同时，也使每步收集的尺寸增加。 小于 1 的值会使收集器工作的非常慢，可能导致收集器永远都结束不了当前周期。 缺省值为 2 ，这意味着收集器将以内存分配器的两倍速运行。你可以通过在 C 中调用 lua_gc 或是在 Lua 中调用 collectgarbage 来改变这些数字。 两者都接受百分比数值（因此传入参数 100 意味着实际值 1 ）。 通过这些函数，你也可以直接控制收集器（例如，停止或是重启）。 2.10.1 - 垃圾收集的元方法使用 C API ， 你可以给 userdata （参见 §2.8）设置一个垃圾收集的元方法。 这个元方法也被称为结束子。 结束子允许你用额外的资源管理器和 Lua 的内存管理器协同工作 （比如关闭文件、网络连接、或是数据库连接，也可以说释放你自己的内存）。一个 userdata 可被回收，若它的 metatable 中有 __gc 这个域 ， 垃圾收集器就不立即收回它。 取而代之的是，Lua 把它们放到一个列表中。 最收集结束后，Lua 针对列表中的每个 userdata 执行了下面这个函数的等价操作： function gc_event (udata) local h = metatable(udata).__gc if h then h(udata) end end 在每个垃圾收集周期的结尾，每个在当前周期被收集起来的 userdata 的结束子会以 它们构造时的逆序依次调用。 也就是说，收集列表中，最后一个在程序中被创建的 userdata 的 结束子会被第一个调用。 2.10.2 - Weak Table（弱表）weak table 是一个这样的 table，它其中的元素都被弱引用。 弱引用将被垃圾收集器忽略掉， 换句话说， 如果对一个对象的引用只有弱引用， 垃圾收集器将回收这个对象。 weak table 的键和值都可以是 weak 的。 如果一个 table 只有键是 weak 的，那么将运行收集器回收它们的键， 但是会阻止回收器回收对应的值。 而一个 table 的键和值都是 weak 时，就即允许收集器回收键又允许收回值。 任何情况下，如果键和值中任一个被回收了，整个键值对就会从 table 中拿掉。 table 的 weak 特性可以通过在它的 metatable 中设置 mode 域来改变。 如果 mode 域中是一个包含有字符 ‘k’ 的字符串时， table 的键就是 weak 的。 如果 __mode 域中是一个包含有字符 ‘v’ 的字符串时， table 的值就是 weak 的。 在你把一个 table 当作一个 metatable 使用之后， 就不能再修改 __mode 域的值。 否则，受这个 metatable 控制的 table 的 weak 行为就成了未定义的。 2.11 - Coroutine （协同例程）Lua 支持 coroutine ，这个东西也被称为协同式多线程 (collaborative multithreading) 。 Lua 为每个 coroutine 提供一个独立的运行线路。 然而和多线程系统中的线程不同，coroutine 只在显式的调用了 yield 函数时才会挂起。 创建一个 coroutine 需要调用一次 coroutine.create 。 它只接收单个参数，这个参数是 coroutine 的主函数。 create 函数仅仅创建一个新的 coroutine 然后返回它的控制器 （一个类型为 thread 的对象）； 它并不会启动 coroutine 的运行。 当你第一次调用 coroutine.resume 时， 所需传入的第一个参数就是 coroutine.create 的返回值。 这时，coroutine 从主函数的第一行开始运行。 接下来传入 coroutine.resume 的参数将被传进 coroutine 的主函数。 在 coroutine 开始运行后，它讲运行到自身终止或是遇到一个 yields 。 coroutine 可以通过两种方式来终止运行： 一种是正常退出，指它的主函数返回（最后一条指令被运行后，无论有没有显式的返回指令）; 另一种是非正常退出，它发生在未保护的错误发生的时候。 第一种情况中， coroutine.resume 返回 true ， 接下来会跟着 coroutine 主函数的一系列返回值。 第二种发生错误的情况下， coroutine.resume 返回 false ， 紧接着是一条错误信息。 coroutine 中切换出去，可以调用 coroutine.yield。 当 coroutine 切出，与之配合的 coroutine.resume 就立即返回， 甚至在 yield 发生在内层的函数调用中也可以（就是说， 这不限于发生在主函数中，也可以是主函数直接或间接调用的某个函数里）。 在 yield 的情况下，coroutine.resume 也是返回 true， 紧跟着那些被传入 coroutine.yield 的参数。 等到下次你在继续同样的 coroutine ，将从调用 yield 的断点处运行下去。 断点处 yield 的返回值将是 coroutine.resume 传入的参数。 类似 coroutine.create ， coroutine.wrap 这个函数也将创建一个 coroutine ， 但是它并不返回 coroutine 本身，而是返回一个函数取而代之。一旦你调用这个返回函数，就会切入 coroutine 运行。 所有传入这个函数的参数等同于传入 coroutine.resume 的参数。 coroutine.wrap 会返回所有应该由除第一个（错误代码的那个布尔量） 之外的由 coroutine.resume 返回的值。 和 coroutine.resume 不同， coroutine.wrap 不捕获任何错误； 所有的错误都应该由调用者自己传递。 看下面这段代码展示的一个例子： function foo (a) print(&quot;foo&quot;, a) return coroutine.yield(2*a) end co = coroutine.create(function (a,b) print(&quot;co-body&quot;, a, b) local r = foo(a+1) print(&quot;co-body&quot;, r) local r, s = coroutine.yield(a+b, a-b) print(&quot;co-body&quot;, r, s) return b, &quot;end&quot; end) print(&quot;main&quot;, coroutine.resume(co, 1, 10)) print(&quot;main&quot;, coroutine.resume(co, &quot;r&quot;)) print(&quot;main&quot;, coroutine.resume(co, &quot;x&quot;, &quot;y&quot;)) print(&quot;main&quot;, coroutine.resume(co, &quot;x&quot;, &quot;y&quot;)) 当你运行它，将得到如下输出结果： co-body 1 10 foo 2 main true 4 co-body r main true 11 -9 co-body x y main true 10 end main false cannot resume dead coroutine 3 - 程序接口（API）这个部分描述了 Lua 的 C API ， 也就是宿主程序跟 Lua 通讯用的一组 C 函数。 所有的 API 函数按相关的类型以及常量都声明在头文件 lua.h 中。 虽然我们说的是“函数”，但一部分简单的 API 是以宏的形式提供的。 所有的这些宏都只使用它们的参数一次 （除了第一个参数，也就是 lua 状态机）， 因此你不需担心这些宏的展开会引起一些副作用。 在所有的 C 库中，Lua API 函数都不去检查参数的有效性和坚固性。 然而，你可以在编译 Lua 时加上打开一个宏开关来 开启 luaconf.h 文件中的宏 luai_apicheck 以改变这个行为。 堆栈Lua 使用一个虚拟栈来和 C 传递值。 栈上的的每个元素都是一个 Lua 值 （nil，数字，字符串，等等）。 无论何时 Lua 调用 C，被调用的函数都得到一个新的栈， 这个栈独立于 C 函数本身的堆栈，也独立于以前的栈。 （译注：在 C 函数里，用 Lua API 不能访问到 Lua 状态机中本次调用之外的堆栈中的数据） 它里面包含了 Lua 传递给 C 函数的所有参数， 而 C 函数则把要返回的结果也放入堆栈以返回给调用者 （参见 lua_CFunction）。 方便起见，所有针对栈的 API 查询操作都不严格遵循栈的操作规则。 而是可以用一个索引来指向栈上的任何元素： 正的索引指的是栈上的绝对位置（从一开始）； 负的索引则指从栈顶开始的偏移量。 更详细的说明一下，如果堆栈有 n 个元素， 那么索引 1 表示第一个元素（也就是最先被压入堆栈的元素） 而索引 n 则指最后一个元素； 索引 -1 也是指最后一个元素（即栈顶的元素）， 索引 -n 是指第一个元素。 如果索引在 1 到栈顶之间（也就是，1 ≤ abs(index) ≤ top） 我们就说这是个有效的索引。 堆栈尺寸当你使用 Lua API 时，就有责任保证其坚固性。 特别需要注意的是，你有责任控制不要堆栈溢出。你可以使用 lua_checkstack 这个函数来扩大可用堆栈的尺寸。无论何时 Lua 调用 C ， 它都只保证 LUA_MINSTACK 这么多的堆栈空间可以使用。 LUA_MINSTACK 一般被定义为 20 ，因此，只要你不是不断的把数据压栈，通常你不用关心堆栈大小。所有的查询函数都可以接收一个索引，只要这个索引是任何栈提供的空间中的值。 栈能提供的最大空间是通过 lua_checkstack 来设置的。 这些索引被称作可接受的索引，通常我们把它定义为： (index &lt; 0 &amp;&amp; abs(index) &lt;= top) || (index &gt; 0 &amp;&amp; index &lt;= stackspace) 注意，0 永远都不是一个可接受的索引。（译注：下文中凡提到的索引，没有特别注明的话，都指可接受的索引。） LUA_GLOBALSINDEX除了特别声明外，任何一个函数都可以接受另一种有效的索引，它们被称作“伪索引”。 这个可以帮助 C 代码访问一些并不在栈上的 Lua 值。 伪索引被用来访问线程的环境，函数的环境，注册表，还有 C 函数的 upvalue。线程的环境（也就是全局变量放的地方）通常在伪索引 LUA_GLOBALSINDEX 处。 正在运行的 C 函数的环境则放在伪索引 LUA_ENVIRONINDEX 之处。可以用常规的 table 操作来访问和改变全局变量的值，只需要指定环境表的位置。 举例而言，要访问全局变量的值，这样做： lua_getfield(L, LUA_GLOBALSINDEX, varname); C Closure当 C 函数被创建出来，我们有可能会把一些值关联在一起， 也就是创建一个 C closure ； 这些被关联起来的值被叫做 upvalue ，它们可以在函数被调用的时候访问的到。 （参见 lua_pushcclosure ）。无论何时去调用 C 函数，函数的 upvalue 都被放在指定的伪索引处。 我们可以用 lua_upvalueindex 这个宏来生成这些伪索引。 第一个关联到函数的值放在 lua_upvalueindex(1) 位置处，依次类推。 任何情况下都可以用 lua_upvalueindex(n) 产生一个 upvalue 的索引， 即使 n 大于实际的 upvalue 数量也可以。它都可以产生一个可接受但不一定有效的索引。 LUA_REGISTRYINDEXLua 提供了一个注册表，这是一个预定义出来的表，可以用来保存任何 C 代码想保存的 Lua 值。 这个表可以用伪索引 LUA_REGISTRYINDEX 来定位。 任何 C 库都可以在这张表里保存数据，为了防止冲突，你需要特别小心的选择键名。 一般的用法是，你可以用一个包含你的库名的字符串做为键名，或者可以取你自己 C 代码 中的一个地址，以 light userdata 的形式做键。注册表里的整数健被用于补充库中实现的引用系统的工作，一般说来不要把它们用于别的用途。 C 中的错误处理在内部实现中，Lua 使用了 C 的 longjmp 机制来处理错误。 （如果你使用 C++ 的话，也可以选择换用异常；参见 luaconf.h 文件。） 当 Lua 碰到任何错误（比如内存分配错误、类型错误、语法错误、还有一些运行时错误） 它都会产生一个错误出去； 也就是调用一个 long jump 。 在保护环境下，Lua 使用 setjmp 来设置一个恢复点； 任何发生的错误都会激活最近的一个恢复点。几乎所有的 API 函数都可能产生错误，例如内存分配错误。 但下面的一些函数运行在保护环境中（也就是说它们创建了一个保护环境再在其中运行）， 因此它们不会产生错误出来： lua_newstate, lua_close, lua_load, lua_pcall, and lua_cpcall。 在 C 函数里，你也可以通过调用 lua_error 产生一个错误。 lua_Alloctypedef void * (*lua_Alloc) (void *ud, void *ptr, size_t osize, size_t nsize); Lua 状态机中使用的内存分配器函数的类型。 内存分配函数必须提供一个功能类似于 realloc 但又不完全相同的函数。 它的参数有 ud ，一个由 lua_newstate 传给它的指针； ptr ，一个指向已分配出来或是将被重新分配或是要释放的内存块指针； osize ，内存块原来的尺寸； nsize ，新内存块的尺寸。 如果且只有 osize 是零时，ptr 为 NULL 。 当 nsize 是零，分配器必须返回 NULL； 如果 osize 不是零，分配器应当释放掉 ptr 指向的内存块。 当 nsize 不是零，若分配器不能满足请求时，分配器返回 NULL 。 当 nsize 不是零而 osize 是零时，分配器应该和 malloc 有相同的行为。 当 nsize 和 osize 都不是零时，分配器则应和 realloc 保持一样的行为。 Lua 假设分配器在 osize &gt;= nsize 时永远不会失败。 这里有一个简单的分配器函数的实现。 这个实现被放在补充库中，由 luaL_newstate 提供。 static void *l_alloc (void *ud, void *ptr, size_t osize, size_t nsize) { (void)ud; (void)osize; /* not used */ if (nsize == 0) { free(ptr); return NULL; } else return realloc(ptr, nsize); } 这段代码假设 free(NULL) 啥也不影响，而且 realloc(NULL, size) 等价于 malloc(size)。 这两点是 ANSI C 保证的行为。 lua_atpaniclua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf); 设置一个新的 panic （恐慌） 函数，并返回前一个。如果在保护环境之外发生了任何错误， Lua 就会调用一个 panic 函数，接着调用 exit(EXIT_FAILURE)， 这样就开始退出宿主程序。 你的 panic 函数可以永远不返回（例如作一次长跳转）来避免程序退出。panic 函数可以从栈顶取到出错信息。 lua_callvoid lua_call (lua_State *L, int nargs, int nresults); 调用一个函数。要调用一个函数请遵循以下协议： 首先，要调用的函数应该被压入堆栈； 接着，把需要传递给这个函数的参数按正序压栈； 这是指第一个参数首先压栈。 最后调用一下 lua_call； nargs 是你压入堆栈的参数个数。 当函数调用完毕后，所有的参数以及函数本身都会出栈。 而函数的返回值这时则被压入堆栈。 返回值的个数将被调整为 nresults 个， 除非 nresults 被设置成 LUA_MULTRET。 在这种情况下，所有的返回值都被压入堆栈中。 Lua 会保证返回值都放入栈空间中。 函数返回值将按正序压栈（第一个返回值首先压栈）， 因此在调用结束后，最后一个返回值将被放在栈顶。 被调用函数内发生的错误将（通过 longjmp）一直上抛。下面的例子中，这行 Lua 代码等价于在宿主程序用 C 代码做一些工作： a = f(&quot;how&quot;, t.x, 14) 这里是 C 里的代码： lua_getfield(L, LUA_GLOBALSINDEX, &quot;f&quot;); /* 将调用的函数 */ lua_pushstring(L, &quot;how&quot;); /* 第一个参数 */ lua_getfield(L, LUA_GLOBALSINDEX, &quot;t&quot;); /* table 的索引 */ lua_getfield(L, -1, &quot;x&quot;); /* 压入 t.x 的值（第 2 个参数）*/ lua_remove(L, -2); /* 从堆栈中移去 &#39;t&#39; */ lua_pushinteger(L, 14); /* 第 3 个参数 */ lua_call(L, 3, 1); /* 调用 &#39;f&#39;，传入 3 个参数，并索取 1 个返回值 */ lua_setfield(L, LUA_GLOBALSINDEX, &quot;a&quot;); /* 设置全局变量 &#39;a&#39; */ 注意上面这段代码是“平衡”的： 到了最后，堆栈恢复成原由的配置。 lua_CFunctiontypedef int (*lua_CFunction) (lua_State *L); C 函数的类型。为了正确的和 Lua 通讯，C 函数必须使用下列 定义了参数以及返回值传递方法的协议： C 函数通过 Lua 中的堆栈来接受参数，参数以正序入栈（第一个参数首先入栈）。 因此，当函数开始的时候， lua_gettop(L) 可以返回函数收到的参数个数。 第一个参数（如果有的话）在索引 1 的地方，而最后一个参数在索引 lua_gettop(L) 处。 当需要向 Lua 返回值的时候，C 函数只需要把它们以正序压到堆栈上（第一个返回值最先压入）， 然后返回这些返回值的个数。 在这些返回值之下的，堆栈上的东西都会被 Lua 丢掉。 和 Lua 函数一样，从 Lua 中调用 C 函数也可以有很多返回值。 下面这个例子中的函数将接收若干数字参数，并返回它们的平均数与和： static int foo (lua_State *L) { int n = lua_gettop(L); /* 参数的个数 */ lua_Number sum = 0; int i; for (i = 1; i &lt;= n; i++) { if (!lua_isnumber(L, i)) { lua_pushstring(L, &quot;incorrect argument&quot;); lua_error(L); } sum += lua_tonumber(L, i); } lua_pushnumber(L, sum/n); /* 第一个返回值 */ lua_pushnumber(L, sum); /* 第二个返回值 */ return 2; /* 返回值的个数 */ } lua_checkstackint lua_checkstack (lua_State *L, int extra); 确保堆栈上至少有 extra 个空位。 如果不能把堆栈扩展到相应的尺寸，函数返回 false 。 这个函数永远不会缩小堆栈； 如果堆栈已经比需要的大了，那么就放在那里不会产生变化。 lua_closevoid lua_close (lua_State *L); 销毁指定 Lua 状态机中的所有对象（如果有垃圾收集相关的元方法的话，会调用它们），并且释放状态机中使用的所有动态内存。 在一些平台上，你可以不必调用这个函数， 因为当宿主程序结束的时候，所有的资源就自然被释放掉了。 另一方面，长期运行的程序，比如一个后台程序或是一个 web 服务器， 当不再需要它们的时候就应该释放掉相关状态机。这样可以避免状态机扩张的过大。 lua_concatvoid lua_concat (lua_State *L, int n); 连接栈顶的 n 个值， 然后将这些值出栈，并把结果放在栈顶。如果 n 为 1 ，结果就是一个字符串放在栈上（即，函数什么都不做）； 如果 n 为 0 ，结果是一个空串。 连接依照 Lua 中创建语义完成（参见 §2.5.4 ）。 lua_cpcallint lua_cpcall (lua_State *L, lua_CFunction func, void *ud); 以保护模式调用 C 函数 func 。 func 只有能从堆栈上拿到一个参数，就是包含有 ud 的 light userdata。 当有错误时， lua_cpcall 返回和 lua_pcall 相同的错误代码， 并在栈顶留下错误对象； 否则它返回零，并不会修改堆栈。 所有从 func 内返回的值都会被扔掉。 lua_createtablevoid lua_createtable (lua_State *L, int narr, int nrec); 创建一个新的空 table 压入堆栈。 这个新 table 将被预分配 narr 个元素的数组空间 以及 nrec 个元素的非数组空间。 当你明确知道表中需要多少个元素时，预分配就非常有用。 如果你不知道，可以使用函数 lua_newtable。 lua_dumpint lua_dump (lua_State *L, lua_Writer writer, void *data); 把函数 dump 成二进制 chunk 。 函数接收栈顶的 Lua 函数做参数，然后生成它的二进制 chunk 。 若被 dump 出来的东西被再次加载，加载的结果就相当于原来的函数。 当它在产生 chunk 的时候，lua_dump 通过调用函数 writer （参见 lua_Writer） 来写入数据，后面的 data 参数会被传入 writer 。最后一次由写入器 (writer) 返回值将作为这个函数的返回值返回； 0 表示没有错误。 这个函数不会把 Lua 返回弹出堆栈。 lua_equalint lua_equal (lua_State *L, int index1, int index2); 如果依照 Lua 中 == 操作符语义，索引 index1 和 index2 中的值相同的话，返回 1 。 否则返回 0 。 如果任何一个索引无效也会返回 0。 lua_errorint lua_error (lua_State *L); 产生一个 Lua 错误。 错误信息（实际上可以是任何类型的 Lua 值）必须被置入栈顶。 这个函数会做一次长跳转，因此它不会再返回。 （参见 luaL_error）。 lua_gcint lua_gc (lua_State *L, int what, int data); 控制垃圾收集器。这个函数根据其参数 what 发起几种不同的任务： LUA_GCSTOP: 停止垃圾收集器。LUA_GCRESTART: 重启垃圾收集器。LUA_GCCOLLECT: 发起一次完整的垃圾收集循环。LUA_GCCOUNT: 返回 Lua 使用的内存总量（以 K 字节为单位）。LUA_GCCOUNTB: 返回当前内存使用量除以 1024 的余数。LUA_GCSTEP: 发起一步增量垃圾收集。 步数由 data 控制（越大的值意味着越多步）， 而其具体含义（具体数字表示了多少）并未标准化。 如果你想控制这个步数，必须实验性的测试 data 的值。 如果这一步结束了一个垃圾收集周期，返回返回 1 。LUA_GCSETPAUSE: 把 data/100 设置为 garbage-collector pause 的新值（参见 §2.10）。 函数返回以前的值。LUA_GCSETSTEPMUL: 把 arg/100 设置成 step multiplier （参见 §2.10）。 函数返回以前的值。 lua_getallocflua_Alloc lua_getallocf (lua_State *L, void **ud); 返回给定状态机的内存分配器函数。 如果 ud 不是 NULL ，Lua 把调用 lua_newstate 时传入的那个指针放入 *ud 。 lua_getfenvvoid lua_getfenv (lua_State *L, int index); 把索引处值的环境表压入堆栈。 lua_getfieldvoid lua_getfield (lua_State *L, int index, const char *k); 把 t[k] 值压入堆栈， 这里的 t 是指有效索引 index 指向的值。 在 Lua 中，这个函数可能触发对应 “index” 事件的元方法 （参见 §2.8）。 lua_getglobalvoid lua_getglobal(lua_State *L, const char *name); 把全局变量name里的值压入堆栈。 这个是用一个宏定义出来的： #define lua_getglobal(L,s) lua_getfield(L, LUA_GLOBALSINDEX, s) lua_getmetatableint lua_getmetatable (lua_State *L, int index); 把给定索引指向的值的元表压入堆栈。 如果索引无效，或是这个值没有元表， 函数将返回 0 并且不会向栈上压任何东西。 lua_gettablevoid lua_gettable (lua_State *L, int index); 把 t[k] 值压入堆栈， 这里的 t 是指有效索引 index 指向的值， 而 k 则是栈顶放的值。这个函数会弹出堆栈上的 key （把结果放在栈上相同位置）。 在 Lua 中，这个函数可能触发对应 “index” 事件的元方法。 lua_gettopint lua_gettop(lua_State *L); 返回栈顶元素的索引。 因为索引是从 1 开始编号的， 所以这个结果等于堆栈上的元素个数（因此返回 0 表示堆栈为空）。 lua_insertvoid lua_insert (lua_State *L, int index); 把栈顶元素插入指定的有效索引处， 并依次移动这个索引之上的元素。 不要用伪索引来调用这个函数， 因为伪索引不是真正指向堆栈上的位置。 lua_Integertypedef ptrdiff_t lua_Integer; 这个类型被用于 Lua API 接收整数值。缺省时这个被定义为 ptrdiff_t ， 这个东西通常是机器能处理的最大整数类型。 lua_isbooleanint lua_isboolean (lua_State *L, int index); 当给定索引的值类型为 boolean 时，返回 1 ，否则返回 0 。 lua_iscfunctionint lua_iscfunction (lua_State *L, int index); 当给定索引的值是一个 C 函数时，返回 1 ，否则返回 0 。 lua_isfunctionint lua_isfunction (lua_State *L, int index); 当给定索引的值是一个函数（ C 或 Lua 函数均可）时，返回 1 ，否则返回 0 。 lua_islightuserdataint lua_islightuserdata (lua_State *L, int index); 当给定索引的值是一个 light userdata 时，返回 1 ，否则返回 0 。 lua_isnilint lua_isnil (lua_State *L, int index); 当给定索引的值是 nil 时，返回 1 ，否则返回 0 。 lua_isnumberint lua_isnumber (lua_State *L, int index); 当给定索引的值是一个数字，或是一个可转换为数字的字符串时，返回 1 ，否则返回 0 。 lua_isstringint lua_isstring (lua_State *L, int index); 当给定索引的值是一个字符串或是一个数字（数字总能转换成字符串）时，返回 1 ，否则返回 0 。 lua_istableint lua_istable (lua_State *L, int index); 当给定索引的值是一个 table 时，返回 1 ，否则返回 0 。 lua_isthreadint lua_isthread (lua_State *L, int index); 当给定索引的值是一个 thread 时，返回 1 ，否则返回 0 。 lua_isuserdataint lua_isuserdata (lua_State *L, int index); 当给定索引的值是一个 userdata （无论是完整的 userdata 还是 light userdata ）时，返回 1 ，否则返回 0 。 lua_lessthanint lua_lessthan (lua_State *L, int index1, int index2); 如果索引 index1 处的值小于 索引 index2 处的值时，返回 1 ； 否则返回 0 。 其语义遵循 Lua 中的 &lt; 操作符（就是说，有可能调用元方法）。 如果任何一个索引无效，也会返回 0 。 lua_loadint lua_load (lua_State *L, lua_Reader reader, void *data, const char *chunkname); 加载一个 Lua chunk 。 如果没有错误， lua_load 把一个编译好的 chunk 作为一个 Lua 函数压入堆栈。 否则，压入出错信息。 lua_load 的返回值可以是： 0: 没有错误；LUA_ERRSYNTAX: 在预编译时碰到语法错误；LUA_ERRMEM: 内存分配错误。这个函数仅仅加栽 chunk ；而不会去运行它。 lua_load 会自动检测 chunk 是文本的还是二进制的， 然后做对应的加载操作（参见程序 luac）。lua_load 函数使用一个用户提供的 reader 函数来 读取 chunk （参见 lua_Reader）。 data 参数会被传入读取器函数。chunkname 这个参数可以赋予 chunk 一个名字， 这个名字被用于出错信息和调试信息。 lua_newstatelua_State *lua_newstate (lua_Alloc f, void *ud); 创建的一个新的独立的状态机。 如果创建不了（因为内存问题）返回 NULL 。 参数 f 是一个分配器函数； Lua 将通过这个函数做状态机内所有的内存分配操作。 第二个参数 ud ，这个指针将在每次调用分配器时被直接传入。 lua_newtablevoid lua_newtable (lua_State *L); 创建一个空 table ，并将之压入堆栈。 它等价于 lua_createtable(L, 0, 0) 。 lua_newthreadlua_State *lua_newthread (lua_State *L); 创建一个新线程，并将其压入堆栈， 并返回维护这个线程的 lua_State 指针。 这个函数返回的新状态机共享原有状态机中的所有对象（比如一些 table）， 但是它有独立的执行堆栈。没有显式的函数可以用来关闭或销毁掉一个线程。 线程跟其它 Lua 对象一样是垃圾收集的条目之一。 lua_newuserdatavoid *lua_newuserdata (lua_State *L, size_t size); 这个函数分配分配一块指定大小的内存块， 把内存块地址作为一个完整的 userdata 压入堆栈，并返回这个地址。userdata 代表 Lua 中的 C 值。 完整的 userdata 代表一块内存。 它是一个对象（就像 table 那样的对象）： 你必须创建它，它有着自己的元表，而且它在被回收时，可以被监测到。 一个完整的 userdata 只和它自己相等（在等于的原生作用下）。当 Lua 通过 gc 元方法回收一个完整的 userdata 时， Lua 调用这个元方法并把 userdata 标记为已终止。 等到这个 userdata 再次被收集的时候，Lua 会释放掉相关的内存。 lua_nextint lua_next (lua_State *L, int index); 从栈上弹出一个 key（键）， 然后把索引指定的表中 key-value（健值）对压入堆栈 （指定 key 后面的下一 (next) 对）。 如果表中以无更多元素， 那么 lua_next 将返回 0 （什么也不压入堆栈）。典型的遍历方法是这样的： /* table 放在索引 &#39;t&#39; 处 */ lua_pushnil(L); /* 第一个 key */ while (lua_next(L, t) != 0) { /* 用一下 &#39;key&#39; （在索引 -2 处） 和 &#39;value&#39; （在索引 -1 处） */ printf(&quot;%s - %s\n&quot;, lua_typename(L, lua_type(L, -2)), lua_typename(L, lua_type(L, -1))); /* 移除 &#39;value&#39; ；保留 &#39;key&#39; 做下一次迭代 */ lua_pop(L, 1); } 在遍历一张表的时候， 不要直接对 key 调用 lua_tolstring ， 除非你知道这个 key 一定是一个字符串。 调用 lua_tolstring 有可能改变给定索引位置的值； 这会对下一次调用 lua_next 造成影响。 lua_Numbertypedef double lua_Number; Lua 中数字的类型。 确省是 double ，但是你可以在 luaconf.h 中修改它。通过修改配置文件你可以改变 Lua 让它操作其它数字类型（例如：float 或是 long ）。 lua_objlensize_t lua_objlen (lua_State *L, int index); 返回指定的索引处的值的长度。 对于 string ，那就是字符串的长度； 对于 table ，是取长度操作符 (‘#’) 的结果； 对于 userdata ，就是为其分配的内存块的尺寸； 对于其它值，为 0 。 lua_pcalllua_pcall (lua_State *L, int nargs, int nresults, int errfunc); 以保护模式调用一个函数。nargs 和 nresults 的含义与 lua_call 中的相同。 如果在调用过程中没有发生错误， lua_pcall 的行为和 lua_call 完全一致。 但是，如果有错误发生的话， lua_pcall 会捕获它， 然后把单一的值（错误信息）压入堆栈，然后返回错误码。 同 lua_call 一样， lua_pcall 总是把函数本身和它的参数从栈上移除。如果 errfunc 是 0 ， 返回在栈顶的错误信息就和原始错误信息完全一致。 否则，errfunc 就被当成是错误处理函数在栈上的索引。 （在当前的实现里，这个索引不能是伪索引。） 在发生运行时错误时， 这个函数会被调用而参数就是错误信息。 错误处理函数的返回值将被 lua_pcall 作为出错信息返回在堆栈上。典型的用法中，错误处理函数被用来在出错信息上加上更多的调试信息，比如栈跟踪信息 (stack traceback) 。 这些信息在 lua_pcall 返回后，因为栈已经展开 (unwound) ， 所以收集不到了。lua_pcall 函数在调用成功时返回 0 ， 否则返回以下（定义在 lua.h 中的）错误代码中的一个： LUA_ERRRUN: 运行时错误。LUA_ERRMEM: 内存分配错误。 对于这种错，Lua 调用不了错误处理函数。LUA_ERRERR: 在运行错误处理函数时发生的错误。 lua_popvoid lua_pop (lua_State *L, int n); 从堆栈中弹出 n 个元素。 lua_pushbooleanvoid lua_pushboolean (lua_State *L, int b); 把 b 作为一个 boolean 值压入堆栈。 lua_pushcclosurevoid lua_pushcclosure (lua_State *L, lua_CFunction fn, int n); 把一个新的 C closure 压入堆栈。当创建了一个 C 函数后，你可以给它关联一些值，这样就是在创建一个 C closure ； 接下来无论函数何时被调用，这些值都可以被这个函数访问到。 为了将一些值关联到一个 C 函数上， 首先这些值需要先被压入堆栈（如果有多个值，第一个先压）。 接下来调用 lua_pushcclosure 来创建出 closure 并把这个 C 函数压到堆栈上。 参数 n 告之函数有多少个值需要关联到函数上。 lua_pushcclosure 也会把这些值从栈上弹出。 lua_pushcfunctionvoid lua_pushcfunction (lua_State *L, lua_CFunction f); 将一个 C 函数压入堆栈。 这个函数接收一个 C 函数指针，并将一个类型为 function 的 Lua 值 压入堆栈。当这个栈顶的值被调用时，将触发对应的 C 函数。注册到 Lua 中的任何函数都必须遵循正确的协议来接收参数和返回值 （参见 lua_CFunction）。 lua_pushcfunction 是作为一个宏定义出现的： #define lua_pushcfunction(L,f) lua_pushcclosure(L,f,0) lua_pushfstringconst char *lua_pushfstring (lua_State *L, const char *fmt, ...); 把一个格式化过的字符串压入堆栈，然后返回这个字符串的指针。 它和 C 函数 sprintf 比较像，不过有一些重要的区别：摸你需要为结果分配空间： 其结果是一个 Lua 字符串，由 Lua 来关心其内存分配 （同时通过垃圾收集来释放内存）。这个转换非常的受限。 不支持 flag ，宽度，或是指定精度。 它只支持下面这些： ‘%%’ （插入一个 ‘%’）， ‘%s’ （插入一个带零终止符的字符串，没有长度限制）， ‘%f’ （插入一个 lua_Number）， ‘%p’ （插入一个指针或是一个十六进制数）， ‘%d’ （插入一个 int)， ‘%c’ （把一个 int 作为一个字符插入）。 lua_pushintegervoid lua_pushinteger (lua_State *L, lua_Integer n); 把 n 作为一个数字压栈。 lua_pushlightuserdatavoid lua_pushlightuserdata (lua_State *L, void *p); 把一个 light userdata 压栈。userdata 在 Lua 中表示一个 C 值。 light userdata 表示一个指针。 它是一个像数字一样的值： 你不需要专门创建它，它也没有独立的 metatable ， 而且也不会被收集（因为从来不需要创建）。 只要表示的 C 地址相同，两个 light userdata 就相等。 lua_pushlstringvoid lua_pushlstring (lua_State *L, const char *s, size_t len); 把指针 s 指向的长度为 len 的字符串压栈。 Lua 对这个字符串做一次内存拷贝（或是复用一个拷贝）， 因此 s 处的内存在函数返回后，可以释放掉或是重用于其它用途。 字符串内可以保存有零字符。 lua_pushnilvoid lua_pushnil (lua_State *L); 把一个 nil 压栈。 lua_pushnumbervoid lua_pushnumber (lua_State *L, lua_Number n); 把一个数字 n 压栈。 lua_pushstringvoid lua_pushstring (lua_State *L, const char *s); 把指针s指向的以零结尾的字符串压栈。 Lua 这个字符串做一次内存拷贝（或是复用一个拷贝）， 因此 s 处的内存在函数返回后，可以释放掉或是重用于其它用途。 字符串中不能包含有零字符；第一个碰到的零字符会认为是字符串的结束。 lua_pushthreadint lua_pushthread (lua_State *L); 把 L 中提供的线程压栈。 如果这个线程是当前状态机的主线程的话，返回 1 。 lua_pushvaluevoid lua_pushvalue(lua_State *L, int index); 把堆栈上给定有效处索引处的元素作一个拷贝压栈。 lua_pushvfstringconst char *lua_pushvfstring (lua_State *L, const char *fmt, va_list argp); 等价于 lua_pushfstring， 不过是用 va_list 接收参数，而不是用可变数量的实际参数。 lua_rawequalint lua_rawequal (lua_State *L, int index1, int index2); 如果两个索引 index1 和 index2 处的值简单地相等 （不调用元方法）则返回 1 。 否则返回 0 。 如果任何一个索引无效也返回 0 。 lua_rawgetvoid lua_rawget (lua_State *L, int index); 类似于 lua_gettable， 但是作一次直接访问（不触发元方法）。 lua_rawgetivoid lua_rawgeti (lua_State *L, int index, int n); 把 t[n] 的值压栈， 这里的 t 是指给定索引 index 处的一个值。这是一个直接访问；就是说，它不会触发元方法。 lua_rawsetvoid lua_rawset (lua_State *L, int index); 类似于 lua_settable ，但是是作一个直接赋值（不触发元方法）。 lua_rawsetivoid lua_rawseti (lua_State *L, int index, int n); 等价于 t[n] = v， 这里的 t 是指给定索引 index 处的一个值， 而 v 是栈顶的值。函数将把这个值弹出栈。 赋值操作是直接的；就是说，不会触发元方法。 lua_Readertypedef const char * (*lua_Reader) (lua_State *L, void *data, size_t *size); lua_load 用到的读取器函数， 每次它需要一块新的 chunk 的时候， lua_load 就调用读取器， 每次都会传入一个参数 data 。 读取器需要返回含有新的 chunk 的一块内存的指针， 并把 size 设为这块内存的大小。 内存块必须在下一次函数被调用之前一直存在。 读取器可以通过返回一个 NULL 来指示 chunk 结束。 读取器可能返回多个块，每个块可以有任意的大于零的尺寸。 lua_registervoid lua_register (lua_State *L, const char *name, lua_CFunction f); 把 C 函数 f 设到全局变量 name 中。 它通过一个宏定义： #define lua_register(L,n,f) \ (lua_pushcfunction(L, f), lua_setglobal(L, n)) lua_removevoid lua_remove (lua_State *L, int index); 从给定有效索引处移除一个元素， 把这个索引之上的所有元素移下来填补上这个空隙。 不能用伪索引来调用这个函数， 因为伪索引并不指向真实的栈上的位置。 lua_replacevoid lua_replace (lua_State *L, int index); 把栈顶元素移动到给定位置（并且把这个栈顶元素弹出）， 不移动任何元素（因此在那个位置处的值被覆盖掉）。 lua_resumeint lua_resume (lua_State *L, int narg); 在给定线程中启动或继续一个 coroutine 。要启动一个 coroutine 的话，首先你要创建一个新线程 （参见 lua_newthread ）； 然后把主函数和若干参数压到新线程的堆栈上； 最后调用 lua_resume ， 把 narg 设为参数的个数。 这次调用会在 coroutine 挂起时或是结束运行后返回。 当函数返回时，堆栈中会有传给 lua_yield 的所有值， 或是主函数的所有返回值。 如果 coroutine 切换时，lua_resume 返回 LUA_YIELD ， 而当 coroutine 结束运行且没有任何错误时，返回 0 。 如果有错则返回错误代码（参见 lua_pcall）。 在发生错误的情况下， 堆栈没有展开， 因此你可以使用 debug API 来处理它。 出错信息放在栈顶。 要继续运行一个 coroutine 的话，你把需要传给 yield 作结果的返回值压入堆栈，然后调用 lua_resume 。 lua_setallocfvoid lua_setallocf (lua_State *L, lua_Alloc f, void *ud); 把指定状态机的分配器函数换成带上指针 ud 的 f 。 lua_setfenvint lua_setfenv (lua_State *L, int index); 从堆栈上弹出一个 table 并把它设为指定索引处值的新环境。 如果指定索引处的值即不是函数又不是线程或是 userdata ， lua_setfenv 会返回 0 ， 否则返回 1 。 lua_setfieldvoid lua_setfield (lua_State *L, int index, const char *k); 做一个等价于 t[k] = v 的操作， 这里 t 是给出的有效索引 index 处的值， 而 v 是栈顶的那个值。这个函数将把这个值弹出堆栈。 跟在 Lua 中一样，这个函数可能触发一个 “newindex” 事件的元方法 （参见 §2.8）。 lua_setglobalvoid lua_setglobal (lua_State *L, const char *name); 从堆栈上弹出一个值，并将其设到全局变量 name 中。 它由一个宏定义出来： #define lua_setglobal(L,s) lua_setfield(L, LUA_GLOBALSINDEX, s) lua_setmetatableint lua_setmetatable (lua_State *L, int index); 把一个 table 弹出堆栈，并将其设为给定索引处的值的 metatable 。 lua_settablevoid lua_settable(lua_State *L, int index); 作一个等价于 t[k] = v的操作，这里t是一个给定有效索引 index 处的值， v 指栈顶的值， 而 k 是栈顶之下的那个值。这个函数会把键和值都从堆栈中弹出。 和在 Lua 中一样，这个函数可能触发 “newindex” 事件的元方法。 lua_settopvoid lua_settop(lua_State *L, int index); 参数允许传入任何可接受的索引以及0。它将把堆栈的栈顶设为这个索引。如果新的栈顶比原来的大，超出部分的新元素将被填为nil。如果index为0，把栈上所有元素移除。 lua_Statetypedef struct lua_State lua_State;一个不透明的结构，它保存了整个 Lua 解释器的状态。 Lua 库是完全可重入的： 它没有任何全局变量。 （译注：从 C 语法上来说，也不尽然。例如，在 table 的实现中 用了一个静态全局变量 dummynode_ ，但这在正确使用时并不影响可重入性。 只是万一你错误链接了 lua 库，不小心在同一进程空间中存在两份 lua 库实现的代码的话， 多份 dummynode_ 不同的地址会导致一些问题。） 所有的信息都保存在这个结构中。 这个状态机的指针必须作为第一个参数传递给每一个库函数。 lua_newstate 是一个例外， 这个函数会从头创建一个 Lua 状态机。 lua_statusint lua_status (lua_State *L); 返回线程 L 的状态。正常的线程状态是 0 。 当线程执行完毕或发生一个错误时，状态值是错误码。 如果线程被挂起，状态为 LUA_YIELD 。 lua_tobooleanint lua_toboolean (lua_State *L, int index); 把指定的索引处的的Lua值转换为一个C中的boolean值（ 0 或是 1 ）。 和 Lua 中做的所有测试一样， lua_toboolean 会把任何 不同于 false 和 nil 的值当作 1 返回； 否则就返回 0 。 如果用一个无效索引去调用也会返回 0 。 （如果你想只接收真正的 boolean 值，就需要使用 lua_isboolean 来测试值的类型。） lua_tocfunctionlua_CFunction lua_tocfunction (lua_State *L, int index); 把给定索引处的 Lua 值转换为一个 C 函数。 这个值必须是一个 C 函数；如果不是就返回 NULL 。 lua_tointegerlua_Integer lua_tointeger (lua_State *L, int idx); 把给定索引处的 Lua 值转换为 lua_Integer 这样一个有符号整数类型。 这个 Lua 值必须是一个数字或是一个可以转换为数字的字符串 （参见 §2.2.1）； 否则，lua_tointeger 返回 0 。如果数字不是一个整数， 截断小数部分的方式没有被明确定义。 lua_tolstringconst char *lua_tolstring (lua_State *L, int index, size_t *len); 把给定索引处的 Lua 值转换为一个 C 字符串。 如果 len 不为 NULL ， 它还把字符串长度设到 *len 中。 这个 Lua 值必须是一个字符串或是一个数字； 否则返回返回 NULL 。 如果值是一个数字，lua_tolstring 还会把堆栈中的那个值的实际类型转换为一个字符串。 （当遍历一个表的时候，把 lua_tolstring 作用在键上，这个转换有可能导致 lua_next 弄错。） lua_tolstring 返回 Lua 状态机中 字符串的以对齐指针。 这个字符串总能保证 （ C 要求的）最后一个字符为零 (‘\0’) ， 而且它允许在字符串内包含多个这样的零。 因为 Lua 中可能发生垃圾收集， 所以不保证 lua_tolstring 返回的指针， 在对应的值从堆栈中移除后依然有效。 lua_tonumberlua_Number lua_tonumber (lua_State *L, int index); 把给定索引处的 Lua 值转换为 lua_Number 这样一个 C 类型（参见 lua_Number ）。 这个 Lua 值必须是一个数字或是一个可转换为数字的字符串 （参见 §2.2.1 ）； 否则，lua_tonumber 返回 0 。 lua_topointerconst void *lua_topointer (lua_State *L, int index); 把给定索引处的值转换为一般的 C 指针 (void*) 。 这个值可以是一个 userdata ，table ，thread 或是一个 function ； 否则，lua_topointer 返回 NULL 。 不同的对象有不同的指针。 不存在把指针再转回原有类型的方法。这个函数通常只为产生 debug 信息用。 lua_tostringconst char *lua_tostring (lua_State *L, int index); 等价于 lua_tolstring ，而参数 len 设为 NULL 。 lua_tothreadlua_State *lua_tothread (lua_State *L, int index); 把给定索引处的值转换为一个 Lua 线程（由 lua_State* 代表）。 这个值必须是一个线程；否则函数返回 NULL 。 lua_touserdatavoid *lua_touserdata (lua_State *L, int index); 如果给定索引处的值是一个完整的userdata ，函数返回内存块的地址。 如果值是一个 light userdata ，那么就返回它表示的指针。 否则，返回 NULL 。 lua_typeint lua_type (lua_State *L, int index); 返回给定索引处的值的类型， 当索引无效时则返回 LUA_TNONE （那是指一个指向堆栈上的空位置的索引）。 lua_type 返回的类型是一些个在 lua.h 中定义的常量： LUA_TNIL ， LUA_TNUMBER ， LUA_TBOOLEAN ， LUA_TSTRING ， LUA_TTABLE ， LUA_TFUNCTION ， LUA_TUSERDATA ， LUA_TTHREAD ， LUA_TLIGHTUSERDATA 。 lua_typenameconst char *lua_typename (lua_State *L, int tp); 返回 tp 表示的类型名， 这个 tp 必须是 lua_type 可能返回的值中之一。 lua_Writertypedef int (lua_Writer) (lua_State L, const void p, size_t sz, void ud); 由 lua_dump 用到的写入器函数。 每次 lua_dump 产生了一块新的 chunk ，它都会调用写入器。 传入要写入的缓存 (p) 和它的尺寸 (sz) ， 还有 lua_dump 的参数 data 。写入器会返回一个错误码： 0 表示没有错误； 别的值均表示一个错误，并且会让 lua_dump 停止再次调用写入器。 lua_xmovevoid lua_xmove (lua_State *from, lua_State *to, int n); 传递 同一个 全局状态机下不同线程中的值。这个函数会从 from 的堆栈中弹出 n 个值， 然后把它们压入 to 的堆栈中。 lua_yieldint lua_yield (lua_State *L, int nresults); 切出一个 coroutine 。这个函数只能在一个 C 函数的返回表达式中调用。如下： return lua_yield (L, nresults); 当一个 C 函数这样调用 lua_yield ， 正在运行中的 coroutine 将从运行中挂起， 然后启动这个 coroutine 用的那次对 lua_resume 的调用就返回了。 参数 nresults 指的是堆栈中需要返回的结果个数，这些返回值将被传递给 lua_resume 。 3.8 - 调试接口Lua 没有内建的调试设施。 取而代之的是提供了一些函数接口和钩子。 利用这些接口，可以做出一些不同类型的调试器， 性能分析器，或是其它一些需要从解释器中取到“内部信息”的工具。 lua_Debugtypedef struct lua_Debug { int event; const char *name; /* (n) */ const char *namewhat; /* (n) */ const char *what; /* (S) */ const char *source; /* (S) */ int currentline; /* (l) */ int nups; /* (u) upvalue 个数 */ int linedefined; /* (S) */ int lastlinedefined; /* (S) */ char short_src[LUA_IDSIZE]; /* (S) */ /* 私有部分 */ 其它域 } lua_Debug; 一个用来携带活动中函数的各种信息的结构。 lua_getstack 仅填写这个结构中的私有部分， 这些部分以后会用到。 调用 lua_getinfo 则可以填上 lua_Debug 中有用信息的那些域。 lua_Debug 中的各个域有下列含义： source: 如果函数是定义在一个字符串中，source 就是这个字符串。 如果函数定义在一个文件中， source 是一个以 ‘@’ 开头的文件名。short_src: 一个“可打印版本”的 source，用于出错信息。linedefined: 函数定义开始处的行号。lastlinedefined: 函数定义结束处的行号。what: 如果函数是一个 Lua 函数，则为一个字符串 “Lua” ； 如果是一个 C 函数，则为 “C”； 如果它是一个 chunk 的主体部分，则为 “main”； 如果是一个作了尾调用的函数，则为 “tail” 。 别的情况下，Lua 没有关于函数的别的信息。currentline: 给定函数正在执行的那一行。 当提供不了行号信息的时候，currentline 被设为 -1 。name: 给定函数的一个合理的名字。 因为 Lua 中的函数也是一个值， 所以它们没有固定的名字： 一些函数可能是全局复合变量的值， 另一些可能仅仅只是被保存在一个 table 中。 lua_getinfo 函数会检查函数是这样被调用的，以此来找到一个适合的名字。 如果它找不到名字，name 就被设置为 NULL 。namewhat: 结实 name 域。 namewhat 的值可以是 “global”, “local”, “method”, “field”, “upvalue”, 或是 “” （空串）。 这取决于函数怎样被调用。 （Lua 用空串表示其它选项都不符合）nups: 函数的 upvalue 的个数。 lua_gethooklua_Hook lua_gethook (lua_State *L); 返回当前的钩子函数。 lua_gethookcountint lua_gethookcount (lua_State *L); 返回当前钩子记数。 lua_gethookmaskint lua_gethookmask (lua_State *L); 返回当前的钩子掩码 (mask) 。 lua_getinfoint lua_getinfo (lua_State *L, const char *what, lua_Debug *ar); 返回一个指定的函数或函数调用的信息。当用于取得一次函数调用的信息时， 参数 ar 必须是一个有效的活动的记录。 这条记录可以是前一次调用 lua_getstack 得到的， 或是一个钩子 （参见 lua_Hook）得到的参数。用于获取一个函数的信息时，可以把这个函数压入堆栈， 然后把 what 字符串以字符 ‘&gt;’ 起头。 （这个情况下，lua_getinfo 从栈顶上弹出函数。） 例如，想知道函数 f 在哪一行定义的， 你可以下下列代码： lua_Debug ar; lua_getfield(L, LUA_GLOBALSINDEX, &quot;f&quot;); /* 取到全局变量 &#39;f&#39; */ lua_getinfo(L, &quot;&gt;S&quot;, &amp;ar); printf(&quot;%d\n&quot;, ar.linedefined); what 字符串中的每个字符都筛选出结构 ar 结构中一些域用于填充，或是把一个值压入堆栈： ‘n’: 填充 name 及 namewhat 域；‘S’: 填充 source， short_src， linedefined， lastlinedefined，以及 what 域；‘l’: 填充 currentline 域；‘u’: 填充 nups 域；‘f’: 把正在运行中指定级别处函数压入堆栈； （译注：一般用于获取函数调用中的信息， 级别是由 ar 中的私有部分来提供。 如果用于获取静态函数，那么就直接把指定函数重新压回堆栈， 但这样做通常无甚意义。）‘L’: 压一个 table 入栈，这个 table 中的整数索引用于描述函数中哪些行是有效行。 （有效行指有实际代码的行， 即你可以置入断点的行。 无效行包括空行和只有注释的行。）这个函数出错会返回 0 （例如，what 中有一个无效选项）。 lua_getlocalconst char *lua_getlocal (lua_State *L, lua_Debug *ar, int n); 从给定活动记录中获取一个局部变量的信息。 参数 ar 必须是一个有效的活动的记录。 这条记录可以是前一次调用 lua_getstack 得到的， 或是一个钩子 （参见 lua_Hook）得到的参数。 索引 n 用于选择要检阅哪个局部变量 （ 1 表示第一个参数或是激活的第一个局部变量，以此类推，直到最后一个局部变量）。 lua_getlocal 把变量的值压入堆栈并返回它的名字。以 ‘(‘ （正小括号）开始的变量指内部变量 （循环控制变量，临时变量，C 函数局部变量）。当索引大于局部变量的个数时，返回 NULL （什么也不压入）。 lua_getstackint lua_getstack (lua_State *L, int level, lua_Debug *ar); 获取解释器的运行时栈的信息。这个函数用正在运行中的给定级别处的函数的活动记录来填写 lua_Debug 结构的一部分。 0 级表示当前运行的函数， 而 n+1 级处的函数就是调用第 n 级函数的那一个。 如果没有错误，lua_getstack 返回 1 ； 当调用传入的级别大于堆栈深度的时候，返回 0 。 lua_getupvalueconst char *lua_getupvalue (lua_State *L, int funcindex, int n); 获取一个 closure 的 upvalue 信息。 （对于 Lua 函数，upvalue 是函数需要使用的外部局部变量， 因此这些变量被包含在 closure 中。） lua_getupvalue 获取第 n 个 upvalue ， 把这个 upvalue 的值压入堆栈，并且返回它的名字。 funcindex 指向堆栈上 closure 的位置。 （ 因为 upvalue 在整个函数中都有效，所以它们没有特别的次序。 因此，它们以字母次序来编号。） 当索引号比 upvalue 数量大的时候，返回 NULL （而且不会压入任何东西） 对于 C 函数，这个函数用空串 “” 表示所有 upvalue 的名字。 lua_Hooktypedef void (*lua_Hook) (lua_State *L, lua_Debug *ar); 用于调试的钩子函数类型。无论何时钩子被调用，它的参数 ar 中的 event 域 都被设为触发钩子的事件。 Lua 把这些事件定义为以下常量： LUA_HOOKCALL， LUA_HOOKRET, LUA_HOOKTAILRET， LUA_HOOKLINE， and LUA_HOOKCOUNT。 除此之外，对于 line 事件，currentline 域也被设置。 要想获得 ar 中的其他域， 钩子必须调用 lua_getinfo。 对于返回事件，event 的正常值可能是 LUA_HOOKRET， 或者是 LUA_HOOKTAILRET 。 对于后一种情况，Lua 会对一个函数做的尾调用也模拟出一个返回事件出来； 对于这个模拟的返回事件，调用 lua_getinfo 没有什么作用。当 Lua 运行在一个钩子内部时，它将屏蔽掉其它对钩子的调用。 也就是说，如果一个钩子函数内再调回 Lua 来执行一个函数或是一个 chunk ， 这个执行操作不会触发任何的钩子。 lua_sethookint lua_sethook (lua_State *L, lua_Hook f, int mask, int count); 设置一个调试用钩子函数。 参数 f 是钩子函数。 mask 指定在哪些事件时会调用： 它由下列一组位常量构成 LUA_MASKCALL， LUA_MASKRET， LUA_MASKLINE， 以及 LUA_MASKCOUNT。 参数 count 只在 mask 中包含有 LUA_MASKCOUNT 才有意义。 对于每个事件，钩子被调用的情况解释如下：call hook: 在解释器调用一个函数时被调用。 钩子将于 Lua 进入一个新函数后，函数获取参数前被调用。return hook: 在解释器从一个函数中返回时调用。 钩子将于 Lua 离开函数之前的那一刻被调用。 你无权访问被函数返回出去的那些值。 （译注：原文 (You have no access to the values to be returned by the function) 如此。 但“无权访问”一词值得商榷。 某些情况下你可以访问到一些被命名为 (*temporary) 的局部变量， 那些索引被排在最后的 (temporary) 变量指的就是返回值。 但是由于 Lua 对特殊情况做了一些优化，比如直接返回一个被命名的局部变量， 那么就找不到对应的 (temporary) 变量了。本质上，返回值一定存在于此刻的局部变量中， 并且可以访问它，只是无法确定是哪些罢了。至于这个时候函数体内的其它局部变量， 是不保证有效的。进入 return hook 的那一刻起，实际已经退出函数内部的运行环节， 返回值占用的局部变量空间以后的部分，都有可能因 hook 本身复用它们而改变。）line hook: 在解释器准备开始执行新的一行代码时， 或是跳转到这行代码中时（即使在同一行内跳转）被调用。 （这个事件仅仅在 Lua 执行一个 Lua 函数时发生。）count hook: 在解释器每执行 count 条指令后被调用。 （这个事件仅仅在 Lua 执行一个 Lua 函数时发生。）钩子可以通过设置 mask 为零屏蔽。 lua_setlocalconst char *lua_setlocal (lua_State *L, lua_Debug *ar, int n); 设置给定活动记录中的局部变量的值。 参数 ar 与 n 和 lua_getlocal 中的一样 （参见 lua_getlocal）。 lua_setlocal 把栈顶的值赋给变量然后返回变量的名字。 它会将值从栈顶弹出。当索引大于局部变量的个数时，返回 NULL （什么也不弹出）。 lua_setupvalueconst char *lua_setupvalue (lua_State *L, int funcindex, int n); 设置 closure 的 upvalue 的值。 它把栈顶的值弹出并赋于 upvalue 并返回 upvalue 的名字。 参数 funcindex 与 n 和 lua_getupvalue 中的一样 （参见 lua_getupvalue）。当索引大于 upvalue 的个数时，返回 NULL （什么也不弹出）。 4 - The Auxiliary LibraryThe auxiliary library provides several convenient functions to interface C with Lua. While the basic API provides the primitive functions for all interactions between C and Lua, the auxiliary library provides higher-level functions for some common tasks. All functions from the auxiliary library are defined in header file lauxlib.h and have a prefix luaL_. All functions in the auxiliary library are built on top of the basic API, and so they provide nothing that cannot be done with this API. Several functions in the auxiliary library are used to check C function arguments. Their names are always luaL_check or luaL_opt\. All of these functions raise an error if the check is not satisfied. Because the error message is formatted for arguments (e.g., “bad argument #1”), you should not use these functions for other stack values. 4.1 - Functions and TypesHere we list all functions and types from the auxiliary library in alphabetical order. luaL_addcharvoid luaL_addchar (luaL_Buffer *B, char c); Adds the character c to the buffer B (see luaL_Buffer). luaL_addlstringvoid luaL_addlstring (luaL_Buffer *B, const char *s, size_t l); Adds the string pointed to by s with length l to the buffer B (see luaL_Buffer). The string may contain embedded zeros. luaL_addsizevoid luaL_addsize (luaL_Buffer *B, size_t n); Adds to the buffer B (see luaL_Buffer) a string of length n previously copied to the buffer area (see luaL_prepbuffer). luaL_addstringvoid luaL_addstring (luaL_Buffer *B, const char *s); Adds the zero-terminated string pointed to by s to the buffer B (see luaL_Buffer). The string may not contain embedded zeros. luaL_addvaluevoid luaL_addvalue (luaL_Buffer *B); Adds the value at the top of the stack to the buffer B (see luaL_Buffer). Pops the value.This is the only function on string buffers that can (and must) be called with an extra element on the stack, which is the value to be added to the buffer. luaL_argcheckvoid luaL_argcheck (lua_State *L, int cond, int narg, const char *extramsg); Checks whether cond is true. If not, raises an error with the following message, where func is retrieved from the call stack: bad argument #&lt;narg&gt; to &lt;func&gt; (&lt;extramsg&gt;) luaL_argerrorint luaL_argerror (lua_State *L, int narg, const char *extramsg); Raises an error with the following message, where func is retrieved from the call stack: bad argument #&lt;narg&gt; to &lt;func&gt; (&lt;extramsg&gt;) This function never returns, but it is an idiom to use it in C functions as return luaL_argerror(args). luaL_Buffertypedef struct luaL_Buffer luaL_Buffer;Type for a string buffer.A string buffer allows C code to build Lua strings piecemeal. Its pattern of use is as follows:First you declare a variable b of type luaL_Buffer.Then you initialize it with a call luaL_buffinit(L, &amp;b).Then you add string pieces to the buffer calling any of the luaL_add* functions.You finish by calling luaL_pushresult(&amp;b). This call leaves the final string on the top of the stack.During its normal operation, a string buffer uses a variable number of stack slots. So, while using a buffer, you cannot assume that you know where the top of the stack is. You can use the stack between successive calls to buffer operations as long as that use is balanced; that is, when you call a buffer operation, the stack is at the same level it was immediately after the previous buffer operation. (The only exception to this rule is luaL_addvalue.) After calling luaL_pushresult the stack is back to its level when the buffer was initialized, plus the final string on its top. luaL_buffinitvoid luaL_buffinit (lua_State *L, luaL_Buffer *B); Initializes a buffer B. This function does not allocate any space; the buffer must be declared as a variable (see luaL_Buffer). luaL_callmetaint luaL_callmeta (lua_State *L, int obj, const char *e); Calls a metamethod.If the object at index obj has a metatable and this metatable has a field e, this function calls this field and passes the object as its only argument. In this case this function returns 1 and pushes onto the stack the value returned by the call. If there is no metatable or no metamethod, this function returns 0 (without pushing any value on the stack). luaL_checkanyvoid luaL_checkany (lua_State *L, int narg); Checks whether the function has an argument of any type (including nil) at position narg. luaL_checkintint luaL_checkint (lua_State *L, int narg); Checks whether the function argument narg is a number and returns this number cast to an int. luaL_checkintegerlua_Integer luaL_checkinteger (lua_State *L, int narg); Checks whether the function argument narg is a number and returns this number cast to a lua_Integer. luaL_checklonglong luaL_checklong (lua_State *L, int narg); Checks whether the function argument narg is a number and returns this number cast to a long. luaL_checklstringconst char *luaL_checklstring (lua_State *L, int narg, size_t *l); Checks whether the function argument narg is a string and returns this string; if l is not NULL fills *l with the string’s length. luaL_checknumberlua_Number luaL_checknumber (lua_State *L, int narg);Checks whether the function argument narg is a number and returns this number. luaL_checkoptionint luaL_checkoption (lua_State *L, int narg, const char *def, const char *const lst[]); Checks whether the function argument narg is a string and searches for this string in the array lst (which must be NULL-terminated). Returns the index in the array where the string was found. Raises an error if the argument is not a string or if the string cannot be found.If def is not NULL, the function uses def as a default value when there is no argument narg or if this argument is nil.This is a useful function for mapping strings to C enums. (The usual convention in Lua libraries is to use strings instead of numbers to select options.) luaL_checkstackvoid luaL_checkstack (lua_State L, int sz, const char msg);Grows the stack size to top + sz elements, raising an error if the stack cannot grow to that size. msg is an additional text to go into the error message. luaL_checkstringconst char luaL_checkstring (lua_State L, int narg);Checks whether the function argument narg is a string and returns this string. luaL_checktypevoid luaL_checktype (lua_State *L, int narg, int t);Checks whether the function argument narg has type t. luaL_checkudatavoid luaL_checkudata (lua_State L, int narg, const char *tname);Checks whether the function argument narg is a userdata of the type tname (see luaL_newmetatable). luaL_dofileint luaL_dofile (lua_State L, const char filename);Loads and runs the given file. It is defined as the following macro: (luaL_loadfile(L, filename) || lua_pcall(L, 0, LUA_MULTRET, 0)) It returns 0 if there are no errors or 1 in case of errors. luaL_dostringint luaL_dostring (lua_State L, const char str);Loads and runs the given string. It is defined as the following macro: (luaL_loadstring(L, str) || lua_pcall(L, 0, LUA_MULTRET, 0)) It returns 0 if there are no errors or 1 in case of errors. luaL_errorint luaL_error (lua_State *L, const char *fmt, ...); Raises an error. The error message format is given by fmt plus any extra arguments, following the same rules of lua_pushfstring. It also adds at the beginning of the message the file name and the line number where the error occurred, if this information is available.This function never returns, but it is an idiom to use it in C functions as return luaL_error(args). luaL_getmetafieldint luaL_getmetafield (lua_State *L, int obj, const char *e); Pushes onto the stack the field e from the metatable of the object at index obj. If the object does not have a metatable, or if the metatable does not have this field, returns 0 and pushes nothing. luaL_getmetatablevoid luaL_getmetatable (lua_State *L, const char *tname); Pushes onto the stack the metatable associated with name tname in the registry (see luaL_newmetatable). luaL_gsubconst char *luaL_gsub (lua_State *L, const char *s, const char *p, const char *r); Creates a copy of string s by replacing any occurrence of the string p with the string r. Pushes the resulting string on the stack and returns it. luaL_loadbufferint luaL_loadbuffer (lua_State *L, const char *buff, size_t sz, const char *name); Loads a buffer as a Lua chunk. This function uses lua_load to load the chunk in the buffer pointed to by buff with size sz.This function returns the same results as lua_load. name is the chunk name, used for debug information and error messages. luaL_loadfileint luaL_loadfile (lua_State *L, const char *filename); Loads a file as a Lua chunk. This function uses lua_load to load the chunk in the file named filename. If filename is NULL, then it loads from the standard input. The first line in the file is ignored if it starts with a #.This function returns the same results as lua_load, but it has an extra error code LUA_ERRFILE if it cannot open/read the file.As lua_load, this function only loads the chunk; it does not run it. luaL_loadstringint luaL_loadstring (lua_State *L, const char *s); Loads a string as a Lua chunk. This function uses lua_load to load the chunk in the zero-terminated string s.This function returns the same results as lua_load.Also as lua_load, this function only loads the chunk; it does not run it. luaL_newmetatableint luaL_newmetatable (lua_State *L, const char *tname); If the registry already has the key tname, returns 0. Otherwise, creates a new table to be used as a metatable for userdata, adds it to the registry with key tname, and returns 1.In both cases pushes onto the stack the final value associated with tname in the registry. luaL_newstatelua_State *luaL_newstate (void); Creates a new Lua state. It calls lua_newstate with an allocator based on the standard C realloc function and then sets a panic function (see lua_atpanic) that prints an error message to the standard error output in case of fatal errors.Returns the new state, or NULL if there is a memory allocation error. luaL_openlibsvoid luaL_openlibs (lua_State *L); Opens all standard Lua libraries into the given state. luaL_optintint luaL_optint (lua_State *L, int narg, int d);If the function argument narg is a number, returns this number cast to an int. If this argument is absent or is nil, returns d. Otherwise, raises an error. luaL_optintegerlua_Integer luaL_optinteger (lua_State *L, int narg, lua_Integer d); If the function argument narg is a number, returns this number cast to a lua_Integer. If this argument is absent or is nil, returns d. Otherwise, raises an error. luaL_optlonglong luaL_optlong (lua_State *L, int narg, long d); If the function argument narg is a number, returns this number cast to a long. If this argument is absent or is nil, returns d. Otherwise, raises an error. luaL_optlstringconst char *luaL_optlstring (lua_State *L, int narg, const char *d, size_t *l); If the function argument narg is a string, returns this string. If this argument is absent or is nil, returns d. Otherwise, raises an error.If l is not NULL, fills the position *l with the results’s length. luaL_optnumberlua_Number luaL_optnumber (lua_State *L, int narg, lua_Number d); If the function argument narg is a number, returns this number. If this argument is absent or is nil, returns d. Otherwise, raises an error. luaL_optstringconst char *luaL_optstring (lua_State *L, int narg, const char *d); If the function argument narg is a string, returns this string. If this argument is absent or is nil, returns d. Otherwise, raises an error. luaL_prepbufferchar *luaL_prepbuffer (luaL_Buffer *B); Returns an address to a space of size LUAL_BUFFERSIZE where you can copy a string to be added to buffer B (see luaL_Buffer). After copying the string into this space you must call luaL_addsize with the size of the string to actually add it to the buffer. luaL_pushresultvoid luaL_pushresult (luaL_Buffer *B); Finishes the use of buffer B leaving the final string on the top of the stack. luaL_refint luaL_ref (lua_State *L, int t); Creates and returns a reference, in the table at index t, for the object at the top of the stack (and pops the object).A reference is a unique integer key. As long as you do not manually add integer keys into table t, luaL_ref ensures the uniqueness of the key it returns. You can retrieve an object referred by reference r by calling lua_rawgeti(L, t, r). Function luaL_unref frees a reference and its associated object. If the object at the top of the stack is nil, luaL_ref returns the constant LUA_REFNIL. The constant LUA_NOREF is guaranteed to be different from any reference returned by luaL_ref. luaL_Regtypedef struct luaL_Reg { const char *name; lua_CFunction func;} luaL_Reg; Type for arrays of functions to be registered by luaL_register. name is the function name and func is a pointer to the function. Any array of luaL_Reg must end with an sentinel entry in which both name and func are NULL. luaL_registervoid luaL_register (lua_State *L, const char *libname, const luaL_Reg *l); Opens a library. When called with libname equal to NULL, it simply registers all functions in the list l (see luaL_Reg) into the table on the top of the stack.When called with a non-null libname, luaL_register creates a new table t, sets it as the value of the global variable libname, sets it as the value of package.loaded[libname], and registers on it all functions in the list l. If there is a table in package.loaded[libname] or in variable libname, reuses this table instead of creating a new one.In any case the function leaves the table on the top of the stack. luaL_typenameconst char luaL_typename (lua_State L, int idx);Returns the name of the type of the value at index idx. luaL_typerrorint luaL_typerror (lua_State L, int narg, const char tname);Generates an error with a message like the following: location: bad argument narg to &#39;func&#39; (tname expected, got rt) where location is produced by luaL_where, func is the name of the current function, and rt is the type name of the actual argument. luaL_unrefvoid luaL_unref (lua_State *L, int t, int ref); Releases reference ref from the table at index t (see luaL_ref). The entry is removed from the table, so that the referred object can be collected. The reference ref is also freed to be used again. If ref is LUA_NOREF or LUA_REFNIL, luaL_unref does nothing. luaL_wherevoid luaL_where (lua_State *L, int lvl); Pushes onto the stack a string identifying the current position of the control at level lvl in the call stack. Typically this string has the following format: chunkname:currentline: Level 0 is the running function, level 1 is the function that called the running function, etc.This function is used to build a prefix for error messages. Standard LibrariesThe standard Lua libraries provide useful functions that are implemented directly through the C API. Some of these functions provide essential services to the language (e.g., type and getmetatable); others provide access to “outside” services (e.g., I/O); and others could be implemented in Lua itself, but are quite useful or have critical performance requirements that deserve an implementation in C (e.g., sort). All libraries are implemented through the official C API and are provided as separate C modules. Currently, Lua has the following standard libraries: basic library;package library;string manipulation;table manipulation;mathematical functions (sin, log, etc.);input and output;operating system facilities;debug facilities.Except for the basic and package libraries, each library provides all its functions as fields of a global table or as methods of its objects. To have access to these libraries, the C host program should call the luaL_openlibs function, which opens all standard libraries. Alternatively, it can open them individually by calling luaopen_base (for the basic library), luaopen_package (for the package library), luaopen_string (for the string library), luaopen_table (for the table library), luaopen_math (for the mathematical library), luaopen_io (for the I/O and the Operating System libraries), and luaopen_debug (for the debug library). These functions are declared in lualib.h and should not be called directly: you must call them like any other Lua C function, e.g., by using lua_call. The basic library provides some core functions to Lua. If you do not include this library in your application, you should check carefully whether you need to provide implementations for some of its facilities. assert (v [, message])Issues an error when the value of its argument v is false (i.e., nil or false); otherwise, returns all its arguments. message is an error message; when absent, it defaults to “assertion failed!”collectgarbage (opt [, arg])This function is a generic interface to the garbage collector. It performs different functions according to its first argument, opt: “stop”: stops the garbage collector.“restart”: restarts the garbage collector.“collect”: performs a full garbage-collection cycle.“count”: returns the total memory in use by Lua (in Kbytes).“step”: performs a garbage-collection step. The step “size” is controlled by arg (larger values mean more steps) in a non-specified way. If you want to control the step size you must experimentally tune the value of arg. Returns true if the step finished a collection cycle.“setpause”: sets arg/100 as the new value for the pause of the collector (see §2.10).“setstepmul”: sets arg/100 as the new value for the step multiplier of the collector (see §2.10).dofile (filename)Opens the named file and executes its contents as a Lua chunk. When called without arguments, dofile executes the contents of the standard input (stdin). Returns all values returned by the chunk. In case of errors, dofile propagates the error to its caller (that is, dofile does not run in protected mode).error (message [, level])Terminates the last protected function called and returns message as the error message. Function error never returns.Usually, error adds some information about the error position at the beginning of the message. The level argument specifies how to get the error position. With level 1 (the default), the error position is where the error function was called. Level 2 points the error to where the function that called error was called; and so on. Passing a level 0 avoids the addition of error position information to the message. _GA global variable (not a function) that holds the global environment (that is, _G._G = _G). Lua itself does not use this variable; changing its value does not affect any environment, nor vice-versa. (Use setfenv to change environments.)getfenv (f)Returns the current environment in use by the function. f can be a Lua function or a number that specifies the function at that stack level: Level 1 is the function calling getfenv. If the given function is not a Lua function, or if f is 0, getfenv returns the global environment. The default for f is 1.getmetatable (object)If object does not have a metatable, returns nil. Otherwise, if the object’s metatable has a “__metatable” field, returns the associated value. Otherwise, returns the metatable of the given object. ipairs (t)Returns three values: an iterator function, the table t, and 0, so that the construction for i,v in ipairs(t) do body end will iterate over the pairs (1,t[1]), (2,t[2]), ···, up to the first integer key absent from the table. load (func [, chunkname])Loads a chunk using function func to get its pieces. Each call to func must return a string that concatenates with previous results. A return of nil (or no value) signals the end of the chunk. If there are no errors, returns the compiled chunk as a function; otherwise, returns nil plus the error message. The environment of the returned function is the global environment. chunkname is used as the chunk name for error messages and debug information. loadfile ([filename])Similar to load, but gets the chunk from file filename or from the standard input, if no file name is given. loadstring (string [, chunkname])Similar to load, but gets the chunk from the given string. To load and run a given string, use the idiom assert(loadstring(s))() next (table [, index])Allows a program to traverse all fields of a table. Its first argument is a table and its second argument is an index in this table. next returns the next index of the table and its associated value. When called with nil as its second argument, next returns an initial index and its associated value. When called with the last index, or with nil in an empty table, next returns nil. If the second argument is absent, then it is interpreted as nil. In particular, you can use next(t) to check whether a table is empty. The order in which the indices are enumerated is not specified, even for numeric indices. (To traverse a table in numeric order, use a numerical for or the ipairs function.) The behavior of next is undefined if, during the traversal, you assign any value to a non-existent field in the table. You may however modify existing fields. In particular, you may clear existing fields. pairs (t)Returns three values: the next function, the table t, and nil, so that the construction for k,v in pairs(t) do body end will iterate over all key–value pairs of table t. See function next for the caveats of modifying the table during its traversal. pcall (f, arg1, ···)Calls function f with the given arguments in protected mode. This means that any error inside f is not propagated; instead, pcall catches the error and returns a status code. Its first result is the status code (a boolean), which is true if the call succeeds without errors. In such case, pcall also returns all results from the call, after this first result. In case of any error, pcall returns false plus the error message. print (···)Receives any number of arguments, and prints their values to stdout, using the tostring function to convert them to strings. print is not intended for formatted output, but only as a quick way to show a value, typically for debugging. For formatted output, use string.format.rawequal (v1, v2)Checks whether v1 is equal to v2, without invoking any metamethod. Returns a boolean.rawget (table, index)Gets the real value of table[index], without invoking any metamethod. table must be a table; index may be any value.rawset (table, index, value)Sets the real value of table[index] to value, without invoking any metamethod. table must be a table, index any value different from nil, and value any Lua value.This function returns table. select (index, ···)If index is a number, returns all arguments after argument number index. Otherwise, index must be the string “#”, and select returns the total number of extra arguments it received. setfenv (f, table)Sets the environment to be used by the given function. f can be a Lua function or a number that specifies the function at that stack level: Level 1 is the function calling setfenv. setfenv returns the given function. As a special case, when f is 0 setfenv changes the environment of the running thread. In this case, setfenv returns no values. setmetatable (table, metatable)Sets the metatable for the given table. (You cannot change the metatable of other types from Lua, only from C.) If metatable is nil, removes the metatable of the given table. If the original metatable has a “__metatable” field, raises an error. This function returns table. tonumber (e [, base])Tries to convert its argument to a number. If the argument is already a number or a string convertible to a number, then tonumber returns this number; otherwise, it returns nil.An optional argument specifies the base to interpret the numeral. The base may be any integer between 2 and 36, inclusive. In bases above 10, the letter ‘A’ (in either upper or lower case) represents 10, ‘B’ represents 11, and so forth, with ‘Z’ representing 35. In base 10 (the default), the number may have a decimal part, as well as an optional exponent part (see §2.1). In other bases, only unsigned integers are accepted. tostring (e)Receives an argument of any type and converts it to a string in a reasonable format. For complete control of how numbers are converted, use string.format.If the metatable of e has a “__tostring” field, then tostring calls the corresponding value with e as argument, and uses the result of the call as its result. type (v)Returns the type of its only argument, coded as a string. The possible results of this function are “nil” (a string, not the value nil), “number”, “string”, “boolean”, “table”, “function”, “thread”, and “userdata”.unpack (list [, i [, j]])Returns the elements from the given table. This function is equivalent to return list[i], list[i+1], ···, list[j]except that the above code can be written only for a fixed number of elements. By default, i is 1 and j is the length of the list, as defined by the length operator (see §2.5.5). _VERSIONA global variable (not a function) that holds a string containing the current interpreter version. The current contents of this variable is “Lua 5.1”.xpcall (f, err)This function is similar to pcall, except that you can set a new error handler. xpcall calls function f in protected mode, using err as the error handler. Any error inside f is not propagated; instead, xpcall catches the error, calls the err function with the original error object, and returns a status code. Its first result is the status code (a boolean), which is true if the call succeeds without errors. In this case, xpcall also returns all results from the call, after this first result. In case of any error, xpcall returns false plus the result from err. Coroutine ManipulationThe operations related to coroutines comprise a sub-library of the basic library and come inside the table coroutine. coroutine.create (f)Creates a new coroutine, with body f. f must be a Lua function. Returns this new coroutine, an object with type “thread”. coroutine.resume (co [, val1, ···])Starts or continues the execution of coroutine co. The first time you resume a coroutine, it starts running its body. The values val1, ··· are passed as the arguments to the body function. If the coroutine has yielded, resume restarts it; the values val1, ··· are passed as the results from the yield. If the coroutine runs without any errors, resume returns true plus any values passed to yield (if the coroutine yields) or any values returned by the body function (if the coroutine terminates). If there is any error, resume returns false plus the error message. coroutine.running ()Returns the running coroutine, or nil when called by the main thread. coroutine.status (co)Returns the status of coroutine co, as a string: “running”, if the coroutine is running (that is, it called status); “suspended”, if the coroutine is suspended in a call to yield, or if it has not started running yet; “normal” if the coroutine is active but not running (that is, it has resumed another coroutine); and “dead” if the coroutine has finished its body function, or if it has stopped with an error. coroutine.wrap (f)Creates a new coroutine, with body f. f must be a Lua function. Returns a function that resumes the coroutine each time it is called. Any arguments passed to the function behave as the extra arguments to resume. Returns the same values returned by resume, except the first boolean. In case of error, propagates the error. coroutine.yield (···)Suspends the execution of the calling coroutine. The coroutine cannot be running a C function, a metamethod, or an iterator. Any arguments to yield are passed as extra results to resume. ModulesThe package library provides basic facilities for loading and building modules in Lua. It exports two of its functions directly in the global environment: require and module. Everything else is exported in a table package.module (name [, ···])Creates a module. If there is a table in package.loaded[name], this table is the module. Otherwise, if there is a global table t with the given name, this table is the module. Otherwise creates a new table t and sets it as the value of the global name and the value of package.loaded[name]. This function also initializes t._NAME with the given name, t._M with the module (t itself), and t._PACKAGE with the package name (the full module name minus last component; see below). Finally, module sets t as the new environment of the current function and the new value of package.loaded[name], so that require returns t. If name is a compound name (that is, one with components separated by dots), module creates (or reuses, if they already exist) tables for each component. For instance, if name is a.b.c, then module stores the module table in field c of field b of global a. This function may receive optional options after the module name, where each option is a function to be applied over the module. require (modname)Loads the given module. The function starts by looking into the package.loaded table to determine whether modname is already loaded. If it is, then require returns the value stored at package.loaded[modname]. Otherwise, it tries to find a loader for the module. To find a loader, first require queries package.preload[modname]. If it has a value, this value (which should be a function) is the loader. Otherwise require searches for a Lua loader using the path stored in package.path. If that also fails, it searches for a C loader using the path stored in package.cpath. If that also fails, it tries an all-in-one loader (see below). When loading a C library, require first uses a dynamic link facility to link the application with the library. Then it tries to find a C function inside this library to be used as the loader. The name of this C function is the string “luaopen_” concatenated with a copy of the module name where each dot is replaced by an underscore. Moreover, if the module name has a hyphen, its prefix up to (and including) the first hyphen is removed. For instance, if the module name is a.v1-b.c, the function name will be luaopen_b_c. If require finds neither a Lua library nor a C library for a module, it calls the all-in-one loader. This loader searches the C path for a library for the root name of the given module. For instance, when requiring a.b.c, it will search for a C library for a. If found, it looks into it for an open function for the submodule; in our example, that would be luaopen_a_b_c. With this facility, a package can pack several C submodules into one single library, with each submodule keeping its original open function. Once a loader is found, require calls the loader with a single argument, modname. If the loader returns any value, require assigns the returned value to package.loaded[modname]. If the loader returns no value and has not assigned any value to package.loaded[modname], then require assigns true to this entry. In any case, require returns the final value of package.loaded[modname]. If there is any error loading or running the module, or if it cannot find any loader for the module, then require signals an error. package.cpathThe path used by require to search for a C loader. Lua initializes the C path package.cpath in the same way it initializes the Lua path package.path, using the environment variable LUA_CPATH (plus another default path defined in luaconf.h). package.loadedA table used by require to control which modules are already loaded. When you require a module modname and package.loaded[modname] is not false, require simply returns the value stored there. package.loadlib (libname, funcname)Dynamically links the host program with the C library libname. Inside this library, looks for a function funcname and returns this function as a C function. (So, funcname must follow the protocol (see lua_CFunction)). This is a low-level function. It completely bypasses the package and module system. Unlike require, it does not perform any path searching and does not automatically adds extensions. libname must be the complete file name of the C library, including if necessary a path and extension. funcname must be the exact name exported by the C library (which may depend on the C compiler and linker used). This function is not supported by ANSI C. As such, it is only available on some platforms (Windows, Linux, Mac OS X, Solaris, BSD, plus other Unix systems that support the dlfcn standard). package.pathThe path used by require to search for a Lua loader. At start-up, Lua initializes this variable with the value of the environment variable LUA_PATH or with a default path defined in luaconf.h, if the environment variable is not defined. Any “;;” in the value of the environment variable is replaced by the default path. A path is a sequence of templates separated by semicolons. For each template, require will change each interrogation mark in the template by filename, which is modname with each dot replaced by a “directory separator” (such as “/“ in Unix); then it will try to load the resulting file name. So, for instance, if the Lua path is &quot;./?.lua;./?.lc;/usr/local/?/init.lua&quot; the search for a Lua loader for module foo will try to load the files ./foo.lua, ./foo.lc, and /usr/local/foo/init.lua, in that order. package.preloadA table to store loaders for specific modules (see require). package.seeall (module)Sets a metatable for module with its __index field referring to the global environment, so that this module inherits values from the global environment. To be used as an option to function module. 5.4 - String ManipulationThis library provides generic functions for string manipulation, such as finding and extracting substrings, and pattern matching. When indexing a string in Lua, the first character is at position 1 (not at 0, as in C). Indices are allowed to be negative and are interpreted as indexing backwards, from the end of the string. Thus, the last character is at position -1, and so on. The string library provides all its functions inside the table string. It also sets a metatable for strings where the __index field points to the string table. Therefore, you can use the string functions in object-oriented style. For instance, string.byte(s, i) can be written as s:byte(i). string.byte (s [, i [, j]])Returns the internal numerical codes of the characters s[i], s[i+1], ···, s[j]. The default value for i is 1; the default value for j is i.Note that numerical codes are not necessarily portable across platforms. string.char (···)Receives zero or more integers. Returns a string with length equal to the number of arguments, in which each character has the internal numerical code equal to its corresponding argument.Note that numerical codes are not necessarily portable across platforms. string.dump (function)Returns a string containing a binary representation of the given function, so that a later loadstring on this string returns a copy of the function. function must be a Lua function without upvalues. string.find (s, pattern [, init [, plain]])Looks for the first match of pattern in the string s. If it finds a match, then find returns the indices of s where this occurrence starts and ends; otherwise, it returns nil. A third, optional numerical argument init specifies where to start the search; its default value is 1 and may be negative. A value of true as a fourth, optional argument plain turns off the pattern matching facilities, so the function does a plain “find substring” operation, with no characters in pattern being considered “magic”. Note that if plain is given, then init must be given as well.If the pattern has captures, then in a successful match the captured values are also returned, after the two indices. string.format (formatstring, ···)Returns a formatted version of its variable number of arguments following the description given in its first argument (which must be a string). The format string follows the same rules as the printf family of standard C functions. The only differences are that the options/modifiers *, l, L, n, p, and h are not supported and that there is an extra option, q. The q option formats a string in a form suitable to be safely read back by the Lua interpreter: the string is written between double quotes, and all double quotes, newlines, embedded zeros, and backslashes in the string are correctly escaped when written. For instance, the call string.format(‘%q’, ‘a string with “quotes” and \n new line’)will produce the string: &quot;a string with \&quot;quotes\&quot; and \ new line&quot; The options c, d, E, e, f, g, G, i, o, u, X, and x all expect a number as argument, whereas q and s expect a string. This function does not accept string values containing embedded zeros. string.gmatch (s, pattern)Returns an iterator function that, each time it is called, returns the next captures from pattern over string s.If pattern specifies no captures, then the whole match is produced in each call. As an example, the following loop s = &quot;hello world from Lua&quot; for w in string.gmatch(s, &quot;%a+&quot;) do print(w) end will iterate over all the words from string s, printing one per line. The next example collects all pairs key=value from the given string into a table: t = {} s = &quot;from=world, to=Lua&quot; for k, v in string.gmatch(s, &quot;(%w+)=(%w+)&quot;) do t[k] = v end string.gsub (s, pattern, repl [, n])Returns a copy of s in which all occurrences of the pattern have been replaced by a replacement string specified by repl, which may be a string, a table, or a function. gsub also returns, as its second value, the total number of substitutions made.If repl is a string, then its value is used for replacement. The character % works as an escape character: any sequence in repl of the form %n, with n between 1 and 9, stands for the value of the n-th captured substring (see below). The sequence %0 stands for the whole match. The sequence %% stands for a single %. If repl is a table, then the table is queried for every match, using the first capture as the key; if the pattern specifies no captures, then the whole match is used as the key. If repl is a function, then this function is called every time a match occurs, with all captured substrings passed as arguments, in order; if the pattern specifies no captures, then the whole match is passed as a sole argument. If the value returned by the table query or by the function call is a string or a number, then it is used as the replacement string; otherwise, if it is false or nil, then there is no replacement (that is, the original match is kept in the string). The optional last parameter n limits the maximum number of substitutions to occur. For instance, when n is 1 only the first occurrence of pattern is replaced. Here are some examples: x = string.gsub(&quot;hello world&quot;, &quot;(%w+)&quot;, &quot;%1 %1&quot;) --&gt; x=&quot;hello hello world world&quot; x = string.gsub(&quot;hello world&quot;, &quot;%w+&quot;, &quot;%0 %0&quot;, 1) --&gt; x=&quot;hello hello world&quot; x = string.gsub(&quot;hello world from Lua&quot;, &quot;(%w+)%s*(%w+)&quot;, &quot;%2 %1&quot;) --&gt; x=&quot;world hello Lua from&quot; x = string.gsub(&quot;home = $HOME, user = $USER&quot;, &quot;%$(%w+)&quot;, os.getenv) --&gt; x=&quot;home = /home/roberto, user = roberto&quot; x = string.gsub(&quot;4+5 = $return 4+5$&quot;, &quot;%$(.-)%$&quot;, function (s) return loadstring(s)() end) --&gt; x=&quot;4+5 = 9&quot; local t = {name=&quot;lua&quot;, version=&quot;5.1&quot;} x = string.gsub(&quot;$name%-$version.tar.gz&quot;, &quot;%$(%w+)&quot;, t) --&gt; x=&quot;lua-5.1.tar.gz&quot; string.len (s)Receives a string and returns its length. The empty string “” has length 0. Embedded zeros are counted, so “a\000bc\000” has length 5.string.lower (s)Receives a string and returns a copy of this string with all uppercase letters changed to lowercase. All other characters are left unchanged. The definition of what an uppercase letter is depends on the current locale.string.match (s, pattern [, init])Looks for the first match of pattern in the string s. If it finds one, then match returns the captures from the pattern; otherwise it returns nil. If pattern specifies no captures, then the whole match is returned. A third, optional numerical argument init specifies where to start the search; its default value is 1 and may be negative.string.rep (s, n)Returns a string that is the concatenation of n copies of the string s.string.reverse (s)Returns a string that is the string s reversed.string.sub (s, i [, j])Returns the substring of s that starts at i and continues until j; i and j may be negative. If j is absent, then it is assumed to be equal to -1 (which is the same as the string length). In particular, the call string.sub(s,1,j) returns a prefix of s with length j, and string.sub(s, -i) returns a suffix of s with length i.string.upper (s)Receives a string and returns a copy of this string with all lowercase letters changed to uppercase. All other characters are left unchanged. The definition of what a lowercase letter is depends on the current locale.5.4.1 - PatternsCharacter Class:A character class is used to represent a set of characters. The following combinations are allowed in describing a character class: x: (where x is not one of the magic characters ^$()%.[]*+-?) represents the character x itself..: (a dot) represents all characters.%a: represents all letters.%c: represents all control characters.%d: represents all digits.%l: represents all lowercase letters.%p: represents all punctuation characters.%s: represents all space characters.%u: represents all uppercase letters.%w: represents all alphanumeric characters.%x: represents all hexadecimal digits.%z: represents the character with representation 0.%x: (where x is any non-alphanumeric character) represents the character x. This is the standard way to escape the magic characters. Any punctuation character (even the non magic) can be preceded by a ‘%’ when used to represent itself in a pattern.[set]: represents the class which is the union of all characters in set. A range of characters may be specified by separating the end characters of the range with a ‘-‘. All classes %x described above may also be used as components in set. All other characters in set represent themselves. For example, [%w_] (or [_%w]) represents all alphanumeric characters plus the underscore, [0-7] represents the octal digits, and [0-7%l%-] represents the octal digits plus the lowercase letters plus the ‘-‘ character.The interaction between ranges and classes is not defined. Therefore, patterns like [%a-z] or [a-%%] have no meaning. set. represents the complement of set, where set is interpreted as above. &#8617; For all classes represented by single letters (%a, %c, etc.), the corresponding uppercase letter represents the complement of the class. For instance, %S represents all non-space characters. The definitions of letter, space, and other character groups depend on the current locale. In particular, the class [a-z] may not be equivalent to %l. Pattern Item:A pattern item may be a single character class, which matches any single character in the class;a single character class followed by ‘‘, which matches 0 or more repetitions of characters in the class. These repetition items will always match the longest possible sequence;a single character class followed by ‘+’, which matches 1 or more repetitions of characters in the class. These repetition items will always match the longest possible sequence;a single character class followed by ‘-‘, which also matches 0 or more repetitions of characters in the class. Unlike ‘‘, these repetition items will always match the shortest possible sequence;a single character class followed by ‘?’, which matches 0 or 1 occurrence of a character in the class;%n, for n between 1 and 9; such item matches a substring equal to the n-th captured string (see below);%bxy, where x and y are two distinct characters; such item matches strings that start with x, end with y, and where the x and y are balanced. This means that, if one reads the string from left to right, counting +1 for an x and -1 for a y, the ending y is the first y where the count reaches 0. For instance, the item %b() matches expressions with balanced parentheses.Pattern:A pattern is a sequence of pattern items. A ‘^’ at the beginning of a pattern anchors the match at the beginning of the subject string. A ‘$’ at the end of a pattern anchors the match at the end of the subject string. At other positions, ‘^’ and ‘$’ have no special meaning and represent themselves. Captures:A pattern may contain sub-patterns enclosed in parentheses; they describe captures. When a match succeeds, the substrings of the subject string that match captures are stored (captured) for future use. Captures are numbered according to their left parentheses. For instance, in the pattern “(a(.)%w(%s))”, the part of the string matching “a(.)%w(%s)” is stored as the first capture (and therefore has number 1); the character matching “.” is captured with number 2, and the part matching “%s*” has number 3. As a special case, the empty capture () captures the current string position (a number). For instance, if we apply the pattern “()aa()” on the string “flaaap”, there will be two captures: 3 and 5. A pattern cannot contain embedded zeros. Use %z instead. 5.5 - Table ManipulationThis library provides generic functions for table manipulation. It provides all its functions inside the table table. Most functions in the table library assume that the table represents an array or a list. For these functions, when we talk about the “length” of a table we mean the result of the length operator. table.concat (table [, sep [, i [, j]]])Given an array where all elements are strings or numbers, returns table[i]..sep..table[i+1] ··· sep..table[j]. The default value for sep is the empty string, the default for i is 1, and the default for j is the length of the table. If i is greater than j, returns the empty string.table.insert (table, [pos,] value)Inserts element value at position pos in table, shifting up other elements to open space, if necessary. The default value for pos is n+1, where n is the length of the table (see §2.5.5), so that a call table.insert(t,x) inserts x at the end of table t. table.maxn (table)Returns the largest positive numerical index of the given table, or zero if the table has no positive numerical indices. (To do its job this function does a linear traversal of the whole table.) table.remove (table [, pos])Removes from table the element at position pos, shifting down other elements to close the space, if necessary. Returns the value of the removed element. The default value for pos is n, where n is the length of the table, so that a call table.remove(t) removes the last element of table t. table.sort (table [, comp])Sorts table elements in a given order, in-place, from table[1] to table[n], where n is the length of the table. If comp is given, then it must be a function that receives two table elements, and returns true when the first is less than the second (so that not comp(a[i+1],a[i]) will be true after the sort). If comp is not given, then the standard Lua operator &lt; is used instead.The sort algorithm is not stable; that is, elements considered equal by the given order may have their relative positions changed by the sort. 5.6 - Mathematical FunctionsThis library is an interface to the standard C math library. It provides all its functions inside the table math. math.abs (x)Returns the absolute value of x. math.acos (x)Returns the arc cosine of x (in radians). math.asin (x)Returns the arc sine of x (in radians). math.atan (x)Returns the arc tangent of x (in radians). math.atan2 (x, y)Returns the arc tangent of x/y (in radians), but uses the signs of both parameters to find the quadrant of the result. (It also handles correctly the case of y being zero.) math.ceil (x)Returns the smallest integer larger than or equal to x. math.cos (x)Returns the cosine of x (assumed to be in radians). math.cosh (x)Returns the hyperbolic cosine of x. math.deg (x)Returns the angle x (given in radians) in degrees. math.exp (x)Returns the the value ex. math.floor (x)Returns the largest integer smaller than or equal to x. math.fmod (x, y)Returns the remainder of the division of x by y. math.frexp (x)Returns m and e such that x = m2e, e is an integer and the absolute value of m is in the range [0.5, 1) (or zero when x is zero). math.hugeThe value HUGE_VAL, a value larger than or equal to any other numerical value. math.ldexp (m, e)Returns m2e (e should be an integer). math.log (x)Returns the natural logarithm of x. math.log10 (x)Returns the base-10 logarithm of x. math.max (x, ···)Returns the maximum value among its arguments. math.min (x, ···)Returns the minimum value among its arguments. math.modf (x)Returns two numbers, the integral part of x and the fractional part of x. math.piThe value of pi. math.pow (x, y)Returns xy. (You can also use the expression x^y to compute this value.) math.rad (x)Returns the angle x (given in degrees) in radians. math.random ([m [, n]])This function is an interface to the simple pseudo-random generator function rand provided by ANSI C. (No guarantees can be given for its statistical properties.) When called without arguments, returns a pseudo-random real number in the range [0,1). When called with a number m, math.random returns a pseudo-random integer in the range [1, m]. When called with two numbers m and n, math.random returns a pseudo-random integer in the range [m, n]. math.randomseed (x)Sets x as the “seed” for the pseudo-random generator: equal seeds produce equal sequences of numbers. math.sin (x)Returns the sine of x (assumed to be in radians). math.sinh (x)Returns the hyperbolic sine of x. math.sqrt (x)Returns the square root of x. (You can also use the expression x^0.5 to compute this value.) math.tan (x)Returns the tangent of x (assumed to be in radians). math.tanh (x)Returns the hyperbolic tangent of x. 5.7 - Input and Output FacilitiesThe I/O library provides two different styles for file manipulation. The first one uses implicit file descriptors; that is, there are operations to set a default input file and a default output file, and all input/output operations are over these default files. The second style uses explicit file descriptors. When using implicit file descriptors, all operations are supplied by table io. When using explicit file descriptors, the operation io.open returns a file descriptor and then all operations are supplied as methods of the file descriptor. The table io also provides three predefined file descriptors with their usual meanings from C: io.stdin, io.stdout, and io.stderr. Unless otherwise stated, all I/O functions return nil on failure (plus an error message as a second result) and some value different from nil on success. io.close ([file])Equivalent to file:close(). Without a file, closes the default output file. io.flush ()Equivalent to file:flush over the default output file. io.input ([file])When called with a file name, it opens the named file (in text mode), and sets its handle as the default input file. When called with a file handle, it simply sets this file handle as the default input file. When called without parameters, it returns the current default input file. In case of errors this function raises the error, instead of returning an error code. io.lines ([filename])Opens the given file name in read mode and returns an iterator function that, each time it is called, returns a new line from the file. Therefore, the construction for line in io.lines(filename) do body end will iterate over all lines of the file. When the iterator function detects the end of file, it returns nil (to finish the loop) and automatically closes the file. The call io.lines() (with no file name) is equivalent to io.input():lines(); that is, it iterates over the lines of the default input file. In this case it does not close the file when the loop ends. io.open (filename [, mode])This function opens a file, in the mode specified in the string mode. It returns a new file handle, or, in case of errors, nil plus an error message. The mode string can be any of the following: “r”: read mode (the default);“w”: write mode;“a”: append mode;“r+”: update mode, all previous data is preserved;“w+”: update mode, all previous data is erased;“a+”: append update mode, previous data is preserved, writing is only allowed at the end of file.The mode string may also have a ‘b’ at the end, which is needed in some systems to open the file in binary mode. This string is exactly what is used in the standard C function fopen. io.output ([file])Similar to io.input, but operates over the default output file. io.popen (prog [, mode])Starts program prog in a separated process and returns a file handle that you can use to read data from this program (if mode is “r”, the default) or to write data to this program (if mode is “w”). This function is system dependent and is not available on all platforms. io.read (···)Equivalent to io.input():read. io.tmpfile ()Returns a handle for a temporary file. This file is opened in update mode and it is automatically removed when the program ends. io.type (obj)Checks whether obj is a valid file handle. Returns the string “file” if obj is an open file handle, “closed file” if obj is a closed file handle, or nil if obj is not a file handle. io.write (···)Equivalent to io.output():write. file:close ()Closes file. Note that files are automatically closed when their handles are garbage collected, but that takes an unpredictable amount of time to happen. file:flush ()Saves any written data to file. file:lines ()Returns an iterator function that, each time it is called, returns a new line from the file. Therefore, the construction for line in file:lines() do body end will iterate over all lines of the file. (Unlike io.lines, this function does not close the file when the loop ends.) file:read (···)Reads the file file, according to the given formats, which specify what to read. For each format, the function returns a string (or a number) with the characters read, or nil if it cannot read data with the specified format. When called without formats, it uses a default format that reads the entire next line (see below). The available formats are “n”: reads a number; this is the only format that returns a number instead of a string.“a”: reads the whole file, starting at the current position. On end of file, it returns the empty string.“*l”: reads the next line (skipping the end of line), returning nil on end of file. This is the default format.number: reads a string with up to this number of characters, returning nil on end of file. If number is zero, it reads nothing and returns an empty string, or nil on end of file.file:seek ([whence] [, offset])Sets and gets the file position, measured from the beginning of the file, to the position given by offset plus a base specified by the string whence, as follows: “set”: base is position 0 (beginning of the file);“cur”: base is current position;“end”: base is end of file;In case of success, function seek returns the final file position, measured in bytes from the beginning of the file. If this function fails, it returns nil, plus a string describing the error. The default value for whence is “cur”, and for offset is 0. Therefore, the call file:seek() returns the current file position, without changing it; the call file:seek(“set”) sets the position to the beginning of the file (and returns 0); and the call file:seek(“end”) sets the position to the end of the file, and returns its size. file:setvbuf (mode [, size])Sets the buffering mode for an output file. There are three available modes: “no”: no buffering; the result of any output operation appears immediately.“full”: full buffering; output operation is performed only when the buffer is full (or when you explicitly flush the file (see io.flush)).“line”: line buffering; output is buffered until a newline is output or there is any input from some special files (such as a terminal device).For the last two cases, sizes specifies the size of the buffer, in bytes. The default is an appropriate size. file:write (···)Writes the value of each of its arguments to the file. The arguments must be strings or numbers. To write other values, use tostring or string.format before write. 5.8 - Operating System FacilitiesThis library is implemented through table os. os.clock ()Returns an approximation of the amount in seconds of CPU time used by the program. os.date ([format [, time]])Returns a string or a table containing date and time, formatted according to the given string format. If the time argument is present, this is the time to be formatted (see the os.time function for a description of this value). Otherwise, date formats the current time. If format starts with ‘!’, then the date is formatted in Coordinated Universal Time. After this optional character, if format is the string “*t”, then date returns a table with the following fields: year (four digits), month (1—12), day (1—31), hour (0—23), min (0—59), sec (0—61), wday (weekday, Sunday is 1), yday (day of the year), and isdst (daylight saving flag, a boolean). If format is not “*t”, then date returns the date as a string, formatted according to the same rules as the C function strftime. When called without arguments, date returns a reasonable date and time representation that depends on the host system and on the current locale (that is, os.date() is equivalent to os.date(“%c”)). os.difftime (t2, t1)Returns the number of seconds from time t1 to time t2. In POSIX, Windows, and some other systems, this value is exactly t2-t1. os.execute ([command])This function is equivalent to the C function system. It passes command to be executed by an operating system shell. It returns a status code, which is system-dependent. If command is absent, then it returns nonzero if a shell is available and zero otherwise. os.exit ([code])Calls the C function exit, with an optional code, to terminate the host program. The default value for code is the success code. os.getenv (varname)Returns the value of the process environment variable varname, or nil if the variable is not defined. os.remove (filename)Deletes the file or directory with the given name. Directories must be empty to be removed. If this function fails, it returns nil, plus a string describing the error. os.rename (oldname, newname)Renames file or directory named oldname to newname. If this function fails, it returns nil, plus a string describing the error. os.setlocale (locale [, category])Sets the current locale of the program. locale is a string specifying a locale; category is an optional string describing which category to change: “all”, “collate”, “ctype”, “monetary”, “numeric”, or “time”; the default category is “all”. The function returns the name of the new locale, or nil if the request cannot be honored. When called with nil as the first argument, this function only returns the name of the current locale for the given category. os.time ([table])Returns the current time when called without arguments, or a time representing the date and time specified by the given table. This table must have fields year, month, and day, and may have fields hour, min, sec, and isdst (for a description of these fields, see the os.date function). The returned value is a number, whose meaning depends on your system. In POSIX, Windows, and some other systems, this number counts the number of seconds since some given start time (the “epoch”). In other systems, the meaning is not specified, and the number returned by time can be used only as an argument to date and difftime. os.tmpname ()Returns a string with a file name that can be used for a temporary file. The file must be explicitly opened before its use and explicitly removed when no longer needed. 5.9 - The Debug LibraryThis library provides the functionality of the debug interface to Lua programs. You should exert care when using this library. The functions provided here should be used exclusively for debugging and similar tasks, such as profiling. Please resist the temptation to use them as a usual programming tool: they can be very slow. Moreover, several of its functions violate some assumptions about Lua code (e.g., that variables local to a function cannot be accessed from outside or that userdata metatables cannot be changed by Lua code) and therefore can compromise otherwise secure code. All functions in this library are provided inside the debug table. All functions that operate over a thread have an optional first argument which is the thread to operate over. The default is always the current thread. debug.debug ()Enters an interactive mode with the user, running each string that the user enters. Using simple commands and other debug facilities, the user can inspect global and local variables, change their values, evaluate expressions, and so on. A line containing only the word cont finishes this function, so that the caller continues its execution. Note that commands for debug.debug are not lexically nested within any function, and so have no direct access to local variables. debug.getfenv (o)Returns the environment of object o.debug.gethook ([thread])Returns the current hook settings of the thread, as three values: the current hook function, the current hook mask, and the current hook count (as set by the debug.sethook function). debug.getinfo ([thread,] function [, what])Returns a table with information about a function. You can give the function directly, or you can give a number as the value of function, which means the function running at level function of the call stack of the given thread: level 0 is the current function (getinfo itself); level 1 is the function that called getinfo; and so on. If function is a number larger than the number of active functions, then getinfo returns nil. The returned table may contain all the fields returned by lua_getinfo, with the string what describing which fields to fill in. The default for what is to get all information available, except the table of valid lines. If present, the option ‘f’ adds a field named func with the function itself. If present, the option ‘L’ adds a field named activelines with the table of valid lines. For instance, the expression debug.getinfo(1,”n”).name returns a name of the current function, if a reasonable name can be found, and the expression debug.getinfo(print) returns a table with all available information about the print function. debug.getlocal ([thread,] level, local)This function returns the name and the value of the local variable with index local of the function at level level of the stack. (The first parameter or local variable has index 1, and so on, until the last active local variable.) The function returns nil if there is no local variable with the given index, and raises an error when called with a level out of range. (You can call debug.getinfo to check whether the level is valid.) Variable names starting with ‘(‘ (open parentheses) represent internal variables (loop control variables, temporaries, and C function locals). debug.getmetatable (object)Returns the metatable of the given object or nil if it does not have a metatable. debug.getregistry ()Returns the registry table (see §3.5). debug.getupvalue (func, up)This function returns the name and the value of the upvalue with index up of the function func. The function returns nil if there is no upvalue with the given index. debug.setfenv (object, table)Sets the environment of the given object to the given table. Returns object. debug.sethook ([thread,] hook, mask [, count])Sets the given function as a hook. The string mask and the number count describe when the hook will be called. The string mask may have the following characters, with the given meaning: “c”: The hook is called every time Lua calls a function;“r”: The hook is called every time Lua returns from a function;“l”: The hook is called every time Lua enters a new line of code.With a count different from zero, the hook is called after every count instructions. When called without arguments, debug.sethook turns off the hook. When the hook is called, its first parameter is a string describing the event that has triggered its call: “call”, “return” (or “tail return”), “line”, and “count”. For line events, the hook also gets the new line number as its second parameter. Inside a hook, you can call getinfo with level 2 to get more information about the running function (level 0 is the getinfo function, and level 1 is the hook function), unless the event is “tail return”. In this case, Lua is only simulating the return, and a call to getinfo will return invalid data. debug.setlocal ([thread,] level, local, value)This function assigns the value value to the local variable with index local of the function at level level of the stack. The function returns nil if there is no local variable with the given index, and raises an error when called with a level out of range. (You can call getinfo to check whether the level is valid.) Otherwise, it returns the name of the local variable. debug.setmetatable (object, table)Sets the metatable for the given object to the given table (which can be nil). debug.setupvalue (func, up, value)This function assigns the value value to the upvalue with index up of the function func. The function returns nil if there is no upvalue with the given index. Otherwise, it returns the name of the upvalue. debug.traceback ([thread,] [message] [, level])Returns a string with a traceback of the call stack. An optional message string is appended at the beginning of the traceback. An optional level number tells at which level to start the traceback (default is 1, the function calling traceback). 6 - Lua Stand-aloneAlthough Lua has been designed as an extension language, to be embedded in a host C program, it is also frequently used as a stand-alone language. An interpreter for Lua as a stand-alone language, called simply lua, is provided with the standard distribution. The stand-alone interpreter includes all standard libraries, including the debug library. Its usage is: lua [options] [script [args]] The options are: -e stat: executes string stat;-l mod: “requires” mod;-i: enters interactive mode after running script;-v: prints version information;—: stops handling options;-: executes stdin as a file and stops handling options.After handling its options, lua runs the given script, passing to it the given args as string arguments. When called without arguments, lua behaves as lua -v -i when the standard input (stdin) is a terminal, and as lua - otherwise. Before running any argument, the interpreter checks for an environment variable LUA_INIT. If its format is @filename, then lua executes the file. Otherwise, lua executes the string itself. All options are handled in order, except -i. For instance, an invocation like $ lua -e&#39;a=1&#39; -e &#39;print(a)&#39; script.lua will first set a to 1, then print the value of a (which is ‘1’), and finally run the file script.lua with no arguments. (Here $ is the shell prompt. Your prompt may be different.) Before starting to run the script, lua collects all arguments in the command line in a global table called arg. The script name is stored at index 0, the first argument after the script name goes to index 1, and so on. Any arguments before the script name (that is, the interpreter name plus the options) go to negative indices. For instance, in the call $ lua -la b.lua t1 t2 the interpreter first runs the file a.lua, then creates a table arg = { [-2] = &quot;lua&quot;, [-1] = &quot;-la&quot;, [0] = &quot;b.lua&quot;, [1] = &quot;t1&quot;, [2] = &quot;t2&quot; } and finally runs the file b.lua. The script is called with arg[1], arg[2], ··· as arguments; it can also access these arguments with the vararg expression ‘…’. In interactive mode, if you write an incomplete statement, the interpreter waits for its completion by issuing a different prompt. If the global variable _PROMPT contains a string, then its value is used as the prompt. Similarly, if the global variable _PROMPT2 contains a string, its value is used as the secondary prompt (issued during incomplete statements). Therefore, both prompts can be changed directly on the command line. For instance, $ lua -e&quot;_PROMPT=&#39;myprompt&gt; &#39;&quot; -i (the outer pair of quotes is for the shell, the inner pair is for Lua), or in any Lua programs by assigning to _PROMPT. Note the use of -i to enter interactive mode; otherwise, the program would just end silently right after the assignment to _PROMPT. To allow the use of Lua as a script interpreter in Unix systems, the stand-alone interpreter skips the first line of a chunk if it starts with #. Therefore, Lua scripts can be made into executable programs by using chmod +x and the #! form, as in #!/usr/local/bin/lua (Of course, the location of the Lua interpreter may be different in your machine. If lua is in your PATH, then #!/usr/bin/env lua is a more portable solution.) 7 - Incompatibilities with the Previous VersionHere we list the incompatibilities that you may found when moving a program from Lua 5.0 to Lua 5.1. You can avoid most of the incompatibilities compiling Lua with appropriate options (see file luaconf.h). However, all these compatibility options will be removed in the next version of Lua. 7.1 - Changes in the LanguageThe vararg system changed from the pseudo-argument arg with a table with the extra arguments to the vararg expression. (See compile-time option LUA_COMPAT_VARARG in luaconf.h.)There was a subtle change in the scope of the implicit variables of the for statement and for the repeat statement.The long string/long comment syntax ([[string]]) does not allow nesting. You can use the new syntax ([=[string]=]) in these cases. (See compile-time option LUA_COMPAT_LSTR in luaconf.h.)7.2 - Changes in the LibrariesFunction string.gfind was renamed string.gmatch. (See compile-time option LUA_COMPAT_GFIND in luaconf.h.)When string.gsub is called with a function as its third argument, whenever this function returns nil or false the replacement string is the whole match, instead of the empty string.Function table.setn was deprecated. Function table.getn corresponds to the new length operator (#); use the operator instead of the function. (See compile-time option LUA_COMPAT_GETN in luaconf.h.)Function loadlib was renamed package.loadlib. (See compile-time option LUA_COMPAT_LOADLIB in luaconf.h.)Function math.mod was renamed math.fmod. (See compile-time option LUA_COMPAT_MOD in luaconf.h.)Functions table.foreach and table.foreachi are deprecated. You can use a for loop with pairs or ipairs instead.There were substantial changes in function require due to the new module system. However, the new behavior is mostly compatible with the old, but require gets the path from package.path instead of from LUA_PATH.Function collectgarbage has different arguments. Function gcinfo is deprecated; use collectgarbage(“count”) instead.7.3 - Changes in the APIThe luaopen_* functions (to open libraries) cannot be called directly, like a regular C function. They must be called through Lua, like a Lua function.Function lua_open was replaced by lua_newstate to allow the user to set a memory-allocation function. You can use luaL_newstate from the standard library to create a state with a standard allocation function (based on realloc).Functions luaL_getn and luaL_setn (from the auxiliary library) are deprecated. Use lua_objlen instead of luaL_getn and nothing instead of luaL_setn.Function luaL_openlib was replaced by luaL_register.Function luaL_checkudata now throws an error when the given value is not a userdata of the expected type. (In Lua 5.0 it returned NULL.)8 - The Complete Syntax of LuaHere is the complete syntax of Lua in extended BNF. (It does not describe operator precedences.) chunk ::= {stat [`;´]} [laststat [`;´]] block ::= chunk stat ::= varlist1 `=´ explist1 | functioncall | do block end | while exp do block end | repeat block until exp | if exp then block {elseif exp then block} [else block] end | for Name `=´ exp `,´ exp [`,´ exp] do block end | for namelist in explist1 do block end | function funcname funcbody | local function Name funcbody | local namelist [`=´ explist1] laststat ::= return [explist1] | break funcname ::= Name {`.´ Name} [`:´ Name] varlist1 ::= var {`,´ var} var ::= Name | prefixexp `[´ exp `]´ | prefixexp `.´ Name namelist ::= Name {`,´ Name} explist1 ::= {exp `,´} exp exp ::= nil | false | true | Number | String | `...´ | function | prefixexp | tableconstructor | exp binop exp | unop exp prefixexp ::= var | functioncall | `(´ exp `)´ functioncall ::= prefixexp args | prefixexp `:´ Name args args ::= `(´ [explist1] `)´ | tableconstructor | String function ::= function funcbody funcbody ::= `(´ [parlist1] `)´ block end parlist1 ::= namelist [`,´ `...´] | `...´ tableconstructor ::= `{´ [fieldlist] `}´ fieldlist ::= field {fieldsep field} [fieldsep] field ::= `[´ exp `]´ `=´ exp | Name `=´ exp | exp fieldsep ::= `,´ | `;´ binop ::= `+´ | `-´ | `*´ | `/´ | `^´ | `%´ | `..´ | `&lt;´ | `&lt;=´ | `&gt;´ | `&gt;=´ | `==´ | `~=´ | and | or unop ::= `-´ | not | `#´]]></content>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#]]></title>
    <url>%2F2018%2F04%2F02%2FCSharp%2F</url>
    <content type="text"><![CDATA[internal、sealedinternal：本应用程序使用，其它进程无法使用 sealed（密封）：由它修饰的类、方法、属性将不能被继承或是重写。sealed 必须和override一起使用sealed修饰符表示密封用于类时，表示该类不能被继承，不能和abstract同时使用，不能被实例化。密封类不能用作基类、也不能继承，而抽象类总是希望被继承的。 fixedfixed 语句可防止垃圾回收器重新定位可移动的变量。 fixed 语句仅允许存在于不安全的上下文中。 Fixed 还可用于创建固定大小的缓冲区。 fixed 语句将为托管变量设置一个指针，并在该语句的执行过程中“单边锁定”该变量。 如果没有 fixed，指向可移动的托管变量的指针将几乎没有什么用处，因为垃圾回收可能会不可预见地重新定位变量。 C# 编译器只允许将指针分配给 fixed 语句中的托管变量。 不支持持多继承，C#类始终继承一个基类（如果未在声明中指定一个基类，则继承自System.Object) 如果对类没有定义显示构造函数，则编译器将提供默认的构造函数，以初始化这些类的成员字段。但是，如果显式添加了构造函数，就可以有效控制整个构造过程。派生类通过使用:base()语法可以显式调用基类的构造函数 override 具有override关键字修饰符的方法是对基类中同名方法的新实现，基类中的同名方法必须声明为virtual或abstract类型。给基类中的方法添加virtual关键字表示可以重写它的实现。new static 和 virtual关键字不能与override访问修饰符同时使用。 virtual 支持多态，不能与static override同时使用 abstract 一个抽象类包含抽象方法和非抽象方法，抽象方法只存放函数原型，不涉及主体代码，override关键字可在派生类中抽象方法，经override声明重写的方法称为重写基类方法，其签名必须与override方法的签名相同。只是不能被实例化，除此以外具有类的其他特性，重要的是抽象类可以包含抽象方法，这是普通类所不能的。抽象方法只能声明于抽象方法中，且不包含任何实现，派生类必须覆盖它们。 interface 包含未实现的方法声明，派生类必须实现未实现的方法，抽象类是抽象方法，接口则是所有成员，接口包含属性，索引器事件 索引器索引器允许类或者结构的实例按照于数组相同的方法进行索引取值，索引器与属性类似，不同的是索引器的访问时带参的 索引器的索引值(Index)类型不受限制 索引器允许重载 索引器不是一个变量 索引器和属性的不同点 属性以名称来标识，索引器以函数形式标识 索引器可以被重载，属性不可以 索引器不能声明为static，属性可以 interface、abstract abstract interface 能否实例化 不能 不能 抽象类和接口的区别： 类是对对象的抽象，可以把抽象类理解为把类当作对象，抽象成的类叫抽象类，而接口只是一个行为的规范或规定， 接口基本上不具备类型的任何具体特点，它仅仅承诺了能够调用的方法 抽象类比较细，而接口比较简单 抽象类和接口的使用 如果预计要创建组件的多个版本，则创建抽象类。抽象类提供简单的方法来控制组件版本。 抽象类主要用于关系密切的对象；而接口适合为不相关的类提供通用功能 Marshal提供了一个方法集合，这些方法用于分配非托管内存、复制非托管内存块、将托管类型转换为非托管类型，此外还提供了在于非托管代码交互时使用的其他方法 命名空间：System.Runtime.InteropServices程序集：mscorlib AllocHGlobal(int32); // 通过使用指定的字节数，从进程的非托管内存中分配内存SizeOf(Type)返回非托管类型的大小(以字节为单位) this12345678910111213public static class PGExt&#123; public static T PG_GetComponent(this List&lt;Component&gt; components) where T : Component &#123; int c = components.Count; for (int i = 0; i &lt; c; ++i) &#123; var p = components[i] as T; if ((object)p != null) return p; &#125; return null; &#125;&#125; 为什么这里会有一个this关键字，做什么用？其实这就是扩展方法！这个扩展方法在静态类中声明，定义一个静态方法，其中第一个参数定义可它的扩展类型，PG_GetComponent方法扩展了List类，因为它的第一个参数定义了List类型，为了区分扩展方法和一般的静态方法，扩展方法还需要给第一个参数使用this关键字。 现在就可以使用带List类型的PG_GetComponent方法了： var mf = cacheComponents.PG_GetComponent&lt;MeshFilter&gt;(); GC GC不能自动释放非托管资源。 GC并不是实时性的。 volatilevolatile关键字指示一个字段可以由多个同时执行的线程修改。声明volatile的字段不受编译器优化的限制。这样可以确保该字段在任何时间呈现的都是最新的值。 volatile修饰符通常用于由多个线程访问但不使用lock语句对访问进行序列化的字段。 volatile关键字可应用于以下类型的字段： 引用类型 指针类型（在不安全的上下文中）。请注意，虽然指针本身可以是可变的，但是它指向的对象不能是可变的。换句话说，无法声明“指向可变对象的指针”。 类型，如sbyte、byte、short、ushort、int、uint、。 引用类型的泛型类型参数。 IntPtr和UIntPtr 事件和委托联系：事件是一种特殊的委托，均类似于C中的函数指针，讲一个方法通过参数传到别的方法中，通过别的方法来调用。 区别：体现在封装性。事件是订阅发布的机制。委托可以在类的外部直接赋值，直接调用。即可以直接使用：12345678910111213141516171819202122class A &#123; public delegate void Say(); public Say m_Say; &#125; class B &#123; public void Say() &#123; Console.WriteLine("Say What?"); &#125; &#125; class Program &#123; static void Main(string[] args) &#123; A a = new A(); B b = new B(); a.m_Say = b.Say; a.m_Say(); &#125; &#125; 事件不可以在类的外部直接赋值，且不可以直接赋值调用。步骤： 创建一个委托 将创建的委托与特定事件关联 编写C#事件处理程序 利用编写的C#事件处理程序生成一个委托实例 把这个委托实例添加到事件对象的事件列表中去，这个过程又叫订阅事件 12345678910111213141516171819202122232425262728293031class A &#123; // 定义一个委托 public delegate void Say(); // 定义一个事件 public event Say m_eventSay; // 引发事件的方法 public void Begin() &#123; m_eventSay(); // 被引发的事件 &#125; &#125; class B &#123; public void Say() &#123; Console.WriteLine("Say What?"); &#125; &#125; class Program &#123; static void Main(string[] args) &#123; A a = new A(); // 实例化事件发布者 B b = new B(); // 实例化事件订阅者 // 订阅事件 a.m_eventSay += new A.Say(b.Say); // 引发事件 a.Begin(); &#125; &#125;]]></content>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xxsy-sence-merge-render]]></title>
    <url>%2F2018%2F04%2F02%2Fxxsy-sence-merge-render%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[PJ04]]></title>
    <url>%2F2018%2F04%2F02%2Fxxsy-skill%2F</url>
    <content type="text"><![CDATA[normal_logic Index Type Data1 Data2 Data3 Data4 Data5 1 随机移动 2 固定线路 3 跟随逻辑 4 恐惧逻辑 5 飞行逻辑 6 7 8 怪物闲聊 talk_list.id 起始延迟时间 间隔时间 9 宠物跟随 20 怪物边聊边走 refresh_table 物体id 刷新方式 cha_list.id 0手动1刷一次2死亡复合3条件 talk_list 事件类型 事件id 4，驾云/瞬移 trans_cmn.id]]></content>
      <tags>
        <tag>Pj04</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL]]></title>
    <url>%2F2018%2F04%2F01%2Fopengl%2F</url>
    <content type="text"><![CDATA[颜色缓冲区颜色缓冲区（COLOR_BUFFER）就是帧缓冲区（FRAME_BUFFER），你需要渲染的场景最终每一个像素都要写入该缓冲区，然后由它渲染到屏幕上显示。 深度缓冲区深度缓冲区（DEPTH_BUFFER）与帧缓冲区对应，用于记录上面每个像素的深度值，通过深度缓冲区，我们就可以进行深度测试，从而确定像素的遮挡关系，保证渲染正确。 模版缓冲区模版缓冲区（STENCIL_BUFFER）与深度缓冲大小相同，通过设置模版缓冲每个像素的值，我们可以指定在渲染的时候只渲染某些像素，从而可以达到一些特殊的效果。 Texture Wrapping通常，纹理坐标的范围在(0,0)到(1,1)之间，但是假如我们制定的坐标在这之外呢？OpenGL会如何做出反应？默认情况下，OpenGL会重复绘制纹理图，不过，OpenGL也提供了更多的选择方案： GL_REPEAT：默认方案，重复纹理图片 GL_MIRRORED_REPEAT：类似于默认方法，不过每次重复的时候进行镜像重复。 GL_CLAMP_TP_EDGE：将坐标限制在0到1之间。超出的坐标会重复绘制边缘的像素，变成一种扩展边缘的图案。 GL_CLAMP_TO_BORDER：超出的坐标将会被绘制成用户指定的边界颜色]]></content>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法]]></title>
    <url>%2F2018%2F03%2F29%2FRed-Black-Tree%2F</url>
    <content type="text"><![CDATA[红黑树红黑树是一种自平衡二叉查找树。 性质1.节点是红色或黑色。2.根节点是黑色3.每个叶节点（NIL或空节点）是黑色4.每个红色节点的两个子节点都是黑色的（也就是说不存在两个连续的红色节点）；5.从任意一个节点到其叶子节点都包含相同数目的黑色节点； AVL树性质1.本身首先是一棵二叉搜索树2.带有平衡条件：每个节点的左右子树的高度之差的绝对值（平衡因子）最多为1. 节点数STL和Linux都使用红黑树作为平衡树的实现1.如果插入一个node引起了树的不平衡，AVL和RB-Tree都是最多只需要2次旋转操作，即两者都是O(1)；但是在删除node引起树的不平衡时，最坏情况下，AVL需要维护从被删node到root这条路径上所有node的平衡性，因此需要旋转的两级O(logN)，而RB-Tree最多只需要3次旋转，只需要O(1)的复杂度。2.其次，AVL的结构相较RB-Tree来说更为平衡，在插入和删除node更容易引起Tree的unbalance，因此在大量数据需要插入或删除时，AVL需要rebalance的频率会更高。因此，RB-Tree在需要大量插入和删除node的场景下，效率更高。自然，由于AVL高度平衡，因此AVL的search效率更高。3.map的实现只是折衷了两者在search、insert以及delete下的效率。总体来说，RB-tree的统计行能是高于AVL的。 二叉查找树定义1.若左子树不空，则左子树所有节点的值均小于或等于它的根节点的值；2.若右子树不空，则右子树所有节点的值均大于或等于它的根节点的值；3.左、右子树也分别为二叉排序树； 查找步骤：若根节点的关键字值等于查找的关键字，成功。否则，若小于根节点的关键字值，递归查左子树。P(n)=O(logn) 非递归遍历前序非递归遍历123456789101112131415161718192021222324252627282930void preorder_traversal_iteratively(TreeNode* root)&#123; if (root == 0) &#123; return; &#125; stack&lt;TreeNode*&gt; s; s.push(root); cout &lt;&lt; root-&gt;val &lt;&lt; ' '; TreeNode* last_pop = root; while (!s.empty()) &#123; TreeNode* top = s.top(); if (top-&gt;left != 0 &amp;&amp; top-&gt;left != last_pop &amp;&amp; top-&gt;right != last_pop) &#123; s.push(top-&gt;left); cout &gt;&gt; top-&gt;left-&gt;val &lt;&lt; ' '; &#125; else if (top-&gt;right != 0 &amp;&amp; top-&gt;right != last_pop &amp;&amp; (top-&gt;left == 0 || top-&gt;left == last_pop)) &#123; s.push(top-&gt;right); cout &gt;&gt; top-&gt;right-&gt;val &lt;&lt; ' '; &#125; else &#123; s.pop(); last_pop = top; &#125; &#125;&#125; Hash(散列函数)给定M，存在函数f(key)，对任意给定给定的关键字key，代入函数厚若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash)表，函数(key)为哈希(Hash)函数。如果key不相同，但是f(k1)=f(k2),这种现象成为碰撞(Collision) 哈希函数1.直接寻址发：取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key) = a * key + b,其中a和b为常熟（这种散列函数叫做自身函数）。]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C]]></title>
    <url>%2F2018%2F03%2F24%2FObjective-C%2F</url>
    <content type="text"><![CDATA[Objective-C: C的超集Objective-C是C语言的严格超集—任何C语言不经修改可以直接通过Objective-C编译器 Objective-C代码文件的扩展名.h 头文件.m 源代码文件，包含Objective-C和C代码.mm 源代码文件，包含Objective-C、C、C++代码，仅在你的Objective-C代码中确实需要使用C++类或者特性的时候采用这种扩展名 当你需要在源代码中包含头文件的时候，你可以使用标准的#include编译选项，但是Objective-C提供了更好的方法。#import选项和#include选项完全相同，只是它可以确保相同的文件只会被包含一次。Objective-C的例子和文档都倾向于使用#import。 语法C++调用方法 obj.method(argument); Objective-C调用方法 [obj method: argument]; 类声明总是由@interface编译选项开始，由@end选项结束。 123456789101112@interface MyObject: NSObject&#123; int memberVar1; // 实体变量 id &#125;+(return_type) class_method; //类方法-(return_type) instance_method1; //实例方法-(void)fbSendInviteByID: (NSDictionary*)info&#123;&#125;@end 方法前面+/-号代表函数的类型：加号(+)代表类方法(class method),不需要实例就可以调用，与C++的静态函数(static member function)相似。减号(-)即是一般的实例方法(instance method)1-(void)setColorToRed: (float)red Green: () pragma mark]]></content>
  </entry>
  <entry>
    <title><![CDATA[Unity热更新方案-ILRuntime]]></title>
    <url>%2F2018%2F03%2F23%2FUnity-ILRuntime%2F</url>
    <content type="text"><![CDATA[ILRuntime的优势同市面上的其他热更方案相比，ILRuntime主要有以下优点： 无缝访问C#工程的线程代码，无需额外抽象脚本API 直接使用VS2015进行开发，ILRuntime的解释编译引擎支持.Net 4.6编译的DLL 执行效率是L#的10-20倍 选择性的CLR绑定使跨域调用更快速，绑定后跨域调用的性能能达到slua的2倍左右(从脚本调用GameObject之类的接口) 支持跨域集成 完整的泛型支持 拥有Vs2015调试插件，可以实现真机源码级调试(WIP) https://github.com/Ourpalm/ILRuntimehttps://ourpalm.github.io/ILRuntime/public/v1/guide/tutorial.html 如果你希望在Unity中使用ILRuntime,推荐的方式是直接使用ILRuntime源代码，这样ILRuntime可以根据你的发布设置自动进行优化。 你需要将下列源代码目录复制到Unity工程的Assets目录： Mono.Cecil.20 Mono.Cecil.Pdb ILRuntime 需要注意的是，需要删除这些目录里面的bin、obj、Properties子目录，以及.csproj文件。此外由于ILRuntime使用了unsafe代码来优化执行效率，所以你需要在Unity中开启unsafe模式： 在Assets目录里建立一个名为smcs.rsp的文本文件 在smcs.rsp文件中假如-unsafe 如果你使用的是Unity5.4及以前的版本，并且使用的编译设置是.Net 2.0而不是.Net 2.0 Subset的话，你需要将上述说明中的smcs.rsp文件名改为gmcs.rsp。如果你使用的是Unity5.5以上的版本，你需要将上述说明的smcs.rsp文件名改为mcs.rsp 从Visual Studio开始如果你希望在VisiualStudio的C#项目中使用ILRuntime，你只需要引用编译好的ILRuntime.dll,Mono.Cecil.20.dll以及Mono.Cecil.Pdb即可。 使用之前ILRuntime项目提供了一个测试用例工程ILRuntimeTest,用来验证ILRuntime的正常运行，在运行测试用例前，需要手动生成一下TestCases里面的工程，生成DLL文件。]]></content>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Skinned Mesh原理解析]]></title>
    <url>%2F2018%2F03%2F23%2FUnity-Skinned-Mesh%2F</url>
    <content type="text"><![CDATA[一、3D模型动画基本原理和分类3D模型动画的基本原理是让模型中各定点的位置随时间变化。主要种类由Morph动画，关节动画和骨骼蒙皮动画(Skinned Mesh)。从动画数据的角度来说，三者一般都采用关键帧技术，即只给出关键帧的数据，其他帧的数据使用插值得到。但由于这三种技术的不同，关键帧的数据是不一样的。 Morph(渐变，变形)动画是直接指定动画每一帧的顶点位置，其动画关键中存储的是Mesh所有顶点在关键帧对应时刻的位置。 关节动画的模型不是一个整体的Mesh，而是分成很多部分(Mesh),通过一个父子层级结构将这些分散的Mesh组织在一起，父Mesh带动其子Mesh运动，各mesh中的顶点坐标定义在自己的坐标系中，这样各个Mesh是作为一个整体参与运动的。动画帧中设置各子Mesh相对于Mesh的变化（主要是旋转，当然也可以包括移动和缩放），通过子到父，一级级的变化累加（当然从技术上，如果是矩阵操作是累乘）得到该Mesh在整个动画模型所在的坐标空间中的变换（从本文的视角来说就是世界坐标系了，下同），从而确定每个Mesh在世界坐标系中的位置和方向，然后以Mesh为单位渲染即可。关节动画的问题是，各部分Mesh中的顶点时固定在其Mesh坐标系中的，这样在两个mesh结合处就可能产生裂缝。 第三类就是骨骼蒙皮动画即Skinned Mesh了，骨骼蒙皮动画的出现解决了关节动画的裂缝问题，而且效果非常酷，骨骼动画的基本原理可概括为：在骨骼控制下，通过顶点混合动态计算蒙皮网格的顶点，而骨骼的运动相对于其父骨骼，并由动画关键帧数据驱动。一个骨骼动画通常包括骨骼层次结构数据，网格(Mesh)数据，网格蒙皮数据(skin info)和骨骼的动画(关键帧)数据。 二、Skinned Mesh 原理和结构分析Skinned Mesh中文一般乘坐骨骼蒙皮动画，这种动画包含骨骼(Bone)和蒙皮(Skinned Mesh)两个部分，Bone的层次结构和关节动画类似，Mesh则和关节动画不同：关节动画中时使用多个分散的Mesh,而Skinned Mesh中的Mesh是一个整体，也就是说只有一个mesh,实际上如果没有骨骼让Mesh运动变形，Mesh就和静态模型一样了，Skinned Mesh技术的精华在于蒙皮，所谓的皮并不是模型的贴图，而是mesh本身，蒙皮是将mesh中的顶点附着（绑定）在骨骼之上，而且每个顶点可以被多个骨骼所控制，这样的关节处的顶点由于同时收到了父子骨骼的拉扯而改变位置就消除了裂缝。 1.理解骨骼和骨骼层次结构(Bone Hierarchy)首先要明确一个观念：骨骼决定了模型整体在世界坐标系中的位置和朝向。先看看静态模型吧，静态模型没有骨骼，我们在世界坐标系中放置静态模型时，只要指定模型自身坐标系在世界坐标系中的位置和朝向。在骨骼动画中，不是把Mesh直接放到世界坐标系中，Mesh只是作为Skin使用的，是依附骨骼的，真正决定模型在世界坐标系中的位置和朝向的是骨骼。在渲染静态模型时，由于模型的顶点都是定义在模型坐标系中的，所以各顶点只要经过模型坐标系到世界坐标系的变换就可以进行渲染。而对于骨骼动画，设置模型的位置和朝向，实际实在设置根骨骼的位置和朝向，然后根据骨骼层级结构中父子骨骼之间的变换关系计算出各个骨骼的位置和朝向，然后根据骨骼堆Mesh中顶点的绑定计算出顶点在世界坐标系中的坐标，从而堆顶点进行渲染，要记住，在骨骼动画中，骨骼才是模型主题，Mesh不过是一层皮，一件衣服。如何理解骨骼？请看第二个管娘：骨骼可理解为一个坐标空间。在一些文章中往往会提到关节和骨骼，那么关节是什么？骨骼有事什么？下图是一个手臂的骨骼层次的实例。骨骼只是一个形象的说法，实际上骨骼可理解为一个坐标空间，关节可理解为骨骼坐标空间的远点。关节的位置由它在父骨骼坐标空间中描述，上图中由三块骨骼，分别是手臂，前臂和两个手指。Clavicle(骨锁)是一个关节，它是上臂的原点，同样肘关节(elbow joint)是前臂的原点，腕关节(wrist)是手指骨骼的远点。关节既决定了骨骼空间的位置，旋转和缩放分量决定了骨骼空间的旋转和缩放。我们来看前臂这个骨骼，其原点位置位于上臂上某处的，对于上臂来说，它知道自己的坐标空间某处(即肘关节所在的位置)有一个子空间，那就是前臂，至于前臂里面是啥就不考虑了。当前臂绕肘关节旋转时，实际是前臂坐标空间在旋转，从而其中包含的子空间也在绕肘关节旋转，这个例子中是finger骨骼。和实际生物骨骼不同的是，我们这里的骨骼并没有实质的骨头，所以前臂旋转时，他自己没啥可转的，改变的只是坐标空间的朝向。你可以说上图蓝线在转，但实际蓝线并不存在，蓝线只是画上去表示骨骼之间关系的，真正转的是骨骼空间，我们能看到在转的是wrist joint,也就是两个finger骨骼的坐标空间，因为他们是子空间，会跟随父空间运动，就好比跟着地球转一样。 骨骼就是坐标空间，骨骼层次就是嵌套的坐标空间。关节只是描述骨骼的位置即骨骼自己的坐标空间原点再其父空间中的位置，绕关节旋转是指骨骼坐标空间(包括所有子空间)自身的旋转。但还有两个可能的疑问，一是骨骼的长度，由于骨骼是坐标空间没有所谓的长度和宽度限制，我们看到的长度一方面是蒙皮后的结果，而另一方面子骨骼的原点(也就是关节)的位置往往决定了视觉上父骨骼的长度，比如这里upper arm线段的长度实际是由elbow joint的位置决定的。第二个问题，实际上我们的例子中手指没有子骨骼，所以那个端点并不存在，那是为了方便演示画上去的。实际问题中总有最下层的骨骼，他们不能决定其他骨骼了，他们的作用只剩下控制Mesh顶点了。对了，那么手指的长度如何确定？我们看到的长度应该是手指部分的顶点和蒙皮决定的，也就是由Mesh中属于手指的那些点离腕关节的距离决定。 经过一段长篇大论，我们终于弄清楚骨骼和骨骼层次结构了，但是为什么要将骨骼组织成层次结构呢？答案是为了做动画方便，设想如果只有一块骨骼，那么让他动起来太简单了，动画每一帧直接指定他的位置即可，如果是n块呢？通过组成一个层次结构，就可以通过父骨骼控制子骨骼的运动，牵一发而动全身，改变某骨骼时并不需要设置其子骨骼的位置，子骨骼的位置会通过计算自动得到，上问已经说过，父子骨骼之间的关系可以理解为，子骨骼位于父骨骼的坐标系中，我们知道物体在坐标系中可以平移变换，以及自身的旋转和缩放。子骨骼在父骨骼的坐标系中也可以做这些变换来改变自己在其父骨骼坐标系中的位置和朝向等，那么如何表示呢？由于4x4矩阵可以同时表示上述三种变换，所以一般描述骨骼在其父骨骼坐标系时使用一个举证，也就是DirectX SkinnedMesh中的FramrTrnsformMatrix。实际上这不是唯一的方法，但应该是公认的方法因为矩阵不光可以同时表示多种变换还可以方便的通过连乘进行变换的组合，这在层次结构中非常方便。在本文的例子-最简单的skinned mesh示例中，我只演示了评议变换，所以只用一个3d坐标就可以表示子骨骼在父骨骼的位置。下面是Bone Class最初的定义：12345class Bone&#123; public: float m_x, m_y, m_z;//这个坐标是定义在父骨骼坐标系中&#125; 同时增加了一组坐标，存放计算好的世界坐标系。将各个骨骼相关于相对于父骨骼摆放好，就形成了一个骨骼层次结构的初始坐标，所谓初始是指定义骨骼层次时，后来动画改变了骨骼的相对位置，准确的说一般是改变了骨骼自身的旋转而位置保持不变。 假设我们通过某种方法建立了骨骼层次结构，那么每一块骨骼的位置都依赖于其父骨骼的位置，而跟骨骼没有父，他的位置就是整个骨骼体系在世界坐标系中的位置。可以认为root的父就是世界坐标系。但是初始位置时，跟骨骼一般不是世界原点的，比如使用3d max character studio创建的biped骨架时，一般两脚之间时世界原点，而根骨骼-骨盆位于原点上方(+z轴上)。这有什么关系呢，其实也没什么大不了的，只是我们在指定骨骼动画模型整体坐标时，比如设定坐标(0,0,0),则根骨骼-骨盆被置于世界原点，假如xy平面时地面，那么人下个身子到地面下了。我们想让两脚之间算作人的原点，这样设定(0,0,0)的坐标时人就站在地面上了，所以可以在两脚之间设定一个额外的根骨骼放到世界原点上，或者这个骨骼并不需要真实存在，只是在你的骨骼模型结构中保存骨盆骨骼到世界原点的变换矩阵。在微软X文件中，一般有一个Scene_Root节点，这算一个额外的骨骼吧，他的变换矩阵为单位阵，表示他初始位于世界原点，而真正骨骼的跟Bip01,作为Scene_root的子骨骼，其变换矩阵表示相对于root的位置。说这么多其实我只是像解释下，为什么要存在Scenen_Root这种额外的骨骼，以及加深理解骨骼定位骨骼动画模型整体的世界坐标的作用。 有了骨骼类，现在让我们看一下建立骨骼层次的代码，在bone class中增加一个构造函数和两个成员函数： 1234567891011121314151617class Bone&#123;public: Bone(float x, float y, float z): m_pSibling(NULL),m_pFirstChild(NULL),m_pFather(NULL), m_x(x),m_y(y),m_z(z)&#123;&#125; void SetFirstChild(Bone *pChild) &#123; m_pFirstChild = pChild; m_pFirstChild-&gt;m_pFather = this; &#125; void SetSibling(Bone *pSibling) &#123; m_pSibling = pSibling; m_pSibling-&gt;m_pFather = m_pFather; &#125;&#125; 注意我增加了一个成员变量，Bone* m_pFather,这是指向父骨骼的指针，在这个例子中计算骨骼动画时本不需要这个指针，但我为了画一条从父骨骼关节到子骨骼关节的连线，增加了它，因为每个骨骼只有第一子骨骼的指针，绘制父骨骼时从父到子画线就只能画一条，所以记录每个骨骼的父，在胡子hi子骨骼时画这根线。 有了这个函数，就可以创建骨骼层次了，例如：1234567891011121314Bone * g_boneRoot;Bone * g_bone1, *g_bone32, *g_bone22;void buildBones()&#123; g_boneRoot = new Bone(0,0,0); g_bone1 = new Bone(0.1,0,0); g_bone21 = new Bone(0,0,0.1,0); g_bone22 = new Bone(0.1, 0.0,0); g_boneRoot-&gt;SetFirstChild(g_bone1); gbone1-&gt;SetFirstChild(g_bone21); g_bone21-&gt;SetSibling(g_bone22);&#125; 接下来是骨骼层次中最核心的部分，更新骨骼！由于动画的作用，某个骨骼的变化(TransformMatrix)变了，这时就要根据新的变化来计算，所以这个过程一般乘坐UpdateBoneMatrix。因为骨骼的变化都是相对父的，要变换顶点必须使用世界变换矩阵，所以这个过程根据更新了某些骨骼的骨骼变换矩阵(TransformMatrix)计算出所有骨骼的世界变换矩阵(CombinedMatrix)。在本文的例子中，骨骼只能平移，甚至我们没有用矩阵，所以当有骨骼变动时要做的只是直接计算骨骼的世界坐标，因此函数命名为ComputeWorldPos,相当于UpdateBoneMatrix后再用顶点相乘CombinedMatrix。123456789101112131415class Bone&#123; //give father's world pos, compute the bone's world pos void ComputeWorldPos(float fatherWX, float fatherWY, float WZ) &#123; m_wx = fatherWX + m_x; m_wy = fatherWY + m_y; m_wz = fatherWZ + m_z; if (m_pSibling != NULL) m_pSibling-&gt;ComputeWorldPos(fatherWX, fatherWY, fatherWZ); if (m_pFirstChild != NULL) m_pFirstChild-&gt;ComputreWorldPos(m_wx, m_wy, m_wz); &#125;&#125; 其中的递归调用使用了微软例子的思想。 有了上述函数，当某骨骼运动时就可以让其子骨骼跟随运动了，但是怎么让骨骼运动呢？这就是动画问题了，我不打算在这个简单的例子中使用关键帧动画，而只是通过程序每帧改变某些骨骼的位置，DEMO中的animateBones就是做这个的，你可以在里面改变不同的骨骼看看效果。在本文下面会对骨骼的关键帧动画做简单的讨论。 2.蒙皮信息和蒙皮过程2-1 Skin info的定义上文曾讨论过，Skinned Mesh中Mesh时作为皮肤使用，蒙在骨骼之上的。为了让普通的Mesh具有蒙皮的功能，必须添加蒙皮信息，即Skin info。我们知道mesh是由顶点构成的，建模时顶点是定义在模型自身坐标系的，即相对于Mesh原点的，而骨骼动画中决定模型顶点最终世界坐标的是骨骼，所以要让骨骼决定顶点的世界坐标，这就要将顶点和骨骼联系起来，Skin info正是起了这个作用。下面是DEMO中顶点类的定义的代码片段： 1234567891011#define MAX_BONE_PER_VERTEX 4class Vertex&#123; float m_x, m_y, m_z;//local pos in mesh space float m_wX, m_wY, m_wZ; // blended vertex pos, in world space // skin info int m_boneNum; Bone * m_bones[MAX_BONE_PER_VERTEX]; float m_boneWeights[MAX_BONE_PER_VERTEX];&#125; 顶点的Skin info包含影响该顶点的骨骼数目，只想这些骨骼的指针，这些骨骼作用于该顶点的权重(Skin weight)。由于只是一个简单的例子，这儿没有考虑优化，所以用静态数组存放骨骼指针和权重，且实际引擎中Skin info的定义方式不一定是这样的，但基本原理一致。 MAX_BONE_PER_VERTEX在这儿用来设置可同时影响顶点的最大骨骼数，实际上由于这个DEMO是手工进行Vertex Blending并且没有硬件加速，以及为了确保速度，一般会定义最大骨骼数。另外在本Demo中，Skin info是手工设定的，而实际项目中，一般是在建模软件中生成这些信息并导出。 Skin info 的作用是使用各个骨骼的变换矩阵对顶点进行变换并乘以权重，这样某块骨骼只能对该顶点产生部分影响。各骨骼权重之和应该为1. Skin info是针对顶点的，然后在使用Skin info前我们必须要使用Bone Offset Matrix对顶点进行变换，下面具体讨论Bone offset Matrix。（写下这句话的时候我感觉不妥，因为实际是先将所有的矩阵相乘最后在用作顶点，这儿是按照理论上的顺序进行讲述吧，请不要与实际情况混肴，其实他们也并不矛盾。而且在我们的DEMO中由于没有使用矩阵，所以变换的顺序和理论顺序是一致的） 2-2 Bone Offset Matrix的含义和计算方法上文已经说过：“骨骼动画中决定模型顶点最终世界坐标的是骨骼，所以要让骨骼决定顶点的世界坐标”，现在让我们看下顶点受一块骨骼的作用的坐标变换过程： mesh vertex(defined in mesh space)——&gt;Bone space——&gt;world从这个过程中可以看出，需要首先将模型顶点从模型空间变换到某块骨骼自身的骨骼空间，然后才能利用骨骼的世界变换计算顶点的世界坐标。Bone Offset Matrix的作用正是将模型从顶点空间变换到骨骼空间。那么Bone Offset Matrix如何得到呢？下面具体分析： Mesh space是建模时使用的空间，mesh中顶点的位置相对于这个空间的原点定义。比如在3dmax中建模时(视xy平面为地面，+z朝上)，可将模型两脚之间的中点作为Mesh空间的原点，并将其放置在世界原点，这样左脚上某一顶点坐标是(10,10,2),右脚上堆成的一点坐标是(-10,10,2)，头顶的坐标是(0,0,170)。由于此时Mesh空间和世界空间重合，上述坐标即在Mesh空间也是世界空间，换句话说，此时实际是以世界空间作为Mesh空间了。在骨骼动画中，在世界中放置的是骨骼而不是Mesh，所以这个区别并不重要。在3d max中添加骨骼的时候，也是将骨骼放入世界空间中，并调整骨骼的相对位置是得和mesh相吻合（即设置骨骼的TransformMatrix),得到股价的初始姿势以及相应的Transform Matrix(按惯例模型做成两臂侧平举直立，骨骼也要适合这个姿态)。由于骨骼的Transform Matrix(作用是将顶点从骨骼空间变换到上层空间)是基于其父骨骼空间的，只有根骨骼的Transform是基于世界空间的，所以要通过自下而上一层层Tranform变换(如果使用行向量右乘矩阵，这个Transform的累计过程就是C=MboneMfatherMgrandpar..Mroot),得到该骨骼在世界空间上的变换矩阵-Combined Transform Matrix,即通过这个矩阵可将该顶点从骨骼空间变换到世界空间。那么这个矩阵的逆矩阵就可以将世界空间中的顶点变换到某块骨骼的骨骼空间。由于Mesh实际上就是定义在世界空间了，所以这个逆矩阵就是Offset Matrix。即OffsetMatrix就是骨骼在初始位置（没有经过任何动画改变）时将bone变换到世界空间的矩阵(CombinedTransformMatrix)的逆矩阵，有一些资料称之为InverseMatrix。在几何流水线中，是通过变换矩阵将顶点变换到上层空间，最终得到世界坐标，逆矩阵则作相反的事，所以Inverse这种提法也符合惯例。那么Offset这种提法从字面上怎么理解呢？Offset即骨骼相对世界原点的偏移，世界原点加上这个偏移就变成骨骼空间的原点，同样定义在世界空间中的点经过这个偏移矩阵的作用也被变换成骨骼空间了。从另一角度理解，在动画中模型中顶点的位置是根据骨骼位置动态计算的，也就是说顶点跟着骨骼动，但首先必须确定顶点和骨骼之间的相对位置（即顶点在该骨骼坐标系中的位置），一个骨骼可能对应很多顶点，如果要保存这个相对位置每个顶点对于每块受控制的骨骼都要保存，这样就要保存太多的矩阵了。。所以只保存mesh空间到骨骼空间的变换（即OffsetMatrix),然后通过这个变换计算每个顶点在该骨骼空间中的坐标，所以OffsetMatrix也反应了mesh和每块骨骼的相对位置，只是这个位置是间接的通过和世界坐标空间的关系表达的，在初始位置将骨骼按照模型的形状摆好的关键之处。 以上的分析是通过mesh space和world space重合得到Offset Matrix的计算方法。那么如果他们不重合呢？那就要先计算顶点从mesh space变换到world space的变换矩阵，并乘上（还是右乘为例）Combined Matrix的Inverse Matrix从而得到Offset Matrix。但是这不是找麻烦吗，因为Mesh的原点在哪里并不重要，为啥不让他们重合呢？ 还有一个问题是，既然Offset Matrix可以计算出来，为啥还要在骨骼动画文件中同时提供TransformMatrix和OffsetMatrix呢？实际上文件中确实可以不提供OffsetMatrix,而只在载入时计算，但TransformMatrix不可缺少，动画关键帧数据一般只存储骨骼的旋转和跟骨骼的位置，骨骼见的相对位置还是要靠TransformMatrix提供。在微软的X文件结构中提供了OffsetMatrix,原因是什么呢？我不知道。我猜想一个可能的原因是为了兼容性和灵活性，比如mesh并没有定义在世界坐标系，而是作为一个object放置在3d max中，在导出骨骼动画时不能简单的认为mesh的顶点坐标时相对于世界远点的，还要把这个object的位置考虑进去，于是导出插件要计算OffsetMatrix并保存在x文件中以避免兼容性问题。 关于OffsetMatrix和TransformMatrix含有评议，旋转和缩放的讨论： 首先，OffsetMatrix取决于骨骼的初始位置(即TransformMatrix),由于骨骼动画中我们使用的动画中的位置，初始位置时什么样并不重要，所以可以在初始位置中包含平移，而旋转和缩放在动画中设置(一般也仅仅使用旋转，这也是为啥动画通常中可以用一个四元数表示骨骼的关键帧)。在这种情况下，OffsetMatrix只包含平移即可。因此一些引擎的Bone中不存放Transform矩阵，而只存放骨骼在父骨骼空间的坐标，然后旋转只在动画帧中设置，最基本的骨骼动画即可实现。但也可在Transform和Offset Matrix中包括旋转和缩放，这样可以提供创建动画时的容错性。 在本文的DEMO中，我们也没有使用矩阵保存Bone Offset，而只用了一个坐标保存偏移位置。 123456789101112131415161718192021222324class BoneOffset&#123;public: float m_offx, m_offy, m_offz;;//在Bone class中，有一个方法用来计算Bone Offsetclass Bone&#123;public: BoneOffset m_boneOffset; //called after ComputeWorldPos() when bone loaded but not animated void ComputeBoneOffset() &#123; m_boneOffset.m_offx = -m_wx; m_boneOffset.m_offy = -m_wy; m_boneOffset.m_offz = -m_wz; if (m_pSibling != NULL) m_pSibing-&gt;ComputeBoneOffset(); if (m_pFirstChild != NULL) m_pFirstChild-&gt;ComputeBoneOffset(); &#125;&#125;; 在ComputeBoneOffset()中，使用计算好的骨骼的世界坐标来计算bone offset,这儿的计算只是取一个负数，在实际引擎中，如果bone offset是一个矩阵，这儿就应该是求逆矩阵，其实由于旋转矩阵是正交的，只要求出旋转矩阵的转置矩阵。注意由于我们计算Bone offset时是使用计算好的世界坐标，所以在这之前必须在初始位置时对根骨骼调用ComputeWorldPos()以计算出各个骨骼在初始位置时的世界坐标。 2-3 最终：顶点混合(vertex blending)现在我们有了Skin info,有了Bone Offset。现在开始做顶点混合，这是骨骼动画的精髓所在，正是这个技术消除了关节处的裂缝。顶点混合后得到了顶点新的世界坐标，对所有的顶点执行vertex blending后，从Mesh的角度看，Mesh deform(变形)了，变成动画需要的形状了。 首先，让我们看看使用单块骨骼对顶点进行作用的过程以下是DEMO中的相关代码：12345678910111213141516class Vertex&#123;public: void ComputerWorldPosByBone(Bone *pBone, float &amp;outx, float &amp;outY, float &amp;outZ) &#123; //step1: transform vertex from mesh space to bone space outX = m_x + pBone-&gt;m_boneOffset.m_offx; outY = m_y + pBone-&gt;m_boneOffset.m_offy; outZ = m_z + pBone-&gt;m_boneOffset.m_offz; //step2: transform vertex bone space to world space outX += pBone-&gt;m_wx; outY += pBone-&gt;m_wy; outZ += pBone-&gt;m_wz; &#125;&#125;; 这个函数使用一块骨骼对顶点进行变换，将顶点Mesh坐标系变换到世界坐标系，这儿使用了骨骼的Bone Offset Matrix和Combined Transform Matrix 对于多块骨骼，对每块骨骼执行这个过程并将结果根据权重混合(即vertex blending)就得到顶点最终的世界坐标。进行vertex blending的代码如下：1234567891011121314151617181920212223class Vertex&#123; void BlendVertex() &#123; //do the vertex blending,get the vertex's pos in world space m_wX = 0; m_wY = 0; m_wZ = 0; for (int i = 0; i &lt; m_boneNum; ++i) &#123; float tx, ty, tz; ComputeWorldPosByBone(m_bones[i], tx, ty, tz); tx *= m_boneWeights[i]; ty *= m_boneWeights[i]; tz *= m_boneWeights[i]; m_wX += tx; m_wY += ty; m_wZ += tz; &#125; &#125;&#125; 这些函数我都放在Vertex类中了，因为只是一个简单DEMO所以没有特别考虑类结构问题，在BlendVertex()中，遍历影响该顶点的所有骨骼，用每块骨骼计算出顶点的世界坐标，然后使用Skin Weight对这些坐标进行加权平均。tx,ty,tz是某块骨骼作用后顶点的世界坐标乘以权重后的值，这些值相加后就是最终的世界坐标了。 现在让我们用一个工时回顾以下Vertex blending的整个过程(使用矩阵变换) 1234Vworld = Vmesh * BoneOffsetMatrix1 * CombindMatrix1 * Weight1+ Vmesh* BoneOffsetMatrix2 * CombineMatrix2*Wright2+ ...+ Vmesh * BoneOffsetMatrixn * CombindMatrixN * WeightN 4 总结从结构上看，SkinnedMesh包括：动画数据，骨骼数据，包括Skin info的Mesh数据，以及Bone Offset Matrix。 从过程上看，载入阶段：载入并建立骨骼层次结构，计算或载入Bone Offset Matrix,载入Mesh数据和Skin info(具体的实现不同的引擎可能都不一样)。运行阶段：根据时间从动画数据中获取骨骼当前时刻的Transfrom Matrix，调用UpdateBoneMatrix计算出各骨骼的CombineMatrix,对于每个顶点根据Skin info进行Vertex Blending计算出顶点的世界坐标，最终进行模型的渲染。 三、关于本文的例子这个例子做了尽可能的简化，只包含一个cpp文件，使用OpenGL和GLUT作为渲染器和框架，仅有400多行代码。例子中手工创建了一个骨骼层次和Mesh，手工设置Skin info并自动计算BoneOffset,使用程序控制骨骼平移演示了骨骼层次的运动和骨骼影响下Mesh顶点的运动，例子中甚至没有使用矩阵。本例子仅作理解骨骼动画只用。截图中绿色网格是模型原始形状，蓝色是骨骼，红色是动画时模型形状，DEMO中左数第二个骨骼做上下运动，最下方的骨骼做x方向平移。DEMO没有使用旋转，而实际的骨骼动画中往往没有平移只有旋转的，因为胳膊只能转不能边长，但原理一致。(这个公式使用的是行向量左乘矩阵)由于BoneOffsetMatrix和Combined Matrix都是矩阵，可以先相乘这样就减少了很多计算了，在实际游戏中可以VS进行硬件加速计算。代码的执行过程为，初始化时：12345678910111213141516171819202122buildBones();//创建骨骼层次buildMesh();//创建mesh,设置skin info，计算bone offset ``` 每帧运行时：```C++//draw original meshg_mesh-&gt;DrawStaticMesh(0,0,0);//move bonesanimateBones();//update all bone's pos in bone treeg_boneRoot-&gt;ComputeWorldPos(0,0,0);//update vertex pos by bones,using vertex blendingg_mesh-&gt;UpdateVertices();//draw deformed meshg_mesh-&gt;Draw();//draw boneg_boneRoot-&gt;Draw(); 为保证文本的完整性，下面贴出所有代码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382// A simplest Skinned Mesh demo#include &lt;GL/glut.h&gt;#define NULL 0class BoneOffset&#123;public : //BoneOffset transform a vertex from mesh space to bone space. //In other words, it is the offset from mesh space to a bone's space. //For each bone, there is a BoneOffest. //If we add the offset to the vertex's pos (in mesh space), we get the vertex's pos in bone space //For example: if a vertex's pos in mesh space is (100,0,0), the bone offset is (-20,0,0), so the vertex's pos in bone space is (80,0,0) //Actually, BoneOffset is the invert transform of that we place a bone in mesh space, that is (-20,0,0) means the bone is at (20,0,0) in mesh space float m_offx , m_offy , m_offz ;&#125;;//----------------------------------------------------------------class Bone&#123;public : Bone () &#123;&#125; Bone ( float x , float y , float z ):m_pSibling (NULL ),m_pFirstChild (NULL ),m_pFather (NULL ),m_x (x ),m_y (y ),m_z (z )&#123;&#125; ~Bone () &#123;&#125; Bone * m_pSibling ; Bone * m_pFirstChild ; Bone * m_pFather ; //only for draw bone void SetFirstChild (Bone * pChild ) &#123; m_pFirstChild = pChild ; m_pFirstChild -&gt;m_pFather = this ; &#125; void SetSibling (Bone * pSibling ) &#123; m_pSibling = pSibling ; m_pSibling -&gt;m_pFather = m_pFather ; &#125; float m_x , m_y , m_z ; //pos in its parent's space float m_wx , m_wy , m_wz ; //pos in world space //give father's world pos, compute the bone's world pos void ComputeWorldPos ( float fatherWX , float fatherWY , float fatherWZ ) &#123; m_wx = fatherWX +m_x ; m_wy = fatherWY +m_y ; m_wz = fatherWZ +m_z ; if (m_pSibling !=NULL ) m_pSibling -&gt;ComputeWorldPos (fatherWX , fatherWY , fatherWZ ); if (m_pFirstChild !=NULL ) m_pFirstChild -&gt;ComputeWorldPos (m_wx , m_wy , m_wz ); &#125; BoneOffset m_boneOffset ; //called after compute world pos when bone loaded but not animated void ComputeBoneOffset () &#123; m_boneOffset .m_offx = -m_wx ; m_boneOffset .m_offy = -m_wy ; m_boneOffset .m_offz = -m_wz ; if (m_pSibling !=NULL ) m_pSibling -&gt;ComputeBoneOffset (); if (m_pFirstChild !=NULL ) m_pFirstChild -&gt;ComputeBoneOffset (); &#125; void Draw () &#123; glColor3f (0,0,1.0); glPointSize (4); glBegin (GL_POINTS ); glVertex3f (m_wx ,m_wy ,m_wz ); glEnd (); if (m_pFather !=NULL ) &#123; glBegin (GL_LINES ); glVertex3f (m_pFather -&gt;m_wx ,m_pFather -&gt;m_wy ,m_pFather -&gt;m_wz ); glVertex3f (m_wx ,m_wy ,m_wz ); glEnd (); &#125; if (m_pSibling !=NULL ) m_pSibling -&gt;Draw (); if (m_pFirstChild !=NULL ) m_pFirstChild -&gt;Draw (); &#125;&#125;;//--------------------------------------------------------------#define MAX_BONE_PER_VERTEX 4class Vertex&#123;public : Vertex ():m_boneNum (0) &#123; &#125; void ComputeWorldPosByBone (Bone * pBone , float &amp; outX , float &amp; outY , float &amp; outZ ) &#123; //step1: transform vertex from mesh space to bone space outX = m_x +pBone -&gt;m_boneOffset .m_offx ; outY = m_y +pBone -&gt;m_boneOffset .m_offy ; outZ = m_z +pBone -&gt;m_boneOffset .m_offz ; //step2: transform vertex from bone space to world sapce outX += pBone -&gt;m_wx ; outY += pBone -&gt;m_wy ; outZ += pBone -&gt;m_wz ; &#125; void BlendVertex () &#123; //do the vertex blending,get the vertex's pos in world space m_wX = 0; m_wY = 0; m_wZ = 0; for ( int i =0; i &lt;m_boneNum ; ++i ) &#123; float tx , ty , tz ; ComputeWorldPosByBone (m_bones [i ], tx , ty , tz ); tx *= m_boneWeights [i ]; ty *= m_boneWeights [i ]; tz *= m_boneWeights [i ]; m_wX += tx ; m_wY += ty ; m_wZ += tz ; &#125; &#125; float m_x , m_y , m_z ; //local pos in mesh space float m_wX , m_wY , m_wZ ; //blended vertex pos, in world space //skin info int m_boneNum ; Bone * m_bones [MAX_BONE_PER_VERTEX ]; float m_boneWeights [MAX_BONE_PER_VERTEX ]; void SetBoneAndWeight ( int index , Bone * pBone , float weight ) &#123; m_bones [index ] = pBone ; m_boneWeights [index ] = weight ; &#125; &#125;; //----------------------------------------------------------- class SkinMesh &#123; public : SkinMesh ():m_vertexNum (0) &#123; &#125; SkinMesh ( int vertexNum ):m_vertexNum (vertexNum ) &#123; m_vertexs = new Vertex [vertexNum ]; &#125; ~SkinMesh () &#123; if (m_vertexNum &gt;0) delete [] m_vertexs ; &#125; void UpdateVertices () &#123; for ( int i =0; i &lt;m_vertexNum ; ++i ) &#123; m_vertexs [i ].BlendVertex (); &#125; &#125; void DrawStaticMesh ( float x , float y , float z ) &#123; glColor3f (0,1.0,0); glPointSize (4); glBegin (GL_POINTS ); for ( int i =0; i &lt;m_vertexNum ; ++i ) glVertex3f (m_vertexs [i ].m_x +x ,m_vertexs [i ].m_y +y ,m_vertexs [i ].m_z +z ); glEnd (); glBegin (GL_LINE_LOOP ); for ( int i =0; i &lt;m_vertexNum ; ++i ) glVertex3f (m_vertexs [i ].m_x +x ,m_vertexs [i ].m_y +y ,m_vertexs [i ].m_z +z ); glEnd (); &#125; void Draw () &#123; glColor3f (1.0,0, 0); glPointSize (4); glBegin (GL_POINTS ); for ( int i =0; i &lt;m_vertexNum ; ++i ) glVertex3f (m_vertexs [i ].m_wX ,m_vertexs [i ].m_wY ,m_vertexs [i ].m_wZ ); glEnd (); glBegin (GL_LINE_LOOP ); for ( int i =0; i &lt;m_vertexNum ; ++i ) glVertex3f (m_vertexs [i ].m_wX ,m_vertexs [i ].m_wY ,m_vertexs [i ].m_wZ ); glEnd (); &#125; int m_vertexNum ; Vertex * m_vertexs ; //array of vertices in mesh &#125;; //-------------------------------------------------------------- Bone * g_boneRoot ; Bone * g_bone1 , *g_bone2 , *g_bone31 , *g_bone32 ; void buildBones () &#123; g_boneRoot = new Bone (0, 0, 0); g_bone1 = new Bone (0.2, 0, 0); g_bone2 = new Bone (0.2, 0, 0); g_bone31 = new Bone (0.2, 0.1, 0); g_bone32 = new Bone (0.2, -0.1, 0); g_boneRoot -&gt;SetFirstChild (g_bone1 ); g_bone1 -&gt;SetFirstChild (g_bone2 ); g_bone2 -&gt;SetFirstChild (g_bone31 ); g_bone31 -&gt;SetSibling (g_bone32 );&#125;void deleteBones ()&#123; delete g_boneRoot ; delete g_bone1 ; delete g_bone2 ; delete g_bone31 ; delete g_bone32 ;&#125;void animateBones ()&#123; static int dir =-1, dir2 =-1; //animate bones manually g_bone1 -&gt;m_y +=0.00001f*dir ; if (g_bone1 -&gt;m_y m_y &gt;0.2) dir *=-1; g_bone32 -&gt;m_x +=0.00001f*dir2 ; if (g_bone32 -&gt;m_x m_x &gt;0.2) dir2 *=-1;&#125;SkinMesh * g_mesh ;void buildMesh ()&#123; float _meshData []= &#123; //x,y,z -0.1,0.05,0, 0.1,0.05,0, 0.3,0.05,0, 0.45,0.06,0, 0.6,0.15,0, 0.65,0.1,0, 0.5,0,0, 0.65,-0.1,0, 0.6,-0.15,0, 0.45,-0.06,0, 0.3,-0.05,0, 0.1,-0.05,0, -0.1,-0.05,0, &#125;; float _skinInfo []= &#123; //bone_num,bone id(0,1,2,31 or 32), bone weight 1~4, 1, 0, -1, -1, -1, 1.0, 0.0, 0.0, 0.0, 2, 0, 1, -1, -1, 0.5, 0.5, 0.0, 0.0, 2, 1, 2, -1, -1, 0.5, 0.5, 0.0, 0.0, 2, 2, 31, -1, -1, 0.3, 0.7, 0.0, 0.0, 2, 2, 31, -1, -1, 0.2, 0.8, 0.0, 0.0, 1, 31, -1, -1, -1, 1.0, 0.0, 0.0, 0.0, 2, 31, 32, -1, -1, 0.5, 0.5, 0.0, 0.0, 1, 32, -1, -1, -1, 1.0, 0.0, 0.0, 0.0, 2, 2, 32, -1, -1, 0.2, 0.8, 0.0, 0.0, 2, 2, 32, -1, -1, 0.3, 0.7, 0.0, 0.0, 2, 1, 2, -1, -1, 0.5, 0.5, 0.0, 0.0, 2, 0, 1, -1, -1, 0.5, 0.5, 0.0, 0.0, 1, 0, -1, -1, -1, 1.0, 0.0, 0.0, 0.0, &#125;; int vertexNum = sizeof (_meshData )/( sizeof ( float )*3); g_mesh = new SkinMesh (vertexNum ); for ( int i =0; i m_vertexs [i ].m_x = _meshData [i *3]; g_mesh -&gt;m_vertexs [i ].m_y = _meshData [i *3+1]; g_mesh -&gt;m_vertexs [i ].m_z = _meshData [i *3+2]; &#125; //set skin info for ( int i =0; i m_vertexs [i ].m_boneNum = _skinInfo [i *9]; for ( int j =0; j &lt;g_mesh -&gt;m_vertexs [i ].m_boneNum ; ++j ) &#123; Bone * pBone = g_boneRoot ; if (_skinInfo [i *9+1+j ]==1) pBone = g_bone1 ; else if (_skinInfo [i *9+1+j ]==2) pBone = g_bone2 ; else if (_skinInfo [i *9+1+j ]==31) pBone = g_bone31 ; else if (_skinInfo [i *9+1+j ]==32) pBone = g_bone32 ; g_mesh -&gt;m_vertexs [i ].SetBoneAndWeight (j , pBone , _skinInfo [i *9+5+j ]); &#125; &#125; //compute bone offset g_boneRoot -&gt;ComputeWorldPos (0, 0, 0); g_boneRoot -&gt;ComputeBoneOffset ();&#125;void deleteMesh ()&#123; delete g_mesh ;&#125;void myInit ()&#123; buildBones (); buildMesh ();&#125;void myQuit ()&#123; deleteBones (); deleteMesh ();&#125;void myReshape ( int width , int height )&#123; GLfloat h = (GLfloat ) height / (GLfloat ) width ; glViewport (0, 0, (GLint ) width , (GLint ) height ); glMatrixMode (GL_PROJECTION ); glLoadIdentity ();// glFrustum(-1.0, 1.0, -h, h, 5.0, 60.0); glFrustum (-1.0, 1.0, -h , h , 1.0, 100.0); glMatrixMode (GL_MODELVIEW ); glLoadIdentity (); glTranslatef (0.0, 0.0, -1.0);&#125;void myDisplay ( void )&#123; glClear (GL_COLOR_BUFFER_BIT ); //draw original mesh g_mesh -&gt;DrawStaticMesh (0,0,0); //move bones animateBones (); //update all bone's pos in bone tree g_boneRoot -&gt;ComputeWorldPos (0, 0, 0); //update vertex pos by bones, using vertex blending g_mesh -&gt;UpdateVertices (); //draw deformed mesh g_mesh -&gt;Draw (); //draw bone g_boneRoot -&gt;Draw (); glFlush (); glutSwapBuffers ();&#125;void myIdle ( void )&#123; myDisplay ();&#125;int main ( int argc , char *argv [])&#123; glutInit (&amp;argc , argv ); glutInitDisplayMode (GLUT_RGB | GLUT_DEPTH | GLUT_DOUBLE ); glutInitWindowPosition (100, 100); glutInitWindowSize (640, 480); glutCreateWindow ( "A simplest skinned mesh DEMO, by happyfirecn@yahoo.com.cn" ); glutDisplayFunc (myDisplay ); glutReshapeFunc (myReshape ); glutIdleFunc (myIdle ); myInit (); glutMainLoop (); myQuit (); return 0;&#125; //]]></content>
  </entry>
  <entry>
    <title><![CDATA[Actor模型原理]]></title>
    <url>%2F2018%2F03%2F23%2Factor%2F</url>
    <content type="text"><![CDATA[1.Actor模型在使用Java进行并发编程时需要特别的关注锁和内存原子性等一系列线程问题，而Actor模型内部的状态由它自己维护即它内部数据只能由它自己修改（通过消息传递来进行状态修改），所以使用Actors模型进行并发编程可以很好避免这些问题，Actor由状态(state),行为(Behavior)和邮箱(mailBox)三部分组成1.状态(state):Actor中的状态指的是Actor对象的变量信息，状态由Actor自己管理，避免了并发环境下的锁和内存原子性等问题2.行为(Behavior):行为指的是Actor中计算逻辑，通过Actor接收到消息来改变Actor的状态3.邮箱(mailBox):邮箱是Actor和Actor之间的通信桥梁，邮箱内部通过FIFO消息队列来存储发送发Actor消息，接收方Actor从邮箱队列中获取消息 Actor的基础就是消息传递 2.使用Actor模型的好处1.事件驱动—Actor之间的通信是异步的，即使Actor在发送消息后也无需阻塞或者等待就能够处理其他事件2.强隔离性—Actor中的方法不能由外部部署直接调用，所有的一切都通过消息传递进行的，从而避免了Actor之间的数据共享，想要观察到另一个Actor的状态变化只能通过消息传递进行询问3.位置透明—无论Actor地址实在本地还是在远程机上对于代码来说都是一样的4.轻量性—Actor是非常轻量的计算单机，单个Actor仅占400多字节，只需少量内存就能达到高并发 3.Actor模型原理以下通过学生于教师之间的邮件通信来理解akka中的Actor模型 学生-教师的消息传递首先只考虑学生单向发送消息给教师（学生—》教师），如下图：图解：1.学生创建一个ActorSystem2.通过ActorSystem创建ActorRef，将QuoteRequest消息发送到ActorRef(教师代理)3.ActorRef(教师代理)消息传到Dispatcher中4.Dispather依次的将消息发送到TeacherActor邮箱中5.Dispather将邮箱推送到一条线程中6.邮箱取出一条消息并委派给TeacherActor的Receiver方法]]></content>
  </entry>
  <entry>
    <title><![CDATA[简单介绍多进程和多线程服务器]]></title>
    <url>%2F2018%2F03%2F22%2Fthread-process%2F</url>
    <content type="text"><![CDATA[首先贴下多进程单线程和单进程多线程的特点：多进程：有独立的地址空间，进程之间不共享内存和变量，但可以通过共享内存实现，每个进程只有一个线程，一般用于单机系统开发。多线程：在同一个进程下所有线程可以共享内存和变量。而共同点是，同开辟的进程数/线程数多余系统cpu核数时，无法继续提供应用的性能。而多线程架构的服务器，只要适当将一些任务分出来用新的进程启动，就可以扩展成分布式架构，使用tcp通信即可。当然多进程也可以这么干，通信方式也是使用tcp。而操作系统对于线程的切换是比进程的切换要快。 下面先介绍下多进程单线程服务器架构，以单机系统为例：下贴架构图：一个游戏服大概就有这几个进程。router:作用如其名，路由。每个功能进程启动时，会先连接router,router会给连上来的进程分配一个唯一标识，所有功能进程都是靠这个router进程通信。login:登录服务器，client登录验证在这个进程进行。login:玩家单人逻辑操作处理进程，login会将登录的玩家平台到这些logic上。global_login:全局操作进程，多人玩法的功能，例如战斗匹配，工会等操作会放在这里进行。log:游戏日志输出进程，所有功能进程的日志输出都发到这个进程，log进程会输出到磁盘文件。db:redis作为内存数据库，Mysql作为数据持久化，其它功能进程取数据都会发送请求到db。back:后台进程，集成了一个http服务器。处理http请求，这里可以集成一些第三方服务功能，如gm指令。 以上每个进程都是单线程，所以无需考虑锁的问题。对于每个进程收发数据： 发数据：直接把{target_id:data}发送到router 收数据：帧驱动，如100ms主动向router询问是否有数据，有则取过来处理。单机系统下，如果采用共享内存方式，通信效率将非常高。所以多进程的服务器架构设计起来还是比较简单的。 在介绍下多线程服务器架构，这里我想介绍actor模型。一个Actor指的是一个最基本的计算单元。它能接收一个消息并且基于其执行计算。这个理念很像面向对象语言，一个对象接受一条消息（方法调用），然后根据接受的消息做事（调用了哪个方法）。Actors一大重要特征在于actors之间相互隔离，它们并不互相共享内存。这点区别于上述的对象。也就是说，一个actor能维持一个私有的状态，并且这个状态不可能被另一个actor所改变。每个Actor都有一个邮箱，用于接受其他actor发送的消息。 这里重点讲一下Actor模型的调度是怎样做的。Actor模型实际上可以有成千上万个，但目前一台通用服务器最多只有24核，当然不可能也开成千上万个线程。 我们可以把Actor简单想象成这样一个类实例： 1234567891011class Actor&#123; public: void process_1(); void process_2(); void fetch_msg(); private: int actor_id; string actor_name; list&lt;msg&gt; msg_queue;&#125; 每个Actor定义了自己实现的功能(process_1,process_2)当msg_queue邮箱有消息到来的时候，就调用fetch_msg取获取这些消息进程处理。这一步就靠调度线程来做了。 Actor模型的调度实现起码要有： 1.一个位于主线程的Actor队列，如global_queue gq,当某个Actor收到消息时，就会被放进这个gp，等待工作线程进行调度。 2.n个工作线程，这个就要根据机器的核数来决定开多少个了，例如只是一台双核的机器，那么开一个就好了，开多了会浪费时间在线程切换上，得不尝试。每个工作线程做的事件很简单，向主线程询问任务，获取任务，处理任务，然后又继续询问，大致如下：12345while(true)&#123; task_list = fetch_task(); process_task(task_list);&#125; 所以一个Actor的创建和调度过程如下：1.在主线程创建并放入管理列表2.其他actor往本actor发送消息，消息进入msg_queue,本actor进入global_queue等待调度。3.有工作线程处理完一堆任务了，向主线程询问任务，主线程把本actor分配给这个工作线程。4.该工作线程取出msg，调用actor相应处理函数处理这个消息。 所以可见，actor数目于工作线程数目没有必然的关系，当然理想状态是，每个actor都有自己的处理线程，这里有消息来到时，就可以马上处理，不用等待。 理论上，actor开的越多，业务逻辑就分的越细，每次处理的时间就越短，只要actor的数目超过线程数，就可以最大限度利用多核的优势，cpu的调度就越充分。所以actor模型设计关键在于如何将业务逻辑平摊到更多的actor上，而不是集中，例如上面提到global_logic是多人玩法的业务逻辑，只要一细分，可以分成帮会actor,组队actor,战斗actor等等，这样三个消息同时就有机会被三个cpu处理，而不是固定只有一个。 Actor可以理解成用户级别的进程，于操作系统级别的进程分离，即使开很多Actor，只要工作线程数目设计合理（&lt;=系统cpu核数),就能保证线程能一直在同一个cpu上进行操作，减少线程切换的消耗，这对于cpu核数小的机器非常游泳，而对于像24核的机器，因为开辟的线程数是配置的，所以也很好规划一台机器能部署多少个服。而多线程如果要对某些功能进程扩展，如增加login,增加Logic,就是要增加一个系统线程，一旦进程超过cpu核，就会有时间浪费在切换线程上了，这是一个缺点。而Actor模型本身是优秀的，但是Actor的调度算法会有很多中实现，而且必然涉及到锁的涉及，这就需要设计者的设计功力了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[JVM的新生代、老年代、MinorGC、MajorGC]]></title>
    <url>%2F2018%2F03%2F21%2FJVM-heap%2F</url>
    <content type="text"><![CDATA[JVM中的堆，一般分为三大部分：新生代、老年代、永久代：一、新生代主要时用来存放新生的对象。一般占据堆的1/3空间。由于频繁创建对象，所以新生代会频繁发MinorGC进行垃圾回收。新生代又分为Eden区、ServivorFrom、ServivorTo三个区。]]></content>
      <tags>
        <tag>-Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM初探：内存分配、GC原理与垃圾收集器]]></title>
    <url>%2F2018%2F03%2F21%2FJVM%2F</url>
    <content type="text"><![CDATA[JVM内存的分配与回收大致可分为如下4个步骤：何时分配-》怎样分配-》何时回收-》怎样回收，除了在概念上可简单认为new时分配外，我们着重介绍后面三个步骤 1.怎样分配-》JVM内存分配策略对象内存主要分配在Eden区，如果启用了本地线程分配缓存，则有限在TLAB上分配，少数情况能会直接分配在老年代，或被拆分成标量类型在栈上分配（JIT优化）。分配的规则并不是百分百固定，细节主要取决于垃圾收集器组合，以及VM内存相关的参数。]]></content>
  </entry>
  <entry>
    <title><![CDATA[String-StringBuffer-StringBuilder]]></title>
    <url>%2F2018%2F03%2F21%2FString-StringBuffer-StringBuilder%2F</url>
    <content type="text"><![CDATA[JAVAString 字符串常量StringBuffer 字符串变量（线程安全）StringBuilder 字符串变量（非线程安全）String类型和StringBuffer类型的主要性能区别其实在于String是不可变的对象，因此每次对String类型进行改变的时候其实都等同于生成了一个新的String对象，然后将指针指向新的String对象，所以经常改变内容的字符串最好不要用String，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后，JVM的GC就会开始工作， CString和JAVA中的一样]]></content>
  </entry>
  <entry>
    <title><![CDATA[Unity手游开发-使用Lua来开发大型游戏（下）]]></title>
    <url>%2F2018%2F03%2F19%2FUnity-Lua-2%2F</url>
    <content type="text"><![CDATA[基本原理Hotfix的基本原理依然是基于动态语言的Reload功能，更加准确的说是Function Reload。下图简单描述了整个Hotfix的流程：更加具体地可以描述为：1.程序发现要修复的bug，编写特殊的Hotfix代码进行修复，测试通过后上传svn服务器；2.通过发布指令，将svn上更新后的Hotfix代码同步到服务器上；3.服务器发现Hotfix代码有更新，则将其压缩序列化后通过socket发送给所有在线的客户端，同时带上字符串的MD5值供客户端验证；4.客户端收到Hotfix消息之后，首先反序列化数据得到代码内容，校验MD5值之后，如果和本地已经执行过的Hotfix的MD5值，则执行替换逻辑，并记录当前已经执行过的Hotfix的MD5值，如果相同则不再执行；5.客户端连接服务器的时候会主动请求一次Hotfix。 实现方式(项目通过打一个更新包来实现，如果是表格的话可以走Hotfix)执行Hotfix执行的代码非常简单，基于loadstring函数即可：1234local f = loadstring(GameContent.HotfixData)if f then ClientUtils.trycall(f)end 这里的实现就没有reload那么复杂，但是也是有一定的限制，比如local的函数或者在闭包的函数依然很难做正确的hotfix,需要编写特殊的Hotfix代码。 向lua中注册c函数的过程是通过lua_pushcclosure(luaState, fn, n)函数实现的]]></content>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown]]></title>
    <url>%2F2018%2F03%2F19%2Fmarkdown%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Unity-Lua]]></title>
    <url>%2F2018%2F03%2F19%2FUnity-Lua-1%2F</url>
    <content type="text"><![CDATA[逻辑使用脚本来做的好处： 使用脚本语言的动态特性，客户端可以做Hotfix,服务器可以做Refresh，无论在运营还是开发期这一特性都很有用； 脚本语言在虚拟机运行，有效控制崩溃率 上手难度低缺点是运行效率低，但是之前看的LuaJit的效率只是略低于c（有待验证),动态语言容易出一些运行时错误（一般是语法错误），但是调试难度在真机下相对容易一些lua的集成在目前维护的这个项目集成了uLua(感觉算是toLua的前身吧)和sLua(腾讯的SDK集成的).具体性能对比自己就不测试了，（懒）在这里可以看到http://link.zhihu.com/?target=http%3A//qiankanglai.me/2016/07/31/unity-lua/性能差异的可能原因之一个人感觉ToLua在属性操作方面性能较好，而Vectore的向量操作，因为可能会有Lua层的优化，即在Lua层完全实现了对应的操作（vector.bytes),因此需要针对源码进行详细的对比。至于性能差异的原因，我没有从Lua虚拟机的实现部分分析，只是查看两种生成的Warp后的接口进行一个简单的猜想。选取同一个接口进行对比，UnityEngine.Animator的GetFloat接口，ToLua的实现如下：1234567891011121314151617181920212223242526[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]static int GetFloat(IntPtr L)&#123; try &#123; int count = LuaDLL.lua_gettop(L); if (count == 2 &amp;&amp; TypeChecker.CheckTypes(L, 1, typeof(UnityEngine.Animator), typeof(int))) &#123; UnityEngine.Animator obj = (UnityEngine.Animator)ToLua.ToObject(L, 1); int arg0 = (int)LuaDLL.lua_tonumber(L, 2); float o = obj.GetFloat(arg0); LuaDLL.lua_pushnumber(L, 0); return 1; &#125; //此处省略另一个重载接口 else &#123; return LuaDLL.luaL_throw(L, "invalid arguments to method: UnityEngine.Animator.GetFloat"); &#125; &#125; catch(Exception e) &#123; return LuaDLL.toluaL_exception(L, e); &#125;&#125; SLua生成的代码如下：12345678910111213141516171819202122[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]static public int GetFloat(IntPtr l)&#123; try &#123; int argc = LuaDLL.lua_gettop(l); if(matchType(l, argc, 2, typeof(int))) &#123; UnityEngine.Animator self = (UnityEngine.Animator)checkSelf(l); System.Int32 a1; checkType(l, 2, out a1); var ret = self.GetFloat(a1); pushValue(1, true); pushValue(1, ret); return 2; &#125; catch(Exception e) &#123; return error(1,e); &#125; &#125;&#125; 我们注意到，这一函数只需要一个返回值的，但是SLua往栈里pushValue了两个值，然后返回2。SLua使用一个单独的值来表示函数运行的结果，这对于错误可以进行更好的处理，但是多出的压栈和出栈操作有额外的性能消耗。 导出方式对比ToLua导出的使用的是白名单的方式，在CustomeSetting.cs文件中定义的接口才会导出，也提供了导出引擎所有的接口功能；而SLua是以黑名单的方式进行，默认提供的功能是导出了除了黑名单中的所有模块接口，也是了一个导出最简接口的方式。从使用角度来看，SLua黑名单的方式在开发期比较方便，默认会导出所有接口，因此不需要每次想要增加一个已经存在的类Lua接口都要自己定义然后重新导出，发布的时候也可以使用最简接口。维护起来ToLua因为所有的导出类都是我们自己定义的，因此更加清晰明确。鉴于这部分内容有源码可以进行修改 ，因此不是一个核心需要考虑的内容，两种方式各有利弊。 如何使用Lua语言在进行了初步集成后，怎样让开发人员可以更好地使用Lua语言是接下来面临的问题。ToLua对应有一套之前uLua作者开发的LuaFramework，这一框架集成了脚本打包和二进制脚本读取，UI制作流程等多个功能，但是也如作者自己所有，这一框架最初源自一个示例形式的Demo，因此其中代码有很多部分是和示例写死的绑定的逻辑，比如启动逻辑，Lua二进制脚本的加载需要手动指定等等。相对应的，SLua也有多套已经开源的框架，其中最为完善的KSFramwork，这套框架集成了资源打包，导表，Lua热重载在内的多个功能，而且代码质量初步开起来还不错，因此最后我们决定把KSFramwork中的SLua部分替换成ToLua的部分来结合使用。改造的过程还比较简单，由于该部分使用Lua耦合的只有两块内容，一是UIControler部分，二是LuaBehavior部分，所有的接口都由LuaModule模块提供。因此改造的过程也就比较明确了：1.删除源代码中的SLua部分，接入ToLua的部分；2.使用ToLua重写LuaModule的实现；3.改造LuaUIController，使用新的LuaModule接口实现之前的功能；4.改造LuaBehavior模块；代码删除和LuaModule模块的重新实现都比较简单，着重介绍一下LuaUIController和LuaBehavior模块的改造。 改造初衷之前的KSFramwork还是一个核心逻辑在C#，Lua只承载UI等逻辑的模块，其实目前逻辑也是这样的，但是个人比较同意“轻引擎，重脚本”，引擎可以看作渲染，资源加载，音效等功能的提供者，脚本逻辑负责使用这些功能构建游戏内容。那这样大部分与逻辑相关的控制权就应该从引擎交给脚本来进行。Unity作为一个比较特殊的例子，虽然对于它来说，C#部分已经是脚本了，但是对于希望着重使用Lua脚本的我们来说，因为C#不可更新，因此被视作了引擎部分。最为简单的设计就是当引擎初始化完毕之后，通过一个接口调用把后续的逻辑都交由脚本来控制，大部分与游戏玩法相关的模型加载、声音播放、特效播放、动画等由脚本控制。tick逻辑为了减少调用次数，没帧也由引擎调用注册的一个脚本接口进行统一调用，脚本层自己做分发。 LuaUIController的改造LuaUIController原始的方式是在C#层通过ui模块的名称加载对应的一个lua文件，获取一个lua table 进行缓存，在比如OnInit等需要接口调用的地方查找这个table中对应的函数进行调用。这种方式的界面是由C#层的逻辑来驱动加载和显示的，而且在加载过程要有文件的搜索和检查过程。这样会存在一个问题，就是脚本层的逻辑无法或者很难或者很难去控制界面对象的生命周期。针对资源的生命周期，“谁创建谁管理”的策略不在可以很方便地来明确责任的划分，因此要进行改造。改造的方向很简单，讲界面在家和显示的接口开放到Lua层，然后在创建的时候由lua层传递一个table对象进来，C#中进行缓存，当界面资源异步加载完毕，需要进行接口调用的地方的实现与之前保存一致。这样，界面资源的生命周期全部交由脚本层来管理，在脚本构建一个结构合理功能齐全的UIManager来进行一些功能的封装，就可以满足大部分的需求。 LuaBehavior的改造MonoBehavior是Unity为了方便开发而提供的一个很好的功能，脚本以组件的方式挂接在GameObject身上，就可以在Awake,Start,Update等接口中处理想要的逻辑。为了能够继续使用Unity的这一特性，在Lua层也实现了一个简单的LuaBehavior封装。KSFramwork中的思路非常简单，同样根据名称来把一个LuaBehavior和一个Lua脚本进行绑定，在对应的逻辑中调用与之对应的接口就可以了，比如Awake接口的实现如下：12345678protected virtual void Awake()&#123; if (!string.IsNullOrEmpty(LuaPath)) &#123; Init(); CallLuaFunction("Awake"); &#125;//else Null Lua Path, pass Awake!&#125; CallLuaFunction的实现也很明确，从缓存的lua table中获取名称为Awake的function进行调用。这种方式没有问题，但是当场景中挂在了LuaBehavior(项目中是LuaComponent)的GameObject很多的时候，每一帧都会有非常多次的update(这个函数就不要暴露了),这个调用从C#层传递到Lua层，有很多额外的性能消耗。前文也提到了，比较好的方式是没帧只有一个C#到Lua层的Update方法调用，然后脚本层自己做分发。因此，针对这一需求，我们使用ToLua#自带的LuaLooper来实现的这一功能。LuaLooper(项目是自己包装的一个luatimer)是全局只创建一个的MonoBehaviour,注意这里只创建一个只由逻辑来决定的，而不是一个单例模式。这里针对单例模式适合场合的讨论不再展开，此处由逻辑来保证只有一个Looper存在是一件比较合理的事情，预留了一些扩展的可能。LuaLooper以时间的方式讲三种Update分发出去：Update,LateUpdate,FixedUpdate,它在自己对应的函数中调用luaState的对应函数来将事件告知脚本，脚本中需要的模块向分发模块注册回调来监听事件,就可以做到每帧只有一次Update调用了。具体的代码实现可以去看ToLua#中的LuaLooper.cs的类实现。-注意 这里有一个小心的点是当事件在脚本层分发的时候，要注意执行时序问题的影响，最好能够保证任意的执行顺序都可以不影响游戏逻辑的结果，否则可能会出现很难查的诡异bug。对于Awake,Start等一次性调用的函数，由于不是频繁的逻辑，因此保留了原始的实现方式，这样可以让Lua层对应的代码实现更加简洁。而使用事件注册的方式，让不需要update逻辑的脚本没有任何额外的性能消耗。]]></content>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XCAAFS]]></title>
    <url>%2F2018%2F03%2F18%2FXCAAFS%2F</url>
    <content type="text"><![CDATA[负载均衡服务器，应用在登录模块上，开新服的时候入口流量会增大，一段时间以后流量会递减或者趋于平缓，市面上已经有了成熟的解决方案了。一般最常用，最简单的也是基于DNS的负载均衡系统了]]></content>
      <tags>
        <tag>server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http]]></title>
    <url>%2F2018%2F03%2F18%2Fhttp%2F</url>
    <content type="text"><![CDATA[什么是http超文本传输协议（HTTP）的设计目的是保证客户机与服务器之间的通信。HTTP的工作方式客户端和服务器之前的请求-应答协议 两种HTTP请求方法：GET和POST GET - 从指定的资源请求数据 POST - 向指定的资源提交要被处理的数据 GET方法请注意，查询字符串（名称/值对）是在GET请求的URL中发送的： /test/deme_from.asp?name1=value1&amp;name2=value2 有关GET请求的其它一些注释： GET请求可被缓存 GET请求保留在浏览器历史纪录中 GET请求可悲收藏为书签]]></content>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[openresty]]></title>
    <url>%2F2018%2F03%2F18%2Fopenresty%2F</url>
    <content type="text"><![CDATA[/usr/local/openresty/luajit:luajit环境，luajit类似于java的jit,即即时编译，lua是一种解释语言，通过luajit可以即时编译lua代码到机器代码，得到很好的性能。/usr/local/openresty/lualib:要使用的lua库，里边提供了一些默认的lua库，如redis,json库等，也可以把自己开发的或者第三方放在这；/usr/local/openresty/nginx:安装的nginx /usr/local/openresty/nginx/sbin/nginx -V 查看nginx版本和安装的模块 启动 nginxnginx -p `pwd`/ -c conf/nginx.conf 重启nginx/usr/local/openresty/nginx/sbin/nginx -s reload nginx.pid no filenginx -c /home/www/conf/nginx.conf add_header directive is not allowed here in]]></content>
      <tags>
        <tag>openresty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity打包详细流程]]></title>
    <url>%2F2018%2F03%2F13%2FUnity-PGK%2F</url>
    <content type="text"><![CDATA[打包策略：按照目录划分目录进行分类配置文件如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159&#123; "AssetBundleInfo": [ &#123; "assetBundleName": "ui.bytes", "dirPrefix": [ "Art/ResExport/GUI/", "Art/GUI/Atlas/", "res/GUI/res/", "res/GUI/" ] &#125;, &#123; "assetBundleName": "ui_font.bytes", "dirPrefix": [ "res/GUI/res/Font/" ] &#125;, &#123; "assetBundleName": "particles.bytes", "dirPrefix": [ "res/Particles/", "Art/Particles/" ] &#125;, &#123; "assetBundleName": "gfx.bytes", "dirPrefix": [ "res/FX/", "res/SkillWarning/", "res/Shader/", "PluginsScripts/NGUI/Resources/Shaders/", "Art/Graphics/shader/" ] &#125;, &#123; "assetBundleName": "misc.bytes", "dirPrefix": [ "Art/", "res/", "Resources/", "Plugins/", "PluginsScripts/", "Models/" ] &#125;, &#123; "assetBundleName": .bytes", "dirPrefix": [ "Scenes/Assets Skyboxes/" ] &#125;, &#123; "assetBundleName": "scenes.bytes", "dirPrefix": [ "res/Scenes/", "Scenes/" ] &#125; ], "PackageInfo": [ &#123; "pkgName": "cfg", "dirPrefix": [ "cfg/" ] &#125;, &#123; "pkgName": "lang", "dirPrefix": [ "Assets/Art/lang" ] &#125;, &#123; "pkgName": "code", "dirPrefix": [ "cfg/", "mb/", "Lua/" ] &#125;, &#123; "pkgName": "gfx", "dirPrefix": [ "FX/", "MaterialEx/", "Shader/", "SkillWarning/", "Textures/", "Still/", "bones/", "weapons/", "Equips/" ] &#125;, &#123; "pkgName": "gui", "dirPrefix": [ "GUI/" ] &#125;, &#123; "pkgName": "particles", "dirPrefix": [ "Particles/", "Assets/Art/Particles/" ] &#125;, &#123; "pkgName": "scenes", "dirPrefix": [ "Scenes/", "scn/" ] &#125;, &#123; "pkgName": "sounds", "dirPrefix": [ "Sounds/", "Assets/Art/Sounds/" ] &#125;, &#123; "pkgName": "animations", "dirPrefix": [ "Animations/" ] &#125;, &#123; "pkgName": "scenes_mesh", "dirPrefix": [ "Assets/Art/Scene/_Mesh/" ] &#125;, &#123; "pkgName": "scenes_assets", "dirPrefix": [ "Assets/Scenes/" ] &#125;, &#123; "pkgName": "models", "dirPrefix": [ "Assets/Models/" ] &#125;, &#123; "pkgName": "misc", "dirPrefix": [ "Assets/" ] &#125;, &#123; "pkgName": "pandora", "dirPrefix": [ "pandora/" ] &#125; ]&#125; 不使用Resources的原因是，打包程序的时候会将Resources目录下的全部文件都加密压缩达到包内，这样如果我们想使用assetbundle方式打小包就不行了（比如更新包）。1.多语言文件先导入2.根据配置文件生成包信息，AssetBundleInfo,AssetBundleIndex3.处理Res目录资源4.AssetDatabase.GetDependencies12345678910111213141516171819202122232425262728293031323334353637383940414243string nameParam = new string[1];string[] GetDirectDeps(string uri)&#123; DepInfo depInfo = new DepInfo(); nameParam[0] = uri; var deps = AssetDatabase.GetDependenices(nameParem, true);//查找这个资源引用了哪些资源,cs和js文件不用处理 depInfos[uri] = depInfo;//global return deps;&#125;string[] MakeDepends(string uri)&#123; var deps = GetDirectDeps(uri);&#125;static void addPkgFile(string filePath, bool isCompress, string accessPath, byte fileType, byte loadType)&#123; accessPath = accessPath.ToLower(); PkgInfo.FileInfo fileInfo = NewPkgFileInfo(filePath, isCompress, accessPath, )&#125;public IEnumerator ProcessSounds()&#123; titleText = "处理音频"; yield return null; string soundsDir = Application.dataPath + "/Art/Sounds"; if (System.IO.Exists(soundsDir)) &#123; int rootSize = Application.dataPath.Length - 6;//Assets string[] file = System.IO.Directory.GetFiles(soundsDir, "*.bank", SearchOption.AllDirectories); foreach (var file in files) &#123; string path = file.SubString(rootSize).ToLower().Replace('\\', '/'); addPkgFile(path, false, 0, 0); addFileProcessed.Add(path); &#125; &#125;&#125;public IEnumerator DoProcess()&#123; yield return ProcessRes(resUri); if (!isRuning) yield return; yield return ProcessSounds();//smod,因为unity自带的容易崩溃&#125;]]></content>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mono-1]]></title>
    <url>%2F2018%2F03%2F13%2FMono-1%2F</url>
    <content type="text"><![CDATA[Mono主要包含了C#的编译器，CLI(Common Language Infrastructure)实现和一系列相关的开发工具。 源码结构msc: msc: Mono实现的基于Ecma标准的C#编译器。 class:CLI的C#的实现。类似于Android中的Java蹭，应用程序看到的是这一层提供的接口。这一层是平台无关的。 ilasm:反汇编器，将Native code反汇编成bytecode。mono: mini:JIT编译器，将bytecode编译成native code。 metadata:Mono的runtime,CLI的Native级的下实现。 io-layer:与操作系统的接口实现，像socket,thread,mutex这些。liggc:GC实现的一部分。 Mono主要工作框架12345678910111213141516171819202122232425262728293031mini/main.c:main() mono_main_with_options() mono_mian() mini_ini() mono_assembly_open() main_thread_handler()//assembly(也就是bytecode)的编译执行 mini_cleanup()main_thread_handler() mono_jit_exec() mono_assembly_get_image()//得到image信息，如"test.ext" mono_image_get_entry_point()//得到类，方法信息 mono_runtime_run_main(method,argc,argv,NULL) mono_thread_set_main(mono_thread_current());//把当前线程设为主线程 mono_assembly_set_main() mono_runtime_exec_main() //编译及调用目标方法mono_runtime_exec_main() mono_runtime_invoke(method, NULL, pa, exc)//要调用的方法，如"ClassName::Main()" default_mono_runtime_invoke()//实际上是调用了mono_jit_runtime_invoke() info-&gt;compiled_method = mono_jit_compile_method_with_opt(method)//编译目标函数 info-&gt;runtime_invoke = mono_jit_compile_method()//编译目标函数的runtime wrapper mono_jit_compile_method_with_opt(method,default_opt,&amp;ex) runtime_invoke=info-&gt;runtime_invoke runtime_invoke(obj,pararms,exc,info-&gt;compiled_method)//调用wrapper,wrapper会调用目标方法mono_jit_compile_method_with_opt() mono_jit_compile_method_inner() mini_method_compile(method, opt, target_domain, TRUE, FALSE, 0)//通过JIT编译给定方法 mono_runtime_class_init_full()//初始化方法所在对象 method=mono_class_get_cctor()//得到类的构造函数 if(do_initialization)//对象需要初始化 mono_runtime_invoke()//调用相应构造函数来构造对象，如"System.console:.cctor()" mono_jit_runtime_invoke() 垃圾回收垃圾回收(GC)是CLI中很重要的部分， 线程池应用程序或者Mono runtime中的一些异步恩物可以交由单独线程完成。Mono中提供了两个线程池:async_tp和async_io_tp。往线程池加线程函数为threadpool_append_jobs()，当第一次试图往里边加线程时，会进行初始化，起一个”Monitor”线程(该线程执行monotor_thread())。现在假设 Mono内存内存占用： 库代码：Unity库、第三方库 Native堆：资源、Unity逻辑、第三方逻辑 Mono堆：C#代码 Unity游戏逻辑代码所使用的语言为C#，我们知道C#代码所占用的内存又称为mono内存，由于Unity它是通过mono来跨平台解析并运行C#代码的，它在Android系统上面，因此游戏的lib目录下存在的libmono.so文件，就是mono在Android系统上的实现。 C#的代码是通过mono来解析执行的，所需要的内存字然也是由mono来进行分配管理，下面来介绍一个mono的内存管理策略以及内存泄漏分析。 Mono内存管理的基本策略Mono通过垃圾回收机制(GarbageCollect，简称GC)堆内存进行管理。Mono内存分为两部分，已用内存(used)和堆内存(heap)，已用内存它指的是mono实际需要使用的内存，堆内存指的是mono向操作系统申请的内存，两者的差值就是mono的空闲内存。 当mono需要分配内存时，首先是会查看空闲内存是否足够，若足够的话，则是直接在空闲内存中分配，否则mono会进行一次GC以释放更多的内存，如果GC之后仍然没有足够的空闲内存，则mono会向操作系统申请内存，并扩充堆内存。 C/C++ Mono运行时 托管代码(CIL) 将Mono运行时潜入应用，可以分为三个步骤： 编译C++程序和链接]]></content>
      <tags>
        <tag>-Mono</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试经历]]></title>
    <url>%2F2018%2F03%2F13%2Finterview-1%2F</url>
    <content type="text"><![CDATA[程序的优化处理，这个是面试考察的重点，内存的管理也是Unity开发的重中之重。内存管理无非就是对内存的使用，针对UI的内存管理使用的图集方式，Unity自身的图集功能浪费内存，比如2048 * 2048的图集大小，它占的内存是4M，也就是说不管图集是否填满，它都需要在内存中开辟4M的空间，但是如果使用Texture Packer工具就可以节省没有填满的空间，针对大量UI的加载可以采用分类打包图集的方法处理。当然内存池的使用也是可以应用到UI的管理，另外就是3D场景资源的管理，需要场景图片有自己的图库，这样图片可以重复利用，另外模型的面熟，骨骼数量，材质数量都是需要去关注。 内存优化还需要涉及到图片的格式，不带Alpha通道的图片采用jpg格式，带有Alpha通过的采用png格式，这是一种处理方式，另外一种处理方式就是将Alpha通道单独拿出来，所有的图片都是jpg格式，然后用带有Alpha通道的图片跟jpg格式文件进行结合使用。 在结构涉及方面，就要注意了，代码的编写，比如常用的设计模式，工厂模式，单例模式，MVC模式，FSM模式，观察者模式等，这些模式作为开发者必须要掌握的。 八、接下来就是Shader的编写了，可以使用Shader Forge编辑器，对于一些材质渲染非常好用，这个可以作为读者学习Shader的工具。 九、另外对于C#中定义的String，StringBuilder或者List,ArrayList等它们之间的区分要搞清楚。 十、不同机型的适配处理，技术验证等。 十一、热更新技术的实现，市面上应用比较广的ulua作为脚本语言架构设计。 十二、作为客户端开发者也需要了解网络方面的知识，比如tcp,udp,http这些协议的处理方式。 十三、场景、导航、寻路 十四、作为渲染场景的后处理方式，比如Bloom,Blur,HDR,SSAO,PSSM等等。 十五、C#中的事件监听，委托的使用也要熟练掌握。 十六、协程与多线程的区别。 十七、文本文件的加载，比如json,xml,csv,二进制等等。 GC是Mono运行时的机智，而非Unity3D引擎的机制，所以GC也主要是针对Mono对象来说的。 1String s = new String("lyf"); 在运行时涉及了几个String Object两个，一个是字符串字面量”lyf”所对应的，驻留(intern)在一个全局共享的字符串常量池中的实例，i另一个是通过new String(String)创建并初始化的、内容于”lyf”相同的实例 OpenGL中要用到哪几种buffer帧缓冲(Frame Buffer)颜色缓冲(Color Buffer)模版缓冲(Stencil Buffer)顶点缓冲(Vertice Buffer)深度缓冲(Depth Buffer) 冰川网络面试由于很久没有复习，导致笔试面试猜的抠脚，冰川给我整体印象还是不错的，人力小姐姐说是600人的大公司，可惜我进不去了。 笔试题1.啥子是泛型？给你一个CBase基类，写一个继承CBase的泛型。百度答：所谓泛型，即通过参数化类型来实现在同一份代码操作多种数据类型。我答：类的数据成员不固定，成员函数的返回值和传参类型不固定的，这样的方式叫做泛型。本想说这样的类叫做泛型类，但是人家问的是泛型，只能说这样的方式了。 我不知道写一个继承CBase的泛型考点是啥子，然后我就开始瞎写12345public class CDrive:public CBase // 为毛还要加public，难道还有公有继承，保护继承，私有继承？？？&#123; public void Do&lt;T&gt;(T t) // 这他妈写的什么玩意。 &#123;&#125;&#125; 2.Awake,Start,OnEnable的执行顺序简直简单的一逼，Awake-&gt;OnEnable-&gt;Start3.啥子是反射？写一段加载程序集，然后获取类型Type，然后通过方法名调用网上答案：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647using System;using System.Collections;using System.Collections.Generic;using System.Reflection;using UnityEngine;public class InvokeReflection : MonoBehaviour&#123; void Start() &#123; Learn00(); &#125; public void Learn00() &#123; /* * System.Reflection.Assembly类有两个静态方法：Assembly.Load(string assemblyname)和Assembly.LoadFrom(string filename) 。 * 通常用这两个方法把程序集加载到应用程序域中。 如果你希望加载的程序集超出了CLR的预定探查范围，你可以用Assembly.LoadFrom直接从一个文件位置加载程序集。 * Assembly.LoadFrom()和Assembly.LoadFile()，两者的主要区别有两点： * 一：Assembly.LoadFile()只载入指定的dll文件，而不会自动加载相关的dll文件。如果下文例子使用Assembly.LoadFile()加载SayHello.dll，那么程序就只会加载 * SayHello.dll而不会去加载SayHello.dll引用的BaseClass.dll文件。 * 二：Assembly.LoadFrom()载入一个Assembly时，会先检查前面是否已经载入过相同名字的Assembly；Assembly.LoadFile()则不会做类似的检查。 */ //C:\Users\Administrator\Desktop\New Unity Project\Assets\DLL Assembly assemly2 = Assembly.LoadFrom(@"C:\Users\Administrator\Desktop\New Unity Project\Assets\Scripts\TestReflection.dll"); Assembly assemly1 = Assembly.LoadFile(@"C:\Users\Administrator\Desktop\New Unity Project\Assets\Scripts\TestReflection.dll"); Assembly assemly = Assembly.Load("TestReflection");//1填加DLL Type testType = assemly.GetType("HaiLan.TestReflection.TestReflectionDLL");//2获取对应的类信息，需要填加对应的命名空间 object oTestReflectionDLL = Activator.CreateInstance(testType);//3 创建对象 IReflectionDLL iTestReflectionDLL = oTestReflectionDLL as IReflectionDLL;//4 类型转换 iTestReflectionDLL.TestShow1();//5 方法调用 foreach (var item in assemly.GetModules()) &#123; Debug.Log(item.Name);//打印结果 TestReflection.dll &#125; foreach (var type in assemly.GetTypes()) &#123; Debug.Log(type.Name); foreach (var item in type.GetMethods()) &#123; Debug.Log(item.Name); &#125; &#125; &#125;&#125; 4.avatar如何换装？5.啥子是Prefab，如何获取一个Prefab实例化的GameObject的类型？PrefabInstance和PrefabModelInstance有啥子区别（我都不知道他在问啥子）6.获取一个Render的材质，然后设置流光shader的uniform/7.地震了，狗跑了，房屋塌了，人慌了，这是哪个设计模式？写出伪代码或者画出流程图；要求可扩展8.给你一个新项目，内存贼高，FPS贼低，咋优化，是Xlua和C#写的。我答：UI：用Profile抓GC，DrawCall，如果是Lua写的，抓函数逻辑占用的内存大小和GC场景：检查面数，静态合批，角色：脚本：预制体：检查是否有Miss Script，检查是否有太多的无用序列化逻辑减少灯光的数量9.说一哈AssetBundle的打包和加载 面试题显示针对笔试题答得不好的问了几个，我没写设计模式那个，他问了问，还有换装那个我也不会他也问了一下。问：你经过过啥子比较难忘的经历在项目上，或者遇到啥子困难，来扯会蛋。我实在不知道咋扯，就说了剧情编辑器的旋转bug和撤销重做bug。还问了一个咋子判断线段和多边形是否相交？这个我做触发器写的，然鹅给忘了。。正解：判断点（p）是否在多边形中，可以先以点p向左引一条射线（L），我们知道，从射线L左端的无穷远处开始一直到点P的过程中，当遇到多边形的第一个交点是L进入多边形，当遇到第二个交点时，L穿出了多边形。可知，规律如下，当在遇到P点之前L与多边形的交点为偶数个时，说明p点不在多边形内，当在遇到p点之前L与多边形交点为奇数个时，说明P点在多边形内。但是，这个规律并不具有普遍性，还有几种特殊情况不满足此规律，需要额外考虑：（1）当点P在多边形的某条边上，可以直接判断其在多边形中。（2）对于多边形的水平边不做考虑 然后实在不想和我尬聊了吧，就说你对我们这块有想了解点啥。我寻思不用尬聊了，我就说我面试的太菜了，就啥也不问了。再见。]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【《Real-Time Rendering 3rd》 提炼总结】(二) 第二章 · 图形渲染管线 The Graphics Rendering Pipeline]]></title>
    <url>%2F2018%2F03%2F13%2FReal-Time-Rendering-3rd-2%2F</url>
    <content type="text"><![CDATA[一、全文内容思维导图1.章节框架思维导图 2.知识结构思维导图 二、核心内容分节提炼2.1 图像渲染管线架构概述 Architecture渲染管线的主要功能就是决定再给虚拟相机、三维物体、光源、照明模式，以及纹理等诸多条件的情况下，生成或绘制一副二维图像的过程。对于实时渲染来说，渲染管线就是基础。因此，我们可以说，渲染管线是实时渲染的底层工具。]]></content>
      <tags>
        <tag>Real-Time Rendering 3rd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能优化，永无止境---CPU篇]]></title>
    <url>%2F2018%2F03%2F05%2Foptimzation-cpu%2F</url>
    <content type="text"><![CDATA[性能优化是游戏项目开发工程中一个永恒的话题。玩家的需求和项目的要求永远都在不停增长，同屏人数、屏幕特效和场景复杂度永远在向着”榨干“硬件的趋势毕竟。所以，无论硬件设备发展到何种成都，无论研发团队有多么丰富的经验积累，性能优化永远是一个非常棘手而又无法绕开的问题。 就当前游戏而言，性能优化主要是围着CPU、GPU和内存三大方面进行。下面，我们就这三方面说说当前移动游戏项目中存在的普遍问题的相应的解决方案。 CPU方面就目前的Unity移动游戏而言，CPU方面的性能开销主要可归结为两大类：引擎模块性能开销和自身代码性能开销。其中，引擎模块中又可细致划分为渲染模块、动画模块、物理模块、UI模块、粒子系统、加载模块和GC调用等等。正因如此，我们在UWA测评报告中，就这些模块进行详细的性能分析，以方便大家快速定位项目的性能瓶颈，同时，根据我们的分析和建议对问题进行迅速排查和解决。通过大量的性能测评数据，我们发现渲染模块、UI模块和加载模块，往往占据了游戏CPU性能开销的Top3。 一、渲染模块渲染模块可以说是任何游戏中最为消耗CPU性能的引擎模块，因为几乎所有的游戏都离不开场景、物体和特效的渲染。对于渲染模块的优化，主要从以下两个方面入手： （1）降低Draw CallDraw Call是渲染模块优化方面的重中之重，一般来说，Draw Call越高，则渲染模块的CPU开销越大。究其原因，要从底层Driver和GPU的渲染流程讲起，限于篇幅我们不在这里做过的的介绍。https://stackoverflow.com/questions/4853856/why-are-draw-calls-expensive降低Draw Call的方法则主要是减少所渲染物体的材质种类，并通过Draw Call Batching来减少其数量。Unity文档对于Draw Call Batching的原理和注意事项有非常详细的讲解。 但是，需要主要的是，游戏性能并非Draw Call越小越好。这是因为，决定渲染模块性能的除了Draw Call之外，还有用于传输渲染数据的总线带宽。当我们使用Draw Call Batching将同种材质的网格模块拼合在一起，可能会造成同一时间需要传输的数据(Texture、VB/IB等)大大增加，以至于造成带宽”阻塞”，在资源无法及时传输过去的情况下，CPU只能等待，从而反倒降低了游戏的运行帧率。 Draw Call和总线带宽是天平的两端，我们需要做的是尽可能维持天平的平衡，任何一边过高或过低，对性能来说都是无益的。 （2）简化资源简化资源是非常行之有效的优化手段。在大量的移动中，其渲染资源其实是“过量”的，过量的网格资源、不合规的纹理资源等等。所以，我们在UWA测评报告中对资源的使用进行了详细的展示（每帧的三角形片数、网格和纹理资源的具体使用情况等），以帮助大家查找和完善存在问题的资源。 关于渲染模块在CPU方面的优化方法还有很多，比如LOD、Occlusion Culling和Culling Distance等等。我们会在后续的渲染模块技术专题中进行更为详细的讲解，敬请期待。 二、UI模块UI模块同样也是几乎所有的游戏项目中必备的模块。一个性能优异的UI模块可以将用户体验在抬高一个档次。在目前国内的大量项目中，NGUI作为UI解决方案的占比仍然非常高。所以，UWA测评报告对NGUI的性能分析进行了极大的支持，我们会根据用户所使用的UI解决方案（UGUI或NGUI）的不同提供不同的性能分析和优化建议。 在NGUI的优化方面，UIPanel.LateUpdate为性能优化的重中之重，它是NGUI中CPU开销最大的函数，没有之一。UI模块制作的难点并不在于其表现上，因为UI界面的表现力是由设计师来决定的，但两套表现完全一直的UI系统，其底层的性能开销则可能千差万别。如何让UI系统使用尽可能小的CPU开销来达到设计师所设计的表现力，则足以考验每一位UI开发人员的制作功底。对于UIPanel.LateUpdate的优化，主要着眼于UIPanel的布局，其原则如下： 尽可能将动态UI元素和静态UI元素分离到不同的UIPanel中(UI的重建以UIPanel为单位)，从而尽可能将因为变动的UI模块引起的重构控制在较小的范围内； 尽可能让动态UI元素按照同步性进行划分，即运动频率不同的UI元素尽可能分离放在不同的UIPanel中； 控制同一个UIPanel中动态UI元素的数量，数量越多，所创建的Mesh越大，从而使得重构的开销显著增加，比如，战斗过程中的HUD运动血条可能会出现较多，此时，建议研发团队将运动血条分离成不同的UIPanel，每组UIPanel下5~10个动态UI为宜，其本质是从概率上尽可能降低单帧中UIPanel的重建开销。 三、加载模块加载模块同样也是任何游戏项目中所不可缺少的组成成分。与之前两个模块不同的是，加载模块的性能开销比较集中，主要出现于场景切换处，且CPU占用峰值均较高。 场景切换时的主要性能开销比较集中，主要出现于场景切换处，且CPU占用峰值均较高。 1.场景卸载对于Unity引擎而言，场景卸载是由引擎自动完成的，即当我们调用类似Application.LoadLevel的API时，引擎即会开始对上一场景进行处理，其性能开销主要被以下几个部分占据： Destroy 引擎再切换场景时会收集未标识成”DontDestoryOnLoad”的GameObject及其Component，然后进行Destroy。同时，代码中的OnDestroy被触发执行，这里的性能开销主要取决于OnDestroy回调函数中的代码逻辑。]]></content>
      <tags>
        <tag>uwa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第六部分 GPU计算]]></title>
    <url>%2F2018%2F03%2F03%2Fnote6%2F</url>
    <content type="text"><![CDATA[第六部分 GPU计算第三十五章 使用CPU进行病毒特征的快速匹配35.1 介绍35.2 模式匹配35.3 GPU实现35.4 结果35.5 结论和后续工作35.6 参考资料第三十六章 用CPU进行AES加密和解密第三十七章 使用CUDA进行高效的随机数生成及应用第三十八章 使用CUDA进行地球内部成像第三十九章 使用CUDA的并行前缀和（扫描方法）第四十章 高斯函数的增量计算第四十一章 使用几何体着色器处理紧凑和可变长度的GPU反馈]]></content>
      <tags>
        <tag>GPU Gems[3]</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第五部分 物理仿真]]></title>
    <url>%2F2018%2F03%2F03%2Fnote5%2F</url>
    <content type="text"><![CDATA[第五部分 物理仿真第二十九章 CPU上实时刚体仿真第三十章 实时仿真与3D流体渲染第三十一章 使用CUDA进行快速N-body仿真第三十二章 使用CUDA进行快速宽阶段碰撞检测第三十三章 用于碰撞检测的LCP算法的CUDA实现第三十四章 使用单过程的GPU扫描和四面体转换的有向距离场]]></content>
      <tags>
        <tag>GPU Gems[3]</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第四部分 图像效果]]></title>
    <url>%2F2018%2F03%2F03%2Fnote4%2F</url>
    <content type="text"><![CDATA[第四部分 图像效果第二十一章 真正的Impostor第二十二章 在GPU上处理发现贴图第二十三章 高速的离屏粒子第二十四章 保持线性的重要性第二十五章 在CPU上渲染向量图第二十六章 通过颜色进行对象探测：使用CPU 进行实时视频图像处理第二十七章 作为后置处理效果的运动模糊第二十八章 使用景深后期处理]]></content>
      <tags>
        <tag>GPU Gems[3]</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三部分 渲染]]></title>
    <url>%2F2018%2F03%2F03%2Fnote3%2F</url>
    <content type="text"><![CDATA[第三部分 渲染第十四章 用于真实感实时皮肤渲染的高级技术第十五章 可播放的全方位捕捉第十六章 Crysis 中植被的过程化动画和着色第十七章 鲁棒的多镜面反射和折射第十八章 用于浮雕映射的松散式锥形步进第十九章 Tabula Rasa中的延迟着色第二十章 基于GPU的重要性采样]]></content>
      <tags>
        <tag>GPU Gems[3]</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二部分 光照和阴影]]></title>
    <url>%2F2018%2F03%2F03%2Fnote2%2F</url>
    <content type="text"><![CDATA[第二部分 光照和阴影第八章 区域求和的差值阴影贴图8.1 介绍8.2 相关工作8.3 percentage-closer 过滤8.4 插值阴影贴图8.5 区域求和插值阴影贴图8.6 percentage-closer 软阴影8.7 结论8.8 参考资料第九章 使用全局照明实现互动的电影级重光照9.1 介绍9.2 算法总览9.3 聚集样本9.4 一次反射的间接照明9.5 用于压缩的小波9.6 增加多次反射9.7 对稀疏矩阵进行压缩9.8 基于GPU的重光照引擎9.9 结果9.10 结论9.11 参考资料第十章 在可编程的GPU中实现并行分割的阴影贴图第十一章 使用层次化的遮挡剔除和几何体着色器得到高效鲁棒的阴影体第十二章 高质量的环境遮挡第十三章 作为后置处理的体积光照散射]]></content>
      <tags>
        <tag>GPU Gems[3]</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一部分 几何体]]></title>
    <url>%2F2018%2F03%2F03%2FGPU-Gems-3-note%2F</url>
    <content type="text"><![CDATA[第一部分 几何体第一章 使用CPU生成复杂的程序化地形1.1介绍传统上，程序化地形(procedural terrains)受限于CPU生成的并用GPU进行渲染的高度长(height fields)。然而，生成复杂的地形是一项高度并行化的任务，CPU的串行处理本质并不适合完成这项工作。此外，CPU生成高度场的方法也无法提供吸引人的地形特征（如凹洞和凸起物）。 为了在交互级的帧速率下，生成高度复杂的程序化地形，我们转而使用GPU。通过使用DirectX 10的新特性，我们可以快速生成大块的复杂程序化地形。最终，这些块共同创建一个大型的、具有细节的多边形网格，以表示当前视锥观察到的地形。 1.2 Marching Cubes算法和密度函数理论上，地形表面可以用单个函数完整的描述，这个函数被称为密度函数(density function)。对于3D空间的任意一点(x,y,z)，密度函数产生一个单精度浮点值。这些值 1.3 地形生成系统概述1.4 在地形块中生成多边形1.5 纹理和光影1.6 对实际应用的考虑1.7 结论1.8 参考资源第二章 群体动画渲染2.1 目的2.2 实例化的简单回顾2.3 技术细节2.4 其它考虑因素结论参考资料第三章 DirectX 10 混合形状：打破限制3.1 介绍Dawn例子的实现运行例子性能参考资料第四章 下一代SpeedTree 渲染4.1 介绍4.2 轮廓裁减4.3 阴影4.4 树叶光照4.5 高动态范围和反锯齿4.6 半透明覆盖4.7 结论4.8 参考资料第五章 普遍自适应的网格优化5.1 介绍5.2 总览5.3 自适应优化模式5.4 渲染工作流5.5 结果5.6 结论和改进5.7 参考资料第六章 GPU生成的树的过程式风动画6.1 介绍6.2 GPU上的过程式动画6.3 现象学方法6.4 模拟步骤6.5 渲染树6.6 分析和比较6.7 结论6.8 参考资料第七章 GPU上基于点的变形球可视化7.1 变形球、光滑粒子流体力学和表面粒子7.2 限制粒子7.3 局部粒子斥力7.4 全局粒子传播7.5 性能7.6 渲染7.7 结论7.8 参考资料]]></content>
      <tags>
        <tag>GPU Gems[3]</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚幻引擎学习之路：渲染模块之光照系统]]></title>
    <url>%2F2017%2F12%2F10%2FStudy_unreal4_Rendering_1%2F</url>
    <content type="text"><![CDATA[我们准备从三方面来介绍Unreal 4引擎的渲染模块，主要包括：光照系统，材质系统喝图像后处理。本篇文章重点讲解第一部分：光照系统。在对比Unreal 4与Unity两者引擎时，本文分别采用的版本是Unreal 4.18.1和Unity 5.3.8.f1。 本节将介绍Unreal 4引擎的光照系统。在介绍基础功能时，本文将分四块进行介绍，主要包括：光源、全局光照、阴影以及反射效果。同时，本文将与Unity引擎中的这些功能进行对比。另外，对于Unreal 4引擎中的特殊功能，本文将单独介绍。 一、光源光源对于游戏引擎的光照系统来说时最为基础的功能模块。游戏渲染中光照计算的每一部分都离不开光源。通常游戏引擎通过三个重要属性对员光源进行了分类：光源类型、实时性以及渲染管线。对于不同属性的光源，其光照计算方式和复杂程度都有所不同。在接下来的内容中，本文将对Unreal 5和Unity引擎的光源在这三个方面进行比较。 1、光源类型Unreal 4引擎中，可在场景中创建的光源类型有四种：方向光、点光源、聚光灯和天空光。 创建方式跟Unity类似，只需通过在Unreal 4地图编辑器中点击左上角的”Modes”页面，选择”Lights”标签，即可在其子菜单选择需要的光源拖放的场景中，如下图所示：Unreal 4引擎中的天空光其作用是：自动获取远处的入射光信息，然后用于场景中物体的光照计算。远处的入射光信息涵盖了”Sky Distance Threshold”设置的距离以外的所有入射光来源，包括远景=天空盒=云雾等。它的实现方式是先将远处的入射光信息渲染到Cube Map中，然后使用这张Cube Map来计算光照。在Unity中也可以在Lighting设置中采用Sky Box作为环境光的输入，但是Unity没有将其作为单独可放入场景的光源。 2、实时性在Unreal 4的光源属性中，有一项Mobility表示光源的可移动性以及光照计算实时性。它包含了三种类型：Static、Stationary以及Movable。它与Unity中光源类型的Static、Mixed、Realtime具有类似含义，如下图所示：]]></content>
      <tags>
        <tag>Unreal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[世界boss设计]]></title>
    <url>%2F2017%2F11%2F07%2Fword-boss%2F</url>
    <content type="text"><![CDATA[设计目的作为主要的金钱额外发放通道，驱动尽可能多的玩家参与。将世界boss分为大小两个类型，阶梯性的学习，鼓励低级用户参与，降低挫折感在世界boss和潜在的竞争对手的压力下，让玩家开始自发的组织，逐步形成社会关系。由于小boss需要的组织难度较低，玩家很容易形成组织。而大boss普通玩家只需要依托公会，而公会的组织主要来源于高端玩家，普通玩家只需要参与到这种社会关系中，而不需要耗费额外的精力去组织同时，世界boss还是一个玩家印证自我价值（和其他玩家同比）的方式，通过PVE和pvp的比拼来作为成长压力的宣泄。 大概描述世界上散落着很多个伏魔阵的阵眼通过各种方式激活阵眼，并击破阵眼后，玩家就会被传入到封印世界boss的禁阵中多个队伍（公会）攻击boss，当限时结束或者成功击杀后，伤害名列前茅的队伍获得额外奖励每个被传入禁阵中的玩家，每对boss造成一次伤害，都会获得和伤害成正比的金钱数，同时在阵中的这段时间内，都会源源不断的获得经验 基础原则世界boss分为大小两种由于一个场景可能存在n条线并行的原因，而这个n并不确定，世界boss如果再单独刷在大世界的场中，则刷多少个boss完全无法确定，作为一个重要和敏感的发放渠道，这种方式将是完全不可接受的。因此需要更改世界boss的形式。世界boss单独刷在一个特定场景（暂且称之为禁阵）中，该场景除了boss以外几乎没有其他NPC和其他逻辑，因此该场景可以容纳更多的玩家，缓解了服务器的逻辑压力必须由击破阵眼来获得进入boss战场景的资格 详细设计世界boss分为大小两种 低级boss设计基础思路 以小队为单位，强调队伍之间的对抗和博弈过程分为【大世界击破阵眼】【禁阵内击杀boss】两个阶段。在大世界上pvp模式不做更改，由玩家控制。默认为和平，玩家可以通过开红来发动pk在禁阵内，是否pk仍然交给玩家决定，想主动发起pk的一方可以先开启【杀戮】和【公会杀戮模式】——【公会杀戮模式】现在还没实现，需要负责人苏博跟进实现开启禁阵无规定时间，无固定时间开启玩家在世界探索中会获得【低级boss召唤符】，在伏魔阵的阵眼附近使用该道具，可以打开伏魔阵。只要拥有道具【召唤符】，就可以随时（世界大boss活动时间内不允许）开启禁阵召唤符有N种，一一对应N个世界小boss，例如：玄黄坤龙召唤符就只能召唤玄黄坤龙，姥姥召唤符就只能召唤姥姥。每个召唤符只能在唯一对应的场景使用（道具tips上有说明，例如玄黄坤龙召唤符，tips上写着“该召唤符只能在海底的伏魔阵周围使用”）有些场景有伏魔阵，有些场景没有。拥有伏魔阵的场景都对应有5个阵眼，想要召唤的玩家必须走到一个阵眼附近使用道具。召唤者身边一定会生成一个阵眼地图上其他的4个阵眼位置会随机生成2个阵眼阵眼生成的时间为30秒（期间会有阵眼逐渐生成的特效表现）阵眼生成的阶段，会有跑马灯和世界聊天提升—-类似：玩家xxx正在【某个场景】打开伏魔阵阵眼。（方括号的为链接，点击后可以直接传送到该场景）如果该召唤场景存在着多条分线，也只能在使用召唤符的本线打开阵眼，其他的分线无动静阵眼持续2分钟，2分钟内每30秒通知一次全服，2分钟后阵眼消失。阵眼生成和持续时间内，跑马灯和世界聊天通知全服，会有以下的处理点击提示上的链接，会自动寻路走到阵眼所在的场景如果和召唤者不在同一个场景，自动寻路到切场景时，自动进入阵眼所在的场景线（如果多线）在同一个场景不在同一条线的，自动切线到阵眼所在线到达召唤场景后，自动寻路中止，接下来需要玩家手动去寻找打开的阵眼如何进入禁阵每个阵眼被击破，都会传送一队人进入boss场景阵眼击破后，都会在阵眼刷出的位置出现一个传送门，该门存在时间由策划填表调整控制如何挑选进入boss场景的人伤害最高的队伍进入boss场景1.一个阵眼被攻击时候，记录对其造成的伤害，对应的玩家，并进行排名2.每次记录的时候，是以队伍为基础单位进行记录，不记录玩家的个人伤害3.攻击阵眼的过程中，会在客户端出现伤害排行榜A.只有走到阵眼附近20米的范围内且当时正处于开启状态下，该排行榜才会在客户端上显示（为什么是20米，20米是玩家有可能对阵眼造成伤害的最大攻击距离）B.该排行榜出现在任务栏的位置，临时顶替掉任务栏C.该排行榜有且只有3行D.如果自己的队伍排名第一，则在下方显示伤害最接近自己的两个组E.如果不排名第一，则显示伤害排名比自己高一名和低一名的队伍F.该排行榜每1秒动态更新一次G.伤害排行的上仅仅显示名次和造成的伤害数值H.自己队伍在排行榜上所在行会凸起显示，让人直观上一眼就能看出这行是自己队伍的数据每个阵眼仅仅只挑选一个队伍进入1.最大只开启3个阵眼，也就是说最多有3个队可以被传入boss场景2.那些玩家可以进入？A.当阵眼被击破的时候，系统才开始挑人B.此时，先确定伤害最高的队伍C.再确定当前队伍里的玩家，并记录这些玩家D.把这些玩家都传入到boss场景里阵眼存在2分钟，阵眼消失前如果阵眼没有被击破，该阵眼不会传送任何一个玩家进入boss场景特别注意1.当阵眼传送人之前，需要判断玩家是否在阵眼所在的场景，只有玩家处于阵眼所在的场景，才把玩家传送。2.阵眼被击碎后的2分钟内（也就是传送门穿在的2分钟内），每秒都会检测拥有进入资格的玩家是否出现在阵眼附近20米区域，如果出现，则把玩家传送进入boss场景（预防阵眼开启前掉线，预防阵眼开启前切了场景）[后面会引用]3.玩家如果死在附近，也可以被传送，传送后复活 Boss战怎么玩场景1.使用天劫副本场景修改A.该场景由中央的大圆形平台和周围的3个浮空阁楼组成B.大平台和阁楼之间没有导航连接，没法通过走路互通C.需要通过对话，触发飞行寻路飞到中间的战斗区域D.该场景禁止玩家手动的飞行2.出生点和复活点A.出生点和复活点在3个小平台上B.玩家随机出生和复活在3个点上C.怎么从出生点到达战斗场景对话，确定后随机选一条该出生点连接到boss平台的飞行路线进行自动寻路飞行使用tx01-85帧的动画，大世界探索动画策划在技能编辑调整为5秒，300帧需要一个运气聚敛云朵的粒子效果5秒后吟唱结束，脚底驾云飞行路径相关在每个复活点种多条飞行寻路路径，让一堆人一起飞出来的时候不重合，感觉更有仪式感飞行寻路花费5-10秒飞到场景中央飞行寻路过程中不能使用技能，不能驾云，坐骑等所有互动功能（最好客户端所有相关互动按钮都隐去）状态处理复活后无敌，初次传入时无敌，无敌时间无限长，跨场景删除，飞行寻路完毕后，删除无敌3.战斗场景A.中间的大圆形区域为boss场景B.战斗只能发生在这里规则1.场景内玩家关系A.可以自由组队和退队B.默认pk模式为善恶C.可以开各种杀戮模式pk2.特殊玩法（二期制作？？）A.阶段性出现特殊玩法B.特殊玩法1：PK鼓励向，boss血量到某个阶段后开启，该阶段一旦击杀了其他玩家，每杀一个玩家获得一层状态，提升攻击10%3.战斗限时A.3-4分钟的时间为宜（策划填表）B.时间长了疲惫C.时间短了拉不开差距Boss战斗属性1.每一个boss都有其固定的属性。2.对应该boss刷出来的阵眼的属性也固订。也就是一个boss对应一个阵眼，boss的阵眼的属性都是固定不变的。比如：姥姥的属性就是npcgrowup里的1101，对应的阵眼cha_list id为11001，属性也对应为1102.3.Boss的等级由玩家决定A.Boss的等级取决由有资格传送进入boss战的玩家中等级最高的玩家，boss的等级等于该玩家的等级B.玩家传送进入boss场景后，boss场景才刷出boss4.Boss最初的1级属性确定，之后的每级属性有npc——growup决定（如果boss属性据此控制不力，则可以使用分段控制法，每个关键等级点单独取一条属性，该属性包括了boss的基础属性和成长属性，直到下一个等级关键点之前的所有等级都使用该属性，到达下个关键点后，取新的关键点的战斗属性匹配给boss（比如30-39使用npc成长表属性ID1000,40-45使用1001,45-50使用1002）5.注意：阵眼的等级等于开启伏魔阵队伍里等级最高的玩家的等级，其属性由其等级匹配到相应的表得到）奖励相关首先需要伤害统计Boss战的时候，类似阵眼击破，对所有对boss造成的伤害进行记录和统计伤害统计栏还是出现在任务栏，隐去任务栏还是只以队伍为单位进行排行和统计参与就有奖励只要进入战斗状态，每秒获得一定经验（策划填表），根据玩家等级获得经验只要对boss造成伤害，就能获得金钱奖励每个boss对应不同等级都有一个总金钱掉落书每次造成的伤害对应boss总血量的必烈决定单次获得基础金钱数1.Boss等级越高，总金钱数越多2.玩家伤害越高，单次获得金钱越多3.可能会一秒判定很多次，获得金钱的间隔就设定为一秒如果有玩家完成了最终一击的击杀，则额外奖励该玩家3%boss掉落金钱的奖励不同的职业在基础金钱数上还有个系数加成（系数策划填表），用来平衡不同职业定位下，职业之间的伤害有差距的问题每个玩家造成的伤害都记录下来，到最后boss战结束的时候统一结算，通过邮件发放额外的排名奖励以队伍伤害排名为标杆选择伤害最高的队伍发奖发奖以道具为基础形式，通过邮件发送。如何退出副本战斗时间倒计时结束后进行结算。因此屏幕中央上方位置有本次挑战的限时倒计时显示，倒计时是从boss刷出开始计时。结算时弹出结算界面（结算界面见界面设计）界面上表明谁的队伍获得了额外奖励，并显示奖励礼包，点击礼包可以看到tips显示自己获得的金钱和经验奖励点击确定离开boss场景，该界面仅仅有确定按钮Boss战结束后，会用跑马灯宣布【xxx（队长）和他的队友击败了xxboss，获取了丰厚的回报】掉线问题的处理大世界掉线阵眼击破前就重新上线了1.队伍还存在，无需特殊处理，因为记录的是队伍伤害和队伍信息2.全队都掉线，队伍只要不删除，还记录有队伍信息即可阵眼开启后才重新上线1.参考【如何进入禁阵】里的【特别注意】第二条 ：链接在此Boss挑战时掉线战斗结束前就重新上线1.单人掉线，队伍还在就出现在掉线前位置，伤害和队伍信息继承2.队伍解散，上线还是出现在掉线前位置，但伤害信息清零3.全队掉线，保留伤害统计和队伍信息，等上线后继续战斗结束后才上线1.结束前没有散队，奖励照发，从邮件获得2.散队了，没有奖励 高阶boss玩的是什么公会间的竞争，同时小队为基础的竞争单元阵眼会开启多次，一个公会怎么保证自己的人尽可能多的在前两轮进入，是很重要的竞争和博弈Boss战时候的竞争和博弈，主要体现在pve伤害的竞争，以及多个公会间因为PK策略的选择展开的博弈Pk规则大世界上默认组队前的pk模式，pk自由交给玩家，玩家可以手段选择开启。基本以公会杀戮为主，不排斥其他pvp模式Boss场景的pk决定权同上，交给玩家怎么开启系统上指定时间点上自动打开地图上的大伏魔阵阵眼，需要打破阵眼，该阵眼才会挑选参与过击破自己的玩家，符合规则被选中的人才能被传送到世界boss身边规定时间开启每天都会开启每天开启2次，分别是中午12:00-12:30,晚上20:00-20:30开启时间内和开启前10分钟内，所有伏魔阵无法使用召唤符召唤小世界boss，（表现为这段时间内，伏魔阵的符咒纹理显示为红色，表明大伏魔阵激活，小伏魔阵无法开启—-小伏魔阵的纹理采用蓝色或者其他做区别）开启时间策划填表决定，原则就是和其他活动不冲突，并安排在大部分玩家有闲的时间段。指定地点开启开启地点1.只能在指定地点生成阵眼2.指定点规则A.要素1：不同boss对应的场景组不一样例如场景ID有1到101号boss对应：1352号boss对应：246如果是打1号boss，则只会在1 3 5场景刷出阵眼B.要素2：一个场景包含了5个阵眼如果该场景可以召唤小boss，该场景的大小boss阵眼点相同世界boss定时活动开启后，一定是5个阵眼一起打开C.要素3：允许一个场景多条线：如果一个场景开了多条线，则每条线的指定点都会生成阵眼D.要素4：PVE和PVP场景都会有指定点PVE场景选择等级略高的地方Pvp的场景也尽量选择等级比较高的地方，但考虑玩家参与情况，可以选择个别对应等级比较低的场景。阵眼开启通知1.阵眼开启前5分钟，每20秒跑马灯提醒一次全服玩家2.阵眼开启后，跑马灯通知全服（完全和小boss相同）A.点击跑马灯和世界聊天的链接，自动寻路走到阵眼所在的场景B.。。。怎么进入每次阵眼被击破，都会传送一定数量的玩家进入boss场景每个阵眼可以被击破3次，随着被击破的次数增加，阵眼扩大，下一次可以被传送的玩家数量随之增加挑选进入boss场景的规则阵眼每次被击碎后，挑选玩家进入boss禁阵阵眼可以被击碎三次，三次后，阵眼不再生成阵眼有存活时间，该时间策划填表决定，时间一到，该阵眼如果还未被击破，阵眼消失，本次不传送攻击阵眼的过程中，会统计伤害并排行，并显示在客户端1.该排行榜最多出现3行2.完全类似小boss的大世界伤害统计（略过不表）第一次传送1.精英传送：只传最厉害的一组人进入A.当阵眼被击破时，才开始挑人B.确定伤害最高的队伍C.确定当前这个队伍的玩家，记录D.把这些玩家传入boss副本E.如果有掉线，不在阵眼同一场景，参考特殊处理2.传送完毕后，有个阵眼重新打开过程，该过程持续时间策划填表决定（改好等于boss场景中复活点到战斗场景时间或更大）3.屏幕提示：阵眼被击碎后，显示【阵眼受到攻击，禁制松动，下一次阵眼会稍后打开】第二次传送1.高级传送：传送最厉害的1组人进入A.类似第一次传送B.这次仍然只传送1队人2.传送完毕后，类似第一次传送，仍然有个阵眼重新打开过程该过程持续时间策划填表决定（改好等于boss场景中复活点到战斗场景时间或更大）3.屏幕提示：阵眼被击碎后，显示【阵眼受到猛烈攻击，禁制受损严重，稍后将会打开最后一次阵眼】第三次传送1.普世传送：仍然只传送一队人A.当阵眼被击碎，所有参与的有伤害的人都被传入B.阵眼有个存活时间，时间到还没被击破，伏魔阵关闭，符文熄灭，阵眼消失，木有传送门2.该次传送后，阵眼不再生成，但会 有传送门存在2分钟初步计算和预估一个boss对应3个场景每个场景2条线一个场景5阵眼每个着眼前两轮传2只队每队6个玩家第一轮最多30个阵眼，可传180个玩家，实际普遍情况可能最多15个阵眼传入90个玩家（参考另个情况：一个大公会100人满员）第二轮第三轮同理一共540，其实最大估计270。Boss战玩法Boss战场景场景内容完全继承小boss出生点和复活点几乎等同于小boss，不同点在于：出生点和复活点随机在预设的3个点，3个点刚好平均分在3个小阁楼上。战斗场景就是中间的大圆圈Boss战规则场景内可以自由组队和退队默认pk模式为善恶，是否开红，自主权给玩家阶段性玩法（二期）1.例如小boss也有的阶段性强化pk玩法战斗限时1.策划填表决定限时。15-20分钟适宜2.时间太长疲惫3.时间短了拉不开伤害差距4.如果需要进一步强化boss战的交互和互动，那可以适当增加写时间，反正由策划手动填表控制Boss的战斗属性Boss的属性是可以升级和降级的世界boss的等级是固定的服务器玩家封顶等级（策划填表）每一级的属性从表里匹配，匹配方式类似小bossBoss如果当次被击杀，则boss会自动升一级，那么boss的属性也会升级如果当次没有被击杀，则boss会自动降一级，那么boss的属性也会降低动态的调整boss等级，等于动态的调整了boss的属性，保证了boss的属性总是趋向于贴合本服务器玩家的当前战斗力水平预期的另外注意：阵眼的等级等于boss的等级，其属性也是动态升级和降级的（也由策划填表控制）奖励发放首先需要伤害统计为依据Boss战的时候，类似阵眼，会对所有造成的伤害记性记录和统计队伍伤害统计1.隐去任务栏，在该处出现伤害统计2.以队伍为单位进行统计和排行公会伤害统计1.在队伍伤害统计下方，客户单显示公会伤害统计2.以公会为单位进行排行和统计3.样式完全类似队伍的4.该伤害统计和排行只能出现在boss战阶段参与就发奖励只要进入战斗状态，每秒获得一定经验（策划填表），根据玩家等级获得经验只要对boss造成伤害，就能获得金钱奖励1.每个boss对应不同等级都有一个总金钱掉落书2.每次造成的伤害对应boss总血量的必烈决定单次获得基础金钱数A.Boss等级越高，总金钱数越多B.玩家伤害越高，单次获得金钱越多C.可能会一秒判定很多次，获得金钱的间隔就设定为一秒3.不同的职业在基础金钱数上还有个系数加成（系数策划填表），用来平衡不同职业定位下，职业之间的伤害有差距的问题4.如果有玩家完成了最终一击的击杀，则额外奖励该玩家3%boss掉落金钱的奖励5.每个玩家造成的伤害都单独记录，直到活动完毕时一并结算成金钱，并通过邮件发放给玩家排名的额外奖励分为队伍和公会两部分奖励队伍1.以队伍伤害为标杆2.选择伤害最高的队伍发奖公会1.排名前3名的公会会的额外奖励，前几名可以获奖，奖励什么都由策划填表控制2.前N名可以获得世界boss妖丹，该妖丹是个直接发放给公会仓库的道具（N暂时取5）3.妖丹的道具只决定了召唤出来的boss的类型4.妖丹的等级等于本次活动的世界boss的等级，不同等级的妖丹召唤出来的门派boss的等级也不相同5.排名第一名的公会得到的妖丹等级等于世界boss的等级，而后的2-5名得到的妖丹都会有个等级修正（策划填表），他们得到的妖丹的等级需要用世界boss的等级减去修正值得到。怎么退出战斗过程中无法主动退出活动倒计时为0时，结束战斗，开始结算结算时弹出结算界面表明那个公会拔得头筹（伤害最高的公会）表明那只队伍贡献最大表明本公会获得奖励表明自己队伍获得的奖励点击确定离开boss场景Boss战结束后，会用跑马灯宣布【xxx公会是降伏世界boss xxx的中流砥柱，获取了丰厚的回报】 掉线处理类似小boss特别注意当阵眼传送人之前，需要判断玩家是否在阵眼所在的场景，只有玩家处于阵眼所在的场景，才把玩家传送。阵眼前两次被击碎后，会有1-2分钟聚力重塑的时间，（时间策划填表）该时间内每秒都会检测拥有进入资格的玩家是否出现在阵眼20米区域，如果出现，则把玩家传送进入boss场景（预防阵眼开启前掉线，预防阵眼开启前切了场景）当第三次阵眼击碎后，阵眼位置生成一个缝隙，存在2分钟，2分钟内有资格进入的玩家走到缝隙附近20米，被传入玩家如果死在附近，也可以被传送，传送后复活]]></content>
  </entry>
  <entry>
    <title><![CDATA[Shell]]></title>
    <url>%2F2017%2F11%2F02%2Fshell%2F</url>
    <content type="text"><![CDATA[${}用来做变量替换。一般情况下，$var与${var}并没啥不一样但是用${}会比较精确的界定变量名称的范围，比方说：$ A=B$ echo $ABg++ -DLINUX -D_FILE_OFFSET_BITS=64 -D_LARGEFILE64_SOURCE -D_LARGEFILE_SOURCE -Wall -Wno-multichar -g -D_DEBUG -DPG_MEMORY_DISABLE_POOL -march=core2 -m32 -rdynamic -std=c++0x -o ../../bin/debug/xxsy/ScnSvr_AllInOne/ScnSvr_AllInOne_d ../../temp/debug/xxsy/ScnSvr_AllInOne/ScnSvr_AllInOne.o_d /root/work_code/src/lib/libGSDB_Lib_d.a /root/work_code/src/lib/libScnSvr_d.a /root/work_code/src/lib/libGZSGamePlay_Lib_d.a /root/work_code/src/lib/libMCE4Chat_d.a /root/work_code/src/lib/libMCE_d.a /root/work_code/src/lib/libDIA4DBI_d.a /root/work_code/src/lib/libDIA_d.a /root/work_code/src/lib/libPNGS_d.a /root/work_code/src/lib/libWHNET_d.a /root/work_code/src/lib/libWHCMN_d.a /root/work_code/src/lib/libxxsy_cmn_d.a /root/work_code/src/lib/libpgcmn_d.a -lpathfind_d -lcJSON_d -lcryptlib_d -llua_d -lzlib_d -ltss_sdk_d /root/work_code/3rd/lib/libqos_client.a -lz -ldl -lssl -lpthread -ldl -lrt -march=prescott -L/root/work_code/3rd/lib -L/root/work_code/src/lib -pthread/usr/bin/ld: skipping incompatible /usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../lib/libm.so when searching for -lm #0 这个是shell的执行名字 #n 这个是shell的第n个参数值，n=1..9 $* 这个是shell的所有参数 $# 表示参数的个数 $$ shell的PID $! 执行上一个的PID $? 执行上一个指令的返回值（显示最后的退出状态，0表示没有错误，其它任何值表明有错误） $- 显示shell使用的当前选项，与set命令功能相同 $@ 跟$* 类似，但是可以当作数组用 -eq 等于 -ne 不等于 -le 小于等于 -ge 大于等于 -lt 小于 -gt 大于 = 就是赋值运算:= 就是当冒号前面的变量不存在或者值为空时，就把等号后的值赋值给变量 删除十天前的文件ltfind ./ -mtime +10 -name &quot;*.*&quot; -exec rm -rf {} \; 文件传输（Windows向Linux传输）安装yum install openssh-clients -y 传输文件scp -p ./file/yum.log root@192.168.199.150:/tmp/yum.log 传输目录scp -rp ./file/ root@192.168.199.150:/tmp/ 查看那个共享内存被哪些进程使用着 lsof | grep &quot;shmid&quot; 将静态库文件解析成.o文件 ar -x libexpat.a 查看归档文件的函数名 nm -s xmltok.o 查看汇编代码 objdump -j .text -Sl tbus.o | more]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日记]]></title>
    <url>%2F2017%2F10%2F30%2Fzentia-note1%2F</url>
    <content type="text"><![CDATA[遇到问题：CLS起不来，自我感觉应该是SSH验证，因为XCLS2中的auth-info解析出来的地址是3.6，研究中。线索：通过上传记录发现配置文件和openresty一块上传，认为配置文件是通过openresty生成的，故而研究openresty。Message:cls 加上认证，win32平台测试通过 Modified : /trunk/server/src/engine/PNGS/inc/pngs_cls_i.hModified : /trunk/server/src/engine/PNGS/src/pngs_cls_i.cppModified : /trunk/server/src/engine/PNGS/src/pngs_cls_i_Tick_DealTE.cpp SetUseAuth由于个人喜欢sublime也在使用，遇到不支持ANSI编码，特标注：ConvertToUtf8 import urllib.request,os; pf = ‘Package Control.sublime-package’; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), ‘wb’).write(urllib.request.urlopen( ‘http://sublime.wbond.net/‘ + pf.replace(‘ ‘,’%20’)).read())上面的是安装package controls grep key1 * | grep key2 并所有文件 find ./ -name &quot;*.ext&quot; | xargs -i rm -rf {} # 查询某个后缀名的所有文件，然后移除，-i表示对文件操作 解决树冲突： svn resolve --accept working dir https://github.com/Unity-Technologies/UnityCsReference README.mdUnity 2018.1.0b12 C# reference source code The C# part of the Unity engine and editor source code.May be used for reference purposes only. https://github.com/duanjiahao/UnityDecompiled https://github.com/MattRix/UnityDecompiled https://github.com/jameslinden/unity-decompiled IP Username Password Environment 192.168.0.171 liyanfeng yanfeng Intranet 192.168.0.171 maobakeji maoba Intranet 106.12.98.12 root lyf8068353A@ Outter net]]></content>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[port-security]]></title>
    <url>%2F2017%2F10%2F30%2Fport-security-1%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[端口映射]]></title>
    <url>%2F2017%2F10%2F30%2Fport-security%2F</url>
    <content type="text"><![CDATA[端口安全（Port Security），从基本原理上讲，Port Security特性会通过MAC地址表记录连接到交换机端口的以太网MAC地址（即网卡号），并只允许某个MAC地址通过本端口通信。其它MAC地址发送的数据包通过此端口是，端口安全特性会组织它。使用端口安全特性可以防止未经允许的设备访问网络，并增强安全性。]]></content>
      <tags>
        <tag>server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ps]]></title>
    <url>%2F2017%2F10%2F30%2Fps%2F</url>
    <content type="text"><![CDATA[USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDroot 44936 99.1 1.4 148660 14340 ? R 10月28 2004:47 ./XGMS_d gms_cfg.txt]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poll]]></title>
    <url>%2F2017%2F10%2F28%2Fpoll%2F</url>
    <content type="text"><![CDATA[Poll就是监控文件是否可读的一种机制，作用与select一样。应用程序的调用如下： int poll(struct pollfd *fds, nfds_t nfds, int timeout) Poll机制会判断fds中的文件是否可读，如果可读则立即返回，返回的就是可读fd的数量，如果不可读，那么进程就会休眠。 内核实现流程：当应用程序调用poll函数的时候，系统会调用sys_poll函数，该函数最终调用do_poll函数，do_poll函数中有一个死循环，在里面又会利用]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XXSY服务器游戏架构]]></title>
    <url>%2F2017%2F10%2F27%2Fgame-framework%2F</url>
    <content type="text"><![CDATA[总体架构图 大区架构图 逻辑服务器架构图]]></content>
      <tags>
        <tag>server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache]]></title>
    <url>%2F2017%2F10%2F27%2FApache%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435[1] 安装 httpd.[root@linuxprobe ~]# yum -y install httpd# 删除默认欢迎页面[root@linuxprobe ~]# rm -f /etc/httpd/conf.d/welcome.conf[2] 配置httpd，将服务器名称替换为您自己的环境[root@linuxprobe ~]# vim /etc/httpd/conf/httpd.conf# line 86: 改变管理员的邮箱地址ServerAdmin root@linuxprobe.org# line 95: 改变域名信息ServerName www.linuxprobe.org:80# line 151: none变成AllAllowOverride All# line 164: 添加只能使用目录名称访问的文件名DirectoryIndex index.html index.cgi index.php# add follows to the end# server's response header（安全性）ServerTokens Prod# keepalive is ONKeepAlive On[root@linuxprobe ~]# systemctl start httpd[root@linuxprobe ~]# systemctl enable httpd[3] 如果Firewalld正在运行，请允许HTTP服务。，HTTP使用80 / TCP[root@linuxprobe ~]# firewall-cmd --add-service=http --permanentsuccess[root@linuxprobe ~]# firewall-cmd --reloadsuccess[4] 创建一个HTML测试页，并使用Web浏览器从客户端PC访问它。如果显示以下页面，是正确的[root@linuxprobe ~]# vi /var/www/html/index.html&lt;html&gt;&lt;body&gt;&lt;div style="width: 100%; font-size: 40px; font-weight: bold; text-align: center;"&gt;Welcome access LinuxProbe.org,This is Test Page!&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; http://blog.csdn.net/wh211212/article/details/52982917]]></content>
      <tags>
        <tag>server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vs]]></title>
    <url>%2F2017%2F10%2F26%2Fvs%2F</url>
    <content type="text"><![CDATA[$(TargetDir)\XGZS_d.exe../data/cfg/network/cfg_relation.txt]]></content>
      <tags>
        <tag>server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[netstat]]></title>
    <url>%2F2017%2F10%2F26%2Fnetstat%2F</url>
    <content type="text"><![CDATA[netstat -tln 查看端口占用情况\p 可以显示进程每一列含义协议类型 接受流量 发送流量 本机地址 目的地址 状态自己的IP地址就是本地地址，需要连接的地址的就是目的地址 nmap 127.0.0.1 查看本机开放的端口0.0.0.0 表示网络的所有主机[{“type”:0,”pid”:-1,”Attr1”:0,”id”:1,”Attr2”:0,”name”:”PC主支”,”tag”:0},{“type”:0,”pid”:1,”Attr1”:0,”id”:2,”Attr2”:0,”name”:”策划大区”,”tag”:1},{“type”:0,”pid”:1,”Attr1”:0,”id”:3,”Attr2”:0,”name”:”程序大区”,”tag”:1},{“type”:0,”pid”:1,”Attr1”:0,”id”:4,”Attr2”:0,”name”:”3.0.90.0”,”tag”:1},{“type”:0,”pid”:1,”Attr1”:0,”id”:22,”Attr2”:0,”name”:”4.0.30.0”,”tag”:1},{“type”:0,”pid”:1,”Attr1”:0,”id”:28,”Attr2”:0,”name”:”云服务器”,”tag”:1},{“type”:0,”pid”:1,”Attr1”:0,”id”:34,”Attr2”:0,”name”:”4.0.0.0”,”tag”:1},{“type”:0,”pid”:1,”Attr1”:0,”id”:35,”Attr2”:0,”name”:”3.0.60.0”,”tag”:1},{“type”:0,”pid”:1,”Attr1”:0,”id”:41,”Attr2”:0,”name”:”合服”,”tag”:1},{“type”:1,”pid”:2,”id”:381,”RoleCount”:0,”RoleInfos”:{},”name”:”[1]策划主支”,”Attr1”:4,”Flag”:64,”Url”:”192.168.3.6:16400”,”Attr2”:0,”tag”:3},{“type”:1,”pid”:2,”id”:382,”RoleCount”:0,”RoleInfos”:{},”name”:”[2]策划主支”,”Attr1”:3,”Flag”:64,”Url”:”192.168.6.113:16400”,”Attr2”:0,”tag”:1},{“type”:1,”pid”:3,”id”:256,”RoleCount”:0,”RoleInfos”:{},”name”:”[1]程序主支”,”Attr1”:2,”Flag”:64,”Url”:”192.168.3.6:26400”,”Attr2”:0,”tag”:3},{“type”:1,”pid”:3,”id”:257,”RoleCount”:0,”RoleInfos”:{},”name”:”[2]程序主支”,”Attr1”:1,”Flag”:64,”Url”:”192.168.6.113:26400”,”Attr2”:0,”tag”:1},{“type”:1,”pid”:3,”id”:259,”RoleCount”:0,”RoleInfos”:{},”name”:”yhy-1”,”Attr1”:0,”Flag”:32,”Url”:”192.168.7.13:3100 192.168.7.13:3110”,”Attr2”:0,”tag”:1},{“type”:1,”pid”:3,”id”:53,”RoleCount”:0,”RoleInfos”:{},”name”:”yhy-2”,”Attr1”:0,”Flag”:32,”Url”:”192.168.7.13:13100”,”Attr2”:0,”tag”:1},{“type”:1,”pid”:3,”id”:19,”RoleCount”:0,”RoleInfos”:{},”name”:”218(zy)”,”Attr1”:0,”Flag”:32,”Url”:”192.168.5.106:3100”,”Attr2”:0,”tag”:1},{“type”:1,”pid”:3,”id”:20,”RoleCount”:0,”RoleInfos”:{},”name”:”190(zmq)”,”Attr1”:0,”Flag”:32,”Url”:”192.168.5.228:26400”,”Attr2”:0,”tag”:1},{“type”:1,”pid”:3,”id”:21,”RoleCount”:0,”RoleInfos”:{},”name”:”230(hjz)”,”Attr1”:0,”Flag”:32,”Url”:”10.96.205.230:26400”,”Attr2”:0,”tag”:1},{“type”:1,”pid”:3,”id”:310,”RoleCount”:0,”RoleInfos”:{},”name”:”测试专服”,”Attr1”:0,”Flag”:64,”Url”:”192.168.6.113:7100”,”Attr2”:0,”tag”:1},{“type”:1,”pid”:3,”id”:268,”RoleCount”:0,”RoleInfos”:{},”name”:”主支跨服大区”,”Attr1”:0,”Flag”:64,”Url”:”192.168.3.6:10010”,”Attr2”:0,”tag”:1},{“type”:1,”pid”:4,”id”:93,”RoleCount”:0,”RoleInfos”:{},”name”:”[1]3.0.90.0”,”Attr1”:0,”Flag”:64,”Url”:”192.168.3.6:51100”,”Attr2”:0,”tag”:3},{“type”:1,”pid”:4,”id”:94,”RoleCount”:0,”RoleInfos”:{},”name”:”[2]3.0.90.0”,”Attr1”:0,”Flag”:64,”Url”:”192.168.6.113:51100”,”Attr2”:0,”tag”:1},{“type”:1,”pid”:22,”id”:95,”RoleCount”:0,”RoleInfos”:{},”name”:”[1]4.0.30.0”,”Attr1”:0,”Flag”:64,”Url”:”192.168.3.6:43100”,”Attr2”:0,”tag”:1},{“type”:1,”pid”:22,”id”:96,”RoleCount”:0,”RoleInfos”:{},”name”:”[2]4.0.30.0”,”Attr1”:0,”Flag”:64,”Url”:”192.168.6.113:43100”,”Attr2”:0,”tag”:1},{“type”:1,”pid”:28,”id”:5999,”RoleCount”:0,”RoleInfos”:{},”name”:”IOS游客”,”Attr1”:0,”Flag”:64,”Url”:”139.199.37.182:48100”,”Attr2”:0,”tag”:1},{“type”:1,”pid”:28,”id”:4999,”RoleCount”:0,”RoleInfos”:{},”name”:”IOS微信”,”Attr1”:0,”Flag”:64,”Url”:”139.199.37.182:53100”,”Attr2”:0,”tag”:1},{“type”:1,”pid”:28,”id”:3999,”RoleCount”:0,”RoleInfos”:{},”name”:”IOS手Q”,”Attr1”:0,”Flag”:64,”Url”:”139.199.37.182:33100”,”Attr2”:0,”tag”:1},{“type”:1,”pid”:28,”id”:1999,”RoleCount”:0,”RoleInfos”:{},”name”:”安卓手Q”,”Attr1”:0,”Flag”:64,”Url”:”139.199.37.182:23100”,”Attr2”:0,”tag”:1},{“type”:1,”pid”:28,”id”:2999,”RoleCount”:0,”RoleInfos”:{},”name”:”安卓微信”,”Attr1”:0,”Flag”:64,”Url”:”139.199.37.182:28100”,”Attr2”:0,”tag”:1},{“type”:1,”pid”:34,”id”:97,”RoleCount”:0,”RoleInfos”:{},”name”:”[1]4.0.0.0”,”Attr1”:0,”Flag”:64,”Url”:”192.168.3.6:20400”,”Attr2”:0,”tag”:1},{“type”:1,”pid”:34,”id”:98,”RoleCount”:0,”RoleInfos”:{},”name”:”[2]4.0.0.0”,”Attr1”:0,”Flag”:64,”Url”:”1921.68.6.113:20400”,”Attr2”:0,”tag”:1},{“type”:1,”pid”:35,”id”:90,”RoleCount”:0,”RoleInfos”:{},”name”:”[1]3.0.60.0”,”Attr1”:6,”Flag”:64,”Url”:”192.168.3.6:6400”,”Attr2”:0,”tag”:1},{“type”:1,”pid”:35,”id”:91,”RoleCount”:0,”RoleInfos”:{},”name”:”[2]3.0.60.0”,”Attr1”:5,”Flag”:64,”Url”:”192.168.6.113:6400”,”Attr2”:0,”tag”:1},{“type”:1,”pid”:41,”id”:311,”RoleCount”:0,”RoleInfos”:{},”name”:”合服后(3014+3016)”,”Attr1”:0,”Flag”:64,”Url”:”192.168.6.113:7100”,”Attr2”:0,”tag”:9},{“type”:1,”pid”:41,”id”:312,”RoleCount”:0,”RoleInfos”:{},”name”:”3014”,”Attr1”:0,”Flag”:64,”Url”:”192.168.6.113:23100”,”Attr2”:0,”tag”:9},{“type”:1,”pid”:41,”id”:313,”RoleCount”:0,”RoleInfos”:{},”name”:”3016”,”Attr1”:0,”Flag”:64,”Url”:”192.168.6.113:37100”,”Attr2”:0,”tag”:9}]]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多语言规范]]></title>
    <url>%2F2017%2F10%2F25%2Flang%2F</url>
    <content type="text"><![CDATA[概述部分多语言资源，客户端和服务器放在不同目录里，公用的部分使用外链。 客户端多语言根目录：Assets\Art\lang二级目录mb：存放mb的多语言数据二级目录res: 存放界面文本，以及其它资源的多语言数据（比如图片和prefab等）三级目录：用各种语言名字来命令的目录config.txt：保存当前语言的名字 服务器多语言根目录：bin\data\lang二级目录mb：存放mb的多语言数据（这个是上面的客户端二级mb的外链）二级目录mbs：存放mbs多语言数据三级目录：用各种语言名字来命名的目录config.txt：保存当前语言的名字（服务器和客户端需要分别配置） 程序需要做的事情:： 处理表格配置，合理设置翻译列； 在界面prefab里，给UILabel等控件填写langId，需要同时创建对应的文字资源文件； 界面用到的Lua/text里的json文件，需要转换成txt文件资源； 脚本里的中文，需要放到文本资源里； 图片文字，需要整理放到单独目录里，便于提供海外运营商； res目录规范此目录是界面文本资源表格，表格无标题行，分三列：名字，文本，英文长度，某些按钮类的空间，如果需要限制文本长度，那么需要填写英文长度列。不要有任何子目录，子目录是无效的。非翻译文本（比如目录配置文本），放到lua里就好，不要放在txt里。此目录里的所有文件，都是用到的时候加载的文本资源使用方式： C#代码访问方式：LangMgr.Find(“login.Username”),此函数无GC prefab访问方式：填写UILabel的langId,格式同上，所有中文标签都要做修改。 lua脚本访问方式：lua_core.LoadLangFile(“login”).Username目录file：可替换掉相同路径的资源，比如字体替换，文字图片替换等，也可以直接用这个替换整个界面的prefab，但是轻易不要这样用。 Json转Text工具在Unity里，选中Lua/text/目录里的某个文件点击菜单项Pangmei/Translate/json转text，这样可以将原本的json文件转txt表格。转换后的文件放在了Assets\Art\lang\res\zh_cn\text\temp里，需要重新命名后挪出来。原本的子目录都不要有了，如果有重命名，就自己改个名字。建议文件别太多，太小的文件自己合并一下，文件少会更容易管理。 新文本merge方式可以使用string.merge()来格式化字符串，这个是仿造C#的Format来设计功能。用{0}引用首个参数，其余参数类推。这个函数在客户端没有C#级别的GCAlloc，大量使用的时候推荐这个，不要用CSFormat系列了。部分带%s的文本，建议都检查一下，多个%s的文本有可能会导致某些语言翻译错误（主谓宾和汉语次序不同导致） mb目录规范翻译列配置表格的json配置文件，每列可以加防疫配置”translate”:true指定翻译的列：会被翻译工具检索出来生成翻译词条。 目录text有工具生成的表格翻译文本，运行期动态替换掉中文表格文本。 目录cell替换掉同名表格指定单元格的内容，不需要写子目录。多个文件可以同名，以二级扩展名区分，比如：item_list.a.txt,item_list.b.txt同名文件按照二级扩展名排序依次执行，重复配置的单元格，以最后的为准。首行是标题，第二行是json配置里的表格列的名字，后续航是替换的内容。第二行的名字，可以不填写，就表示忽略该列。此特性通常用于注释或者名字之类的。空单元格表示不需要替换，如果需要替换为空，那么填写“##” 目录file整文件替换表格，对应的参照目录是mb目录。这个功能尽量别用，使用cell来精确替换某个单元格更可控。 mbs目录规范翻译列配置：规则同mb 目录text规则同mb 目录cell基本规则同mb有子目录npc_refresh和flag，分别对应那两组表，目录内的规则也同mb 目录file规则同mb 翻译工具海外专员翻译工具路径：svn://zentia/welcome/LangTool海外专员一般是市场部同学。负责将待翻译的文本到处，然后发给海外运营商翻译，并且将译文导入公用词条库里。 项目分支翻译工具路径：svn://zentia/trunk/xxpub/LangTool（其余分支路径类似）项目的导入职能由产品负责需要在每个海外版本发布前，将特定分支生成海外文本资源并且上传。 多语言名字参照微软的多语言名称参考网站：https://www.microsoft.com/en-us/locale.aspx]]></content>
      <tags>
        <tag>sy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fork]]></title>
    <url>%2F2017%2F10%2F25%2Ffork%2F</url>
    <content type="text"><![CDATA[通过系统调用创建一个与原来进程几乎完全相同的进程，也就是说两个进程可以做完全相同的事情，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。一个进程调用fork()函数之后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后吧原来的进程的所有值都复制到新的进程中，只有少数值与原来进程的值不同。相当于克隆了一个自己。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849int whdaemon_init(bool bAutoCloseFD)&#123; printf("Transform to daemon ... "); pid_t pid; if( (pid=fork()) &lt; 0) &#123; printf("Failed!%s", WHINEED); return -1; &#125; else if(pid !=0) &#123; //parent goes bye-bye printf("SUCCESS, pid might be:%d!%s", pid+1, WHLINEEND); exit(0); &#125; // 关闭所有句柄 if (bAutoCloseFD) &#123; for (int i =0; i &lt; MAXFD; i++) &#123; close(i); &#125; &#125; else &#123; // 否则至少关闭标准的输入输出 close(0); close(1); close(2); &#125; // 变成seeion leader setsid(); signal(SIGHUP, SIG_IGN); // 结束第一个紫禁城 if ((pid=for() != 0)) &#123; exit(0); &#125; umask(0); return 0;&#125;]]></content>
      <tags>
        <tag>linux</tag>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[time]]></title>
    <url>%2F2017%2F10%2F24%2Ftime%2F</url>
    <content type="text"><![CDATA[设置时间同步timedatectl set-ntp yes]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[systemctl]]></title>
    <url>%2F2017%2F10%2F24%2Fsystemctl%2F</url>
    <content type="text"><![CDATA[显示防火墙状态：systemctl status firewalld.service关闭防火墙：systemctl stop firewalld.service开启防火墙：systemctl start firewalld.service上面的firewalld的，不过我后来安装了iptables换一下就好了]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器搭建和日常维护]]></title>
    <url>%2F2017%2F10%2F24%2Fserver-set%2F</url>
    <content type="text"><![CDATA[1 概述2 系统软硬件要求软件：所有的服务器程序都可以在linux和windows系统上。推荐使用linux系统。我们一般使用的系统是suse10.1，不过按要求，我们在tlinux的服务器上实验编译并运行了我们的所有服务器成。Gcc版本：gcc(GCC)4.8.5数据库使用MYSQL。版本：5.6.38硬件：参考先前提供的硬件配置资料另外，请在启动文件/etc/rc.d/rc.local中设置共享内存、网络参数以及core文件模式123456789101112131415#increase Linux SHM maxecho 300000000 &gt; /proc/sys/kernel/shmmax#increase Linux TCP buffer limitsecho 8388608&gt;/proc/sys/net/core/rmem_maxecho 8388608&gt;/proc/sys/net/core/wmem_maxecho 262114&gt;/proc/sys/net/core/rmem_defaultecho 262114&gt;/proc/sys/net/core/wmem_default#increase Linux autotruning TCP buffer limitsecho "4096 87380 8388608"&gt;/proc/sys/net/ipv4/tcp_rmemecho "4096 65536 8388608"&gt;/proc/sys/net/ipv4/tcp_wmemecho "8388608 8388608 8388608"&gt;/proc/sys/net/ipv4/tcp_memecho "840"&gt;/proc/sys/net/ipv4/echo "core-%e-%p-%s"&gt;/proc/sys/kernel/core_pattern 3 维护人员账号配置为了安全的原因，请不要使用root账号进行服务器的维护工作。 4 MySQL的配置5 服务程序简介6 服务程序的版本辨认7 日志服务程序启动过程7.1 启动日志服务7.2 检查8 游戏服务器启动过程8.1 启动日志服务8.2 启动游戏总控框架8.3 启动游戏场景线8.4 检查9 服务组关闭过程10 YYCGZS的维护]]></content>
      <tags>
        <tag>server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器安装说明]]></title>
    <url>%2F2017%2F10%2F24%2Fserver-install%2F</url>
    <content type="text"><![CDATA[解压服务器执行文件xx_svr_binfull_XXXX.tgz到指定文件夹。 解压配置文件xx_svr_cfgfull_XXXX.tgz到相同的文件夹。 解压配置文件xx_svr_resfull_XXXX.tgz到相同的文件夹。 将我们提供的key文件修改文件名为auth-info.key放在XCAAFS和XCLS文件夹下 XGMS目录下创建filecache目录，并给予执行服务器帐号写权限。 XLBA目录下创建siglog目录，并给予执行服务器帐号写权限。 确认pid文件目录/tmp有写权限，确认/data日志目录有写权限。 创建数据库，执行SQL下ca.sh，命令为：./ca.sh 版本后缀 地址如：./ca.sh sy xxsy.cxebfhyvgemb.us-east-2.rds.amazonaws.com 修改配置文件cmncfg.txt，主要修改如下：SVRGRPID 大区ID，如果需要在一个集群建立多个大区，则大区ID不可重复VER_EXT 版本后缀，同一台机器配置多组大区的时候必须不同ONEOUTERIP 对外IP，客户端主要从此IP连接服务器ONEINNERIP 服务器组内部IP，服务器间通信通过此IPMYSQLIP 数据库IPGDB_PORT 数据库端口DB_USER 数据库帐号DB_PASSWORD 数据库密码PORTSHIFT 同一台机器上启动多组服务器必须不同SHMSHIFT 同上注：如分开多台服务器架设还需要修改指定服务器地址 按照《服务器搭建和日常维护》文档第2节修改共享内存限制和tcp相关配置。 runGlog.sh启动日志服务器，一共15个进程。 执行run.sh启动服务器组。 共有IP:18.219.246.109私有IP:172.31.29.118]]></content>
      <tags>
        <tag>server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[uwa]]></title>
    <url>%2F2017%2F10%2F23%2Fuwa%2F</url>
    <content type="text"><![CDATA[AssetBundle lockpersistentmanager开销观察性能曲线，发现某一帧AssetBundle加载中，lockpersistentmanager耗时比较大。请问这块是否能够优化？这说明当前帧或前几帧中存在较大量的资源在通过LoadAsync来进行加载，其本质是所加载的资源过大所致，对自身资源进行合理优化可降低Loading.LockPersistentManager的开销。另外，将异步加载换成同步加载，LockPersistentManager就不会出现了，但其总加载耗时是没有变化的，因为总加载量没变。关于主要资源的加载优化，可参考如下链接：https://blog.uwa4d.com/archives/LoadingPerformance_Texture.htmlhttps://blog.uwa4d.com/archives/LoadingPerformance_Mesh.htmlhttps://blog.uwa4d.com/archives/LoadingPerformance_Shader.htmlhttps://blog.uwa4d.com/archives/Loading_AnimationClip.htmlhttps://blog.uwa4d.com/archives/livebroadcast6-8.html ** IN DIR:3rd, make dep with Makefile_debug.mk dep ** make[1]: 进入目录“/root/work_code/3rd” ** IN DIR:cryptlib, make dep with Makefile_debug.mk dep ** make[2]: 进入目录“/root/work_code/3rd/cryptlib” g++ -DLINUX -D_FILE_OFFSET_BITS=64 -D_LARGEFILE64_SOURCE -D_LARGEFILE_SOURCE -march=core2 -m32 -MM -MT &quot;../temp/debug/cryptlib/cpu.o_d&quot; -MF ../temp/debug/cryptlib/cpu.d_d cpu.cpp -I/usr/include/mysql -I/root/work_code/3rd -I/root/work_code/3rd/freetype221 -I/root/work_code/src/engine -I/root/work_code/src/svr -I/root/work_code/src/xxsy -I/root/work_code/src/svr/glogger/tlog/linux &lt;built-in&gt;:0:0: 致命错误：打开依赖文件 ../temp/debug/cryptlib/cpu.d_d：没有那个文件或目录 -DLINUX #define LINUX -D_FILE_OFFSET_BITS #define _FILE_OFFSET_BITS -D_LARGFEFILE64_SOURCEmarch指定的是当前cpu的架构，而mtune是真正作用于某一型号cpu的选项。 -M 生成文件关联的信息。 -MM 忽略由#include造成的依赖关系 -MF 指一个文件用于存放生成文件的关联信息，这些信息与-M或-MM是一样的， -MT 指定目标文件名 Camera.Render里面Animation.RebuildInternalState耗时较多之所以出现这一项，主要可以说以下两点：（1）项目用的是Animation老版动画系统；（2）对含有Animation组件的GameObject进行了大量频繁的Active或者Instantiate操作，一般这种情况比较常见于特效、UI HUD、角色/怪物等。 是否可以针对特定GameObject提升它的物理模拟次数我们在做一个尽速项目，发现有时候物理的计算并不是非常准确，在运动速度较快时，依然会和墙体造成部分穿插，这给我们的游戏带来了很不好的体验，我知道可以通过Fixed TimeStep来提升物理系统的每帧的计算速度，目前该值为0.02，也就是1秒计算50次，Edit&gt;Project Settings&gt;Time&gt;Fixed TimeStep=0.02。我们曾将其设置为0.005，穿插问题明显好转，但是看上去该值是对所有GameObject均使用的，所以我想问问能否仅针对某一个GameObject来进行提升它的物理计算频率？这是不行的，因为Fixed TimeStep是Unity引擎物理模块的全局参数。建议题主可以考虑将碰撞检测的模式改为”Continuous Dynamic”，看看是否满足需求。但是，需要说明的是，如果物体的速度确实非常快，那么任何一种碰撞模式都不能100%达到不穿插的效果。建议题主可以考虑增大碰撞体的Size或者通过射线求交的方式来将出现穿插问题的概率降到最低。 请教AssetBundle Diff Patch 方案是否可行我原先的更新方案是比对AssetBundle文件的hash值直接替换整个AssetBundle和manifest来达到更新效果的，有没有其它方案类似diff patch,可以减少更新包体，如果可以做diff patch，资源颗粒度是不是九可以忽略了基于AB的直接Diff更新目前没有成熟的方案，不过只把完整的Resources库中的部分资源更新的项目，已经做了2个了。思路其实很简单：1、出整包的时候，用ScriptableObject记录下AssetsDataBase中所有被发布资源的MD5码（不能用Unity自己的hash码）。2、用工具调出哪些assets是代码动态Load的，分一个Res包中；找出这些资源的依赖资源，分入一个Share包中，并记录每个Asset所属的AB包。3、出补丁时，对比当前AssetsDataBase中哪些代码中动态Load的资源出现了增加和改动（删除可以无视），包括他们依赖的资源。仍然把代码中动态Load的资源ResPatch中，依赖放入SharePatch中。对于没有变化的资源，仍然维持原来AB名字。4、记录下次补丁之后，更新每个Asset所属的AB包。5、下一次补丁时的Res和Share可能会依赖上一次的补丁的Share。6、运行时，对所有补丁入的Res建立一个字典索引。Load的时候，有限判断这个Asset是否在补丁的Res包中，如果是则读补丁的AB包，并按套路处理依赖包。否则就用二进制版本内建的包 这种做法的好处是：1、充分利用版本中的已经发布的资源，以减小补丁包的体积2、补丁包的打包规则可以几乎无视完整包的分包规则，方便后续折腾 当然缺点也是很严重的： Reserved Total - Unity引擎在内存方面的总体分配量。Unity引擎的内存并不是随用随取，而是预先从操作系统中申请一块，然后再进行使用。 Uesd Total - Unity引擎再内存方面的总体使用量。 Reserved Unity &amp; Used Unity - Unity引擎自身各个模块内部的内存分配，宝库偶各个Manager的内存占用、序列化信息的内存站哟个，WebStream/SerializedFile内存占用和部分资源的内存暂用等等。]]></content>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gcc]]></title>
    <url>%2F2017%2F10%2F23%2Fgcc%2F</url>
    <content type="text"><![CDATA[extern staticextern 指为导出到其它文件所使用的非statice变量static是当前文件的静态变量二者不能同时定义setarch i386 ./config -m32编译32位的openssh缺少 gnu/stubs-32.h yum install glibc-devel.i686 gcc没有找到 yum install libstdc++-devel.i686 yum install -y gcc gcc+ gcc-c++]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity Shader PBR]]></title>
    <url>%2F2017%2F10%2F23%2FShaderLab%2F</url>
    <content type="text"><![CDATA[观察两个空间阴影映射(Shadow Mapping)牵涉到两个空间的Z深度比较,一个是灯光空间,一个是相机空间,首先打开ShadowMapping_2下的场景,场景是默认的相机视角,单击下面的Light View按钮,可以切换到灯光视角,13.1.2 两个视角的Z深度分别单机LightView Depth和CamView Depth,然后到Shadow/ShadowMapping工程文件夹下面找到_CamViewZDepth和_LightViewZDepth两张Render Texture,查看一下渲染输出的ZDepth13.1.3 渲染Z深度的材质这两张ZDepth是分别在灯光视角和相机使用Replacement Shader 渲染出来的在vertex函数vert中,主要操作除了对物体形体的必要输出外,就是UNITY_TRANSFERDEPTH(o.depth),打开UnityCG.cginc文件,会发现它一般情况下的操作就是o.depth = o.pos.zw,把物体在投影空间做的zw值赋给o.depth,再将它的值输出到一张Render Texture 之前,通过Linear01Depth(d)函数把Z的值变换到01空间,这样我们可以看到一张对比度更强的Z深度图,就像在上面所看到的那样,而不是一张大多数情况下都朦朦胧胧的Z深度图13.2 投射Z深度13.2.1 准备灯光视角的投影矩阵 在进行映射阴影经典的Z深度比较之前,我们需要把灯光视角ZDepth深度图投射到相机视角.打开ShadowMapping_3下的场景.和上一个场景系相比,附加在Main Camera物体上的ShadowMapping_3.cs13.3.4 对Z值进行偏移显然,Z的精度是个问题,而且通过上述编码操作我们已经解决了Shadow ance的问题,但是主要问题依然,这个现象叫Peter Panning,源自迪尼斯的一部动画主角Peter Pan,他的影子可以脱离自身活动起来,打开 分开处理反射面的绝缘体特性和金属属性，最后光照应该是Diffuse+Specular 纯金属没有Diffuse，非金属主要是Diffuse，有一点反射 光部分主要有3个东西影响：微表面的法线分布（NDF），微表面的入射和反射遮挡（Geometry Function），反射率和入射角的关系（Fresnel反射）。]]></content>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua中元方法_newindex详解]]></title>
    <url>%2F2017%2F10%2F23%2Fnewindex%2F</url>
    <content type="text"><![CDATA[__index元方法用于处理调用table中不存在的字段和查询__newindex用于更新 123456789101112131415161718192021local smartMan = &#123; name = "lyf", money = 900, sayHello = function() print("hello,I’m lyf"); end&#125;local t1 = &#123;&#125;local mt = &#123; __index = smartMan,&#125;setmetatable(t1, mt);t1.sayHello = function() print("en");endt1.sayHello() 这是一个模仿继承结构的例子mt作为t1的元表,设置__index为smartMan于是,当我们调用t1中不存在的字段时,就会自动去smartMan中查找比如我们调用了t1.sayHello(),自然就能找到对应的函数 1234567891011121314151617181920212223242526272829 local smartMan = &#123; name = "none", money = 9000000, sayHello = function() print("Hello world!"); end &#125; local t1 = &#123;&#125;; local mt = &#123; __index = smartMan, __newindex = function(table, key, value) print(key .. "字段是不存在的，不要试图给它赋值！"); end &#125; setmetatable(t1, mt); t1.sayHello = function() print("en"); end t1.sayHello() 留意mt元表,我们给他加了一个newindex导致sayHello字段赋值失败,因为给sayHello字段赋值的时候,调用了index元方法,代替了赋值操作和index一样,newindex元方法也可以赋值一个table__newindex规则 如果__newindex是一个函数,则在给table不存在的字段赋值时,会调用这个函数 如果newindex是一个table,则在给table不存在的字段赋值时,会直接给newindex的table赋值 Lua类和继承实现Lua本身不能像C++那样直接实现继承，但是可以用table来实现1234567Object = &#123;class_id = 0&#125;funtion Object:New(o) o = o or &#123;&#125; setmetatable(o, self) -- 对象o调用不存在的成员时会去self中查找，而这里的self指的就是Object self.__index = self return oend]]></content>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c]]></title>
    <url>%2F2017%2F10%2F22%2Fc%2F</url>
    <content type="text"><![CDATA[先被声明为‘extern’后又被声明为‘static’In file included from src/mt_mysql_connector.cpp:14:0:/usr/include/mysql/my_global.h: 在函数‘double log2(double)’中:/usr/include/mysql/my_global.h:823:35: 错误：‘double log2(double)’先被声明为‘extern’后又被声明为‘static’ [-fpermissive] static inline double log2(double x)static 声明的全局变量只能在当前源文件中使用。extern不是定义，是引入（声明）在其它源文件中定义的非static全局变量]]></content>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lua-select]]></title>
    <url>%2F2017%2F10%2F20%2Flua-select%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[lua]]></title>
    <url>%2F2017%2F10%2F20%2Flua%2F</url>
    <content type="text"><![CDATA[让lua编译时计算由于lua的编译速度相当快，而且这种迭代编译的过程仅仅在程序加载的时候进行一次，故而可以带来性能的提高；一些在系统初始化可以决定的参数（比如从配置文件中读出来的数据直接编译为常量置入程序中。 1234567891011121314151617local select = selectlocal setmetatable = setmetatablelocal getfenv = getfenvlocal setfenc = setfenvlocal loadstring = loadstringlocal type = typelocal tostring = tostringlocal next = nextlocal unpack = unpacklocal assert = assertlocal string = stringlocal table = tablelocal io = iolocal function result(...) return select("#", ...), select(1, ...) -- 参数的个数，第一个参数end Lua的upvalue和闭包Lua函数可以被当成参数传递，也可以被当成结果返回，在函数体中仍然可以定义内嵌函数，Lua闭包是Lua函数生成的数据对象。每个闭包可以有一个upvalue值，或者多个闭包共享一个upvalue值。 1.upvalue如果函数f2定义在函数f1中，那么f2为f1的内嵌函数，f1 什么是JITJIT=Just In Time即时编译，是动态编译的一种形式，是一种优化虚拟机运行的技术。程序运行通常有两种方式，一种是静态编译，一种是动态编译，即使编译混合了这二者。Java和.Net/mono中都使用了这种技术。然而IOS中禁止使用（不是针对JIT，而是所有的动态编译都不支持） 为什么要使用JIT解释执行： 效率低 代码暴露 静态编译： 不够灵活，无法热更新 平台兼容性差。 JIT： 效率：高于解释执行，低于静态编译。 安全性：一般都会先转换成字节码。 热更新：无论源码还是字节码本质都是资源文件。 兼容性：虚拟机会处理平台差异，对用户透明。 JIT是如何实现的这里讲的实际上是JIT的一个变种：自适应动态编译(adaptive dynamic compilation)。它分为两种：Method JIT和Trace JIT。如图所示，这是jvmjit的流程：简单来讲：1.跟踪热点函数或trace，编译成机器码执行，并缓存起来供以后使用。2.非热点函数解释执行。 为什么只编译热点函数？对只执行一次的代码而言，解释执行其实总是比JIT编译要快。对这些代码做JIT编译在执行，可以说是得补偿式。而对于只执行少量次数的代码，JIT编译带来的执行速度的提升也未必必能抵消掉最初编译带来的开销。只有对频繁执行的代码，JIT编译才能保证有正面的收益。 Lua元素(Metatable)1.定义算术操作符和关系操作符的行为 + __add * __mul - __sub / __div - __unm(for negation) 自减 % __mod ^ __pow 关系操作符 == __eq &lt; __lt &lt;= __le 元方法__index当我们访问某个不存在的字段的时候，就会调用__index元方法。 1.1 源文件划分1.虚拟机运转核心功能|源文件名 |功能 |前缀||———————:|———————————————:|—-:||lapi.c |C语言接口 |luaC||lctype.c |C标准库中ctype相关实现 |||ldebug.c |Debug 接口 |||ldo.c |函数调用以及栈管理 |luaD||lfunc.c |函数原型及闭包管理 |||lgc.c |垃圾回收 |||lmem.c |内存管理接口 |||lobject.c |对象操作的一些函数 |||lopcodes.c |虚拟机的字节码定义 |||lstate.c |全局状态机 |||lstring.c |字符串池 |||ltable.c |表类型的相关操作 |luaH||ltm.c |元方法 |||lvm.c |虚拟机 |||lzio.c |输入流接口 |luaZ| 2.源代码解析以及预编译字节码|源文件名 |功能 |前缀||———————:|———————————————:|—-:||lcode.c |代码生成器|||ldump.c |序列化预编译的Lua字节码|||llex.c |词法分析器|||lparser.c |解析器|||lundump.c |还原预编译的字节码|| 3.内嵌库|源文件名 |功能 |前缀||———————:|———————————————:|—-:||lauxlib.c |库编写用到的辅助函数库|||lbaselib.c |基础库|||lbitlib.c |位操作库|||ldblib.c |Debug库|||lini.c | 内嵌库的初始化|||liolib.c |IO库|||lstrlib.c |字符串库|||ltablib.c |表处理库|| 4.可执行的解析器，字节码编译器|源文件名 |功能 |前缀||———————:|———————————————:|—-:||lua.c |解释器|||luac.c |字节码编译器|| 1.3 Lua核心Lua核心部分仅包括Lua虚拟机的运转。Lua虚拟机的行为是由一组组opcode控制的。这些opcode定义在lopcodes.h及lopcodes.c中。而虚拟机对opcode的解析和运作在lvm.c中，其API以luaV为前缀。 Lua虚拟机的外在数据形式是一个lua_State结构体，取名State大概意为Lua虚拟机的当前状态。全局State引用了整个虚拟机的所有数据。这个全局State的相关代码放在lstate.c中，API使用luaE为前缀。 函数的运行流程：函数调用及返回则放在ldo.c中，相关API以luaD为前缀。 Lua中最复杂和重要的三种数据类型function、table、string的实现分属在lfunc.c、ltable.c、lstring.c中。这三组内部API分别以luaF、luaH、luaS为前缀命名。不同的数据类型最终呗统一定义为LuaObject，相关操作在lobject.c中，API以luaO为前缀。 Lua从第五版后增加了元表，元表的处理在ltm.c中，API以luaT为前缀。 另外，核心系统还用到两个基础设施：内存管理lmem.c，API以luaM为前缀；带缓存的流处理lzio.c，API以luaZ为前缀。 最后是核心系统里最为复杂的部分，垃圾回收部分，在lgc.c中实现，API以luaC为前缀。 Lua设计的初衷之一就为了最好的和宿主系统相结合。它是一门嵌入式语言，所以必须提供和宿主系统交互API。这些API以C函数的形式提供，大多数实现在lapi.c中。API直接以lua为前缀，可供C编写的程序库直接调用。 1.4 代码翻译及预编译字节码光有核心代码和一个虚拟机还无法让Lua程序运行起来。因为必须从外部输入将Lua运行起来。Lua的脚本需要经过解析得到内部的数据结构（常量和opcode的集合）。这个是用parser:lparser.c （luaY:语法解析)及词法分析llex.c(luaX) 解析完脚本代码，还需要最终生成code码，在lcode.c中实现。luaK 为了满足某些需求，加快代码翻译的流程。还可以采用预编译的过程。把运行时编译的结果，生成为字节码。这个过程以及逆过程由ldump.c和lundump.c实现。luaU 1.5 内嵌库作为嵌入式语言，其实完全可以不提供任何库及函数。全部由宿主系统注入到State中即可。也的确有许多系统是这么用的。但Lua的官方版本还是提供了少量必要的库。尤其是一些基础函数paris、error、setmetatable、type等等，完成了语言的一些基本特性，几乎很难不使用。 而coroutine、string、table、math等等库，也很常用。Lua提供了一套简洁的方案，允许你自由加载你需要的部分，以控制最终执行文件的体积和内存的占用量。主动加载这些内建库进入lua_State，是由在lualib.h中的API实现的。 1234567891011121314static TValue *index2addr (lua_State *L, int idx) &#123; CallInfo *ci = L-&gt;ci; if (idx &gt; 0) &#123; TValue *o = ci-&gt;func + idx; api_check(L, idx &lt;= ci-&gt;top - (ci-&gt;func + 1), "unacceptable index"); if (o &gt;= L-&gt;top) return NONVALIDVALUE; else return o; &#125; else if (!ispseudo(idx)) &#123; /* nagative index */ api_check(L, idx != 0 &amp;&amp; -idx &lt;= L-&gt;top - (ci-&gt;func + 1), "invalid index"); return L-&gt;top + idx; &#125; ...&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class LuaMgr&#123; public static Module GetModule(string name) &#123; Module m = m_modules.PG_TryGetValue(name); if (m == null) &#123; ... &#125; // repeat if (m.m_state != Module.State.None) &#123; if (m.m_state == Module.State.Failed) return null; return m; &#125; var L = m_L;//lua_State string[] names = name.Split(m_dotSep); // mulit file LuaDLL.lua_pushvalue(L, LuaIndexes.LUA_GLOBALSINDEX); // 0 for (int i = 0; i &lt; names.Length; ++ i) &#123; LuaDLL.lua_pushstring(L, names[i]); LuaDLL.lua_rawget(L, -2); // var t = LuaDLL.lua_type(L, -1); // 1 switch (t) &#123; case LuaTypes.LUA_TNIL: LuaDLL.lua_pop(L, 1); luaDLL.lua_newtable(L); luaDLL.lua_pushstring(L, names[i]); luaDLL.lua_pushvalue(L, -2); LuaDLL.lua_rawset(L, -4); // _G.name = module LuaDLL.lua_rawgeti(L, LuaIndexes.LUA_REGISTRYINDEX, m_ref_globalMeta); LuaDLL.lua_setmetatable(L, -2); LuaDLL.lua_pushvalue(L, -1); LuaDLL.lua_setfield(L, -2, "_M"); // module._M = module break; case LuaTypes.LUA_TTABLE: break; default: m.m_state = Module.State.Failed; LuaDLL.lua_pop(L, 2); return null; &#125; LuaDLL.lua_remove(L, -2); &#125; m.m_index = ++m_moduleIndex; m.m_ref_module = LuaDLL.luaL_ref(L, luaIndexes.LUA_REGISTRYINDEX); ReloadModule(m); return m; &#125;&#125;public static int LoadModule()&#123; var L = LuaMgr.m_L; string name = LuaDLL.lua_tosting(L, 1); var m = LuaMgr.GetModule(name); LuaDLL.lua_pushboolean(L, m != null); return 1;&#125; 1.7 阅读源代码的次序首先、阅读外围的库是如何实现功能扩展的，这样可以熟悉Lua公开API，不必陷入功能细节。然后、阅读API的具体实现。Lua对外暴露的API可以说是一个对内部模块的一层封装，这个层次尚未触及核心，但可以对核心代码有个初步的了解。之后、可以开始了解Lua VM的实现。接下来就是分别理解函数调用、返回，string,table,metatable等如何实现。debug模块是一个额外的设施，但可以帮助你理解Lua内部细节。最后是parser等编译相关的部分。垃圾回收是最难的部分，可能会花掉最多的时间去理解细节。]]></content>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[expect]]></title>
    <url>%2F2017%2F10%2F19%2Fexpect%2F</url>
    <content type="text"><![CDATA[安装 yum install -y tcl tclx tcl-develExpect是一个免费的免费的编程工具语言，用来实现自动和交互任务进行通信，而无需人的干预。expect是交互性很强的脚本语言，可以帮助运维人员实现批量管理成千上百台服务器操作，是一款很实用的批量部署工具！下载：expect-5.43.0.tar和tcl8.4.11-src.tar]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作记录]]></title>
    <url>%2F2017%2F10%2F19%2Fserver%2F</url>
    <content type="text"><![CDATA[pwd: ~/work_codemkdbg_allvim src/ini/Jenkins_Script/compile.sh IN DIR:BNMSGamePlay, make all with Makefile_debug.mk all 115 make[3]: 进入目录“/root/work_code/src/svr/BNMSGamePlay”116 ==== making DLL file … ====117 g++ -DLINUX -D_FILE_OFFSET_BITS=64 -D_LARGEFILE64_SOURCE -D_LARGEFILE_SOURCE -Wall -Wno-multichar -g -D_DEBUG -DPG_MEMORY_DISABLE_POOL -march=core2 -m32 -rdynamic -std=c++0x -o ../../bin/debug/svr/BNMSGamePlay/BNMSGamePlay_d.so ../../temp/debug/svr/BNMSGamePlay/BNMSGamePlay.s.o_d /root/work_code/src/lib/libBNMSGamePlay_Lib_d.s.a /root/work_code/src/lib/lib PNGS_d.s.a /root/work_code/src/lib/libWHNET_d.s.a /root/work_code/src/lib/libWHCMN_d.s.a -lpthread -ldl -lrt -march=prescott -shared -L/root/work_code/3rd/lib -L/root/work_code/src/lib118 /usr/bin/ld: skipping incompatible /usr/lib/gcc/x86_64-redhat-linux/4.8.5/libstdc++.so when searching for -lstdc++119 /usr/bin/ld: cannot find -lstdc++120 /usr/bin/ld: skipping incompatible /usr/lib/gcc/x86_64-redhat-linux/4.8.5/libgcc_s.so when searching for -lgcc_s121 /usr/bin/ld: cannot find -lgcc_s122 collect2: 错误：ld 返回 1123 make[3]: * [../../bin/debug/svr/BNMSGamePlay/BNMSGamePlay_d.so] 错误 1124 make[3]: 离开目录“/root/work_code/src/svr/BNMSGamePlay” 1ldconfig #更新缓冲 g++ -DLINUX -D_FILE_OFFSET_BITS=64 -D_LARGEFILE64_SOURCE -D_LARGEFILE_SOURCE -Wall -Wno-multichar -g -D_DEBUG -DPG_MEMORY_DISABLE_POOL -march=core2 -m32 -rdynamic -std=c++0x -o ../../bin/debug/xxsy/ScnSvr_AllInOne/ScnSvr_AllInOne_d ../../temp/debug/xxsy/ScnSvr_AllInOne/ScnSvr_AllInOne.o_d /root/work_code/src/lib/libGSDB_Lib_d.a /root/work_code/src/lib/li bScnSvr_d.a /root/work_code/src/lib/libGZSGamePlay_Lib_d.a /root/work_code/src/lib/libMCE4Chat_d.a /root/work_code/src/lib/libMCE_d.a /root/work_code/src/lib/libDIA4DBI_d.a /root/work_code/src/lib/libDIA_d.a /root/work_code/src/lib/libPNGS_d.a /root/work_code/src/lib/libWHNET_d.a /root/work_code/src/lib/libWHCMN_d.a /root/work_code/src/lib/libxxsy_cmn_d.a /root/work_code/src/lib/libpgcmn_d.a -lpathfind_d -lcJSON_d -lcryptlib_d -llua_d -lzlib_d -ltss_sdk_d -lz -ldl -lssl -lpthread -ldl -lrt -march=prescott -L/root/work_code/3rd/lib -L/root/work_code/src/libg++ -DLINUX -D_FILE_OFFSET_BITS=64 -D_LARGEFILE64_SOURCE -D_LARGEFILE_SOURCE -Wall -Wno-multichar -g -D_DEBUG -DPG_MEMORY_DISABLE_POOL -march=core2 -m32 -rdynamic -std=c++0x -o ../../bin/debug/xxsy/ScnSvr_AllInOne/ScnSvr_AllInOne_d ../../temp/debug/xxsy/ScnSvr_AllInOne/ScnSvr_AllInOne.o_d /root/work_code/src/lib/libGSDB_Lib_d.a /root/work_code/src/lib/libScnSvr_d.a /root/work_code/src/lib/libGZSGamePlay_Lib_d.a /root/work_code/src/lib/libMCE4Chat_d.a /root/work_code/src/lib/libMCE_d.a /root/work_code/src/lib/libDIA4DBI_d.a /root/work_code/src/lib/libDIA_d.a /root/work_code/src/lib/libPNGS_d.a /root/work_code/src/lib/libWHNET_d.a /root/work_code/src/lib/libWHCMN_d.a /root/work_code/src/lib/libxxsy_cmn_d.a /root/work_code/src/lib/libpgcmn_d.a -lpathfind_d -lcJSON_d -lcryptlib_d -llua_d -lzlib_d -ltss_sdk_d -lz -ldl -lssl -lpthread -ldl -lrt -march=prescott -L/root/work_code/3rd/lib -L/root/work_code/src/lib -pthread/root/work_code/3rd/lib/liblua_d.a(core_profiler.o_d)：在函数‘lprofP_init_core_profiler’中：/root/work_code/3rd/lua/profiler/core_profiler.c:154: 警告：the use of tmpnam&#39; is dangerous, better usemkstemp’/usr/bin/ld: /root/work_code/src/lib/libScnSvr_d.a(RegScn.o_d): undefined reference to symbol ‘EVP_sha256@@libcrypto.so.10’/lib/libcrypto.so.10: error adding symbols: DSO missing from command line]]></content>
      <tags>
        <tag>server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VMware12中CentOS7网络设置]]></title>
    <url>%2F2017%2F10%2F18%2FVm%2F</url>
    <content type="text"><![CDATA[VMware提供了三种将虚拟网卡和物理网卡捆绑起来的方式，即桥接(Bridge）模式，网络地址转换(Network Address Transformation, NAT)模式和主机(Host Only)模式。三种模式区别，参见关于三种模式的区别，简单而言，Bridge模式直接将虚拟机添加到局域网中，使虚拟机看起来像网内的一台真实计算机，虚拟网卡和宿主物理网卡之间不存在名义上的从属关系，因而需要局域网内具有多余的IP地址能够提供给虚拟机网卡，如果局域网内严格给每台计算机分配固定的IP，那这种Bridge模式就基本失效。在Bridge模式下虚拟机既可以访问到Internet也可以同局域网内的其他真实计算机通信；NAT模式下宿主的物理网卡就充当了路由器或交换机的角色，这时VMware会根据宿主的真实IP提供很多Subset IP供虚拟机使用，这样所有的虚拟机都是通过宿主的网络端口进行对Internet的访问，但看起来这些虚拟计算机都合法地访问到了局域网或者Internet，因为他们的IP地址通过NAT技术之后看起来是合法的。Host Only模式下虚拟机之间可以相互通信，但虚拟机并不能同局域网内的其他真实计算机直接通信，但该模式下通过宿主访问Internet还是可以的。VM的虚拟网卡可以被设置成上述的三种网络连接模式，默认情况下，VMnet0被设置成为Bridge模式，VMnet1被设置为Host Only模式，而VMnet8的默认连接方式为NAT模式。VMnet2-VMnet7和VMnet9这七块虚拟网卡用户可以自定义，但是在所有的虚拟网卡中仅有一块能被设置为NAT模式，默认情况就是VMnet8。用户可以在VMware workstation-&gt;编辑-&gt;虚拟网络编辑器 中查看这些信息。这里已NAT模式配置 打开“网络和共享中心”选择“VMware Virtual Ethernet Adapter for VMnet8”网卡右键属性，选择VMware Bridge Protocol,同时设置ip自动获取 将物理网卡网络分享给VMware Virtual Ethernet Adapter for VMnet8 虚拟机网络连接设置为NAT模式，选择虚拟机，右键》设置》网络适配器》NAT 模式 检验网络是否正常，不正常，检测ifcfg-e**(每台可能不一样)中的bootproto是不是dhcp，如果不是则修改为dhcp，此外还需要设置onboot = yes; 然后用命令service network restart重启网络连接，就可以连上网络了]]></content>
      <tags>
        <tag>VMware</tag>
        <tag>CentOS7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[www]]></title>
    <url>%2F2017%2F10%2F16%2Fwww%2F</url>
    <content type="text"><![CDATA[StartCoroutine开启一个协程，yield return是迭代器返回调用迭代的地方。协程至少产生十几还是多少B的GC具体是多少我忘记了，至少在5.3.8f2之前的版本是，未来如果有时间和有机会我会讲解一个可以避免掉GC的办法。CoroutineTool，本篇不再介绍范围内。一个协程的执行可以在任何地方用yield语句来暂停，yield return的值决定了什么时候协程恢复执行。WWW的加载方式，本身会增加FileSystem的崩溃率，然后还增加显存占用提高了Present的崩溃率。]]></content>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins]]></title>
    <url>%2F2017%2F10%2F16%2FJenkins%2F</url>
    <content type="text"><![CDATA[添加Jenkins的源（repository） sudo wget -O /etc/yum.repos.d/jenkins.repo http://jenkins-ci.org/redhat/jenkins.repo sudo rpm —import http://pkg.jenkins-ci.org/redhat/jenkins-ci.org.key 安装/检查JDK java —version # 这个必须安装成功 sudo yum install java-1.6.0-openjdk # 我用的1.8 安装Jenkins: sudo yum install jenkins 安装完成后，有如下相关目录：/usr/lib/jenkins/ :jenkins安装目录，WAR包会放在这里。 cd /usr/lib/jenkins ll 启动Jenkins echo &amp;JAVA_HOME /usr/java/…(懒的复制了)昨天还好好的，今天不知道为什么访问不了，各种查最后通过 service jenkins start搞定了，但是昨天一直没关，ps -aux | grep “jenkins” 也能找到。奇怪。不过使用service jenkins start之后多了一个。]]></content>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[makefile]]></title>
    <url>%2F2017%2F10%2F15%2Fmakefile%2F</url>
    <content type="text"><![CDATA[make: Nothing to be done for xxxx中间文件、链接文件C、C++要把源文件编译成中间代码文件，在Windows是.obj文件，在Linux是.o文件，即Object File，这一步叫做编译。然后把这些Object File合成可执行文件，这一步叫做链接(link)。编译时，编译器需要的是语法正确，函数和变量声明正确，然后编译中中间目标文件。一般来说每个源文件都对应一个中间目标文件（O文件或者OBJ文件）。链接主要是链接函数和全局变量，所以我们可以使用这些中间目标文件来链接我们的可执行文件。链接器并不考虑源文件，只考虑中间目标文件（OBJ文件），大点的项目文件成千上百，导致会变成生成太多的中间文件，而链接时需要明确指出中间目标文件名，这对于编译很不方便，所以出现了库文件来合并这些目标文件windows下“库文件”（Library File）.lib文件，在Liunx下叫Archive File（.a）文件，所以一般包Link 错误就是指没有找到这个中间文件，即没有找到该声明的实现（一般情况下）。 Makefilemake命令执行时，需要一个Makefile（一般是.mk 缺省Makefile或者makefile，作者习惯Makefile.mk）文件，告诉make命令如何编译和链接程序。规则：1234target ... : prerequisites ... command ... ... target也就是一个目标文件，可是是Object File，也可以是执行文件。还可以是一个标签（Label）。prerequisites就是，要生成那个target所需要的文件或目标。command是make需要执行的命令。（Shell命令）这是一个依赖关系，就是说，target这一个或多个目标文件依赖于prerequisties中的文件，而规则是由command决定的。也就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。这就是Makefile的规则。 ifeq的用法 ifeq($(SRCFILE),) else ifeq() endif如果没有变量值，则判断是否定义，有则判断是否相等./test.sh -f config.conf -v —prefix=/home我们称-f为选项，它需要一个参数，即config.conf，-v也是一个选项，但它不需要参数。—prefix我们称之为长选项，即选项本身多余一个字符，它也需要一个参数，用等号连接，当然等号不是必须的，/home可以直接卸载—prefix后面，即—prefix/home。伪目标、虚目标伪目标不是一个真正的文件名，在执行make时可以指定这个目标执行 如果我们需要书写这样一个规则：规则所定义的命令不是去创建目标文件，而是使用make指定具体的目标来执行一些特定的命令。像下边那样： clean: rm .o temp规则中”rm”不是创建文件”clean”的命令，只是删除当前目录下的所有.O文件和temp文件。在工作目录下不存在”clean”这个文件时，我们输入”make clean”后，”rm .o temp”总会被执行。这是我们的初衷。但当前工作目录下存在”clean”时情况就不一样了，在我们输入”make clean”时。规则没有依赖文件，所以目标被认为是最新的而不去执行规则所定义的命令，命令”rm”将不会被执行。这并不是我们的初衷。为了避免这个问题，我们可以将目标”clean”明确声明为伪目标。讲一个目标声明为伪目标需要将它作为特殊目标.PHONY的依赖。如下： .PHONY: dummy_help all dep obj cleanobj cleanint cleanout clean veryclean verycleanint install dirint dirout dirs pch cleanpch这样dummy_help等就是一些伪目标或者说是虚目标，无论当前目录下是否存在”clean”这个文件。我们输入”make clean”之后，”rm”命令都会被执行。而且当一个目标被声明为伪目标后，make在执行规则时不会试图去查找隐含规则来创建这个目标。这样也提高了make的执行效率，同时我们也不用担心由于目标和文件名重名而使我们的期望失败。在书写伪目标规则时，首先需要声明目标是一个伪目标，之后才是伪目标的规则定义。目标”clean”书写格式应该如下： .PHONY: clean cleanint: cleanobj 移除所有临时文件(目标文件、依赖文件) $(RM) -f $(DEPFILE_TO_DEL) cleanout: ifeq ($(ISWHAT),LIB) 库 $(RM) -f $(TargetOutFile).* else ifeq ($(ISWHAT),EXE) EXE文件 $(RM) -f $(TargetOutFile) else DLL或其他 $(RM) -f $(TargetOutFile).* ifneq ($(OutDirLib),) $(RM) -f $(TargetOutFileLib).* endif endif endif cleanpch: $(RM) -f $(PchFile) clean: cleanint cleanout cleanpch @echo ==== clean now ==== 通配符通配符是一种特殊语句，主要有星号(*)和问号(?)，用来模糊搜索文件 Makefile中的wildcard用法在Makefile规则中，通配符会被自动展开。但在变量的定义和函数引用时，通配符将失效。这种情况下如果需要通配符有效，就需要使用函数”wildcard”，它的用法是：$(wildcard PATTERN…)。在Makefile中，它被展开为已经存在的、使用空格分开的、匹配此模式的所有文件列表。如果不存在任何符合此模式的文件，函数会忽略模式字符并返回空。需要 Linux make 保存错误日志$mkdbg all 2&gt;&amp;1|tee xxx.log这条命令是编译并保存打印信息。在Linux Shell的设备定义中，“0”表示标准输入，“1”表示标准输出，“2”表示标准出错信息输出。2&gt;&amp;1表示把2设备的信息重定向到1设 备；“|”是管道符号，把标准输出的信息直接传递给后面的命令；tee是创建文件并保存信息的工具；xxx.log是文件名。这种管道的用法在Linux Shell命令中使用非常普遍。编译过程中都可以使用这个方法，生成日志文件，保存到buildlogs目录下。 1 # 编译模式名 2 ConfigurationName := debug 3 # 用于体现该编译模式的文件标记 4 # (对于debug版来说，比如目标文件后缀就会变成._do) 5 CfgFileTag := _d 6 # 编译选项 7 #CCFlag := -Wall -g -D_DEBUG -march=native 8 CFlag := -Wall -Wno-multichar -g -D_DEBUG -DPG_MEMORY_DISABLE_POOL -march=core2 -m32 -rdynamic 9 CCFlag := $(CFlag) -std=c++0x 10 11 #CCFlag := -finput-charset=gb2312 -Wall -g -D_DEBUG 12 # 连接选项 13 #LNFlag := -lpthread -march=native 14 LNFlag := -lpthread -ldl -lrt -march=prescott]]></content>
      <tags>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gdb]]></title>
    <url>%2F2017%2F10%2F15%2Fgdb%2F</url>
    <content type="text"><![CDATA[断点 break filename:linenum 在源文件filename的linenum行处停住。d 清除所有断点|—|—||step(s)|执行下一句，如果有函数则进入函数里面执行|set follow-fork-mode parentglibc-2.17-196.el7.i686 libgcc-4.8.5-16.el7.i686 libstdc++-4.8.5-16.el7.i686gdb debugme pidclear 删除所在行的所有断点clear 12 //删除12行的所有断点clear list.c:12 //删除该文件该行号的所有断点b list.c:12 // 在该文件该行号添加断点backtrace\bt 打印全部栈帧的简要信息，按Ctrl-c可终止打印。finish 跳出当前函数。 调试守护进程如果需要调试子进程，在启动gbd后：set follow-fork-mode child并在子进程代码设置断点此外还有detach-on-fork参数，只是gdb在fork之后是否断开(detach)某个进程的调试，或者都交由GDB控制。 观察点(WatchPoint)在变量读、写或变化时中断，这类方式常用来定位bug。 watch 变量发生变化时中断 rwatch 变量被读时中断 awatch 变量值被读或写时中断 条件断点(gdb) b 13 if i == 8 程序运行参数set args 可指定运行时的参数。(如：set args 10 20 30 40 50show args 命令可以查看设置好的运行参数 打印堆栈bt显示所有的函数调用的栈帧信息，每个帧一行。]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux]]></title>
    <url>%2F2017%2F10%2F15%2Flinux%2F</url>
    <content type="text"><![CDATA[例子：将目录A重命名为B mv A B 例子：将/a目录移动到/b下，并重命名为c mv /a /b/c yum install wget yum install gcc yum install gcc-c++ wget http://ftp.gnu.org/pub/gnu/ncurses/ncurses-5.6.tar.gz tar -zxvf ./configure -prefix=/usr/local -with-shared-without-debug make &gt; t.log make install no termcap library foundwget http://ftp.gnu.org/gnu/termcap/termcap-1.3.1.tar.gztar -zxvf termcap-1.3.1.tar.gzcd termcap./configure —helpset t.logvim t.log/MACHTYPE=x86_64-redhat-linux-gnuyum install gdb (这尼玛坑爹呀) du查看某个文件或目录占空间大小du -ah du -sh linux下修改.bash_profile立即生效的方法 source .bash_profile exec bash —login linux中文乱码查看当前系统默认的字符集locale安装中文包yum -y groupinstall chinese-support 生效export LANG=”zh_CN.UTF-8”重新载入. /etc/profile 解决中文乱码export LC_ALL=”zh_CN.utf8” Linux中安装gcc g++ yum方式123yum -y install gccyum -y install gcc-c++yum intall make Linux注销用户who 列出登陆的用户列表 whoroot@localhost:~/work_code/src/svr&gt; whoroot pts/0 2017-10-20 06:33 (192.168.171.1)root@localhost:~/work_code/src/svr&gt; pkill -kill -t pts/0 cannot find -lgcc_s在64位Centos7上编译32位C程序，因为是编译32位的目标程序，所以使用gcc编译的时候需要加上-m32选项，但是编译的话会报错，如下：1234root@localhost:~/work_code&gt; gcc -g -m32 -o hello hello.c/usr/bin/ld: skipping incompatible /usr/lib/gcc/x86_64-redhat-linux/4.8.5/libgcc_s.so when searching for -lgcc_s/usr/bin/ld: cannot find -lgcc_scollect2: 错误：ld 返回 1 getconf LONG_BIT #查看自己版本是32位还是64位32位的库yum install glibc-devel.i686yum install libstdc++-devel.i686 kill -2 和 kill -9的区别-2类似Ctrl + C 是程序在结束之前，能够保存相关数据，然后在退出。-9直接强制结束程序。 硬链接(hard link)和软链接(符号链接，fsoft link或symbolic link)我们知道文件都有文件名和数据，在Linux上被分成两个部分：用户数据(user data)和元数据(metadata)。用户数据，即文件数据块(data block)，数据块时记录文件真实内容的地方；而元数据则是文件的附加属性，如文件大小、创建时间、所有者等信息。在Linux中，元数据中的inode号(inode是文件元数据的一部分但其并不包含文件名，inode号即索引节点号)才是文件的唯一标识而非文件名。文件名仅是为了方便人们的记忆和使用，系统或程序通过inode号寻找正确的文件数据块。若一个inode号对应多个文件名，则称这些文件为硬链接。换言之，硬链接就是同一个文件使用了多个别名。硬链接可由命令link或ln创建。 link oldfile newfile ln oldfile newfile由于硬链接有着相同inode号仅文件名不同的文件，因此硬链接存在以下几点特性： 文件有相同的inode及data block； 只能对已存在的文件进行创建； 不能交叉文件系统进行硬链接的创建； 不能对目录进行创建，只可对文件创建； 删除一个硬链接文件并不影响其它有相同inode号的文件。软连接与硬链接不同，若文件用户数据块存放的内容是另一文件的路径名的指向，则该文件就是软连接。软链接就是普通文件，只是数据块内容有点特殊。软链接有着自己的inode号以及用户数据块usage: ln -s 源文件 目标文件 ssh登录方法ssh -l username ip 永久性获取ROOT权限sudo passwd su 64位linux机器上编译32位openssl库setarch i386 ./config -m32 wget http://zlib.net/zlib-1.2.11.tar.gz tar -zxvf zlib-1.2.111.tar.gz cd zlib-1.2.11 ./configure --prefix=/usr/local make &amp;&amp; make install find ./ -name &quot;*.o&quot; -exec rm {} \; make: ***[install_docs] Error 1 vim /usr/bin/pod2man 注释69行# i386 几乎所有的X86平台i686 只是i386的一个子集 在EC2上创建root用户，并使用root用户登录su vim /etc/ssh/sshd_config 找到PasswordAuthentication no，把no改成yes PermitRootLogin yes sudo /sbin/service sshd restart su root Linux内存管理&lt;% img asset_img Linux1.webp %&gt;在linux中，每一个进程都被抽象为task_struct结构体中，成为进程描述符，存储着进程各方面的信息；例如打开的文件，信号以及内存等等；然后task_struct中的一个属性mm_struct管理着进程的所有虚拟内存，成为内存描述符。在mm_struct结构体中，存储着进程各个内存段的开始以及结尾，如上图所示；进程使用的物理内存，即常驻内存RSS页数，这个内存使用的虚拟地址空间VSZ页数，还有进程虚拟内存区域集合和页表。从上图可以看出，进程有代码段Text segment,数据段（已初始化的全局，静态变量），BSS段（未初始化的全局，静态变量），堆，内存映射区以及栈；每一块虚拟内存区（VMA）都是由一块连续的虚拟地址组成，这些地址从不覆盖。一个vm_area_struct实例描述了一块内存区域，包括这块内存区域开始以及结尾地址；flags标志决定了这块内存的访问权限和行为；vm_file决定这块内存是由哪个文件映射的，如果没有文件映射，则这块内存为匿名的(anonymous)。上图中提到的每个内存段，都对应一个vm_area_struct结构。如下图所示&lt;% asset_img Linux2.webp %&gt;上图即为/bin/gonzo进程的内存布局。程序的二进制文件映射到代码段和数据段，代码段为只读只执行，不可更改；全局以及静态的未初始化的变量映射到BSS段，为匿名映射，堆和栈也是匿名映射，因为没有相对应的文件映射；内存映射区可以映射共享库，映射文件以及匿名映射，所以这块内存段可以使文件映射也可以是匿名映射。而且不同的文件，映射到不同的vm_area_struct区。这些vm_area_struct集合存储在mm_struct中的一个单向链表和红黑树中；当输出/proc/pid/maps文件时，只需要遍历这个链表即可。红黑树主要是为了快速定位到某一个内存块，红黑树的跟存储在mm_rb域。线性地址需要通过页表才能转换为物理地址。每个进程的内存描述符也保存了这个进程页表指针pgd,每一块虚拟内存页都和页表的某一项对应。虚拟内存是不存储任何数据的，它只是将地址空间映射到物理内存。物理内存有内核伙伴系统分配，如果一块物理内存没有被映射，就可以被伙伴系统分配给虚拟内存。刚分配的物理内存可能是匿名的，存储进程数据，也可能是缓存，存储文件或块设备的数据。一块虚拟内存vm_area_struct块是由连续的虚拟内存也组成的，而这些虚拟内存块映射的物理内存却不一定连续，如下图所示：&lt;% asset_img Linux3.webp %&gt;]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[svn]]></title>
    <url>%2F2017%2F10%2F15%2Fsvn%2F</url>
    <content type="text"><![CDATA[svn: E200002: line 19: Option expected错误解决这是因为修改svnserve.conf时，打开注释时，配置的前面有空格，应该顶格写。修改后即可。 解决svn Authorization failed错误出现该问题基本都是三个配置文件的问题，下面把这个文件列出来svnserve.conf:[general]anon-access = readauth-access = writepassword-db = passwdauthz-db = authzpasswd:[users]admin=123authz:[groups][/]admin= rw出现authorization failed异常，一般都是authz文件里，用户组或者用户权限没有配置好，只要设置[/]就可以，代表根目录下所有的资源，如果要限定资源，可以加上 子目录即可。 checkoutsvn checkout path（path是服务器上的目录） 例如：svn checkout svn://192.168.171.128/zentia/trunk/xxprj/server revertsvn revert [-R] dir CentOS下svn迁移备份的三种方法一般采用三种方式： svnadmin dump svnadmin hotcopy svnsync注意，svn备份不宜采用普通的文件拷贝方式（除非你很懂svn，并且将库暂停），如copy、rsync命令。svnadmin dump是官方推荐的备份方式，优点是比较灵活，可以全量备份也可以增量备份，并提供了版本恢复机制。缺点：如果版本比较大，如版本数增长到数万、数十万，那么dump的过程将非常慢；备份耗时，恢复更耗时；不利于快速进行灾难恢复。个人建议在版本数比较小的情况下使用这种备份方式。svnadmin hotcopy原设计目的估计不是用来备份的，只能进行全量拷贝，不能进行增量备份；优点是：备份过程较快，灾难恢复也很快；如果备份机上已经搭建了svn服务，甚至不需要恢复，只需要进行简单配置即可切换到备份库上工作。缺点是：比较消耗硬盘，需要有较大的硬盘支持。svnsync实际上是CentOS下SVN服务的启动语关闭svnserve -d -r /home/svn/home/svn 为版本的根目录关闭SVN服务：ps aux | grep svnkill -s 9 6443464434为进程ID 或者 killall svnserve linux下SVN中改变执行权限本地文件在commit到仓库之前若没有chmod+x权限的话，拿在svn仓库里的文件将会保持当前无可执行属性状态，我们可以做svn命令修改。SVN中，如果我们在linux下提交权限为755文件，就会在svn的属性中存在一个svn:executable。只在本地chmod 644 ，是不能造成修改的。svn propset svn:executable on * （注意，如果包含目录会执行失败）svn commit 前一个操作被卡住的问题去官网下载win32那个包就可以了。sqlite3.exe .svn/wc.db “delete from wc_lock”sqlite3.exe .svn/wc.db “delete from work_queue”/OUT:”F:\zentia\server\bin\vc120debugs\glogger_d.exe” /MANIFEST /NXCOMPAT /PDB:”F:\zentia\server\bin\vc120debugs\glogger_d.pdb” /DYNAMICBASE:NO “WHCMN_d.lib” “WHNET_d.lib” “PNGS_d.lib” “cryptlib_d.lib” “zlib_d.lib” “kernel32.lib” “user32.lib” “gdi32.lib” “winspool.lib” “comdlg32.lib” “advapi32.lib” “shell32.lib” “ole32.lib” “oleaut32.lib” “uuid.lib” “odbc32.lib” “odbccp32.lib” /FIXED /LARGEADDRESSAWARE /IMPLIB:”F:\zentia\server\bin\vc120debugs\glogger_d.lib” /DEBUG /MACHINE:X86 /OPT:NOREF /SAFESEH:NO /INCREMENTAL /PGD:”F:\zentia\server\bin\vc120debugs\glogger_d.pgd” /SUBSYSTEM:CONSOLE”,5.01” /MANIFESTUAC:”level=’asInvoker’ uiAccess=’false’” /ManifestFile:”F:\zentia\server\temp\vc120\glogger2010\debug\glogger_d.exe.intermediate.manifest” /OPT:NOICF /ERRORREPORT:PROMPT /NOLOGO /LIBPATH:”F:\zentia\server\src\svr\glogger\/lib/win32” /LIBPATH:”F:\zentia\server\lib\vc120lib\” /LIBPATH:”F:\zentia\server\3rd\lib\vc120\” /LIBPATH:”F:\zentia\server\3rd\lib” /LIBPATH:”%(AdditionalLibraryDirectories)” /TLBID:1g++ -DLINUX -D_FILE_OFFSET_BITS=64 -D_LARGEFILE64_SOURCE -D_LARGEFILE_SOURCE -Wall -Wno-multichar -g -D_DEBUG -DPG_MEMORY_DISABLE_POOL -march=core2 -m32 -rdynamic -std=c++0x -o ../../bin/debug/svr/GBNMS/GBNMS_d.so ../../temp/debug/svr/GBNMS/GBNMS.s.o_d /root/work_code/src/lib/libGBNMS_Lib_d.s.a /root/work_code/src/lib/libDIA_d.s.a /root/work_code/src/lib/libPNGS_d.s.a /root/work_code/src/lib/lib WHNET_d.s.a /root/work_code/src/lib/libWHCMN_d.s.a /usr/lib64/mysql/libmysqlclient_r.a -lz -lpthread -ldl -lrt -march=prescott -shared -L/root/work_code/3rd/lib -L/root/work_code/src/lib 拉分支svnserve -d -r /var/svn启动svn服务器，但是客户端还是一直连接不上 svn info 查看库版本路径 客户端一直连接不上服务器，最后发现是防火墙的问题，最暴力直接关掉防火墙就好啦。 post-commit.tmpl它在事务外城后运行，创建一个新的修订版本。大多数人用这个钩子来发送关于提交的描述性邮件，或者作为版本库的备份。版本库传给程序两个参数：到版本库的路径和被创建的新的修订版本号。退出程序时被忽略。 关闭防火墙重启后生效开启: chkconfig iptables on关闭: chkconfig iptables off即时生效，重启后失效开启：service iptables start关闭：service iptables stop 查看磁盘空间df -h 创建版本库12345678mkdir /var/svn# 进入svn目录cd /var/svn # 用svn管理员创建bigsvrsvnadmin create /var/svn/bigsvr# 进入库cd bigsvr subversion目录说明db 所有版本控制的数据存放目录hooks 放置hook脚本locks 用户操作的锁文件format 记录当前文件库的版本号conf 配置文件 Svn命令行总结 上传项目到SVN服务器上 svn import project_dir(本地项目全路径) 下载checkout svn项目到本地 svn checkout 简写：svn co 添加新文件 svn add file(文件名) svn add *.php(添加当前目录下所有的php文件) 提交到版本库 svn commit -m “LogMessage” [-N] [—no-unlock] PATH(如果选择了保持锁，就使用—no-unlock开关) 更新文件 svn update svn update -r 修正版本 文件名 svn update (后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本) svn update -r 200 test.cpp (将版本库中的文件test.cpp还原到修正版本(revision)200) svn update test.php (更新于版本库同步) 设置忽略 svn propset svn:ignore Temp . relocate svn switch —relocate svn://18.223.184.177/project/ss/ss/bin/data svn://18.223.184.177/project/ss/ss/bin/data]]></content>
      <tags>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7下 vim]]></title>
    <url>%2F2017%2F10%2F14%2Fvi%2F</url>
    <content type="text"><![CDATA[1yum -y install vim 环境配置 /etc/vimrc 全局 vim ~/.vimrc 新建1234567set nu // 行号set showmode //显示当前模式set ruler //显示行数信息set autoindent //回车对齐syntax on //语法检测set encoding=urf-8 fileencodings=ucs-born,utf-8,cp936 //自动识别编码，如果没有找到，用latin-1(ASCII)编码打开(解决乱码问题)set ts=4 //四个空格 vi查看文件编码格式 :set fileencoding:edit ++enc=utf-8 最后来看看处理中文文档最典型的几种情况和设置方式： 1，系统locale是utf-8（很多linux系统默认的locale形式），编辑的文档是GB2312或GBK形式的（Windows记事本 默认保存形式，大部分编辑器也默认保存为这个形式，所以最常见），终端类型utf-8（也就是假定客户端是putty类的unicode软件） 则vim打开文档后，encoding=utf-8（locale决定的），fileencoding=latin1（自动编码判断机制不准导致的），termencoding=空（默认无需转换term编码），显示文件为乱码。 解决方案1：首先要修正fileencoding为cp936或者euc-cn（二者一样的，只不过叫法不同），注意修正的方法不是:set fileencoding=cp936，这只是将文件保存为cp936，正确的方法是重新以cp936的编码方式加载文件为:edit ++enc=cp936，可以简写为:e ++enc=cp936。 解决方案2：临时改变vim运行的locale环境，方法是以LANG=zh_CN vim abc.txt的方式来启动vim，则此时encoding=euc-cn（locale决定的），fileencoding=空（此locale下文件 编码自动判别功能不启用，所以fileencoding为文件本身编码方式不变，也就是euc-cn），termencoding=空（默认值，为空则等 于encoding）此时还是乱码的，因为我们的ssh终端认为接受的数据为utf-8，但vim发送数据为euc-cn，所以还是不对。此时再用命令: set termencoding=utf-8将终端数据输出为utf-8，则显示正常。 2，情况与1基本相同，只是使用的ssh软件为secure CRT类ansi类软件。 vim打开文档后，encoding=utf-8（locale决定的），fileencoding=latin1（自动编码判断机制不准导致的），termencoding=空（默认无需转换term编码），显示文件为乱码。 解决方案1：首先要保证运行secure CRT的windows机器的默认代码页为CP936，这一点中文windows已经是默认设置了。其他的与上面方案1相同，只是要增加一步，:set termencoding=cp936 解决方案2：与上面方案2类似，不过最后一步修改termencoding省略即可，在此情况下需要的修改最少，只要以locale为zh_CN开 启vim，则encoding=euc-cn，fileencoding和termencoding都为空即为encoding的值，是最理想的一种情 况。 可见理解这3个关键点和3个参数的意义，对于编码问题有很大助力，以后就可以随心所欲的处理文档了，同时不仅仅是应用于vim，在其他需要编码转换的环境里，都可以应用类似的思路来处理问题解决问题。 行跳转 12gg / 12G :12 打开文件时输入vim +12 filename vim 精确匹配查找单词精确匹配查找单词如果你输入 “/the”，你也可能找到”there”。要找到以”the”结尾的单次，可以用: /the> “>“是一个特殊的记号，表示只匹配单词末尾。类似的，”\&lt;” 只匹配单词的开头。这样要匹配一个完整的单词”the”，只需要: /\ :e 刷新文件内容]]></content>
      <tags>
        <tag>vi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql]]></title>
    <url>%2F2017%2F10%2F14%2Fmysql%2F</url>
    <content type="text"><![CDATA[修改mysql密码12345mysql -uroot -puse mysql;UPDATE user SET password=password("123456") WHERE user='root'; flush privileges;exit; 1SHOW DATABASES; 首先CentOS7 已经不支持mysql，因为收费了你懂得，所以内部集成了mariadb，而安装mysql的话会和mariadb的文件冲突，所以需要先卸载掉mariadb，以下为卸载mariadb，安装mysql的步骤。 列出所有被安装的rpm packagerpm -qa | grep mariadb 卸载rpm -e mariadb-libs-5.5.37-1.el7_0.x86_64错误：依赖检测失败：libmysqlclient.so.18()(64bit) 被 (已安裝) postfix-2:2.10.1-6.el7.x86_64 需要libmysqlclient.so.18(libmysqlclient_18)(64bit) 被 (已安裝) postfix-2:2.10.1-6.el7.x86_64 需要 强制卸载，因为没有—nodepsrpm -e —nodeps mariadb-libs-5.5.37-1.el7_0.x86_64 安装mysql依赖yum install vim libaio net-tools 其他情况： 1、centos下yum暂时没有mysql-server直接安装包；MariaDB是MySQL社区开发的分支，也是一个增强型的替代品; 2、安装MariaDB（目前还是先不要安装了）yum -y install mariadb-server mariadb mariadb-develsystemctl start mariadbsystemctl enable mariadbmysql_secure_installationfirewall-cmd —permanent —add-service mysqlsystemctl restart firewalld.serviceiptables -L -n|grep 3306 CentOS7的yum源中默认好像是没有mysql的。为了解决这个问题，我们要先下载mysql的repo源。 下载mysql的repo源 $ wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm 安装mysql-community-release-el7-5.noarch.rpm包 $ sudo rpm -ivh mysql-community-release-el7-5.noarch.rpm 安装这个包后，会获得两个mysql的yum repo源：/etc/yum.repos.d/mysql-community.repo，/etc/yum.repos.d/mysql-community-source.repo。 安装mysql $ sudo yum install mysql-server根据步骤安装就可以了，不过安装完成后，没有密码，需要重置密码。 重置密码重置密码前，首先要登录$ mysql -u root登录时有可能报这样的错：ERROR 2002 (HY000): Can‘t connect to local MySQL server through socket ‘/var/lib/mysql/mysql.sock‘ (2)，原因是/var/lib/mysql的访问权限问题。下面的命令把/var/lib/mysql的拥有者改为当前用户：$ sudo chown -R openscanner:openscanner /var/lib/mysql然后，重启服务：$ service mysqld restart 开放3306端口$ sudo vim /etc/sysconfig/iptables添加以下内容：-A INPUT -p tcp -m state —state NEW -m tcp —dport 3306 -j ACCEPT保存后重启防火墙：$ sudo service iptables restart这样从其它客户机也可以连接上mysql服务了。MYSQL启动后报：ERROR! The server quit without updating PID file错误的问题解决MYSQL日志：Can’t find file: ‘./mysql/plugin.frm’ (errno: 13 - Permission denied) 权限不够：chown -R mysql:mysql /home/mysql/data” chmod -R 755 /home/mysql/data centos7的selinux问题：打开/etc/selinux/config，把SELINUX=enforcing改为SELINUX=disabled后存盘退出重启机器。查看存储过程的创建代码show create procedure proc_name; ERROR 1728 (HY000): Cannot load from mysql.proc. The table is probably corrupted【错误过程】：MySQL从5.1升级至5.5后在调用存储过程时报出“Cannot load from mysql.proc. The table is probably corrupted。”【造成原因】：MySQL升级完成后未对相关数据库执行升级.【解决办法】：在命令行中执行mysql_upgrade -uroot -p 即可~ 查看Mysql端口show global variables like &#39;port&#39;; 字符集系统变量 character_set_server 默认的内部操作字符集 character_set_client 客户端来源数据使用的字符集 character_set_connection 连接层字符集 character_set_results 查询结果字符集 character_set_database 当前选中数据库的默认字符集 character_set_system 系统元数据（字段名等）字符集 查看show variables like &#39;character_set_database&#39;; show variables like &#39;%character%&#39;; show variables like &#39;collation%&#39;; 修改临时修改alter database xxx CHARACTER SET gb2312; // 修改库的字符集 SET character_set_client = utf8; 永久修改修改my.cnf 位置在/etc/my.cnf在[mysqld]上面加下面两句话 [client] default-character-set=utf8 在[mysqld]最下面加入下面几句话 default-storage-engine=INNODB character-set-server=utf8 collation-server=utf8_general_ci 然后保存 重启Mysql service mysqld restart 查看MYSQL所支持的字符集show charset; 查看库的字符集show create database db_xxsy_game_1004\G; 查看表的字符集show table status from db_xxsy_game_1004 like &#39;common_accounts&#39;; CentOS7 开放3306端口访问CentOS 7.0默认使用的是firewall作为防火墙，这里改为iptables防火墙。1、关闭firewall：systemctl stop firewalld.servicesystemctl disable firewalld.servicesystemctl mask firewalld.service 2、安装iptables防火墙yum install iptables-services -y 3.启动设置防火墙 # systemctl enable iptables # systemctl start iptables 4.查看防火墙状态 systemctl status iptables 5编辑防火墙，增加端口vi /etc/sysconfig/iptables #编辑防火墙配置文件-A INPUT -m state —state NEW -m tcp -p tcp —dport 22 -j ACCEPT-A INPUT -m state —state NEW -m tcp -p tcp —dport 80 -j ACCEPT-A INPUT -m state —state NEW -m tcp -p tcp —dport 3306 -j ACCEPT:wq! #保存退出 3.重启配置，重启系统systemctl restart iptables.service #重启防火墙使配置生效systemctl enable iptables.service #设置防火墙开机启动 Host ‘192.168.171.128’ is not allowed to connect to this MySQL serverERROR 1044 (42000):Access denied for user ‘’@’localhost’ to database ‘mysql’在mysql数据库的user表里，存在用户名为空的账户即为匿名账户，导致登陆的时候虽然用的时root，但实际时匿名登陆的。解决办法： 关闭mysqlservice mysqld stop 屏蔽权限mysqld_safe —skip-grant-table 新开一个终端mysql -u root mysqldelete from user where user=’’;flush privileges; mysql.h no found file or directoryyum install mysql-devel 数据类型 解释 存储范围 字节 TINYINT 有符号值:-128到127unsigned : [0 255] 1 SMALLINT signed[-32768,32767]unsigned [0,65535] 2 BINARY 用来表示二进制数据 VARBINARY 大小写忽略 CHAR和VARCHAR类型都用来存储字符串VARCHAR 可以存储可变长度的字符串CHAR 存储定长字符串定义如下CHAR(M)或者VARCHAR(M)M指的是字符串的最大长度比如插入值’ab’CHAR(4) 需要4个字节VARCHAR(4) 需要3个字节当数据为CHAR(M)类型时，不管插入值的长度是多少，所占用的存储空间都是M个字节。当为VARCHAR(M)类型时，所占用的字节数为实际长度加1。 BINARY和VARBINARY类型类似于CHAR和VARCHAR用来表示二进制数据定义如下BINARY(M)或者VARBINARY(M)M指的是二进制数据的最大字节长度注意BINARY类型的长度是固定的，如果数据的长度不足最大长度，在后面用”\0”补齐。比如，数据类型为BINARY(3)，当插入a时，实际存储的时”a\0\0” Centos7安装Mysqlyum install mysql yum install mysql-devel yum install mariadb-server mariadb systemctl start mariadb]]></content>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云主机CentOS7.2密钥丢失重新注入密钥方法]]></title>
    <url>%2F2017%2F10%2F13%2Fcentos%2F</url>
    <content type="text"><![CDATA[一、单用户模式重置ROOT密码（如有root密码，则跳过该步骤） 登录控制台，输入VNC密码并回车 点击【Send CtrlAltDel】重启linux系统； 在弹出界面，按键盘‘e’；4、如图修改前/修改后，将ro修改成rw init=/sysroot/bin/sh 去除console=ttyS0 115200，确认修改完成后，键盘输入Ctrl加x。 5、依次输入如下命令：chroot /sysroot/ passwd root touch /.autorelabel进行root密码修改6、返回云主机侧点击【重启】使得密码修改生效7、待云主机重启完成后，进入VNC输入用户名root，修改后的密码进入系统]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 服务器搭建]]></title>
    <url>%2F2017%2F10%2F13%2Fgit-server%2F</url>
    <content type="text"><![CDATA[首先要明确现在代码的分布情况，开发者电脑上的本地仓库，git服务器上的远端仓库，web服务器上的另一个本地仓库，我们浏览器访问的就是这里的代码。其实自动部署就是要当开发者本地仓库提交代码到远端仓库的时候，自动把代码部署到web服务器的本地仓库，实现开发着本地仓库和web服务器的本地仓库同步。（即通过GitHook中的post-receive脚本文件） 1、安装Git12yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-develyum install git 接下来我们创建一个git用户组和用户，用来运行git服务：12groupadd gitadduser git -g git 3、初始化Git仓库12$ git init --bare runoob.gitInitialized empty Git repository in /home/gitrepo/ git init 使用当前目录作为Git仓库,该命令执行完后回生成一个.git目录git init zentia 指定目录创建Git仓库 修改/etc/ssh/sshd_config文件，将其中的PermitRootLogin no修改为yes,PublicAuthentication yes修改为no,AuthorizedKeysFile .ssh/authorized_keys前面加上的#屏蔽掉,PasswordAuthentication no修改为yes就可以了ssh -l username hostname 在服务器checkout出一份代码123# In remote servercd ~git clone sample.git/ my_repo 这个时候就会出现my_repo文件夹，里面就会有你的代码。同时，这个代码文件夹的默认origin远端（remote）就会变成my_repo文件夹。当你做git fetch git pull等动作的时候就会从my_repo取信息。3.配置Git Hook进入到/home/gitrepo/sample.git文件夹，使用vi post-receive创建一个脚本，当你在本地仓库执行git push后就会触发post-receive。 /usr/games/project.git/git clone git@ec2-18-191-158-223.us-east-2.compute.amazonaws.com:/usr/games/project.git/添加到本地仓库 git add . 添加提交描述 git commit -m ‘内容’ 提交前先从远程仓库🐖分支中拉取请求 git pull origin master 把本地仓库代码提交 git push -u origin master]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git clone 命令]]></title>
    <url>%2F2017%2F10%2F13%2Fgit-clone%2F</url>
    <content type="text"><![CDATA[git clone 命令将存储库克隆到新目录中。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssh]]></title>
    <url>%2F2017%2F10%2F13%2Fssh-key%2F</url>
    <content type="text"><![CDATA[ssh中，有两个钥匙：公钥、私钥，公钥主要是用于对一些敏感信息进行加密，私钥适用于解密。ssh的文件都存在于机器~/.ssh中。 客户端：id_rsa(私钥)、id_rsa.pub(公钥)、known_hosts(已知远程主机) 服务端: authorized_keys(验证过的公钥列表)、sshd_config(ssh配置文件) 设置ssh连接不断开vim /etc/ssh/sshd_config # 客户端每隔多少秒向服务器发送一个心跳数据 ClientAliveInterval 30 # 客户端多少秒没有响应，服务器自动断掉连接 ClientAliveCountMax 1800 service sshd restart]]></content>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站部署规则]]></title>
    <url>%2F2017%2F10%2F13%2Fsite-dealy-role%2F</url>
    <content type="text"><![CDATA[网站发布只在自己笔记本电脑发布，公司电脑只能hexo s —debug,不能 hexo d -g本地内容修改完成之后记得123git add . git commit -am "m"git push origin master]]></content>
  </entry>
  <entry>
    <title><![CDATA[fatal:remote error You can't push to git 的解决办法]]></title>
    <url>%2F2017%2F10%2F13%2Fgithub-remote-error%2F</url>
    <content type="text"><![CDATA[branch正确的情况下，不知为什么，在push的时候出现:123fatal: remote error:You can't push to git://github.com/zentia/hexo.gitUse git@github.com:zentia/hexo.git 解决办法:123git remote rm origingit remote add origin git@github.com:zentia/hexo.gitgit push origin master]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity Shader]]></title>
    <url>%2F2017%2F10%2F12%2Fshader%2F</url>
    <content type="text"><![CDATA[CGPROGRAM和ENDCG包裹的部分就是CG\HLSL语言部分。 Vertex &amp; Fragment Shader: 顶点/片元着色器。它是最基本，也是非常强大的着色器类型。一般用于2D场景、特效之类的。Unlit Shader(无光照着色器，不包含无效)在世界三维空间中，一开始传入Shader处理的数据其实就是网格数据(Mesh Data)但是一般情况下，光是网格数据不能满足我们处理画面的需求，这时就需要引入一些常数属性数据(Properties)属性的声明规则如下： _Name(“Display Name”, type)=defaultValue[{options}] _Name是属性的名字，也就是变量名，在之后整个Shader代码中将使用这个名字来获取该属性的内容，切记要添加下划线。 Displayer Name 这个字符串将显示在Unity的Inspector中作为Shader的使用者可读的内容，即显示的名称。 type属性的类型。常用的有几种：Color颜色，一般为RGBA的数组；2D纹理，宽高为2的幂次尺寸；Rect纹理，对应非2的幂次尺寸；Cube立方体，即6张2D纹理组成；Float和Range，都是浮点数，但是Range要求定义最小值和最大值，以Range(min,max)形式显示；Vector四位数。 defauleValue默认值，与类型直接挂钩。一开始赋予该属性的初始值，但是在检视窗口调整过属性值之后，不再有效。Color以0~1定义rgba颜色，比如(1,1,1,1)；2D/Rect/Cube，对于纹理来说，默认可以为一个代表默认tint颜色字符串，可以使空字符串或者”white”，”black”等中的一个；Float和Range为某个指定的浮点数；同样，Vector的是一个四维数值，(x,y,z,w)的形式。 Options可选项，它只对2D，Rect或者Cube纹理有关，一般填入OpenGL中TexGen的模式。这样我们可以尝试解读上图中的那些属性声明的是声明了。比如_MainTex(“A Texture”, 2D)=””{},就是声明了一个变量名为_MainTex的2次幂尺寸纹理，它在检视窗口中显示的名称是A Texture，默认是空的。 语义语义（Semantics）是附加到着色器输入或输出的字符串，其传达关于参数的预期使用的信息。对于在着色器级之间传递的所有变量都需要语义，通常，在流水线级之间传递的数据是完全通用的，并且不被系统唯一地解释；允许任意语义没有特殊意义。 Surface Shader: 表面着色器。它拥有更多的光照运算，其实在系统内部它会被编译成一个比较复杂的顶点/片元着色器。Standard Surface Shader(标准光照模型表面着色器) Standard Shader: 标准着色。它是表面着色器升级版，因为它使用了Physically Based Rendering（简称PBR）技术，即基于物理的渲染技术。所以在这个着色器中开放了更多处理光照与材质的参数。 Tag表面着色器可以被若干的标签(tags)所修饰，而硬件将通过判定这些标签来决定什么时候调用该着色器。比如我们的粒子中SubShader的第一句Tags{“RenderType”=”Opaque”}告诉了系统应该在渲染非透明物体的时调用我们。Unity定义了一系列这样的渲染过程，与RenderType是Opaque相对应的显而易见的是”RenderType”=”Transparent”，表明渲染含有透明效果的物体时调用它。在这里Tags其实暗示了你的Shader输出的是什么，如果是渲染非透明物体，那添加”Queue”=”Opaque”标签；如果渲染透明或者半透明的像素，那添加”Queue”=”Transparent”。另外比较有用的标签”IgnoreProject”=”True”(不背Projectors影响)，”ForceNoShadowCasting”=”True”(从不产生阴影)以及”Queue”=”xxx”(指定渲染顺序队列)。这里想要赵忠说一下的是Queue这个标签，如果你使用Unity做过一些透明和不透明物体的混合的话，很可能已经遇到过不透明物体无法呈现在透明物体之后的情况。这种情况很可能是由于Shader的渲染顺序不正确导致的。Queue指定了物体的渲染顺序，预定义的Queue有： Background - 最早被调用的渲染，用来渲染天空盒或者背景 Geometry - 这是默认值，用来渲染非透明的物体（普通情况下，场景中的绝大多数物体应该是非透明的） AlphaTest - 用来渲染经过Alpha Test的像素，单独为AlphaTest设定一个Queue是出于对效率的考虑 Overlay - 用来渲染效果的叠加，是渲染的最后阶段（比如镜头光晕等效果） 这些预设值本质是一组整数，Background = 1000(背景), Geometry = 2000(几何体), AlphaTest = 2450(alpha测试), Transparent = 3000(透明),最后Overlay = 4000。在我们实际设置Queue值时，不仅能使用上面的几个预定义值，我们也可以指定自己的Queue值，写成类似这样：”Queue”=”Transparent+100”,表示一个在Transparent之后100的Queue上进行调用。通过调整Queue值，我们可以确保某些物体一定在另一些物体之前或者之后渲染。 LODLOD很简单，它是Level of Detail的缩写，在这里例子里我们指定了其为200（其实这是Unity的内建Diffuse着色器的设定值）。这个数值决定了我们能用上面样的Shader。在Unity的Quality Settings中我们可以设定允许最大LOD，当设定的LOD小于SubShader所指定的LOD时，这个SubShader将不可用。Unity内建Shader定义了一组LOD的数值，我们在实现自己的Shader的时候可以将其作为参考来设定自己的LOD数值，这样在之后调整根据设备图形性能来调整画质时可以紧急性比较精确的控制。 VertexLit及其系列 = 100 Decal,Reflective VertexLit = 150 Diffuse = 200 Diffuse Detail,Reflective Bumped Unlit,Reflective Bumped VertexLit = 250 Bumped,Specular = 300 Bumped Specular = 400 Parallax = 500 Parallax Specular = 600 Shader本体123456789101112131415CGPROGRAM#pragma surface surf Lambertsampler2D _MainTex;struct Input &#123; float2 uv_MainTex;&#125;;void surf(Input IN, inout SurfaceOutput o)&#123; half4 c = tex2D(_MainTex, IN.uv_MainTex); o.Albedo = c.rgb; o.Alpha = c.a;&#125;ENDCG 还是逐行来看，首先是CGPROGRAM。这是一个开始标记，表明从这里开始是一段CG程序（我们在写Unity的Shader时用的是Cg/HLSL语言）。最后一行的ENDCG与CGPROGRAM是对应的，表明CG程序到此结束。接下来是一个编译指令：#program surface surf Lambert,它表明了我们要写一个表面Shader，并指明了光照模型。它的写法是这样的 #pragma surface surfaceFunction lightModel [optionalparams] surface -表明的是一个表明着色器 surfaceFunction -着色器代码的方法的名字 lightModel -使用的光照模型我们声明了一个表面着色器，实际的代码在surf函数，使用Lambert(也就是普通的diffuse)作为光照模型。接下来一句sampler2D MainTex,sampler2D是个啥？其实在CG中，sampler2D就是和Texture所绑定的一个数据容器接口。等等..这个说法还是太复杂了，简单理解的话，所谓加载以后的texture(贴图)说白了不过是一块内存存储的，使用了RGB(也许还有A)通道，且每个通道8bits的数据。而具体想知道像素与坐标的对应关系，以及获取这些数据，我们总不能一次次去自己计算内存地址或者偏移，因此可能通过sampler2D来对贴图进行操作。更简单理解，sampler2D就是GLSL中的2D贴图类型，相应的，还有smapler1D,sampler2D,samplerCube等等格式。解释通了sampler2D是什么之后，还需要解释下为什么在这里需要一句对_MainTex的声明，之前我们不是已经在Properties里声明过它是贴图了么。答案是我们用来实力的这个shader其实是由两个相对独立的块组成的，外层的属性声明，回滚等等是Unity可以直接使用和编译的ShaderLab;而现在我们是CGPROGRAM..ENDCG这样一个代码块中，这是一段CG程序。对于这段CG程序，要想访问在Properties中所定义的变量的话，必须使用和之前变量形同的名字进行声明。于是其实sampler2D _MainTex;做的事情就是再次声明并链接了_MainTex,使接下来的CG程序能够使用这个变量。解释通了sampler2D是什么之后，还需要解释为什么在这里需要一句对_MainTex的声明，之前我们不是已经在Properties里声明过它是贴图了吗。答案是我们用来实力的这个shader其实是由两个独立的快组成的，外层的属性声明，会。- 在CG中，函数就像C中那样声明。你可以随意的指定传递给函数的参数，以及将被函数啊发你会的值。下面是一个简单的函数声明：1234float getX(float3 v)&#123; return v.x;&#125; 这个函数采用了一个三元向量v作为一个参数，并且将v的x分量作为返回值，其类型为float。关键字return被用来返回函数的结果。你可以像调用任何其它Cg函数那样调用getX函数：123456//声明一个临时使用的向量float3 myVector = float3(0.5,1.0,-1.0);//取得myVector的x分量float x = getX(myVector);//现在 x=0.5 有些时候，你想要一个函数返回几个结果而不仅仅是一个结果。在这种情况下，你能够使用out修饰符来指定一个程序的某个特定的参数只用于输出。下面的例子用一个向量作为输入，然后返回它的x、y和z分量。123456void getComponents(float3 vector, out float x, out float y, out float z)&#123; x = vector.x; y = vector.y; z = vector.z;&#125; 注意这个函数被声明为void类型，因为它通过参数来返回所有的值。下面的代码示例显示了getComponents是如何被使用的：12345678//声明一个临时使用的向量float3 myVector = float3(0.5,1.0,-1.0);//声明一个临时使用的变量flaot x,y,z;//获得myVector的x、y和z分量getComponents(myVector, x,y,z);//现在x=0.5,y=1.0,z=-1.0 一个光照函数因为光照是一个复杂的过程，你能够编写许多不同类型的光照函数，每个函数都能接受不同的参数。现在，你只需要采用你实现的简单模型，并为它创建一个函数。下面是这个函数的最基本的样子：1234float3 lighting(float Ke, float3 Ka, float3 Kd,float3 Ks,float shininess,float3 lightPosition,float3 lightColor,float3 globalAmbient,float3 P,float3 N,float3 eyePosition)&#123; //在这里计算光照&#125; 这个方法的一个主要问题是这个函数需要很多参数。把这些参数组成“材质参数”和“光参数”，然后把每个参数集当成一个单独变量来传递，这将使得整个函数整洁许多。幸运的是Cg支持这种结构，恰好能够提供这种功能。 结构Cg的结构使用与C和C++同样的方法来声明。struct关键字被用来声明结构，它后面跟随的是结构的成员。下面是一个结构的例子，它分封装了基于基本光照模型的某个材质的所有性质： Fog语法: Fog {Fog Commands} Mode Off | Global | Linear | Exp | Exp2(雾的模式，缺省值是Global) Color ColorValue(雾的颜色) Density FloatValue(雾的浓度，影响Exp/Exp2) Range FloatValue,FloatValue(雾的开始和结束距离，影响Linear) 注意如果使用了片段着色器的话，着色器种的雾设定仍然是有效的。另外可以通过菜单Edit-&gt;Render Settings可以打开渲染设置 Alpha Test和Alpha BlendingAlpha Test是不需要关闭ZWrite的。Alpha Test要么完全透明，要么完全不透明 Alpha Blending 需要关闭ZWrite，如果不关闭ZWrite，那么在进行深度检测的时候，它背后的物体本来可以被外面看到的，但由于深度检测时大于它的深度就被剔除了，从而我们就看不到它后面的物体了。因此，我们需要保证物体的渲染顺序是从后往前，并且关闭该半透明对象的ZWrite。 Appha Blending 只是关闭ZWrite，但是不会关闭ZTest。这意味着，在输出一个Alpha Blending的fragment时，它还是会判断和当前Color Buffer种的fragment的深度关闭，如果它比当前的fragement深度更远，那么它就不会再做后续的混合操作了； ColorMaskColorMask可让我们指定渲染结果的输出通道，而不是通常情况下的RGBA这4个通道皆会被写入。可选参数是RGBA的任意组合以及0，这将意味着不会写入到任何通道，可以用来单独做一次Z Test，而不将结果写入颜色通道。 _Time_Time是个4维向量，跟Unity3D中的deltaTime（这个是一维的，数值）不同。 名称 类型 说明 _Time float4 t是自该场景加载开始所经过的时间，4个分量分别是(t/20,t,t2,t3) _SinTime float4 t是时间的正弦值，4个分量分别是(t/8,t/4,t/2,t) _CosTime float4 t是时间的余弦值，4个分量分别是(t/8,t/4,t/2,t) unity_DeltaTime float4 dt是时间增量，4个分量分别是(dt,1/dt,smoothDt,1/smoothDt) 上述表格中t表示当前时间，并且只有当游戏运行的时候才要有效，但是不知道如何支持在编辑器有效，懒得研究了。]]></content>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器配置文件说明]]></title>
    <url>%2F2017%2F10%2F12%2Fservercfg%2F</url>
    <content type="text"><![CDATA[摘要：本文档描述手游服务器的各个配置文件的使用和配置参数说明。关键字：服务器 维护 配置 1.概述请先参考《游戏系统架构》以了解手游的服务器架构状况。手游的所有配置文件都采用相同的格式。运维人员会经常用到的配置文件特性有：注释，文件包含include、宏定义、条件读取。 2.各个服务器主要配置参数说明2.1 公共配置文件文件名：cmncfg.txt该文件主要用来被所有的配置文件包含，可以定义一些全局性的信息（比如在不同的服务器配置信息不同的地方就可以放在这个文件里，这样不同的服务器只要修改这一个文件即可。）它一般放在所有服务器程序目录的上层目录，命名为cmncfg.txt典型内容如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788////////////////////////////////////////////// 经常要变的部分////////////////////////////////////////////// 大区的ID（这个配置很重要，如果配置错误会导致所有的角色和物品ID错误，影响合服）#defene SVRGRPID 2// 代表版本字串#define VERMAIN 0.7100// 各类服务器IP定义// 日志服务器的地址#define LOGSVR 192.168.0.49// GMS4Chat#define GMS4CHATINNERIP 192.168.0.49// CAAFS4CHAT#define CAAFS4CHATOUTTERIP 192.168.0.49// GMS4Game#define GMS4GAMEINNERIP 192.168.0.49// DBS#define DBSINNERIP 192.168.0.49// P2PSERVER#define P2POUTTERIP 192.168.0.49// XGMS#define XGMSINNERIP 192.168.0.49// TTYGZS#define TTYGZSINNERIP 192.168.0.49// XCAAFS#define XCAAFSOUTTERIP 192.168.0.49// XCLS#define XCLSOUTERIP 192.168.0.49// 本组配置的端口增量（主要用于在同一台机器上启动多组服务器）#define PORTSHIEF 0// 共享内存增量#define SHMSHIFT 0// 日志的跟路径（注意这个配置，如果在后面加上了"/"则会导致目录创建失败，因为字串中后来形成的//会被当成注释）#define LOGPATH /ITC/LOG// 数据库相关的定义#define DB_HOST localhost// 如果DB_HOST是localhost则需要填写这个，默认值是/tmp/mysql.sock#define DB_SOCKET /TMP/mysql.sock#define DB__USER root#define DB_PASSWORD zentiadb2017#define DB_CHARSET utf8// 用户数据库#define PLAYERDB zentia0// 全局总控相关数据库（GMS4Game使用的）#define IMSDB ims0////////////////////////////////////////////////////// 不经常变的部分////////////////////////////////////////////////////// 表面这是debug版本#define DEBUG// 表明这是内部调试用的，可以放宽一些限制（正常运营时应该注视掉）// #define INNERDEBUG// 表明客户端超时不要太长（在内部测试的时候可能有用，因为有时候需要长时间不断，有时候需要正常超时断）// define QUICKDROP/////////////////////////////////////////////////////// 日志服务定义/////////////////////////////////////////////////////// 日志服务的描述串（根据各个服务器需求的不同分为下面三个等级）#define LOGADDRSTR_0 0,$(LOGSVR):2000+$(PORTSHIFT), 1,$(LOGSVR):2001+$(PORTSHIFT), 2,$(LOGSVR):2002+$(PORTSHIFT)#define LOGADDRSTR_1 0,$(LOGSVR):2000+$(PORTSHIFT), 1,$(LOGSVR):2001+$(PORTSHIFT), 2,$(LOGSVR):2002+$(PORTSHIFT), 3,$(LOGSVR):2003+$(PORTSHIFT), 4,$(LOGSVR):2004+$(PORTSHIFT), 5.$(LOGSVR):2005+$(PORTSHIFT), 6,$(LOGSVR):2006+$(PORTSHIFT)#define LOGADDRSTR_1 0,$(LOGSVR):2000+$(PORTSHIFT), 1,$(LOGSVR):2001+$(PORTSHIFT), 2,$(LOGSVR):2002+$(PORTSHIFT), 3,$(LOGSVR):2003+$(PORTSHIFT), 4,$(LOGSVR):2004+$(PORTSHIFT), 5.$(LOGSVR):2005+$(PORTSHIFT), 6,$(LOGSVR):2006+$(PORTSHIFT), 7,$(LOGSVR):2007+$(PORTSHIFT), 8,$(LOGSVR):2008+$(PORTSHIFT), 9,$(LOGSVR):2009+$(PORTSHIFT), 10,$(LOGSVR):2010+$(PORTSHIFT), 11,$(LOGSVR):2011+$(PORTSHIFT), 12.$(LOGSVR):2012+$(PORTSHIFT), 13,$(LOGSVR):2013$(PORTSHIFT), 14,$(LOGSVR):2014$(PORTSHIFT)// 本大区最多支持的同时在线用户数量#define MAXPLAYER 16000// 服务器间tcp通讯的消息缓冲设置#define MSGBUFFLEN 10*1024*1024// debug版的文件后缀#ifdef DEBUG#define CFGEXT#else#define CFGEXT#endif// 这个只有配置caafs4chat的时候才需要，正常的配置不需要，这个一般不变的，因为CAAFS4Chat一般就起一个即可#define CAAFS4CHATID 1// 是否在GSZ宕掉之后重新拉起自动载入用户#define GZSDOWNRESTOREPLAYER true// CNL网络超时（和客户端的断线超时）#ifdef INNERDEBUG#define DROPTIMEOUT 2000000#else#define DROPTIMEOUT 100000#endif#ifdef QUICKDROP#define DROPTIMEOUT 600000#endif 2.2 GMS4Game配置文件：gms4game_cfg.txt典型内容如下：123456789101112131415161718192021#include ../cmncfg.txtCMN&#123; stream_size = $(MSGBUFFLEN) // 本地监听的地址和端口（供其他服务器连接） tcp_listen_host = $(MYOUTERIP):5000+$(PORTSHIFT) // 和其他服务器TCP连接的超时设置 keepalive_idle = 60000 keepalive_interval = 2000 // MySQL配置 db_host = $(DB_HOST) db_user = $(DB_USER) db_password = $(DB_PASSWORD) db_database = $(IMSDB) db_charset = $(DB_CHARSET) db_socket = $(DB_SOCKET) // 日志服务（这个只需要比较少的日志种类） logger_addr = $(LOGADDRSTR_0) // szPIDFile = /tmp/GMS4Game-$(SVRGRPID).pid&#125; 2.3 XLBA配置文件：lba_cfg.txt典型内容如下（基于XCMNSVR的配置）:gzs_cfg1.txt12 附录1.基于XCMNSVR的配置 XCMNSVR是PNGS框架中的一种标准服务器程序结构。 通过该结构配置的服务器由一个主程序框架：XCMNSVR和一系列的动态连接库插件构成。 其配置文件一般都是下面的样子：12345678910111213141516171819CMN&#123; // 用于记录日志中表示程序名和在windows下显示窗口标题栏上 szSvrName = 服务器名 // 是否运行为后台守护进程（这个选项一般在GDB启动程序进行调试比较有用） bDaemon = true // 日志服务地址 szLoggerAddr = $(LOGADDRSTR) // 每个逻辑循环的最大时间（其大小会影响服务器在没有网络输入输出的情况下的逻辑tick精度） nSelectInterval = 50&#125;PlugIn&#123; // 各个插件的载入和创建参数 // 注意：插件的文件名必须是带路径的。即便是当前路径下也需要写"./"前缀 DLL = 0,/TCPReceiver$(CFGEXT).so,TCPReceiver_Create DLL = 0,/TCPReceiver$(CFGEXT).so,LBACDTest_Create&#125;// 后面跟着各个插件自己需要的参数配置 附录2.CNTRSVR的配置附录3.GSMEM的配置附录4.IP的允许禁止文件的配置]]></content>
      <tags>
        <tag>server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Manual]]></title>
    <url>%2F2017%2F10%2F12%2Fhexo%2F</url>
    <content type="text"><![CDATA[关闭背景动画背景动画基于canvas，个人感觉比较耗，毕竟i3，所以关闭，在\themes\next_config.yml中修改字段1three_waves: false 嵌入PDFnpm install —save hexo-pdf添加 hexo deploy -- 发布 编辑主题的 source/css/_variables/custom.styl 文件，新增变量：12345// 修改成你期望的宽度$content-desktop = 700px// 当视窗超过 1600px 后的宽度$content-desktop-large = 900px 发布： hexo d -g Insert Image1&#123;% asset_img example.jpg This is an example image %&#125; Font1&lt;font size = 4 color=red&gt;&lt;/font&gt; # 字体大小颜色设置 列表嵌套 上一级和下一级之间敲三个空格即可 用pass-by-refrence-to-const替换pass-by-value内置类型，STL迭代器，和函数对象采用pass-by-value不要返回pointer或者reference指向一个on stack对象（被析构）不要返回pointer或者reference指向一个on heap对象（需要用户delete）不要返回pointer或者reference指向local static对象切记将成员变量声明为privateprotected并不比public更有封装性（其实我不是很喜欢封装这个东西）多一个成员函数，就多一分破坏封装性若所有参数都需要类型转换，采用non-member函数（member类型转换不行吗？）]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git笔记]]></title>
    <url>%2F2017%2F10%2F12%2Fgit-question%2F</url>
    <content type="text"><![CDATA[warning:LF will be replaced by CRLF问题解决方法CRLF — Carriage-Return Line-Feed回车(ASCLL 13, \r)换行(LF, ASCLL 10, \n)。解决方法1git config --global core.autocrlf false]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The following untracked working tree files would be overwritten by merge]]></title>
    <url>%2F2017%2F10%2F12%2FThe-following-untracked%2F</url>
    <content type="text"><![CDATA[git pull的时候遇到的问题。解决办法：git clean -d -fxnote:会删除没有add到仓库的文件，操作记得慎重，以免改动文件的丢失。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初始化云服务器]]></title>
    <url>%2F2017%2F10%2F11%2Finit-server%2F</url>
    <content type="text"><![CDATA[注册网易云创建网易云服务器搭建git服务器yum install -y gitadduser git //创建用户gitgit clone git@10.173.32.7:/home/git/sample.git //克隆远程仓库 clone git仓库上传代码git commit -am ““, 将所有修改，但未进stage的改动加入stage,并记录commit信息（某种程度上相当于git add 和 git commit -m的组合,前提是被改动文件已经是tracked)1find ./ -type d -name "del_dir" -exec rm -r &#123;&#125; \; 注意中间的空格]]></content>
      <tags>
        <tag>server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity 2D描边实现介绍]]></title>
    <url>%2F2017%2F10%2F05%2F2d-outline%2F</url>
    <content type="text"><![CDATA[像素着色器描边： 首先最直观的想法，就是使用fragment shader找出2D角色贴图透明像素和非透明像素的边界，然后通过边界周边Alpha值Blur的方式，给边界上描边色。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869Shader &quot;Hidden/NewImageEffectShader&quot;&#123; Properties &#123; _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125; _Offset (&quot;Offset&quot;, Range(0,1)) = 0.1 // 偏移 _Color (&quot;Color&quot;, Color) = (1,0,0,1) // 边缘色 _AlphaThreshold(&quot;Alpha Threshold&quot;, Range(0,1)) = 0.5 &#125; SubShader &#123; Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot;&#125; Blend SrcAlpha OneMinusSrcAlpha Pass &#123; CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;UnityCG.cginc&quot; struct appdata &#123; float4 vertex : POSITION; float2 uv : TEXCOORD0; &#125;; struct v2f &#123; float2 uv[5] : TEXCOORD0; float4 vertex : SV_POSITION; &#125;; sampler2D _MainTex; float4 _MainTex_ST; fixed _Offset; // 偏移 fixed4 _Color; // 边缘色 fixed _AlphaThreshold; // Alpha 阀值 v2f vert (appdata v) &#123; v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.uv[0] = v.uv; o.uv[1] = v.uv + float2(0, _Offset);// 上 o.uv[2] = v.uv + float2(0, -_Offset); // 下 o.uv[3] = v.uv + float2(-_Offset, 0); // 左 o.uv[4] = v.uv + float2(_Offset, 0); // 右 return o; &#125; fixed4 frag (v2f i) : SV_Target &#123; fixed4 col = tex2D(_MainTex, i.uv[0]); fixed alpha = col.a; fixed p1 = tex2D(_MainTex, i.uv[1]).a; fixed p2 = tex2D(_MainTex, i.uv[2]).a; fixed p3 = tex2D(_MainTex, i.uv[3]).a; fixed p4 = tex2D(_MainTex, i.uv[4]).a; alpha = (alpha + p1 + p2 + p3 + p4) / 5; fixed ret = step(alpha, _AlphaThreshold); col.rgb = ret * _Color.rgb + col.rgb * (1-ret); return col; &#125; ENDCG &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566Shader "Hidden/NewImageEffectShader"&#123; Properties &#123; _Edge ("Edge", Range(0,0.5)) = 0.1 // 边缘 _EdgeColor ("Edge Color", Color) = (1,0,0,1) // 边缘色 _FlowColor ("Flow Color", Color) = (0,1,0,1) // 流动色 _Speed ("Speed", Range(0, 2)) = 1 // 旋转速度 _MainTex("MainTex", 2D) = "white" &#123;&#125; // 主纹理 &#125; SubShader &#123; Tags &#123;"Queue" = "Transparent"&#125; Blend SrcAlpha OneMinusSrcAlpha Pass &#123; CGPROGRAM #pragma vertex vert #pragma fragment frag #include "UnityCG.cginc" struct appdata &#123; float4 vertex : POSITION; float2 uv : TEXCOORD0; // 纹理uv坐标 &#125;; struct v2f &#123; float4 vertex : SV_POSITION; float2 uv : TEXCOORD0; &#125;; sampler2D _MainTex; float4 _MainTex_ST; fixed _Edge; // 边缘阀值 fixed4 _EdgeColor; // 边缘色 fixed4 _FlowColor; // 流动色 fixed _Speed; // 旋转速度 v2f vert (appdata v) &#123; v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.uv = v.uv; return o; &#125; fixed4 frag (v2f i) : SV_Target &#123; fixed x = i.uv.x; fixed y = i.uv.y; if (x &lt; _Edge || abs(1 - x) &lt; _Edge || y &lt; _Edge || abs(1 - y) &lt; _Edge) // 求边缘 &#123; x -= 0.5; y -= 0.5; fixed w = _Speed * _Time.y; fixed temp = saturate(x* cos(w) - y* sin(w)); return (temp )* _EdgeColor + (1-temp)*_FlowColor; &#125; return tex2D(_MainTex, i.uv); &#125; ENDCG &#125; &#125;&#125; 后处理+像素着色器描边： 于是，很自然的想到，使用Postprocessing 的方式来处理屏幕最终渲染出来的仅包含有需要描边的角色的图片，然后进行上述的fragment描边处理。 首先，在场景中添加一个专用的描边相机，Depth设为比默认相机高一级，视口大小、位置全部和默认相机一致。另外给场景物体添加一个”Outline1”layer，设置到专用相机的cullingmask，需要描边的角色的layer都设置为”Outline1”。 这个时候专用相机只渲染描边物体，然后给相机添加Monobehavior脚本，在OnRenderImage里对相机渲染的图像进行像素着色器的描边处理，得到如下效果： 描边效果的确是预期的效果，但是还是有两个问题： 一个是：由于我们游戏UI是使用Screen space - camera的方式，它和游戏中对象都是在默认相机渲染的，专用相机的depth比默认相机高一级，所以所有渲染内容都会在UI层次之上，这显然也不是我们想要的。 另一个是：角色的不同行动状态需要用不同的描边颜色来区分，上述方式只支持一种描边颜色。 三、RenderTarget + 像素着色器描边： 现在我们着重来解决上述两个问题：第一个遮挡UI的问题： 描边效果需要在默认相机中进行z轴排序，让其渲染在UI之后，所以，我们需要让描边效果作为一个默认相机渲染的常规游戏对象放到游戏中。于是，我想到的是给它创建一个和屏幕尺寸同大小的Mesh，再将描边渲染的图片放到Mesh上，所以，做法是给专用相机分配一个屏幕尺寸同大小的RenderTarget，然后将RenderTarget渲染到创建的Mesh上。如下图所示，该Mesh在骨骼动画和相机之间创建。 第二个颜色区分的问题： 查询Unity Camera的API有两个回调接口可以用： OnPreRender 在相机渲染场景之前被调用。 OnPostRender 在相机完成场景渲染之后被调用。 我们给专用相机添加这两个回调，在OnPreRender里： 给所有需要描边的物体更换Material，该Material负责绘制该物体的状态纯颜色到RenderTarget上，并保存原有Material。在OnPostRender里： 将原有Material又置换回来供默认相机正常渲染。得到的RenderTarget如下， 这个时候，再用像素着色器对应用了RenderTarget的Mesh进行描边，得到如下效果]]></content>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pixel-and-voxel]]></title>
    <url>%2F2017%2F10%2F05%2Fpixel-and-voxel%2F</url>
    <content type="text"><![CDATA[原文地址: https://medium.com/retronator-magazine/pixels-and-voxels-the-long-answer-5889ecc18190#.8gf6zy8mc 伪3D等轴游戏 赛达尔, Sir Carma, 2016 像素和体素，一个详细的答案Retronator Stray Pixels 像素和体素的区别是什么？ 我很清楚他的问题。你会在生活中看到类似像素大战电影海报这样的东西，而你会对此产生困惑。它是像素吗？还是体素？它是一只鸟？还是一架飞机？这个东西一定不简单。不必害怕，我来解释这个问题。当你阅读完这篇文章后你会知道所有关于像素和体素的知识以及它们之间的联系。 首先我先介绍一点背景知识以便你更好的了解该领域的全貌。在计算机中有两种表示图像的方法：向量和栅格（raster）。 向量图像（左）的数学准确性和栅格图像（右）的离散性向量图像使用各种表示直线，曲线和不同形状的数学方程描述图像。相反，栅格图像将图像描述为一个含有颜色值的数组，该数组中的颜色值依次被放置在一个网格系统中。 计算机图像学中的第二个区别在于2D和3D空间之间的差别。算上向量/栅格的区别总共有四种情况： 大家都喜欢象限！向量图像在2D向量图像中，直线或不同形状上的每个点都由具有两个分量（x和y）的向量来表示。这就是它被称为2D的原因（两个分量——两个维度）。 2D向量是这样表示2D向量图像中每个点的以下是一张所谓的低多边形2D向量图像 伟大梦想着乌鲁鲁（Uluru the Mighty Dreamer）, Anh Tran, 2015它完全使用了2D多边形（在这个情况中为三角形）。低多边形这个术语意味着制成图像所需的多边形数量相对较少。这使得三角形容易被识别出来。我们加入一个维度。在3D向量图像中情况相同，但是每个向量使用了三个分量（x，y，z）。三个分量——三个维度。我们看一张3D低多边形的作品。 iOS概念游戏 赛道, Timothy J. Reynolds, 2013 之前的Ayers Rock的2D图像和这里的3D跑道之间的区别在于我们可以在我们想要的任意位置看这个跑道。 iOS概念游戏 赛道 (另外视角), Timothy J. Reynolds, 2013为了在你的屏幕（一个2D平面）上显示跑道，我们需要一个特定的视点（viewpoint）然后从那一点将3D几何体投影到2D中。 从3D向2D的变换叫做投影这是我们得到一个特定2D图片的方法。 但是我们可以使用一个小技巧来在2D中显示3D几何体的体积特征——我们可以制作一个动画，将我们的视点设置为绕物体旋转（或者固定视点，旋转物体，如下图所示） 旅行车, Timothy J. Reynolds, 2013耶！我们真的看到了3D，不需要3D眼镜！ 栅格图像这只是热身。向量暂告一段落，我们继续看看栅格图像如何处理2D和3D。在2D栅格图像中，图片被分为若干行列的小方格，这些小方格大小相等。 Turbo Esprit Sprite, Matej ‘Retro’ Jan, 2014每个单元被称作一个像素（来自图片的元素）。除了网格中的2D坐标（x，y）它的主要性质还有那个坐标的颜色。 我们已经见过低多边形向量方法如何使用易于辨认的大多边形。如果我们在栅格图像中也这样做（使用明显的大像素）我们得到了像素艺术。 Tribute (修正版), Matej ‘Retro’ Jan, 2005, 2012对于2D像素图片来说，尽管它们想要表示三维物体（一个Lotus Esprit 或者一个X-wing），但是它们被直接画到了2D像素网格上。你不能像前面旋转3D向量小汽车那样旋转这张图片。同样，文章开始的那张Ayers Rock图片也不能被旋转。尽管是由多边形构成的，它们没有被放置在3D空间内，而是直接被放在2D中。 目前我们已经介绍完了2D和3D向量图像以及2D栅格图像。最后我们介绍3D栅格图像。 即将介绍激动人心的东西！在3D栅格图像中，体积被均匀分到行和列中，覆盖了全部三个不同的方向（上下，左右，里外）。这样3D空间被分为许多小立方体，称为体素（体积元素或者体积像素）。每个体素由一个3D坐标和位于该坐标的颜色定义。 和像素艺术（指的是精心安排像素位置的艺术）一样，我们现在有了体素艺术，其中每个小方块都需仔细安排。 星球大战场景, Sir Carma, 2015太像乐高了，你不这么认为吗？注意由于我们在3D场景中，我们可以从各种方向观察体素。这是从另一个角度看Tatooine的体素。 星球大战场景 (从另一视点观测), Sir Carma, 2015 我们甚至可以做动画！这是Sir Carma的动画体素角色中的一个例子： 骑士快跑（Knight Run）, Sir Carma, 2015将它和2D像素艺术角色作比较： 最后元素（Last Element）中的精灵, Glauber Kotaki, 2015你可以看出在体素艺术中，动画是如何改变小方块——也就是体素——的外表（颜色）的，以及在像素艺术中颜色的改变是如何发生在小方块——像素上的。现在你知道了像素和体素之间的差别（以及更多……哈哈，对于这一点很抱歉）。但是还没完。瞧，我之所以解释向量/栅格，以及2D/3D是因为在现代显示设备上，每种图像类型最后都会被显示为2D栅格图片。 我们在一本像素艺术杂志中提及这个的原因是我们可以使用这类变换来创造出现代像素艺术的风格，此风格使用非像素艺术象限中的艺术资源。“我可以使用体素或3D模型制作像素图像？”你觉得呢？没错就是这样！巧妙地运用着色和渲染技术可以使我们创造出独特的视觉风格，将像素艺术带入到未来。向量的显示和投影上面的图示并不全部正确。有一种直接显示2D向量图像的方法，它使用了一个小技巧。 一张2D向量图像只能直接显示在一个向量显示器上，和Atari的街机游戏太空射击使用的那些一样。 太空射击, Atari, 1979这是它实际看上去的样子（示波器上显示的是一款类似于太空射击的游戏） 太空岩石(游戏), Autopilot, 见 Wikimedia Commons [CC BY-SA 3.0]我们还可以这样显示3D向量图像（通常被称为3D模型）。与之前提到的一样，3D模型首先需要被投影到两个维度上，产生一张可以显示在向量显示器上的2D向量图像。 VEC9, Andrew Reitano &amp; Todd Bailey, 2013我极度推荐观看VEC9宣传片以及80年代的硬汉片：https://youtu.be/rSPixmsLfn4 VEC9, Andrew Reitano &amp; Todd Bailey, 2013 栅格化处理如今你很难在博物馆以外的地方找到一个向量显示器。相反，我们使用像素进行显示！ RGB LCD, Luís Flávio Loureiro dos Santos, 见 Wikimedia Commons [CC BY 3.0]一个现代LCD显示器通过开启和关闭（或半开半关）小的红绿蓝LCD（液晶显示器）创造出不同的颜色。以免你有疑问，CRT（阴极射线管）原理类似，只不过它们使用三种荧光体进行搭配以便电子束撞击的时候产生红绿蓝三种颜色。 CRT 荧光点, 见 Wikipedia [CC-SA] 那么我们该如何将一张向量图片显示在一个栅格显示器上呢？嗯，从2D向量图片到2D栅格图片，图片需要被渲染或者被栅格化处理。每个多边形（通常一个三角形）被渲染为网格中的一个像素。 使用抽样法进行栅格化处理, Making WebGL Dance的一张幻灯片, Steven Wittens, 2013 这可以被拓展到在栅格显示器上渲染3D模型。首先，3D三角形被投影为2D三角形。然后2D向量三角形被栅格化处理为像素。 星际火狐, Nintendo, 1993 三角化那么体素呢？现在体素艺术使用的最常见方法是将每个体素表示为一个3D向量方块，为此我们可以创建一个沿体素方块边缘摆放三角形的3D模型 世界上最激动人心的3D模型, Matej ‘Retro’ Jan, 2016 和之前一样，3D三角形接着被投影到2D图像空间中最后被栅格化处理来显示一张2D栅格图像。 旋转的方块 (技术演示), Matej ‘Retro’ Jan, 2016这是我们现在得到最常见的体素艺术风格的方法，几乎完全使用免费建模工具MagicaVoxel完成。 长发公主的塔（Rapunzel tower）, Thibault Simar, 2016 无题, Argo San, 2016 口袋妖怪的体素, Playiku, 2016 猫咪 vs 体素, Stefan Smiljkovic, 2016 战壕奔跑（Trench Run）, Gabriel de Laubier, 2015 体素气球, Gabriel de Laubier, 2015 空中追击, Sir Carma, 2015 塔拉克村庄（Talaak village）, Sir Carma, 2016 Latica悬崖, Sir Carma, 2015 光线投射其实我们可以不采用立方体方法。每个体素都可以被认为是3D空间中的一个点，那个位置的一个blob（二进制大对象）体积。你可以通过在2D空间中的一个位置放置一个（或多个）像素来直接在2D空间中画出每个体素。或者相反——你可以选择屏幕中的一个像素然后找出场景中出现在那个位置的体素。 该逆向方法被称为光线投射。你可以从视点向场景内投射一束光线然后找出击中的体素。事实上，你可以射出多个射线来扫过全部的视界。 使用鱼眼矫正的简单光线投射, Kieff, 见 Wikimedia Commons [public domain] 这个技巧被首次使用在德军司令部中，其中它的体素全部是房间中的小方块，所以这只是另一种将体素作为小方块进行渲染的方法。不过它的速度很快，因为你只需将一整列的像素投射到屏幕中。这本质上是一个2D过程，也就是为什么我们有时将这类3D图像称为2.5D（某种程度上讲第三个维度是假的，因为它是沿着突出的2D平面的）。 德军司令部, id Software, 1992 不过通常我们不认为Wolfenstein使用了体素。我们必须让单元足够小并让它们有不同的高度。于是到了90年代我们有了经典体素图像引擎。 超级科曼奇, NovaLogic, 1992 一开始体素只被用于地形制作。它们必须简化物体使得全部的体积信息只有存储在2D图像（又被称为高度贴图）中的地形高度。 一个高度贴图（左）告诉我们体素的垂直高度有多少（黑代表低，白代表高） 将体素信息限制在高度贴图中意味着不能有类似于突出的悬崖的东西。但是已经很好了，地形含有的的细节数量是所有之前游戏不能企及的。 三角洲特种部队, NovaLogic, 1998 时空英豪, Appeal, 1999 体素的结束光线投影不是90年代的游戏渲染体素信息所用的唯一方法。其它的方法各有优势，例如支持可以毁坏的地形或者可以渲染汽车或者人物。这些在当时都是最先进的方法了！讽刺的是，这种富有创造的多样性也预示着这项技术迎来迟暮。 万杰赛车, K-D Lab, 1998问题是，直到2000年底图形加速卡诞生了。这些硬件专门处理投影和栅格化3D多边形（现在我们管这些芯片叫做图像处理单元或GPU）。它们渲染三角形的速度飞快，不过这也是它们所能做的全部工作了。自定义体素渲染算法，包括光线投射，在它们的能力之外。 Hexplore, Doki Denki Studio, 1998体素引擎继续在CPU（中央处理单元）上实现，但是CPU另外还要接管剩余的工作，包括物理模拟，游戏流程和人工智能。在GPU上处理图像的主要原因是将渲染放在一张单独的芯片上完成，提高渲染速度的同时还给予了CPU更多的空间做更复杂的模拟。体素引擎跟不上多边形图像的性能所以死翘翘了…… ……直到大约十年后有一款游戏将它们带到了一个新的受欢迎程度。它摒弃了旧的方法，为“将体素作为小方块”方法铺平了道路。现在这可以有效地使用GPU进行渲染而其它的皆成为历史。 我的世界, Mojang, 2009–今 定义我们总结一下我们学到的内容，然后使用一点数学知识回答一开始的关于什么是像素和体素的问题。 一个像素是将2D空间分割为离散的，均匀的（大小相同的）区域时得到的最小单位。 每个像素可以使用一个两个分量均为整数的向量来表示。这是为什么像素空间是离散的，而不是像连续的向量图像那样每个坐标都是一个实数（使用浮点数表示）。 相似地，一个体素是将3D空间分割为离散的，均匀的区域时得到的最小单位。这下你明白了。 我说完了吗？还没有，我还没说完。 被定义得如此宽泛，像素和体素可以以许多不同的方式出现，而我们可以创造性地将概念以各种形式表达出来。尤其，我们考虑综合了4象限的栅格/向量，2D/3D。 纯2D图像 在早些时候如果你想将2D 精灵（sprite）画到屏幕上你必须将一块储存精灵颜色的内存直接复制到另一块储存屏幕显示颜色的内存中（这个复制过程也被称为位块转换，或者叫bit BLT）。如今几乎没人单纯使用这种方法进行2D渲染了。幻想主机PICO-8作为现代的范本向过去那个位块转移作为唯一方法的时代致敬。 PICO-8, Lexallofle Games (以及各自特征小车的作者), 2014–今 3D图像中的纹理 如今大多图像引擎在基础层次使用向量，因为GPU就是这样工作的。在这个系统中使2D图像出现在屏幕上的主要方法是使用一种叫做纹理映射的方法将它们画在多边形上。 纹理是2D栅格图片，可以被放置在（或被映射到）3D多边形上。 这是大多数3D视频游戏（广泛上讲还有3D图像）在制作中所采用的最简单的方法。 例如，这是一个高多边形的3D模型，我们加入一张高分辨率的纹理： 镜之边缘：催化剂 Keyart, Per Haagensen, 2016 由于我们使用平滑的多边形着色和纹理映射我们甚至不需要那么多的三角形来创造出人物好看的外表。这是一个低多边形3D模型外加一个高分辨率的纹理。 低多边形的工匠, Mark Henriksen, 2015当我们也将高分辨率纹理转换为低分辨率时，我们得到了类似于下面这个低多边形3D模型和一个像素艺术纹理： 漂移阶段, 2014–今 (正在制作中)这个情况最出色的例子当然是我的世界了。尽管我的世界的块根据定义是体素（它们是游戏中最小的离散体积单位），但是它们以各种低多边形模型和像素艺术纹理代表的类型出现。尽管它们是一个个的小块，它们中的许多都不是简单的立方体。 我的世界, Mojang, 2009–今 这样所有的3D模型情况就都讲完了（高多边形3D模型和低分辨率纹理的组合并不是很常见，但是如果错了请纠正我） 镜之边缘(左上), 马克思佩恩(左下) 和我的世界 (右下) 2D图像中的纹理 回到2D！当我们将纹理投影应用到2D矩形上时，我们得到了现在常见的2D游戏。使用当今的硬件，每张2D图像（在这种情况下常被称为精灵）被放在一个由两个三角形组成的矩形中进行显示。两个三角形（加起来也被称为一个四边形）通过映射到它们上面的精灵进行渲染，使得图像出现在正确的位置。 人物图像的一部分(左) 被纹理映射到动画四边形中(右)。羽毛球, Matej ‘Retro’ Jan, 2006 高分辨率图像就很直接了…… 时空幻境, Number None, 2008 地狱边境, Playdead, 2010……但是低分辨率，像素艺术纹理就稍微复杂一些了。它完全取决于我们采用什么显示分辨率来渲染精灵。 时空幻境(左上), 通往天空的路(右上), 王国(右下) 我们已经见识到了可以将像素艺术纹理应用到一个低多边形3D模型上，但是仍使用高分辨率进行渲染。考虑一下我的世界。低多边形模型，低分辨率16x16像素纹理，放在一个显示分辨率为1920x1080的场景中。 我的世界, Mojang, 2009–今 同样2D多边形也可以这样做。我们使用一张像素艺术图片，将它放在一个2D四边形上，然后将它渲染到高分辨率屏幕上，这样一来源图像中的每个像素都包含了显示中的多个像素。 迈阿密热线, Dennaton Games, 2012 我们将此风格称为大像素艺术风格。每个精灵像素按照大于显示像素进行渲染，以便它在图像中作为一个大方块出现。 每个源精灵像素被渲染为3x3显示像素， 登月者, Ben Porter, 2011–今 （正在制作中) 大像素风格在精灵被旋转或倾斜时变得明显： 通往天空的路, Johannes ‘Dek’ Märtterer, 2011–今 (正在制作中) 看看上图中的树叶，然后将它和低分辨率渲染下的旋转精灵进行对比。 王国, Noio &amp; Licorice, 2015 你看到水轮的像素是如何水平/垂直排列开来的，而在通往天空的路中树叶，小鸟，和桥梁的大像素都被调整了角度和做了变换吗？ 王国在低分辨率下渲染整个游戏然后只将结果图像放大（调大尺度）到显示分辨率。另一方面，通往天空的路，迈阿密热线和登月者直接将精灵渲染到高分辨率显示。 回到3D王国是一款2D游戏，但是它所采用的方法也能放到3D中。 我们可以使用像素艺术纹理的3D模型，但是在低分辨率中渲染它们，我们得到如下： 像素艺术学院技术演示, Matej ‘Retro’ Jan, 2016你会发现我们正确地得到了带有投射阴影的3D着色。尽管结果看上去像2D像素艺术，但它实际上是一个使用像素艺术纹理在低分辨率下进行渲染得到的3D场景。 像素艺术学院技术演示 (场景视觉), Matej ‘Retro’ Jan, 2016 基于向量（使用骨骼绑定）的动画也可以利用这个优势。这是它们在大像素风格中的样子： 动画绑定, Matej ‘Retro’ Jan, 2016 但是当在低分辨率下渲染时，它们显得更像像素艺术，排成一列的像素和上面的王国相似。 像素艺术学院动画测试, Matej ‘Retro’ Jan, 2016 这和手绘的、一帧一帧的动画相差甚远，但是具有一定的美感，让人想起了90年代的rotoscope（动态遮罩）动画。 波斯王子, Jordan Mechner, 1989 3D效果回到高分辨率，一个充分利用3D优势的游戏是Odd Tales的Last Night 最后一夜（The Last Night）, Odd Tales, 2014–今 (正在制作中) 它们的美术资源本质上是2D的，但是采用所有你能想象到的现代图像效果（动态光照，全屏泛光（bloom），景深，电影级别的相机角度，反射……）展开到3D世界中。 最后一夜中的WIP场景, Tim Soret, 2016 这样他们构建了一个可以从不同角度观察的三维世界。 最后一夜中的3D场景构建, Tim Soret, 2016 另一个动态3D光照的例子是拥有优秀场景但是命运不佳的游戏致命快递。 致命快递, Maksym Pashanin, 2013–2014 (未发布) 虽然美术资源仍是2D的，但是它们还包括了从多个方向的着色的图片。这些是使用类似于Sprite Lamp这样的工具进行处理的，并且任何位置的光源都会产生精灵的平滑照明。 来自于体素的像素艺术以上方法的问题在于只有精灵的着色可以准确完成，而它们投射的阴影缺少所需的3D几何因此不能正确生成。为此你还是需要体积信息。又到体素了！ 这种方法一个很棒的例子是最近宣布的Pathway： 道路（Pathway）, Robotality, 2016 (正在制作中) 图像看上去完全像是在使用像素艺术精灵，但是其背后的信息却是体积的。和90年代试图看上去更现代和更现实的体素引擎不同，Robotality的开发者最多只将体素和显示像素的大小相匹配。这制造了一个巧妙的伪装，使它看上去像像素艺术，但是实际上它们拥有所有的3D信息来创造出完全正确的动态光照。 不过使用体素几何产生像素艺术并不完全是个新方法。之前FEZ使用了被其称之为三像素（3d 像素）的方法。三像素就是被综合为16x16x16方格（3d方格）的体素。 FEZ的游戏开发截图, Polytron, 2007 当一个FEZ场景在游戏中被渲染时我们基本上看到的是一个2D正交投影，这样他们既达到了传统像素艺术的外观又加入了FEZ标志性的视角旋转功能。 FEZ GDC ’09年宣传片, Polytron Corporation, 2009 FEZ, Polytron Corporation, 2012 纯体素最终，由于我们绕了一大圈终于回到了体素几何上，我们可以完全不管像素，仅在3D空间中渲染纯离散体素（使用不带任何纹理的立方体方法）。 Lexallofle’s Voxatron 是这个空间内的游戏名字. Voxatron, Lexallofle Games, 2010–今(正在制作中) 你注意到Lexallofle虚拟主机中的一个主题了吗？Pico-8有一个纯2D图像引擎而Voxatron则有一个3D体素的。它们是完美的搭档。 Voxatron, Lexallofle Games, 2010–今 (正在制作中)Voxatron是少数几个（如果不是唯一的话）真正使用3D空间的纯离散分割的游戏。但是与之相似的大像素风格却应用于许多游戏中，尤其在移动设备中。 天天过马路, Hipster Whale, 2014 Shooty Skies, Mighty Games, 2016 吃豆人256, Hipster Whale, 2015我们绕了一整圈回到了Sir Carma。在成为最著名的体素艺术师后，他现在在使用Unity将仅含体素的美学推向更高的高度，得到各种视觉效果，和Odd Tales对于像素艺术做出的贡献一样。 返回之路, Sir Carma, 2016 (正在制作中) 返回之路, Sir Carma, 2016 (正在制作中)有人知道Voxel Zelda/Atic Atac吗? 返回之路, Sir Carma, 2016 (正在制作中)好了，我们介绍了2D/3D/栅格/向量/低分辨率/高分辨所有我能想到的组合。我确定我忘记了一些内容，但是我更确定未来会有更多有趣的方法，但是目前这样就不错了。 我希望你们阅读愉快——为我们一路到尾欢呼！我希望你更深刻地了解了像素和体素图像，以及对它们下一步如何发展有了一些创造性的想法。想要更多有关像素艺术特征的信息你可以在Tumblr，Twitter，和Facebook上关注Retronator。每天都有新发现哦！—Retro]]></content>
      <tags>
        <tag>渲染</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大规模场景的资源拆分合动态加载]]></title>
    <url>%2F2017%2F10%2F04%2FassetSplit-dynamicLoad%2F</url>
    <content type="text"><![CDATA[概要 资源拆分 地形，地表 动态加载/卸载 打包策略资源拆分 地形资源拆分 Unity原始地形有网格尺寸的限制（4096） Mesh地形有面片数限制 降低内存占用，仅需载入部分地形数据 降低渲染面片数，视域体剔除 制作大规模地形 Terrain Composer 2 T4M 建模软件… 拆分现有地形 Terrain Slicing &amp; Dynamic Loading Kit 地形数据 filed meaning basemapDistance Heightmap patches beyond basemap distance will use a preomputed low res basemap. castShadows Should terrain cast shadows? ollectDetailPatches Collect Detail patches from memory. detailObjectDensity Density of detail objects. detailObjectDistance Detail objets will be displayed up to this distance. heightmapMaxmumLOD Lets you essentially lower the heightmap resolution used for rendering. heightmapPixelError An approximation of how many pixels the terrain will pop in the worst case when switching lod. lightmapindex The index of the lightmap applied to this renderer. terrainData The Terrain Data that stres htightmaps,terrain textures,detail meshes and trees. treeBillboardDistance Distance from the camera where trees will be rendered as billboards only. terrCrossFadeLength Total distance delta that trees will use to transition from billboard orientation to to mesh orientation. treeDistance The maximum distance at which trees are rendered. treeMaximumFullLODCount Maximum number of trees rendered at full LOD. Lightmap 拆分后重新烘培 切分烘培好的Lightmap exr 格式，FreeImage 切割跨地形的大模型 按地形块分组动态加载 关键在于：流畅 卡顿分析 Instantiate 前自动加载未加载的引用资源 Shader(Fallback) Texture Mesh AnimationClip 预加载资源 Shader(Fallback) Texture 预加载资源异步加载 Resources.LoadAsync AssetBundle.LoadAsync 实例化引起的序列化操作(Loading.LoadFileHeaders) 避免一次性实例化过多的粒子系统（预加载） 避免层级复杂，组件Awake过多 尝试拆分Prefab，流失Instantiate 加载策略(Assetbundle) Shared包常驻内存 大纹理等资源采用LoadFromCacheOrDownload Material/Mesh等可采用new WWW 卸载策略（AssetBundle） Prefab 包 GameObject可通过Destroy来销毁 TerrainData,Object等可通过Resources.UnloadAsset来进行卸载 Shared包 建议在确认不适用或切换场景时进行卸载 切换场景时调用UnloadUnusedAssets来卸载Texture，Mesh等加载的共享资源 注意事项 加载方式 九宫格 适用于非自由视角 建立缓冲池，防止反复实例化。 Load vs LoadAsync 进场景预加载，推荐Load 游戏中，推荐LoadAsync Lightmap动态加载 LightmapSettings lightmapindex/lightmapScaleOffset Shader Stripping Terrain动态加载 Lightmapld Terrain.SetNeighbors 动态 Static Batching (StaticBatchingUtility) 运行时CPU/堆内存开销较大 优先推荐手动拼合 推荐分组拼合 防止资源泄露 运行时创建 new Material,Mesh Material set AssetBundle重复加载 共享资源 Texture,Mesh,Font Prefab 隐形资源 TerrainData/AlphaMap打包策略 地形资源 12345List&lt;Object&gt; groundObjs = new List&lt;Object&gt;();groundObjs.AddRange(Resources.LoadAll(BundleConfig.GroundObjectsPath, typeof(Texture2D)));groundObjs.AddRange(Resources.LoadAll(BundleConfig.GroundObjectsPath, typeof(GameObject)));BuildPipeline.PushAssetDependencies(); 地表资源 复杂资源拆分 “流失”实例化 按地形块分组打包]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity5.x场景优化之动态设置光照贴图lightmap]]></title>
    <url>%2F2017%2F10%2F03%2Flightmap%2F</url>
    <content type="text"><![CDATA[在很多情况下，我们为了提高渲染效率，一般都会让美术同学在制作场景时，设置场景相关节点的lightmap static属性，提前给整个场景烘培出静态的光照贴图lightmap，烘培的数据保存在场景目录下的LightmapSnapshot文件中，主要包括的数据有：lightmaps：烘培出的光照贴图数组；gameobject uid：被烘焙的gameobject的唯一标识；renderer的lightmapIndex：]]></content>
  </entry>
  <entry>
    <title><![CDATA[AssetBundle管理机制]]></title>
    <url>%2F2017%2F10%2F02%2FABTheory%2F</url>
    <content type="text"><![CDATA[接上期AssetBundle打包的讲解，我们今天为大家继续探秘AssetBundle,从管理机制的角度出发，谈谈其资源加载和卸载的原理。 AssetBundle加载基础通过AssetBundle加载资源，分为两步，第一步获取AssetBundle对象，第二步是通过该对象加载需要的资源。而第一步又分为两种方式，下文中将结合常用的API进行详细的描述。 一 获取AssetBundle对象常用的API（1）先获取WWW对象，在通过WWW.assetBundle获取AssetBundle对象： public WWW(string url);加载Bundle文件并获取WWW对象，完成后会在内存中创建较大的WebStream(解压后的内容，通常为原Bundle文件的4~5倍大小，纹理资源比例可能更大),因此后续的AssetBundle.Load可以直接在内存中惊醒。 public static WWW LoadFromCacheOrDownload(string url, int version, uint crc = 0);加载Bundle文件获取WWW对象，同时将解压形式的Bundle内容存入磁盘中作为缓存(如果该Bundle已在缓存中，则省去这一步),完成后只会在内存中创建较小的SerializedFile,而后续的AssetBundle.Load需要通过IO从磁盘中的缓存获取。 public AssetBundle assetBundle;通过之前的两个接口获取WWW对象后，即可通过WWW.assetBundle获取AssetBundle对象。 （2）直接获取AssetBundle: public static AssetBundle CreateFromFile(string path);通过未压缩的Bundle文件，同步创建AssetBundle对象，这是最快的创建方式。创建完成后只会在内存中创建较小的SerializedFile，而后续的AssetBundle.Load需要通过IO从磁盘中过去。 public static AssetBundleCreateRequest CreateFromMemory(byte[] binary);通过Bundle的二进制数据，异步创建AssetBundle对象。完成后会在内存中创建较大的WebStream。调用时，Bundle的解压时异步进行的，因此对于未压缩的Bundle文件，该接口与CreateFromMemoryImmediate等价。 public static AssetBundle CreateFromMemoryImmediate(byte[] binary);该接口是CreateFromMemory的同步版本。 注：5.3下分别改名为LoadFromFile,LoadFromMemory,LoadFromMemoryAsync并增加了LoadFromFileAsync，且机制也有一定的变化，可详见Unity官方文档。 二·从AssetBundle加载资源的常用API public ObjectLoad(string name, Type type);通过给定的名字和资源类型，加载资源。加载时会自动在家其依赖的资源，即Load一个Prefab时，会自动Load其引用的Texture资源。 public Object[] LoadAll(Type type);一次性加载Bundle中给定资源类型的所有资源。 public AssetBundleRequest LoadAsync(string name, Type type);该接口是Load的异步版本。 注：5.x下分别改名为LoadAsset,LoadAllAssets,LoadAssetAsync，并增加了LoadAllAssetsAsync。 AssetBundle加载进阶一·接口对比：new WWW与WWW.LoadFromCacheOrDownload(1)前者的优势 后续的Load操作在内存中进行，相比后者的IO操作开销更小； 不形成缓存文件，而后者则需要额外的磁盘空间存放缓存； 能通过WWW.texture,WWWW.bytes,WWW.audioClip等接口直接加载外部资源，而后者只能用于加载AssetBundle (2)前者的劣势 每次加载涉及到解压操作，而后者在第二次加载时就省去了解压的开销； 在内存中会有较大的WebStream,而后者在内存中只有通常较小的SerializedFile。（此项为一般情况，但并不绝对，对于序列化信息较多的Prefab,很可能出现SerializedFile比WebStream更大的情况） 二·内存分析 在管理AssetBundle时，了解其加载过程中对内存的影响意义重大。在上图中，我们在中间列出了AssetBundle加载资源后，内存中各类物件的分布图，在左侧则列出了每一类内存的产生所涉及到的加载API: WWW对象：在第一步的方式1中产生，内存开销小； WebStream:在使用new WWW或CreateFromMemory时产生内存开销通常较大； SerializedFile:在第一步中两种方式都会产生，内存开销通常较小； AssetBundle对象：在第一步中两种方式都会产生，内存开销小； 资源（包括Prefab）：在第二步中通过Instantiate产生，内存开销通常较小。 场景物件（GameObject):在第二步中通过Instantiate产生，内存开销通常较小。在后续的章节中，我们还将针对该图中各类内存物件分析其卸载方式，从而避免内存残留甚至泄露。 三·注意点 CreateFromFile只能适用于未压缩的AssetBundle,而Android系统下StreamingAssets是在压缩目录(.jar)中，因此需要先将未压缩的AssetBundle放到SD卡中国才能对其使用CreateFromFile。 iOS系统有256个开启文件的上限，因此，内存中通过CreateFromFile或WWW.LoadFromCacheOrDownload加载的AssetBundle对象也会低于该值，在较新的版本中，如果LoadFromCacheOrDownload超过上限，则会自动改为new WWW的形式加载，而焦躁的版本中则会加载失败。 CreateFromFile和WWW.LoadFromCacheOrDownload的调用会增加ResistenManager.Remapper的大小，而PersistentManager负责维护资源的持久化存储，Remapper保存的是加载到内存的资源HeapID与源数据FileID的映射关系，它是一个MemoryPool,其行为类似Mono堆内存，只增不减，因此需要对两个接口的使用做合理的规划。 对于存在依赖关系的Bundle包，在加载时主要注意顺序，举例来说，假设CanvasA在BundleA中，所依赖的AtlasB在BundleB中，为了确保资源正确引用，那么最晚创建BundleB的AssetBundle对象的时间点是在实例化CanvasA之前，即，创建BundleA的AssetBundle对象时，Load(“CanvasA”)时，BundleB的AssetBundle对象都可以不在内存中。 根据经验，建议AssetBundle文件的大小不超过1MB，因为在普遍情况下Bundle的加载时间与其大小并非呈线性关系，过大的Bundle可能引起较大的加载开销。 由于WWW对象的加载是异步的，因此逐个加载容易出现下图中CPU空间的情况（选中帧处Vsync占了大部分）此时建议适当的同时加载多个对象，以增加CPU的使用率，同时加快加载的完成。 AssetBundle卸载前文提到了通过AssetBundle加载资源时的内存分配情况，下面，我们结合常用的API介绍如何将已分配的内存进行卸载，最终达到清空所有相关内存的目的。 一·内存分析 在上图中的右侧，我们列出了各种内存物件的卸载方式： 场景物件(GameObject):这类物件可通过Destroy函数进行卸载； 资源(包括Prefab):除了Prefab以外，资源文件可以通过三种方式来卸载1）通过Resources.UnloadAsset卸载指定的资源，CPU开销小；2）通过Resources.UnloadUnusedAssets一次性卸载所有未被引用的资源，CPU开销大；3）通过Resources.Unload(true)在卸载AssetBundle对象时，将加载出来的资源一起卸载。而对于Prefab,目前仅能通过DestroyImmediate来卸载，且卸载后，必须重新加载AssetBundle才能重新加载该Prefab。由于内存开销较小，通常不建议进行针对性的卸载。 WWW对象：调用对象的Dispose函数或将其置为null即可； WebStream:在卸载WWW对象以及对应的AssetBundle对象后，这部分内存即会被引擎自动卸载； SerializedFile:卸载AssetBundle后，这部分内存会被引擎自动卸载; AssetBundle对象：AssetBundle的卸载方式有两种：1）通过AssetBundle.Unload(false),卸载AssetBundle对象时保留内存中已加载的资源；2)通过AssetBundle.Unload(true),卸载AssetBundle对象时卸载内存中已加载的资源，由于该方法容易引起资源引用丢失，因此并不建议经常使用；二·注意点在通过AssetBundle.Unload(false)卸载AssetBundle对象后，如果重新创建该对象并加载之前加载过的资源的时候，会出现冗余，即两份相同的资源。 被脚本静态变量引用的资源，在调用Resources.UnloadUnusedAssets时，并不会被卸载，在Profiler中能够看到其引用情况。 UWA推荐方案通过以上的讲解，相信您对AssetBundle的加载和卸载有了明确的了解。下面，我们简单地做一下API选择上的推荐： 对于需要常驻内存的Bundle文件来说，优先考虑减少内存占用，因此对于存放非Prefab资源（特别是纹理）的Bundle文件，可以考虑使用WWW.LoadFromCacheOrDownload或AssetBundle.CreateFromFile加载，从而避免WebStream常驻内存；而对于存放较多Prefab资源的Bundle，则考虑使用new WWW加载，因为这类Bundle用WWWW.LoadFromCacheOrDownload加载时产生的SerializedFile可能会比new WWW产生的WebStream更大。 对于加载完后即卸载的Bundle文件，则分两种情况：优先考虑速度（加载场景时）和优先考虑流畅度（游戏进行时）。1）加载场景的情况下，需要注意的是避免WWW对象的逐个加载导致的CPU空间，可以考虑使用加载速度较快的WWW.LoadFromCacheOrDownload或AssetBundle.CreateFromFile，但需要避免后续大量地进行Load资源的操作，引起IO开销（可以尝试直接LoadAll）。2）游戏进行的情况下，则需要避免使用同步操作引起卡顿，因此可以考虑使用new WWW配合AssetBundle.LoadAsync来进行平滑的资源加载，但需要注意的是，对于Shader，较大的Texture等资源，其初始化操作通常很耗时，容易引起卡顿，因此建议将这类资源在加载场景时进行预加载。 只在Bundle需要加密的情况下，考虑使用CreateFromMemory，因为该接口加载速度较慢。 尽量避免在游戏进行中调用Resources.UnloadUnusedAssets(),因为该接口开销较大，容易引起卡顿，可尝试使用Resources.Unload(obj)来逐个进行卸载，以保证游戏的流畅度。 需要说明的是，以上内存管理交适合于Unity5.3之前的版本。Unity引擎在5.3中对AssetBundle的内存占用进行了一定的调整，目前我们也在进一步的学习和研究中。 以上即为我们这次为您带来的AssetBundle管理机制，希望对您的项目研发有所帮助。我们会在后续技术文章通过大量的案例来进一步解释AssetBundle的管理机制，敬请关注。 原文链接：https://blog.uwa4d.com/archives/ABTheory.html]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AI]]></title>
    <url>%2F2017%2F09%2F29%2FAI%2F</url>
    <content type="text"><![CDATA[Unity正朝着AI的方向潜心探索着。本文是Unity发布的首篇AI相关文章，为大家介绍AI的一些概念及术语，详细介绍机器学习相关理论与方法，并讲解在使用Unity开发游戏的过程中如何应用AI。未来我们还将为大家分享更多AI的内容。 ML（机器学习）与AI(人工智能）首先来介绍下Machine Learning(机器学习，下文简称ML）和游戏Artificial Intelligence(人工智能，下文简称AI）间的关系。现存的大部分游戏AI都是手工源码，由大量决策树组成，有时会包含多达数千条规则。而且必须由手工维护和测试。而ML所依赖的算法可以自动从原始数据寻找规律，无需专家预先定义数据的解读方式。 以图片内容分类这个计算机视觉问题为例。直到几年前，专家们仍然通过手工编写过滤器，提取图像的有用特征，用于分辨某个图像中包含的是猫还是狗。而ML，特别是i最新的深度学习方法，仅需图像和类型标签，就可以自动学习有用的特征。我们相信这种自动化学习不仅可以扩展Unity平台的应用范围，例如用于ML场景模拟，还可以帮助所有开发者简化和加速游戏的开发过程。 这种自动化学习尤其可以应用于游戏代理（即NPC）的行为方面。我们可以使用Reinforcement Learning(增强学习，简称RL）来训练代理，预估某一环境中施行特定行为的价值。一旦训练完成，代理即可以最佳行为模式做出反应，无需通过程序对行为进行显示的编码。 采用老虎机算法的增强学习RL背后的一个核心概念是价值估计，并据此进行相应动作。在继续深入之前，最好先了解一些术语。 在RL中，实施动作的个体被称为agent(代理),它使用policy(策略)进行动作决策。一个代理通常嵌入一个environment中，并在任意给定的时刻都处于某个特定的state(状态).从哪个状态，它可以进行一系列actions(动作）。某个给定状态的value(值)指的是处于该状态的最终回报价值。在某个状态的value(值)指的是处于该状态的最终回报值。在某个状态执行一个动作可以让代理进入另一个新的状态，获得一个reward(回报),或者同事拥有两者。所有的RL代理都在尽可能最大化累计回报。 &lt;img = /2017/09/30/AI/“&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Real-Time Rendering 3rd]]></title>
    <url>%2F2017%2F09%2F29%2FReal-Time-Rendering-3rd%2F</url>
    <content type="text"><![CDATA[Overviewurl: www.realtimerendering.com The Graphics Rendering Pipeline 核心内容分节提炼图像渲染管线架构概述 Architecture渲染管线的主要功能就是决定在给虚拟相机，三维物体，光源，照明模式，以及纹理等诸多条件的情况下，生成或绘制一幅二维图像的过程。对于实时渲染来说，渲染管线就是基础。因此，我们可以说，渲染管线是实时渲染的底层工具。 上图，相机放在棱锥的顶端（四条线段的交汇点），只有可视体内部的图元会被渲染。在概念上可以将图形渲染管线分为三个阶段： 应用程序阶段（The Application Stage) 几何阶段(The Geometry Stage) 光栅化阶段(The Rasterizer Stage)如下图：原书图2.2绘制管线的基本结构包括3个阶段：应用程序，几何，光栅化。 几个要点：-每个阶段本身也可能是一条管线，如图中的几何阶段所示。此外，还可以对有的阶段进行全部或者部分的并行化处理，如图中的光栅化阶段。应用程序阶段虽然是一个单独的过程，但是依然可以对之进行管线化或者并行化处理。-最慢的管线阶段决定绘制速度，即图像的更新速度，这种速度一般用FPS表示，也就是帧率。 应用程序阶段The Application Stage-应用程序阶段一般是图形渲染管线概念上的第一个阶段。应用程序阶段是通过软件方式来实现的阶段，开发者能够对该阶段发生的情况进行完全控制，可以通过改变实现方法来改变实际性能。其他阶段，他们全部或者部分建立在硬件的基础上，因此要改变实现过程会非常困难。-正因应用程序阶段是软件方式实现，因此不能像集合和光栅化阶段那样继续分为诺干个子阶段。但为了提高性能，该阶段还是可以在几个并行处理器上同时执行。在CPU设计商，称这种形式为超标量体系(superscalar)结构，因为它可以在同一个阶段同一个时间做不同的几件事情。-应用程序阶段通常实现的方法有碰撞检测，加速算法，输入检测，动画，力反馈以及纹理动画，变化仿真，几何变形，以及一些不在其他阶段执行的计算，如层次堆裁剪等加速算法就可以在这里实现。-应用程序阶段的主要任务：在应用程序阶段的末端，将需要在屏幕(具体形式取决于具体输入设备)显示出来绘制的几何体(也就是绘制图元,rendering primitives,如点，线，矩形等)输入到绘制管线的下一个阶段。-对于被渲染的每一帧，应用程序阶段将摄像机位置，光照和模型的图元输出到管线的下一个主要阶段-几何阶段。 几何阶段 The Geometry Stage几何阶段主要负责大部分多边形操作和顶点操作。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Unity-Weather]]></title>
    <url>%2F2017%2F09%2F26%2FUnity-Weather%2F</url>
    <content type="text"><![CDATA[抄：https://zhuanlan.zhihu.com/p/29668925]]></content>
  </entry>
  <entry>
    <title><![CDATA[UGUI vs NGUI]]></title>
    <url>%2F2017%2F09%2F24%2FUGUIvsNGUI%2F</url>
    <content type="text"><![CDATA[Tables NGUI UGUI 锚点 Anchor RectTransform Anchor 图片 Sprite Image 文字 Label Text 根节点 UIRoot Canvas UI面板 Panel Canvas UI容器 Lets you essentially lower the heightmap resolution used for rendering. heightmapPixelError An approximation of how many pixels the terrain will pop in the worst case when switching lod. lightmapindex The index of the lightmap applied to this renderer. terrainData The Terrain Data that stres htightmaps,terrain textures,detail meshes and trees. treeBillboardDistance Distance from the camera where trees will be rendered as billboards only. terrCrossFadeLength Total distance delta that trees will use to transition from billboard orientation to to mesh orientation. treeDistance The maximum distance at which trees are rendered. treeMaximumFullLODCount Maximum number of trees rendered at full LOD. UGUI 上图是UIWidget，UIGeometry和UIDrawCall的关系图UIPanel用来收集和管理它下面所有的widget的组件。通过widget的geometry创建实际的draw call。没有panel所有东西都不能被渲染出来。可以把UIPanel当作Renderer。 每一个UIWidget都有一个UIGeometry，但是并不都有一个UIDrawCall，而是要通过Batch合并达到减少DrawCall的数量。所有Panel都有一个Depth值，会影响所有它包含的widget。Panel的depth权重要高于widget的depth权重，但是低于render queue。 当勾选static的时候，该panel下面所有的widget都不会被移动，这样可以提高性能。此时，NGUI会忽略所有的position/rotation/scale改变。所以在运行时移动widget不会有效。 UIDrawCall1.成员变量a) List mActiveList和mInactiveList，mActiveList保持当前激活的UIDrawCall，mInactiveList主要是用于回收UIDrawCall.Destroy()的UIDrawCall，以达到循环利用避免内存的反复申请和释放，减少GC的次数。b) Material mMaterial和mDynamicMat，mMaterial是图集的Material，mDynamicMat是实际采用的Material，因为UIPanel的Clipping有AlphaClip和SoftClip这两个是要通过切换Shader实现的，所以需要对应动态创建一个Material，这个就是mDynamicMat的存在。c) bool mRebuildMat和isDirty，这两者表示UIDrawCall所处的状态，当改变UIDrawCall的Material和Shader，mRebuildMat就变成true，就会引起RebuildMaterial()的调用。isDirty若为true，表示UIDrawCall要进行重写“填充”，调用Set函数。 负责将uv、顶点、color等信息输入到mesh中，继而绘制图形。 1234567891011121314151617void UpdateGeometry()&#123; if (mFilter == null) &#123; mFilter = gameObject.AddComponent&lt;MeshFilter&gt;(); mMesh = new Mesh(); mTriangles = (verts.size &gt;&gt; 2); mMesh.verticess = verts.buffer; mMesh.uv = uvs.buffer; mFilter.mesh = mMesh; &#125; if (mRenderer == null) &#123; mRenderer = gameObject.AddComponent&lt;MeshRenderer&gt;(); &#125; UpdateMaterial();&#125; 以上所有的buffer都是用BetterList来存储的。 1234567891011121314151617void UpdateMaterial()&#123; if (mDynamicMat == null || mRebuildMat || mClipCount != panel.clipCount) &#123; RebuildMaterial(); mRebuildMat = false; &#125; else if (mSharedMat != mDynamicMat) &#123; mSharedMaterials = new Material[]&#123;mDynamicMat&#125;; &#125;&#125;void RebuildMaterial()&#123; CreateMaterial();&#125; 优化DrawCall使用相同material的连续UIWidget(UILbale,UISprite)共用一个UIDrawCall。对UIWidget.list进行排序，使得相同的material的UIWidget在UIWidget.list相连，而UIWidget.list是根据UIWidget的depth进行排序。（但是这样不会改变渲染顺序吗？）1) 修改UIWidget(UILabel,UISprite)的depth，限定好UIWidget.list的排序2) 重写UIWidget的CompareFunc方法。夹层问题 UIRootUIRoot的作用是缩放UI PixelPerfect 保持原分辨率FiexedSize 根据比例缩放FixedSizeOnMobile PC保持原分辨率，Mobile缩放 UICamera 带有这个组件渲染出来的物体可以接受NGUI事件 UIPanelPanel的集合，一个Panel中包含多个Widget，负责更新会决定何时绘制Widget。 123456789101112131415static public List&lt;UIPanel&gt; list = new List&lt;UIPanel&gt;();public RenderQueue renderQueue = RenderQueue.Automatic; //渲染次序类型public int startingRenderQueue = 3000;public List&lt;UIWidget&gt; widgets = new List&lt;UIWidget&gt;();public List&lt;UIDrawCall&gt; drawcalls = new List&lt;UIDrawCall&gt;();int mDepth = 0; // 深度int mSortingOrder; // 队列排序值bool mRebuild = false;//如果为true，需要重构所有的Drawcall，Panel中的OnEnable、RemoveWidget、AddWidget等和改变depth会将该值设置为true。void LateUpdate()&#123; if (mUpdateFrame != Time.frameCount) &#123; &#125;&#125;]]></content>
      <tags>
        <tag>Unity3D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE3的3D渲染流水线处理流程]]></title>
    <url>%2F2017%2F09%2F24%2F3%E7%9A%843D%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[本文要给大家讲述的是UE3的3D渲染流水线的处理流程，让开发者知道UE3引擎在3D流水线各个阶段的工作内容，这样在开发的过程中才能更好的去使用3D渲染流水线。 什么是渲染(Rendering)渲染简单的理解可能这样：就是将三维物体或三维场景的描述转化为一张2D图像,生成的2D图像能很好展示3D对象或场景。 什么是流水线？3D渲染流水线也类似一个工厂的流水线，它的原材料是一系列的3D网格数据，最终产品就是显示在2D屏幕的3D场景。3D渲染流水线的处理和照相机的原理很像，它们都同样是通过将3D世界的内容放置到2D平面上，通过2D的方式来展示3D世界，顶点管线中有这么几个坐标空间：局部空间-&gt;世界空间-&gt;相机空间-&gt;投影空间-&gt;屏幕空间(视口空间),初始的网格数据是在局部空间中的，顶点管线将其从局部空间变换到屏幕空间作为输入供”像素管线”处理。比如局部空间内，一个人物的骨骼模型，它的中心点就是根骨骼的位置，在进行骨骼层次计算的时候，根谷歌放在中心位置是易于计算的，如果将其放置到世界空间中进行骨骼计算，那么根骨骼的位置不在原点且朝向也不为0，计算起来相当复杂。而世界空间中，易于描述场景中各个物体间的关系，易于作碰撞处理，伤害计算，顶点光照计算等。在相机空间中，容易描述被观察物体与观察者之间的关系，利用相机视锥体对物体进行裁剪，把观察不到的物体剔除掉。 坐标空间转换及推倒这种内容涉及到相当多的几何学，线性代数等内容。 VertexShader—顶点着色器是用来替换这个阶段中固定管线的定点变换及光照计算的，传统管线处理顶点及光照的方式都是固定流程的，所以固定管线下的3D程序特效都有很大的局限性，引入顶点着色器之后，顶点在空间中的变换以及光照处理都可以可编程化了。顶点着色器主要是用来改变顶点固定流程中的变换过程，所以使用顶点着色器表现出来的大多是几何外形的变化以及顶点的光照，纹理等数据的变化。 在UE3中，是不能直接编写Shader语言的，UE3中把所有的Shader特效都绑定到材质中，只能通过材质编辑器来间接的编辑顶点着色器和像素着色器内容。UE3中修改顶点着色器的方式也是在材质编辑器中进行的，其中比较典型的一个输入节点叫做WorldPositionOffset，它就是在顶点管道阶段对材质对应的网络物体顶点进行编辑的一个节点，对应到底层是修改了该材质对应的顶点着色器代码(通过HLSL按钮能够看到该材质对应的Shader代码 8,9,10步骤这三个步骤统称为像素管道，主要是对步骤7输入的光栅化像素进行操作的阶段。 这个阶段会逐像素地处理该像素的纹理映射，光照颜色，alpha融合，深度测试，模板测试等，并且根据该像素的距离信息进行雾化公式的应用，所以，顾名思义，像素管道主要处理的是像素信息，最终输出像素最终的颜色。 传统的3D管线只能通过有限几个图形API接口来操作像素，比如DX中设置多纹理的一些接口以及Alpha融合的接口，能够操作的范围很有限。 像素着色器所替换固定流水线的功能就是在这个阶段，在引入像素着色器之后，就可以根据需要对像素做许多自由的处理，因为帧缓存内的像素信息不止包含该像素的颜色、Alpha值、深度信息和模版信息，还可以包含该像素对应的法线贴图信息、高光贴图信息、凹凸贴图信息等（这些贴图实际上保存的是一系列向量信息），通过传入一定的参数，比如时间信息、物理量等，就能制作出各种贴近现实的精美特效。 UE3中的像素着色器也是通过材质编辑器中的表达式来处理的，UE3材质编辑器中的大部分输入节点都是用于处理像素着色的，如图所示]]></content>
  </entry>
  <entry>
    <title><![CDATA[游戏对象和脚本]]></title>
    <url>%2F2017%2F09%2F20%2F%E6%B8%B8%E6%88%8F%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[原文：http://catlikecoding.com/unity/tutorials/basics/game-objects-and-scripts/ 用简单的脚本构建一个时钟 用C#写脚本 让时钟转动起来 完成 这边文章通过创建简单的组件脚本来实现一个时钟。您仅需几分钟来熟悉Unity编辑器，如果您已经熟悉此部分，可以跳过本篇文章。 构建一个简单的时钟打开Unity创建一个3D对象，你不需要任何额外的资源包. 1.1 创建一个游戏对象默认的场景包含两个游戏对象，他们在层次窗口中而且你能看到他们的图标在场景窗口中，第一个是主相机，它是用来渲染的，第二个是方向光，照明场景的。使用GameObject-&gt;Create Empty 选项，也可以选择层级窗口添加一个新的对象在scene上。 监视窗口(Inspector window)展示游戏对象的细节，当选择时钟对象的时候，Inspector会展示他的name和一些额外的属性,默认为可用，非静态，没有标签属于一个默认的层。并且展示了所有的组件，transform组件是一定有的。 transform组件包括位置，旋转和缩放在3D空间，确保position和rotation是0，scale是1（这里指的都是本地坐标) 1.2 创建一个时钟虽然我们有了clock object,但是我们什么也做不了,我们还得创建3D模型来渲染，Unity包含一些原始的对象，用这些我们能构建一个简单的时钟，s首先添加一个cylinder(圆柱Gameobject-&gt;3D Object-&gt;Cylinder) 圆柱体有一个Mesh Filter包含一个圆柱体的mesh，第二个是Capsule Collider(胶囊碰撞体)用来搞物理的，第三是Mesh Renderer确保可以得到渲染的，也用来控制用那个材质来渲染，最后一个就是材质(Material). 虽然对象是一个圆柱体，但是它用了capsule collider,因为unity没有原生的cylinder collider,我们不需要它，干掉！如果你不需要物理的话，你可以选择Mesh Collider 组件,组件能被干掉。 为了搞一个时钟的脸，我们必须把这玩意搞平，缩减scale的y值， 将圆柱体的名字改为Face,表示clock的脸, 1.3 创建时钟刻度时钟有一圈刻度来告诉你现在几点了。添加一个立方体对象通过Gameobject-&gt;3D Object-&gt;Cube,改变缩放(0.5,0.2,1)刻度是难以看到的，因为他和表盘的颜色相同，让我们通过材质来区分吧，Assets-&gt;Create-&gt;Material，或者Proect Window都可以的，这个材质是复制默认的材质的，]]></content>
  </entry>
  <entry>
    <title><![CDATA[Unity渲染1 材质]]></title>
    <url>%2F2017%2F09%2F20%2FUnity%E6%B8%B2%E6%9F%931-%E6%9D%90%E8%B4%A8%2F</url>
    <content type="text"><![CDATA[PS：翻译Catlike的文章 创建一个立方体格子 支持缩放，位移，旋转 创建简单的相机投影 这是关于渲染的第一篇文章，]]></content>
  </entry>
  <entry>
    <title><![CDATA[scene和prefab的区别]]></title>
    <url>%2F2017%2F09%2F17%2Farticle-title%2F</url>
    <content type="text"><![CDATA[如果一个场景有多个相同的pfb(指引用相同的pfb，具体每个pfb可能有参数不同），那么Scene里每个pfb都是独立的对象，加载时每个对象都要走全套的流程: 文件I/O -&gt;反序列化 (解析，new obj + ctor) -&gt; awake -&gt; shader\texture\vbo create\upload，如果走pfb+Instantiate，那么前面的流程(文件I/O，反序列化）只用走一遍，直接Instantiate复制内存中现有的对象就行.另外pfb可以在合适的时候提前异步预加载，这样切场景的时候就更快了（场景也可以异步预加载，不过awake\upload to gpu这些必须在主线程做，所以会卡一下），pfb也便于做细粒度的热更. 但pfb对美术日常调整场景不友好，除非有个一键生成场景+一键存pfb.单论切换速度，什么都比不过预加载 + 大内存永驻 网易云搭建云服务器ssh -i zentia -l root 10.173.32.4例子: ssh -l sy 192.168.3.6Password:(QQ微云中保存)-i 表示私钥-l 表示登录帐号后跟着内网IP连内网IP需要配置OpenVPN，网上可以下载https://www.163yun.com/help/documents/56817419033956352 这是网易的文档，都有 SVN服务器搭建项目研发期间暂时用SVN管理服务器，等上线之后在考虑其它的思路。CentOS1.yum install subversion2.创建svn版本目录: mkdir -p /var/svn/svnrepos3.创建版本库: svnadmin create /var/svn/svnrepos4.cd /var/svn/svnrepos/conf (authz文件是权限控制文件;passwd是帐号密码文件;svnserve.conf SVN服务器配置文件)5.设置帐号密码 vi passwd 在[users]块中添加用户和密码，格式：帐号=密码，如zentia=zentia6.设置权限vi authz在末尾添加如下代码[/]zentia=rwliyanfeng=r意思是版本库的根目录zentia对其有读写权限，liyanfeng只有读权限。7.修改svnserve.conf文件打开下面几个注释：anon-access=read #匿名用户可读auth-access = write #授权用户可写password-db = passwd #使用哪个文件作为帐号文件authz-db = authz #使用哪个文件作为权限文件realm = /var/svn/svnrepos #认证空间名，版本库所在目录8.启动svn版本库svnserve -d -r /var/svn/svnreposps aux | grep svnserve #查看服务是否启动 SVN客户端搭建1.修改host文件 10.173.32.4 zentiasvr]]></content>
      <tags>
        <tag>Unity3D</tag>
      </tags>
  </entry>
</search>
