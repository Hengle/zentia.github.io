<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>高斯函数</title>
      <link href="/2019/03/25/Gaussian/"/>
      <url>/2019/03/25/Gaussian/</url>
      
        <content type="html"><![CDATA[<h1 id="一维高斯函数"><a href="#一维高斯函数" class="headerlink" title="一维高斯函数"></a>一维高斯函数</h1><p>高斯函数，Gaussian Function，也简称为Gaussian，一维形式如下：</p><p><font size="4">$f(x)=ae^{(x-b) \over 2c^2}$</font><br>高斯的一维图是特征对称“bell curve”</p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Opencv</title>
      <link href="/2019/03/25/opencv/"/>
      <url>/2019/03/25/opencv/</url>
      
        <content type="html"><![CDATA[<h1 id="平滑处理"><a href="#平滑处理" class="headerlink" title="平滑处理"></a>平滑处理</h1><p>“平滑处理”（smoothing）也称“模糊处理”（bluring），是一项简单且使用频率很高的图像处理方法。<br>平滑处理的用途很多，最常见的是用来减少图像上的噪点或者失真。在涉及到降低图像分辨率时，平滑处理是非常好用的方法。</p><h1 id="图像滤波和滤波器"><a href="#图像滤波和滤波器" class="headerlink" title="图像滤波和滤波器"></a>图像滤波和滤波器</h1><p>图像滤波：即在尽量保留图像细节特征的条件下对目标图像的噪声进行抑制，是图像预处理中不可缺少的操作，其处理效果的好坏将直接影响到后续图像处理和分析的有效性和可靠性。<br>消除图像中噪声成为叫做图像的平滑化或滤波操作。信号或图像的能量大部分几种在幅度谱的低频和中频段是很常见的，而在较高频段，信息经常被噪声淹没。因此一个能减低高频成分幅度的滤波器就能够减弱噪声的影响。<br>图像滤波的目的有两个：一个是抽出对象的特征作为图像识别的特征模式；另一个是为适应图像处理的要求，消除图像数字化时所混入的噪声。<br>而对滤波处理的要求也有两条：一是不能损坏图像的轮廓及边缘等重要信息；二是使图像清晰视觉效果好。</p><p>平滑滤波是低频增强的空间域滤波技术。它的目的有两类：一类是模糊；另一类是消除噪音。</p><h1 id="滤波和模糊"><a href="#滤波和模糊" class="headerlink" title="滤波和模糊"></a>滤波和模糊</h1><p>滤波可分为低通滤波和高通滤波两种。而高斯滤波是指用高斯函数作为滤波函数的滤波操作，至于是不是模糊，要看是高斯低通还是高斯高通，低通就是模糊，高通就是锐化。<br>高斯滤波是指用高斯函数作为滤波函数的滤波操作。<br>高斯模糊就是高斯低通滤波。</p><h1 id="高斯滤波"><a href="#高斯滤波" class="headerlink" title="高斯滤波"></a>高斯滤波</h1><p>高斯滤波是一种线性平滑滤波，适用于消除高斯噪声，广泛应用于图像处理的减噪过程。</p>]]></content>
      
      
      <categories>
          
          <category> Opencv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高斯模糊</title>
      <link href="/2019/03/25/gauss/"/>
      <url>/2019/03/25/gauss/</url>
      
        <content type="html"><![CDATA[<p>模式的实现有很多方法，例如均值模糊和中值模糊。均值模糊同样适用了卷积操作，它适用的卷积核中的各个元素值都相等，且相加等于1，也就是说，卷积后得到的像素值是其领域内各个像素值的平均值。而中值模式则是选择领域内对所有像素排序后的中值替换掉的颜色。一个更高级的模糊方法是高斯模糊。</p><h1 id="高斯滤波"><a href="#高斯滤波" class="headerlink" title="高斯滤波"></a>高斯滤波</h1><p>高斯模糊（Gaussian Blur），也叫高斯平滑，高斯滤波，其通常用它来减少图像噪声以及降低细节层次，尝尝也被用于对图像进行模糊。<br>通俗的讲，高斯模糊就是对整幅图像进行加权平均的过程，每一个像素点的值，都由其本身和领域内的其他像素经过加权平均后得到。高斯模糊的具体操作是：用一个模版（或称卷积、掩模）扫描图像中的每一个像素，用模版确定的领域内像素的加权平均灰度值去替代模版中心像素点的值。<br>高斯模糊同样利用了卷积计算，它适用了卷积核名为高斯核。高斯核是一个正方形大小的滤波器，其中每个元素的计算都是基于下面的高斯方程：</p><p><font size="4">$G(x,y)= {1 \over 2\pi\delta^2}^{e^{x^2+y^2 \over 2\delta^2}}$</font><br>其中，$\delta$是标准方差（一般取值为1），x和y分别对应了当前位置到卷积核中心的整数距离。要构建一个高斯核，我们只需要计算高斯核中各个位置对应的高斯值。为了保证滤波后的图像不会变暗，我们需要对高斯核中的权重进行归一化，既让每个权重除以所有权重的和，这样可以保证所有权重的和为1。因此，高斯函数中e前面的系数实际不会对结果有任何影响。<br>高斯方程很好地模拟了领域每个像素对当前处理像素的影响程度，距离越近，影响越大。</p>]]></content>
      
      
      <categories>
          
          <category> Unity Shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AssetBundles</title>
      <link href="/2019/03/24/AssetBundlesIntro/"/>
      <url>/2019/03/24/AssetBundlesIntro/</url>
      
        <content type="html"><![CDATA[<h1 id="AssetBundles"><a href="#AssetBundles" class="headerlink" title="AssetBundles"></a>AssetBundles</h1><p>AssetBundle是一个包含模型，纹理，预制，音频剪辑，甚至整个场景的可以在运行中加载的档案文件。AssetBundles可以表达彼此之间的依赖关系；例如，AssetBundle A中的Matrial可以引用AssetBundle B中的纹理。为了通过网络进行有效传递，可以根据用例需求使用内置算法选择压缩AssetBundle。</p><h2 id="压缩格式-BuildAssetBundleOptions"><a href="#压缩格式-BuildAssetBundleOptions" class="headerlink" title="压缩格式(BuildAssetBundleOptions)"></a>压缩格式(BuildAssetBundleOptions)</h2><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>None</td><td>无需任何特殊选项即可构建assetBundle</td></tr><tr><td>UncompressedAssetBundle</td><td>创建ab包时不压缩数据</td></tr><tr><td>DisableWriteTypeTree</td><td>不再ab中包含类型信息</td></tr><tr><td>DeterministicAssetBundle</td><td>使用存储在asset中的id的hash构建ab</td></tr><tr><td>ForceRebuildAssetBundle</td><td>强制rebuild ab</td></tr><tr><td>IgnoreTypeTreeChanges</td><td>执行增量构建检查时忽略类型树的改变</td></tr><tr><td>AppendHashToAssetBundleName</td><td>将hash附加到assetBundle名称</td></tr><tr><td>ChunkBasedCompression</td><td>创建AssetBundle时使用基于块LZ4压缩</td></tr><tr><td>StricMode</td><td>如果在其中报告任何错误，则不允许构建成功</td></tr><tr><td>DryRunBuild</td><td>只编译</td></tr><tr><td>DisableLoadAssetByFileName</td><td>禁用掉通过文件名加载ab</td></tr><tr><td>DisableLoadAssetByFileNameWithExtension</td><td>禁用掉通过文件名后缀加载ab</td></tr></tbody></table></div><p>Unity5的BuildAssetBundleOptions有CollectionDependencies但是在Unity2018.3中已经废弃了，原因是2018.3默认收集资源的依赖资源。<br>这个特性十分的方便，我们只需要将所有东西都做成prefab，将prefab作为资源指定给AssetBundle，由Unity自己去收集所用到的资源就好了。但实际项目中仅仅如此是不够的，原因在复用的资源上。<br>如果多个prefab使用了同一个资源，会出现什么问题呢？我们来试验一下。</p><p>而image下面的Dependencies是空的，也就是它没有任何依赖了。</p><p>然后此时我在将资源也打包，此时的Dependencies就出来了，但是路径是绝对路径。<br>这其实就是AssetBundle的链式结构和增量打包了。一个小的部分改变了，它将会改变的只有总的AssetBundle.manifest，还有直接依赖它本身的manifest。其他不依赖的部分是不需要重新打包的。<br>还有一点需要注意的地方是，除了manifest文件以外，还有一个没有后缀名称的AssetBundle文件。这个文件其实才是包含了所有依赖关系的总的依赖关系的配置文件，刚才我们能用txt打开的manifest文件，都只是用来做本地依赖关系和增量打包的时候用的。我们加载AssetBundle的时候，完全不需要加载那么manifest文件的，只需要那个没有后缀名称的AssetBundle文件（具体名字和你导出的文件夹有关）就行了。它代表的是该项目的所有AssetBundle依赖关系。<br>所以，刚才我们看到的manifest里面用的都是本地绝对路劲，那是针对你本地打包时用的，和加载无关。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> AssetBundle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DirectX 9 3D游戏设计入门</title>
      <link href="/2019/03/24/DirectX93DGame/"/>
      <url>/2019/03/24/DirectX93DGame/</url>
      
        <content type="html"><![CDATA[<p>随书代码下载地址：<a href="http://www.moon-labs.com/ml_book_samples.htm" target="_blank" rel="noopener">http://www.moon-labs.com/ml_book_samples.htm</a></p><h1 id="第一部分-必备的数学知识-Mathematical-Prerequisites"><a href="#第一部分-必备的数学知识-Mathematical-Prerequisites" class="headerlink" title="第一部分 必备的数学知识(Mathematical Prerequisites)"></a>第一部分 必备的数学知识(Mathematical Prerequisites)</h1><p>　　在这最开始的一部分中我们将介绍本书所要用到的数学知识。我们讨论的主题是向量，矩阵和相应的变换，当然还有一些有关面和线的内容。<br>对于想了解更多更全的这方面信息的读者，请查看有关线性代数的书籍。当然已经学习过线性代数的读者也可将它作为有必要的复习内容来阅读。（这里推荐你看看《线性代数与空间解析几何》）<br>　　除此之外，我们还将展示D3DX类中相关的数学模型和执行特殊变换的函数。<br>目标</p><ul><li>学习向量以及它们的3D计算机图形程序</li><li>学习矩阵以及学会使用它们来变换3D图形</li><li>学习怎样模拟面和线以及它们的3D图形程序</li><li>熟悉用于3D数学运算的D3DX库中包含的类和程序的子集<br>三维空间中的向量<br>　　几何学中，我们用有向线段表示向量，如图1。向量的两个属性是他的长度和他的顶点所指的方向。因此，可以用向量来模拟既有大小又有方向的物理模型。例如，以后我们要实现的粒子系统。我们用向量来模拟粒子的速度和加速度。在3D计算机图形学中我们用向量不仅仅模拟方向。例如我们常常想知道光线的照射方向，以及在3D世界中的摄象机。向量为在3维空间中表示方向的提供了方便。<br>　　<br>　　<img src="/2019/03/24/DirectX93DGame/1.png"><br>　　向量与位置无关。有同样长度和方向的两个向量是相等的，即使他们在不同的位置。观察彼此平行的两个向量，例如在图1中u和v是相等的。<br>　　我们继续学习左手坐标系。图2显示的是左手坐标系和右手坐标系。两者不同的是Z轴的方向。在左手坐标系中Z轴是向书的里面去的，而右手坐标系是向书的外边去的。<br>　　　　<img src="/2019/03/24/DirectX93DGame/2.png"><br>　　图2<br>　　因为向量的位置不能改变它的性质，我们可以把所有向量平移使他们的尾部和坐标系的原点重合。因此，当一个向量在标准位置我们能通过头点来描述向量。图3显示的是图1中的向量在标准位置的样子。<br>　　<img src="/2019/03/24/DirectX93DGame/3.png"><br>　　图3<br>　　我们通常用小写字母表示一个向量，但有时也用大写字母。如2、3和4维向量分别是：<br>　　　　　u = (ux, uy),<br>　　　　　N = (Nx, Ny, Nz),<br>　　　　　c = (cx, cy, cz, cw)。<br>　　我们现在介绍4个特殊的3D向量，就象图4显示的。首先是都由含有0的零向量；它被表示成加粗的0 = (0, 0, 0)。接下来3个特殊的向量标准基向量。它们被叫做i, j和k向量，分别沿着坐标系的x轴,y轴和z轴，并且有1的单位长：i = (1, 0, 0), j = (0, 1, 0), and k = (0, 0, 1)。<br>注意：只有1个单位长度的向量叫做单位向量（模长为1的向量）。<br>　　<img src="/2019/03/24/DirectX93DGame/4.png"><br>　　图4<br>在D3DX库中，我们能用D3DXVECTOR3类表示3维空间中的向量。它的定义是：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">D3DXVECTOR3</span> :</span> <span class="keyword">public</span> D3DVECTOR</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    D3DXVECTOR3() &#123;&#125;;</span><br><span class="line">    D3DXVECTOR3( CONST FLOAT * );</span><br><span class="line">    D3DXVECTOR3( CONST D3DVECTOR&amp; );</span><br><span class="line">    D3DXVECTOR3( CONST D3DXFLOAT16 * );</span><br><span class="line">    D3DXVECTOR3( FLOAT x, FLOAT y, FLOAT z );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// casting</span></span><br><span class="line">    <span class="keyword">operator</span> FLOAT* ();</span><br><span class="line">    <span class="keyword">operator</span> CONST FLOAT* () <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// assignment operators</span></span><br><span class="line">    D3DXVECTOR3&amp; <span class="keyword">operator</span> += ( CONST D3DXVECTOR3&amp; );</span><br><span class="line">    D3DXVECTOR3&amp; <span class="keyword">operator</span> -= ( CONST D3DXVECTOR3&amp; );</span><br><span class="line">    D3DXVECTOR3&amp; <span class="keyword">operator</span> *= ( FLOAT );</span><br><span class="line">    D3DXVECTOR3&amp; <span class="keyword">operator</span> /= ( FLOAT );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// unary operators</span></span><br><span class="line">    D3DXVECTOR3 <span class="keyword">operator</span> + () <span class="keyword">const</span>;</span><br><span class="line">    D3DXVECTOR3 <span class="keyword">operator</span> - () <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// binary operators</span></span><br><span class="line">    D3DXVECTOR3 <span class="keyword">operator</span> + ( CONST D3DXVECTOR3&amp; ) <span class="keyword">const</span>;</span><br><span class="line">    D3DXVECTOR3 <span class="keyword">operator</span> - ( CONST D3DXVECTOR3&amp; ) <span class="keyword">const</span>;</span><br><span class="line">    D3DXVECTOR3 <span class="keyword">operator</span> * ( FLOAT ) <span class="keyword">const</span>;</span><br><span class="line">    D3DXVECTOR3 <span class="keyword">operator</span> / ( FLOAT ) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> D3DXVECTOR3 <span class="keyword">operator</span> * ( FLOAT, CONST struct D3DXVECTOR3&amp; );</span><br><span class="line"></span><br><span class="line">    BOOL <span class="keyword">operator</span> == ( CONST D3DXVECTOR3&amp; ) <span class="keyword">const</span>;</span><br><span class="line">    BOOL <span class="keyword">operator</span> != ( CONST D3DXVECTOR3&amp; ) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">&#125; D3DXVECTOR3, *LPD3DXVECTOR3;</span><br></pre></td></tr></table></figure></li></ul><p>注意D3DXVECTOR3是从D3DVECTOR继承的。它的定义是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">D3DVECTOR</span> &#123;</span></span><br><span class="line">    <span class="keyword">float</span> x, y, z;</span><br><span class="line">&#125; D3DVECTOR;</span><br></pre></td></tr></table></figure></p><p>　　向量有它们自己的算法，就像你在D3DXVECTOR3定义中看到的数学运算。现在你不需要知道它们怎么使用。以后介绍这些向量运算以及一些有用的函数和关于向量的重要的详细资料。<br>注意：在3D图形程序中，虽然我们主要关心3D向量，但有时也会用到2D和4D向量。在D3DX库中提供了D3DXVECTOR2和D3DXVECTOR4类来分别表现2D和4D向量。不同维数的向量有着和3D向量一样的性质，也就是它们描述大小和方向，仅仅是在不同的维数中。所有这些向量的数学运算对于不同维数向量都有效只是有一个除外，就是向量积。这些运算我们可通过论述3D向量扩展到2D, 4D甚至n维向量。</p><h2 id="向量相等"><a href="#向量相等" class="headerlink" title="向量相等"></a>向量相等</h2><p>　　几何学上，有同样方向和长度的两个向量相等。数学上，我们说有同样维数和分量的向量相等。例如：如果ux = vx, uy = vy, 且 uz = vz.那么(ux, uy, uz) = (vx, vy, vz)。在代码中我们能够用“==”判断两个向量相等。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">D3DXVECTOR <span class="title">u</span><span class="params">(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>)</span></span>;</span><br><span class="line"><span class="function">D3DXVECTOR <span class="title">v</span><span class="params">(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span>( u == v ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></p><p>同样的，我们也能用“！=”判断两个向量不相等。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( u != v ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></p><p>注意：当比较浮点数时，必须注意。因为浮点数不是精确的，我们认为相等的两个浮点数是有细微差别的；因此，我们测试它们近似相等。我们定义一个常数EPSILON，把它当作非常小的“buffer”。假如两个数和EPSILON相差很小我们说它们近似相等。换句话说，EPSILON让浮点数有一定的精度。接下来的实例函数是怎样用EPSILON比较两个浮点数相等。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Equals</span><span class="params">(<span class="keyword">float</span> lhs, <span class="keyword">float</span> rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// if lhs == rhs their difference should be zero</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(lhs - rhs) &lt; EPSILON ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>   当我们用D3DXVECTOR3类时不必担心，因为它已经帮我们处理了，但是在一般情况下适当注意比较两个浮点数是很重要的。</p><h2 id="计算向量大小（向量的模）"><a href="#计算向量大小（向量的模）" class="headerlink" title="计算向量大小（向量的模）"></a>计算向量大小（向量的模）</h2><p>　　几何学上，向量的大小是有向线段的长度。知道向量的分量，利用下面的公式我们就能计算出向量的大小。</p><p><font size="4">$||u||=\sqrt{u_{x}^2+u_{y}^2+u_{z}^2}$</font><br>‖u‖表示向量u的长度。例如：计算向量u = (1, 2, 3)和v = (1, 1)的大小。<br>根据公式（1），我们得到：<br>　　<font size="4">$||u||=\sqrt{1^2+2^2+3^2} = \sqrt{1+4+9}=\sqrt{14}$</font><br>　　<br>我们利用D3DX库中下面的函数便能计算向量的大小。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FLOAT <span class="title">D3DXVec3Length</span><span class="params">( <span class="comment">// Returns the magnitude.</span></span></span></span><br><span class="line"><span class="function"><span class="params">　　CONST D3DXVECTOR3* pV <span class="comment">// The vector to compute the length of.</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="function">D3DXVECTOR3 <span class="title">v</span><span class="params">(<span class="number">1.0f</span>, <span class="number">2.0f</span>, <span class="number">3.0f</span>)</span></span>;</span><br><span class="line"><span class="keyword">float</span> magnitude = D3DXVec3Length( &amp;v ); <span class="comment">// = sqrt(14)</span></span><br></pre></td></tr></table></figure></p><h2 id="标准化向量"><a href="#标准化向量" class="headerlink" title="标准化向量"></a>标准化向量</h2><p>　　<font color="red">标准化向量是让向量的大小等于1，即被叫作单位向量。</font>我们能利用向量大小以及各个分量把一个向量标准化，就像这样：<br>　　$\hat{u} ={u \over ||u||} = {({u_x \over ||u||}, {u_y \over ||u||}, {u_z \over ||u||})}$<br>我们这样表示单位向量$\hat{u}$。如：标准化向量u = (1, 2, 3) 和 v = (1, 1)。<br>解答方法：根据(2)和(3)我们得到‖u‖=√14 和 ‖v‖=√2,因此：<br>　　<br>我们利用D3DX库中下面的函数能标准化向量。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">D3DXVECTOR3 *<span class="title">D3DXVec3Normalize</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    D3DXVECTOR3* pOut, <span class="comment">// Result.</span></span></span></span><br><span class="line"><span class="function"><span class="params">    CONST D3DXVECTOR3* pV <span class="comment">// The vector to normalize.</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure></p><p>注意：这个函数返回一个指针，因此它可以作为一个参数传递给另一个函数。大数情况下，除非另作说明，D3DX数学函数返回的结果是一个指针。但不是所有函数都这样。</p><h2 id="向量相加"><a href="#向量相加" class="headerlink" title="向量相加"></a>向量相加</h2><p>　　我们能够通过分别把两个向量的各个分量相加得到向量之和，注意在相加之前必须保证它们有相同的维数。<br>$u + v = ({u_x + v_x, u_y + v_y, u_z + v_z})$<br>图5显示的是几何学上的向量相加。<br><img src="/2019/03/24/DirectX93DGame/5.png" title="图5"></p><p>两个向量相加的代码，我们使用重载的加法操作符：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">D3DXVECTOR3 <span class="title">u</span><span class="params">(<span class="number">2.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>)</span></span>;</span><br><span class="line"><span class="function">D3DXVECTOR3 <span class="title">v</span><span class="params">(<span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">5.0f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2.0 + 0.0,  0.0 + (-1.0),  1.0 + 5.0)</span></span><br><span class="line">D3DXVECTOR3 sum = u + v; <span class="comment">// = (2.0f, -1.0f, 6.0f)</span></span><br></pre></td></tr></table></figure></p><h2 id="向量相减"><a href="#向量相减" class="headerlink" title="向量相减"></a>向量相减</h2><p>　　和加法类似，通过分别把两个向量的各个分量相减得到向量之差。再次重声两个向量必须是相同维数。<br>　　$u + v = ({u_x - v_x, u_y - v_y, u_z - v_z})$<br>图6显示的是几何学上的向量相减。<br><img src="/2019/03/24/DirectX93DGame/5.png" title="图6"><br>两个向量相减的代码，我们使用重载的减法操作符：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">D3DXVECTOR3 <span class="title">u</span><span class="params">(<span class="number">2.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>)</span></span>;</span><br><span class="line"><span class="function">D3DXVECTOR3 <span class="title">v</span><span class="params">(<span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">5.0f</span>)</span></span>;</span><br><span class="line">D3DXVECTOR3 difference = u - v; <span class="comment">// = (2.0f, 1.0f, -4.0f)</span></span><br></pre></td></tr></table></figure></p><p>　　图6显示，向量减法得到一个从v向量终点到u向量终点的向量。假如我们解释u和v的分量，我们能用向量相减找到从一个点到另一个点的向量。这是非常方便的操作，因为我们常常想找到从一个点到另一个点的方向向量。</p><h2 id="标量与向量的乘积"><a href="#标量与向量的乘积" class="headerlink" title="标量与向量的乘积"></a>标量与向量的乘积</h2><p>　　我们能用一个标量与向量相乘，就象名字暗示的一样，向量按比例变化。这种运算不会改变向量的方向，除非标量是负数，这种情况向量方向相反。<br>　　$ku=(ku_x,ku_y,ku_z)$<br>D3DXVECTOR3类提供了向量与标量乘法的操作符。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">D3DXVECTOR3 <span class="title">u</span><span class="params">(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">-1.0f</span>)</span></span>;</span><br><span class="line">D3DXVECTOR3 scaledVec = u * <span class="number">10.0f</span>; <span class="comment">// = (10.0f, 10.0f, -10.0f)</span></span><br></pre></td></tr></table></figure></p><h2 id="点积"><a href="#点积" class="headerlink" title="点积"></a>点积</h2><p>　　数学上定义点积是两个向量的乘积。按下面等式计算：<br>　　$u \cdot v = u_{x}v_z{$}+u_{x}v_z{$}+u_{x}v_z{$} = S$<br>　　上面的等式不能很明显的体现几何上的意义。利用余弦定律，我们能够发现它们的关系。<br>　　u · v =|u||v|cosθ，表示两个向量的点积是它们的模和夹角的余弦之积。因此，如果u 和v都是单位向量，那么u · v就是它们夹角的余弦。<br>一些点积中有用的特性<br>　　■　假如u · v = 0，那么u⊥v。<br>　　■　假如u · v &gt; 0，那么两个向量的角度θ小于90度。<br>　　■　假如u · v &lt; 0，那么两个向量的角度θ大于90度。<br>　　我们使用下面的D3DX函数计算两个向量的点积：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FLOAT <span class="title">D3DXVec3Dot</span><span class="params">( <span class="comment">// Returns the result.</span></span></span></span><br><span class="line"><span class="function"><span class="params">　　CONST D3DXVECTOR3* pV1, <span class="comment">// Left sided operand.</span></span></span></span><br><span class="line"><span class="function"><span class="params">　　CONST D3DXVECTOR3* pV2 <span class="comment">// Right sided operand.</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="function">D3DXVECTOR3 <span class="title">u</span><span class="params">(<span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>)</span></span>;</span><br><span class="line"><span class="function">D3DXVECTOR3 <span class="title">v</span><span class="params">(<span class="number">3.0f</span>, <span class="number">2.0f</span>, <span class="number">1.0f</span>)</span></span>;</span><br><span class="line"><span class="comment">// 1.0*3.0 + -1.0*2.0 + 0.0*1.0</span></span><br><span class="line"><span class="comment">// = 3.0 + -2.0</span></span><br><span class="line"><span class="keyword">float</span> dot = D3DXVec3Dot( &amp;u, &amp;v ); <span class="comment">// = 1.0</span></span><br></pre></td></tr></table></figure></p><h2 id="叉积"><a href="#叉积" class="headerlink" title="叉积"></a>叉积</h2><p>　　第二种乘法在向量数学中叫叉积。<strong>不像点积，结果值是一个标量，叉积的结果值是另一个向量。</strong>通过把两个向量u和v相乘得到另一的向量p，向量p垂直于u和v。也就是说向量p垂直于u并且垂直于u。<br>十字相乘就像这样计算：<br>$p=u \times v=[(u_{y}v_z-u_{z}v_{y}),(u_{z}v_x-u_{x}v_{z}),(u_{x}v_y-u_{y}v_{x})]$<br>$p_x = (u_{y}v_z-u_{z}v_{y})$<br>$p_y = (u_{z}v_x-u_{x}v_{z})$<br>$p_z = (u_{x}v_y-u_{y}v_{x})$<br>　　<br>如：发现j = k×i = (0, 0, 1)×(1, 0, 0) 并且j同时垂直于k和i.<br>因此，j = (0, 1, 0)。回忆一下上节的标题“叉积”，是说如果u · v = 0，那么u⊥v。同样的如果j · k = 0并且j · i = 0那么我们便能知道j既垂直于k又垂直于i的。<br>我们使用下面的D3DX函数计算两个向量的叉积：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">D3DXVECTOR3 *<span class="title">D3DXVec3Cross</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    D3DXVECTOR3* pOut, <span class="comment">// Result.</span></span></span></span><br><span class="line"><span class="function"><span class="params">    CONST D3DXVECTOR3* pV1, <span class="comment">// Left sided operand.</span></span></span></span><br><span class="line"><span class="function"><span class="params">    CONST D3DXVECTOR3* pV2 <span class="comment">// Right sided operand.</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure></p><p>　　从下图很明显，向量-p与u和v也都相互垂直。我们执行叉积的命令，确定得到的的结果不管是p或者-p。换句话说，u×v = -(v×u)。这说明叉积是不可交换的。你能通过左手法则确定叉积返回的向量。按照第一个向量指向第二个向量弯曲你的左手，这时拇指所指的方向就是向量所指的方向。<br><img src="/2019/03/24/DirectX93DGame/7.png" title="图7">　</p><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p>在这一部分我们关注的焦点是数学中的矩阵。它们在3D图形学中的应用将在下一部分讲解。<br>一个m×n的矩阵是由m行和n列的数字组成的矩阵列。行和列的数字就是这个矩阵的维数。我们通过写在下方的数字识别矩阵清单，数字中的第一个表示行第二个表示列。例如下边的M是3×3矩阵，B是2×4矩阵, C是3×2矩阵。<br>$M=\begin{bmatrix} m_{11} &amp; m_{12} &amp; m_{13} \\ m_{21} &amp; m_{22} &amp; m_{23} \\ m_{31} &amp; m_{32} &amp; m_{33} \\\end{bmatrix}$ $B=\begin{bmatrix} b_{11} &amp; b_{12} &amp; b_{13} b_{14} \\ b_{21} &amp; b_{22} &amp; b_{23} b_{24} \\\end{bmatrix}$ $C=\begin{bmatrix} c_{11} &amp; c_{12} \\ c_{21} &amp; c_{22} \\c_{31} &amp; c_{32} \\\end{bmatrix}$<br>我们使用加粗的大写字母表示矩阵。有时一个矩阵只包含一行或者一列。我们用行矩阵和列矩阵这个特殊的名称来称呼。例如下边就是行和列矩阵：<br>$V = \begin{bmatrix} v_{1} &amp; v_{2} &amp; v_{3} v_{4} \\\end{bmatrix}$ $U = \begin{bmatrix} u_{x} \\ v_{y} \\ v_{z} \\\end{bmatrix}$<br>当使用行或列矩阵时，我们只用一个下标，有时我们还用字母表示。</p><h2 id="相等、数乘矩阵以及相加"><a href="#相等、数乘矩阵以及相加" class="headerlink" title="相等、数乘矩阵以及相加"></a>相等、数乘矩阵以及相加</h2><p>这部分我们将用到下边4个矩阵：<br>　　$A = \begin{bmatrix} 1 &amp; 5 &amp; -2 3 \\\end{bmatrix}$ $B = \begin{bmatrix} 6 &amp; 2 &amp; 5 -8 \\\end{bmatrix}$ $C = \begin{bmatrix} 1 &amp; 5 &amp; -2 3 \\\end{bmatrix}$ $D = \begin{bmatrix} 1 &amp; 2 &amp; -1 &amp; 3 \\ -6 &amp; 3 &amp; 0 &amp; 0 \\\end{bmatrix}$<br>　■假如两个矩阵维数和成员都相同那么它们就相等。例如，A = C 因为A和C有同样的维数并且他们的成员都相等。A≠B同时A≠D因为他们的成员或者维数是不相同的。<br>　■我们能通过标量与矩阵的每个成员相乘得到标量与矩阵相乘。如矩阵D与k相乘：<br>　　$kD = \begin{bmatrix} k(1) &amp; k(2) &amp; k(-1) &amp; k(3) \\ k(-6) &amp; k(3) &amp; k(0) &amp; k(0) \\\end{bmatrix}$<br>假如k = 2,那么：<br>　　$kD = 2D = \begin{bmatrix} 2(1) &amp; 2(2) &amp; 2(-1) &amp; 2(3) \\ 2(-6) &amp; 2(3) &amp; 2(0) &amp; 2(0) \\\end{bmatrix} = \begin{bmatrix} 2 &amp; 4 &amp; -2 &amp; 6 \\ -12 &amp; 6 &amp; 0 &amp; 0 \\\end{bmatrix}$<br>　■当两个矩阵的维数相同时才能把它们相加。和是把两个矩阵相应的成员相加得到。如：<br>　　$A+B=\begin{bmatrix} 1 &amp; 5 \\ -2 &amp; 2(3) &amp; 2(0) &amp; 2(0) \\\end{bmatrix} + \begin{bmatrix} 2(1) &amp; 2(2) &amp; 2(-1) &amp; 2(3) \\ 2(-6) &amp; 2(3) &amp; 2(0) &amp; 2(0) \\\end{bmatrix}$<br>　■矩阵有加法当然也就有减法，前提是有相同的维数。矩阵减法如图所示：</p><p>乘法<br>　　矩阵相乘在3D计算机图形学中是非常重要的运算。通过矩阵相乘，我们能变换向量并且，将不同向量转换到一起。变换是下一节的内容。<br>　　为了得到矩阵之积AB，A的列数必须等于B的行数。假如这个条件不满足，就不能相乘。考虑下边两个矩阵，A 和 B，分别是2×3 和 3×3，如：<br>　　<br>　　我们看乘积AB是可以计算的，因为A的列数等于B的行数。注意乘积BA,它们是不能计算的，因为B的列数不等于A的行数。由此说明：一般情况下矩阵乘法不满足乘法交换律（也就是, AB≠BA）。我们说“一般不可交换”因为有一些矩阵乘法的实例还是可以的。<br>　　知道了矩阵乘法的计算方法，现在我们就能给出精确的定义：假如A是一个m×n的矩阵，B是一个n×p的矩阵，那么它们之积AB可计算并且是一个m×p 的矩阵C, C的成员ij 等于A的第i个与B的第j个相乘：<br>　　<br>例如，求解：<br>　　<br>　　我们检查知道乘法是可计算的，因为A的列数等于B的行数。也知道计算的结果是一个2×2的矩阵。根据公式（4），我们得到：<br>　　<br>作为练习，检查AB≠BA。<br>更一般的例子：<br>　　<br>单位矩阵<br>　　有一种特殊矩阵叫做单位矩阵。单位矩阵是除了对角（左上到右下）以外所有成员都是0，对角都是1的方矩阵。例如，下边是2×2, 3×3, 和 4×4的单位矩阵：</p><p>单位矩阵有如下特性：<br>MI = IM=M<br>即，用单位矩阵乘以矩阵不会改变矩阵。此外，这是一个特例：用单位矩阵进行乘法运算满足乘法交换律。单位矩阵可以看作矩阵运算中的数字“1”。</p><p>例如：验证2×2矩阵M与单位矩阵相乘得到的结果是M。</p><p>逆转<br>下面列举了关于逆矩阵的重要信息。</p><ul><li>只有正方形的矩阵（方阵）才能求逆，因此当我们说矩阵求逆，那么它就是方矩阵。</li><li>n×n矩阵M的逆矩阵是一个n×n矩阵表示为M–1</li><li>不是每个方矩阵都有逆矩阵</li><li><p>矩阵和他的逆矩阵相乘得到一个单位矩阵：M M–1 = M–1M = I。注意当我们进行这样的操作时矩阵是可交换的。<br> 逆矩阵用来解决与其他矩阵相等是非常有用的。例如，考虑等式p’= pR 并且假设我们知道p’和R想求p。首先找到R–1，一旦求得R–1，我们便能求出p，就象这样：</p><p> 求逆矩阵的方法已经超出了本书的范围，但是这在任何一本线性代数书上都有讲解。在“基本变换”一节我们给出一个特定矩阵的逆矩阵。在“D3DX 矩阵”部分我们将学习一个为我们求逆矩阵的D3DX函数。<br>　　我们介绍几个有用的推论：(AB) –1 = B–1 A–1。这个性质前提是：假定A和B都能求逆并且它们都是有相同维数的方矩阵。<br>矩阵的转置<br>　　矩阵的转置是相互交换矩阵的行和列。因而，m×n的矩阵的转置是一个n×m的矩阵。我们把矩阵M的转置记作MT。<br>例如：求下面两个矩阵的转置：<br>　　<br>　　重声一下，转置是交换矩阵的行和列。<br>因此：<br>　　<br>D3DX 矩阵<br>　　当设计Direct3D应用程序时，使用4×4矩阵和1×4行矩阵（向量）是有代表性的。注意使用这两种矩阵意味着可以进行下列定义的矩阵乘法。</p></li><li>向量-矩阵乘法。即，假如1×4的单行矩阵V，和4×4的矩阵T，那么积VT可计算并且返回的结果是一个1×4的单行矩阵（向量）。</li><li>矩阵-矩阵乘法。即，假如4×4的矩阵T，和4×4的矩阵R，那么积TR和RT可计算并且两者返回的结果都是一个4×4的矩阵。注意因为矩阵乘法不满足交换律所以TR和RT不一定相等。<br>　　在D3DX中表示1×4的行矩阵（向量），我们用D3DXVECTOR3和D3DXVECTOR4向量类。当然D3DXVECTOR3只有3个成员，不是4个。然而，第4个成员缺省是1或0（在下一部分有更多信息）。<br>　　在D3DX中表示4×4的矩阵，我们用D3DXMATRIX类，定义如下：<br>typedef struct D3DXMATRIX : public D3DMATRIX {<br>public:<br>  D3DXMATRIX() {};<br>  D3DXMATRIX( CONST FLOAT * );<br>  D3DXMATRIX( CONST D3DMATRIX&amp; );<br>  D3DXMATRIX( FLOAT _11, FLOAT _12, FLOAT _13, FLOAT _14,<pre><code>          FLOAT _21, FLOAT _22, FLOAT _23, FLOAT _24,          FLOAT _31, FLOAT _32, FLOAT _33, FLOAT _34,          FLOAT _41, FLOAT _42, FLOAT _43, FLOAT _44 );</code></pre>  // access grants<br>  FLOAT&amp; operator () ( UINT Row, UINT Col );<br>  FLOAT  operator () ( UINT Row, UINT Col ) const;<br>  // casting operators<br>  operator FLOAT<em> ();<br>  operator CONST FLOAT</em> () const;<br>  // assignment operators<br>  D3DXMATRIX&amp; operator <em>= ( CONST D3DXMATRIX&amp; );<br>  D3DXMATRIX&amp; operator += ( CONST D3DXMATRIX&amp; );<br>  D3DXMATRIX&amp; operator -= ( CONST D3DXMATRIX&amp; );<br>  D3DXMATRIX&amp; operator </em>= ( FLOAT );<br>  D3DXMATRIX&amp; operator /= ( FLOAT );<br>  // unary operators<br>  D3DXMATRIX operator + () const;<br>  D3DXMATRIX operator - () const;<br>  // binary operators<br>  D3DXMATRIX operator <em> ( CONST D3DXMATRIX&amp; ) const;<br>  D3DXMATRIX operator + ( CONST D3DXMATRIX&amp; ) const;<br>  D3DXMATRIX operator - ( CONST D3DXMATRIX&amp; ) const;<br>  D3DXMATRIX operator </em> ( FLOAT ) const;<br>  D3DXMATRIX operator / ( FLOAT ) const;<br>  friend D3DXMATRIX operator <em> ( FLOAT, CONST D3DXMATRIX&amp; );<br>  BOOL operator == ( CONST D3DXMATRIX&amp; ) const;<br>  BOOL operator != ( CONST D3DXMATRIX&amp; ) const;<br>} D3DXMATRIX, </em>LPD3DXMATRIX;</li></ul><p>D3DXMATRIX类是从单数结构D3DMATRIX继承的复数形式。D3DMATRIX的定义是：<br>typedef struct _D3DMATRIX {<br>    union {<br>        struct {<br>            float        _11, _12, _13, _14;<br>            float        _21, _22, _23, _24;<br>            float        _31, _32, _33, _34;<br>            float        _41, _42, _43, _44;<br>        };<br>        float m[4][4];<br>    };<br>} D3DMATRIX;<br>　　<br>　　观察D3DXMATRIX类发现有很多有用的运算符，比如对矩阵检测相等，矩阵相加和矩阵相减，标量与矩阵相乘，铸造（casting），以及非常重要的两个D3DXMATRIXs相乘。因为矩阵相乘是非常重要的，我们给出一段实例代码：<br>D3DXMATRIX A(…); // initialize A<br>D3DXMATRIX B(…); // initialize B<br>D3DXMATRIX C = A * B; // C = AB</p><p>   D3DXMATRIX类另一个重要的运算符是小括号，它允许我们非常方便的为矩阵成员赋值。注意当使用小括号时我们的下标就象C语言数组下标一样是从0开始的。例如，为一个矩阵的ij = 11 赋值，我们写成：<br>D3DXMATRIX M;<br>M(0, 0) = 5.0f; // Set entry ij = 11 to 5.0f.</p><p>   D3DX库也提供下列有用的函数：将D3DXMATRIX转化为单位矩阵，转置D3DXMATRIX矩阵以及求逆矩阵。<br>   D3DXMATRIX <em>D3DXMatrixIdentity(<br>        D3DXMATRIX </em>pout // 将矩阵转换为单位矩阵<br>   );<br>D3DXMATRIX M;<br>D3DXMatrixIdentity( &amp;M ); // M = 单位矩阵</p><p>D3DXMATRIX <em>D3DXMatrixTranspose(<br>    D3DXMATRIX </em>pOut, // 输出的转置矩阵<br>    CONST D3DXMATRIX *pM // 原矩阵<br>);<br>D3DXMATRIX A(…); // 初始化矩阵A<br>D3DXMATRIX B;<br>D3DXMatrixTranspose( &amp;B, &amp;A ); // B = 输出的转置矩阵</p><p>   假如我们将不能求逆的矩阵用求逆函数，那么函数将会返回null.同样的，这本书我们忽视第二个参数，并且总是把它设置为0。<br>D3DXMATRIX <em>D3DXMatrixInverse(<br>    D3DXMATRIX </em>pOut, // 输出的逆矩阵<br>    FLOAT <em>pDeterminant, // 除非是必需的，一般设为0<br>    CONST D3DXMATRIX </em>pM // 原矩阵<br>);<br>D3DXMATRIX A(…); // 初始化矩阵<br>D3DXMATRIX B;<br>D3DXMatrixInverse( &amp;B, 0, &amp;A ); // B = A的逆矩阵<br>基本变换<br>　　当用Direct3D编程时，我们使用4×4矩阵来进行矩阵变换。用它的原因是：我们设置一个4×4矩阵X是为了更精确的描述矩阵变换。同样我们设置一个相匹配的点或者把向量的分量放置到一个1×4的行矩阵V中。VX的乘积返回一个新的向量V’。例如：让X沿着x轴平移10个单位同时V = [2, 6, –3, 1]，乘积VX = V’= [12, 6, –3, 1]。<br>　　有一些东西需要阐明。我们使用4×4矩阵是因为这样的大小能表现我们需要的所有变换。最初看来一个3×3的好象更适合3D。然而这里有很多种我们喜欢用的变换是不能用一个3×3的矩阵来表示的，比如平移、投影、反射。我们使用向量-矩阵相乘来工作，因此我们至少要通过一个矩阵乘法来完成相应的变化。增大到4×4的矩阵后，它允许我们用一个矩阵描述更多的变换，并且向量-矩阵乘法是可行的。<br>　　我们说过把一个相匹配的点或者一个向量的成员放置到一个1×4的行矩阵中。但是点和向量是3D的！为什么我们要用一个1×4的行矩阵呢？我们必需把3D点/向量增大为4D的单行矩阵，是为了符合向量与矩阵的乘法定义，而1×3的单行矩阵和4×4的矩阵相乘是不允许的。<br>　　那么，我们怎么使用第四个成员（我们用w来表示）呢？当我们把一个点放置到一个1×4的行矩阵中时，我们设置w为1。允许对点进行适当的平移。因为向量和位置无关，所以向量的平移没有被定义，如果试图这样做会返回一个无意义的向量。为了防止对向量进行平移，当在把一个向量放置到一个1×4行矩阵中时我们把w设置为0。例如：<br>把点p = (p1, p2, p3)放置到一个单行矩阵中就象这样：<br>[p1, p2, p3, 1]，<br>同样把向量v = (v1, v2, v3) 放置到一个单行矩阵中就象这样：<br>[v1, v2, v3, 0]。<br>　　<br>注意：我们设置w = 1是为了让点可以被恰当的移动，同样我们设置w = 0是为了防止向量被平移。当我们检查矩阵实际平移时这是一个非常清晰的模型。<br>　　有时一个矩阵变换时我们改变向量成员w的值，即w≠0 且 w≠1。考虑下边例子：<br>　　<br>　　因为p3≠0 且 p3≠1。<br>　　我们注意w =p3。当w≠0 且 w≠1时，我们说我们有一个向量在同类空间中，与3维空间中的向量是相对的。我们能通过把向量的每个分量与w相除将同类空间中的向量映射到3维空间中来。例如把同类空间中向量(x, y, z, w) 映射到3维空间中的向量x，我们这样做：<br>　　<br>　　在3D图形程序设计中，从齐次坐标空间映射到3D空间时使用投影透视。<br>矩阵平移</p><p>图8<br>    我们能通过与下面的矩阵相乘把向量(x, y, z, 1)沿x轴移动px个单位，沿y轴移动py 个单位，沿z轴移动pz个单位：</p><p>将矩阵平移的D3DX函数是：<br>D3DXMATRIX <em>D3DXMatrixTranslation(<br>    D3DXMATRIX</em> pOut, // 返回平移后的矩阵.<br>    FLOAT x, // x轴移动的单位<br>    FLOAT y, // y轴移动的单位<br>    FLOAT z // z轴移动的单位<br>);<br>　　练习：让T(p)做为一个平移变换矩阵，v = [v1, v2, v3, 0]是也个任意向量。验证vT(p) = v（即，假如w = 0，验证通过平移不会改变向量）。<br>　　平移矩阵求逆只需要简单的将向量p取反即可：</p><p>矩阵旋转</p><p>图9<br>    我们能用下面的矩阵把一个向量围绕x,y 和z轴旋转δ弧度。注意：当我们俯视绕轴原点时，角度是指顺时针方向的角度。</p><p>将矩阵饶着x轴旋转的D3DX函数是：<br>D3DXMATRIX <em>D3DXMatrixRotationX(<br>    D3DXMATRIX</em> pOut, // 返回旋转后的矩阵<br>    FLOAT Angle // Angle是旋转的弧度<br>);</p><p>将矩阵饶着y轴旋转的D3DX函数是：<br>D3DXMATRIX <em>D3DXMatrixRotationY(<br>    D3DXMATRIX</em> pOut, // 返回旋转后的矩阵<br>    FLOAT Angle // Angle是旋转的弧度<br>);</p><p>将矩阵饶着z轴旋转的D3DX函数是：<br>D3DXMATRIX <em>D3DXMatrixRotationZ(<br>    D3DXMATRIX</em> pOut, // 返回旋转后的矩阵<br>    FLOAT Angle // Angle是旋转的弧度<br>);<br>旋转矩阵R的逆矩阵等于它的转置矩阵：RT= R-1。这样的矩阵我们说它们是互相垂直的。<br>矩阵缩放</p><p>图10<br>　　我们能通过与下面的矩阵相乘把向量沿x轴缩放qx个单位，沿y轴缩放qy 个单位，沿z轴缩放qz个单位：<br>　　<br>将矩阵缩放的D3DX函数是：<br>D3DXMATRIX <em>D3DXMatrixScaling(<br>    D3DXMATRIX</em> pOut, // 返回缩放后的矩阵<br>    FLOAT sx, // x轴缩放的比例<br>    FLOAT sy, // y轴缩放的比例<br>    FLOAT sz // z轴缩放的比例.<br>);<br>　　缩放矩阵求逆只需要将每个缩放因子取倒即可：<br>　　<br>综合变换<br>    常常我们要对一个向量进行一系列的变换。比如，我们可能先缩放一个向量，然后旋转它，最后把它平移到指定的位置。<br>　　例如：先把向量p = [5, 0, 0, 1] 在所有轴上缩小为原来的1/5，然后沿着y轴旋转π/4，最后把它在x轴上移动1个单位，在y轴上移动2个单位，在z轴上移动3个单位。<br>　　解答：注意我们必须完成缩放，沿y轴旋转，以及移动。我们设缩放、旋转、移动的变换矩阵分别是S, Ry, T，如下：<br>　　<br>　　<br>　　应用缩放，旋转，以及平移一系列变换，我们得到：<br>　　<br>　　我们能用矩阵乘法把几个变换矩阵转换成一个矩阵，它是非常有益的矩阵。比如，重新考虑这部分开始的例子。通过使用矩阵相乘把3个变换矩阵合成一个矩阵。注意我们必须按实际应用的顺序来进行矩阵相乘。<br>　　<br>那么 pQ = [1.707, 2, –3.707, 1]。<br>　　联合变换有提高效率的能力。假如我们需要对一组数量巨大的向量（在3D图形任务中是很普遍的）进行同样的缩放，旋转以及移动变换。替换这一系列的变换，即就象等式(5)中对每一个向量的做法，我们能把所有3个变换转换到一个矩阵中，即就象在等式(6)中的做法。这样我们只需要对每一个向量进行一次乘法就可以实现3种变换。这就减少了大量的向量-矩阵乘法操作。<br>一些向量变换函数<br>　　D3DX库分别提供了下边两个对点和向量的变换函数。D3DXVec3TransformCoord函数变换点同时设置向量第4个成员为1（用于变换点向量）。D3DXVec3TransformNormal函数变换向量并且设置第4个成员为0（用于变换方向向量）。<br>D3DXVECTOR3 <em>D3DXVec3TransformCoord(<br>        D3DXVECTOR3</em> pOut, // 返回的点向量<br>        CONST D3DXVECTOR3<em> pV, // 点向量<br>        CONST D3DXMATRIX</em> pM // 变换矩阵<br>　　);<br>D3DXMATRIX T(…); // 初始化矩阵<br>D3DXVECTOR3 p(…); // 初始化点<br>D3DXVec3TransformCoord( &amp;p, &amp;p, &amp;T); // 变换一个点</p><p>D3DXVECTOR3 <em>WINAPI D3DXVec3TransformNormal(<br>        D3DXVECTOR3 </em>pOut, //返回的方向向量<br>        CONST D3DXVECTOR3 <em>pV, // 方向向量<br>        CONST D3DXMATRIX </em>pM //变换矩阵<br>);<br>D3DXMATRIX T(…); // 初始化变换矩阵<br>D3DXVECTOR3 v(…); // 初始化方向向量<br>D3DXVec3TransformNormal( &amp;v, &amp;v, &amp;T); // 变换方向向量<br>注意：D3DX库也提供D3DXVec3TransformCoordArray和D3DXVec3TransformNormalArray来分别变换一个点数组和向量数组<br>平面<br>   一个平面能通过一个向量n和平面上的一个点p0来描述。这个向量n垂直于平面，它被称为此平面的法向量（如图11）。</p><p>图11</p><p>在图12中我们能够发现平面上任意一点p都满足如下等式。即：假如p、p0都是平面上一点，那么向量（p - p0）垂直于平面的法向量。</p><p>图12<br>　　当我们通过法向量n和平面上一个已知点来描述一个平面时，等式（7）又被写成这样：<br>　　<br>　　这时d = –n·p0。<br>D3DX平面<br>　　在代码中描述一个平面：仅仅需要一个法向量n和常数d就可以了。因此我们就使用一个4D向量（我们记录成(n, d)）来实现它。D3DX库中用如下的结构来定义一个平面：<br>typedef struct D3DXPLANE<br>{</p><h1 id="ifdef-cplusplus"><a href="#ifdef-cplusplus" class="headerlink" title="ifdef __cplusplus"></a>ifdef __cplusplus</h1><p>public:<br>    D3DXPLANE() {}<br>    D3DXPLANE( CONST FLOAT<em> );<br>    D3DXPLANE( CONST D3DXFLOAT16</em> );<br>    D3DXPLANE( FLOAT a, FLOAT b, FLOAT c, FLOAT d );<br>    // casting<br>    operator FLOAT<em> ();<br>    operator CONST FLOAT</em> () const;<br>    // unary operators<br>    D3DXPLANE operator + () const;<br>    D3DXPLANE operator - () const;<br>    // binary operators<br>    BOOL operator == ( CONST D3DXPLANE&amp; ) const;<br>    BOOL operator != ( CONST D3DXPLANE&amp; ) const;</p><h1 id="endif-cplusplus"><a href="#endif-cplusplus" class="headerlink" title="endif //__cplusplus"></a>endif //__cplusplus</h1><pre><code>FLOAT a, b, c, d;</code></pre><p>} D3DXPLANE, *LPD3DXPLANE;<br>对照等式（8）可知：这里a, b和c是平面法向量n的成员，d就是那个常数。<br>点和平面的空间关系<br>　　我们判定点和平面的关系主要是利用等式(8)来实现。例如，假设平面(n, d)，我们能判定点p和平面的关系：<br>    假如n·p + d = 0，那么点p与平面共面。<br>    假如n·p + d &gt;0，那么点p在平面的前面且在平面的正半空间里。<br>    假如n·p + d &lt;0，那么点p在平面的背面且在平面的负半空间里。</p><p>下边的D3DX函数就是利用n·p + d 来判定点和平面的关系的函数：<br>FLOAT D3DXPlaneDotCoord(<br>    CONST D3DXPLANE <em>pP, // 平面<br>    CONST D3DXVECTOR3 </em>pV // 点<br>);<br>// 测试点相对于平面的位置<br>D3DXPLANE p(0.0f, 1.0f, 0.0f, 0.0f);<br>D3DXVECTOR3 v(3.0f, 5.0f, 2.0f);<br>float x = D3DXPlaneDotCoord( &amp;p, &amp;v );</p><p>if( x approximately equals 0.0f ) // v在平面.上<br>if( x &gt; 0 ) // v在正半空间<br>if( x &lt; 0 ) // v在负半空间<br>创建平面<br>　　我们能通过两种方法创建平面。<br>　　第一种方法，直接用指定法线和点创建平面。假设法线n和在平面上的已知点p0,我们就能求出d：<br>　　<br>D3DX库提供如下函数来完成创建平面的任务：<br>D3DXPLANE <em>D3DXPlaneFromPointNormal(<br>    D3DXPLANE</em> pOut, // Result.<br>    CONST D3DXVECTOR3<em> pPoint, // Point on the plane.<br>    CONST D3DXVECTOR3</em> pNormal // The normal of the plane.<br>);<br>　　<br>　　第二种方法，我们能通过在平面上的3个点创立一个平面。<br>　　假如有点p0, p1, p2，那么我们就能得到平面上的两个向量：<br>　　<br>　　因此我们能通过把平面上的两个向量进行十字相乘得到平面的法线。回忆左手坐标系。<br>　　<br>那么–(n·p0) = d.<br>D3DX库提供如下函数来完成通过同一平面上的3个点确定一个平面：<br>D3DXPLANE <em>D3DXPlaneFromPoints(<br>    D3DXPLANE</em> pOut, // Result.<br>    CONST D3DXVECTOR3<em> pV1, // Point 1 on the plane.<br>    CONST D3DXVECTOR3</em> pV2, // Point 2 on the plane.<br>    CONST D3DXVECTOR3* pV3 // Point 3 on the plane.<br>);<br>标准化平面<br>　　有时我们可能想标准化一个平面的法向量，即标准化平面。初一想，好象我们只需象标准化其他向量一样标准化平面的法向量就可以了。但是回忆在等式n·p + d = 0中的d = –n·p0。我们明白法向量的长度将影响常数d。因此，假如我们标准化法向量，我们必须重新计算d.注意<br>　　<br>　　因此，我们有下边公式来标准化平面(n, d)的法向量：</p><p>我们能用下面的D3DX函数来标准化一个平面：<br>D3DXPLANE <em>D3DXPlaneNormalize(<br>    D3DXPLANE </em>pOut, // Resulting normalized plane.<br>    CONST D3DXPLANE <em>pP // Input plane.<br>);<br>变换平面<br>　　我们能够通过如下处理来变换一个面（n, d），就象一个4D向量通过乘以它渴望得到变换的变换矩阵的逆矩阵一样来达到变换目的。（哎，好难说清楚，还是看例子吧。）注意平面的法向量必须首先被标准化。<br>　　我们能用下面的D3DX函数来完成操作：<br>D3DXPLANE </em>D3DXPlaneTransform(<br>    D3DXPLANE <em>pOut, // Result<br>    CONST D3DXPLANE </em>pP, // Input plane.<br>    CONST D3DXMATRIX *pM // Transformation matrix.<br>);<br>　　示例代码：<br>D3DXMATRIX T(…); // Init. T to a desired transformation.<br>D3DXMATRIX inverseOfT;<br>D3DXMATRIX inverseTransposeOfT;<br>D3DXMatrixInverse( &amp;inverseOfT, 0, &amp;T );<br>D3DXMatrixTranspose( &amp;inverseTransposeOfT, &amp;inverseOfT );<br>D3DXPLANE p(…); // Init. Plane.<br>D3DXPlaneNormalize( &amp;p, &amp;p ); // make sure normal is normalized.<br>D3DXPlaneTransform( &amp;p, &amp;p, &amp;inverseTransposeOfT );<br>点到平面上最近的点<br>　　假如我们在空间中有一个点p并且想找到在平面( n, d)上的与p最接近一个点q。注意如果平面的法向量是单位长度，这将简化问题。</p><p>图13<br>　　从图13我们能看出q = p + (–k_n)，k是有符号之分的从点p到平面的距离，也就是点p和q之间的有向距离。假如平面的法向量n是单位长度，那么n·p + d 就是从平面到点p有向距离.<br>射线（可选的）<br>　　设想在游戏中的一个玩家，正用他的枪射击敌人。我们怎么判断子弹是否从一个位置击中另一个位置的目标？一个方法是用一条射线模拟子弹，用一个球体模型模拟敌人。（球体模型只是一个球体，它紧紧的围绕一个物体，从而粗略地表示它的大小。球体模型将在第11章中做更详细的介绍。）那么通过计算我们就能够判定是否射中球体。在这部分我们学习射线的数学模型。<br>射线<br>　　一条射线能用一个起点和方向来描述。射线的参数方程是：<br>　　<br>　　<br>　　图14<br>　　p0 是射线的起点，u是射线的方向，t是参数。通过赋予不同的t值，我们能计算出在射线上不同的点。要描述一条射线，参数t范围就必须在[0, ∞)之间。实际上，假如我们让t∈(–∞, ∞),那么我们就能得到一条3维空间直线。<br>线/面相交<br>　　假设一条射线p(t) = p0 + tu 和 一个平面n·p + d = 0，我们想知道射线是否与平面相交，以及相交的交点信息（如果相交的话）。照这样做，我们把射线代入平面方程并且求满足平面方程的参数t，解答出来的参数就是相交的点。<br>　　把等式（9）代入平面方程：<br>　　<br>　　假如t 不在[0, ∞)之间，那么射线与平面不相交。<br>　　假如t 在[0, ∞)之间，那么射线与平面相交。且把参数代入射线方程就能找到交点：<br>　　<br>摘要（略）<br>第一部分完</p><p>第二部分 Direct3D基础<br>(Direct3D Fundamentals)<br>第一章 初始化Direct3D<br>(Direct3D Initialization)<br>　　以前Direct3D的初始化一直是一项单调乏味的工作。幸运的是8.0版本简化了初始化模式并且DX9.0也使用和它相同的模式。然而，在这个过程中仍需要程序员熟知图形学的基础知识和D3D的基本类型，本章的前几节将讲述这方面的内容。在余下的部分里将解释初始化的过程。<br>目标</p><ul><li>学习D3D怎样与图形硬件相互作用</li><li>弄懂COM在D3D中所扮演的角色</li><li>学习基础图形学知识，如2D图片是如何存储的、页面切换和深度缓冲</li><li>学习如何初始化D3D</li><li>熟悉本书例程中的一些常用的结构<br>1.1 Direct3D概述<br>　　Direct3D是一种低层图形API，它能让我们利用3D硬件加速来渲染3D世界。我们可以把Direct3D看作是应用程序和图形设备之间的中介。例如通知图形设备清空屏幕，应用程序将调用Direct3D的IDirect3DDevice9::Clear方法。图1.1显示了应用程序、Direct3D和图形设备之间的关系。<br>　　<br>　　图1.1<br>　　图1.1中Direct3D所表示的是Direct3D中已定义的，供程序员使用的Direct3D接口和函数的集合。这些接口和函数代表了当前版本的Direct3D所支持的全部特性。注意：仅仅因为Direct3D支持某种特性，并不意味着你所使用的图形硬件（显卡）也能支持它。<br>　　如图1.1所示，在Direct3D和图形设备之间有一层中介——叫做硬件抽象层（HAL，Hardware Abstraction Layer）。Direct3D不能直接作用于图形设备，因为现在市面上的显卡种类实在是太多了并且每种显卡都有不同的性能和处理事件的方式。例如，两种不同的显卡实现清屏的方式也可能是不同的。因此，Direct3D要求设备制造商实现HAL。HAL是一组指示设备执行某种操作的特殊设备代码的集合。用这种方法，Direct3D避免了必须去了解某个设备的特殊细节，使它能够独立于硬件设备。<br>　　设备制造商在HAL中实现他们的产品所支持的所有特性。HAL将不会实现那些Direct3D支持但硬件产品不支持的特性。调用一个HAL中没有实现的Direct3D的函数将会出错，除非它是顶点处理操作，因为这个功能可以由软件模拟来实现。因此当使用某些仅由市面上少数显卡所支持的高级特性时，必须检测一下设备是否支持。（设备的功能将在1.3.8节中讲解）<br>1.1.1 REF设备<br>　　你也许想把一些你的设备不支持的Direct3D函数写入程序。为了达到这个目的，Direct3D提供了REF设备,它用软件模拟了所有的Direct3D API。这允许你写并测试那些你的显卡不支持的Direct3D特性的代码。例如在本书的第四部分，某些人的显卡可能会不支持顶点和像素着色器。如果你的显卡不支持着色器，你仍然能够使用RE设备测试示例代码。懂得RE设备仅仅是为了发展，这是很重要的。它只会和DirectX SDK一起被装载，而不会发布给最终用户。 另外，RE设备实在是太慢了，除了测试以外它没有任何利用价值。<br>1.1.2 D3DDEVTYPE<br>　　在代码中，我们用D3DDEVTYPE_HAL来定义HAL设备，它是D3DDEVTYPE枚举类型的一个成员。同样的，REF设备则由D3DDEVTYPE_REF来定义，它也属于D3DDEVTYPE枚举类型。记住这些类型很重要，因为在创建设备的时候我们需要指定我们将要使用的类型。<br>1.2 COM<br>　　组件对象模型（COM, Component Object Model）是一种能使DirectX独立于编程语言和具有向下兼容性的技术。我们通常把COM对象作为一个接口，你可以把它当作达到某种目的的C++类来使用它。当使用C++写DirectX程序的时候，COM的大部分细节对我们来说是透明。但是有一件事，我们必须知道，那就是我们通过某个特殊的COM接口的函数或指针获得了另一个COM接口指针，而不是通过C++的新关键字来创建它。当我们使用完某个接口后，调用它的Release方法比直接Delete它更好。COM对象具有它们自己的内存管理。<br>　　对COM来说还有很多细节可以了解，但是掌握这些细节对于我们有效的使用DirectX不是必须的。<br>注意：COM接口都具有前缀大写字母“I”，例如表示一个表面的COM接口叫做IDirect3DSurface9。<br>1.3 一些准备工作<br>　　Direct3D的初始化过程要求我们对图形学基础知识和Direct3D类型有一定了解。本节将介绍这些知识和类型，以确保下一节能把焦点集中在讨论Direct3D的初始化上。<br>1.3.1 表面<br>　　表面是一个像素点阵，在Direct3D中主要用来存储2D图形数据。图1.2指明了表面的一些成分。由图可以看出表面数据就像一个矩阵，像素数据实际上存储在线性数组里面。<br>　　<br>　　图1.2<br>表面的Width和Height是按像素计算的。Pitch以字节为单位。而且Pitch有可能比Width大且依赖于低层硬件，所以不能单纯的认为Pitch = Width * sizeof (pixelFormat)。<br>　　在代码中，我们可以使用IDirect3DSurface9接口来描述表面。这个接口提供若干方法来直接读写表面数据并且还有一个方法用来返回表面信息。IDirect3DSurface9中最重要的方法是：</li><li>LockRect——使用这个方法，我们将获得一个指向表面内存的指针，然后，通过一系列指针运算，我们可以对表面上任一个像素点进行读、写操作。</li><li>UnlockRect——当你调用了LockRect和完成了对表面内存的访问后，你必须调用这个方法给表面解锁。</li><li>GetDesc——这个方法将通过填充D3DSURFACE_DESC结构来返回表面的描述信息。<br>　　最初锁定表面和改写每一像素看来稍微有点迷茫。下面的代码表示锁定表面并将每一像素染成红色：<br>// 假定_surface是一个指向IDirect3DSurface9接口的指针<br>// 假定每个像素为：32-bit的像素格式</li></ul><p>// 取得表面描述<br>D3DSURFACE_DESC surfaceDesc;<br>_surface-&gt;GetDesc(&amp;surfaceDesc);</p><p>// 取得被锁定表面的像素数据的指针<br>D3DLOCKED_RECT lockedRect;<br>_surface-&gt;LockRect(<br>        &amp;lockedRect, // 指向被锁定表面的数据<br>        0, // 0表示锁定全部表面<br>        0); // 0表示没有指定锁定标记</p><p>// 遍例表面上的每个像素，将它们设为红色<br>DWORD<em> imageData = (DWORD</em>)lockedRect.pBits;<br>for(int i = 0; i &lt; surfaceDesc.Height; i++)<br>{<br>    for(int j = 0; j &lt; surfaceDesc.Width; j++)<br>    {<br>        // 取得纹理索引, 注意我们用pitch 除以4是因为pitch的单位是像素，<br>        // 并且一个DWORD类型占为4 bytes空间<br>        int index = i * lockedRect.Pitch / 4 + j;<br>        imageData[index] = 0xffff0000; // 每个像素设为红色<br>    }<br>}</p><p>_surface-&gt;UnlockRect();<br>　　程序中D3DLOCKED_RECT结构的定义如下：<br>typedef struct _D3DLOCKED_RECT {<br>    INT Pitch; // 表面深度<br>    void *pBits; // 指向表面开始处的内存<br>} D3DLOCKED_RECT;<br>   在这里有一些关于表面锁定代码的一些说明。32-bit像素格式这个设定很重要，我们把bits转换成DWORDs。这让我们能把每一个DWORD视为表示一个像素。同样我们暂时不用去关心为什么0xffff0000表示红色,关于颜色的说明将在第四章讲到。<br>1.3.2 Multisampling<br>　　由于使用像素矩阵来表示图像，在显示时会出现锯齿状，Multisampling就是使其变得平滑的技术。它的一种最普通的用法即为——全屏抗锯齿（看图1.3）。<br>　　<br>　　图1.3<br>D3DMULTISAMPLE_TYPE枚举类型使我们可以指定全屏抗锯齿的质量等级：</p><ul><li>D3DMULTISAMPLE_NONE——不使用全屏抗锯齿。</li><li>D3DMULTISAMPLE_1_SAMPLE…D3DMULTISAPLE_16_SAMPLE——设定1~16级的等级。<br> 本书的示例程序中没有使用全屏抗锯齿的功能，因为它大大的降低了程序运行速度。如果你实在很想使用它的话，要记住使用IDirect3D9::CheckDeviceMultisampleType来检测你的显卡是否支持。<br>1.3.3像素格式<br>　　当我们创建一个表面或纹理时，经常需要指定这些Direct3D资源的像素格式。它是由D3DFORMAT枚举类型的一个成员来定义的。这里例举一部分：</li><li>D3DFMT_R8G8B8——表示一个24位像素，从左开始，8位分配给红色，8位分配给绿色，8位分配给蓝色。</li><li>D3DFMT_X8R8G8B8——表示一个32位像素，从左开始，8位不用，8位分配给红色，8位分配给绿色，8位分配给蓝色。</li><li>D3DFMT_A8R8G8B8——表示一个32位像素，从左开始，8位为ALPHA通道，8位分配给红色，8位分配给绿色，8位分配给蓝色。</li><li>D3DFMT_A16B16G16R16F——表示一个64位浮点像素，从左开始，16位为ALPHA通道，16位分配给蓝色，16位分配给绿色，16位分配给红色。</li><li>D3DFMT_A32B32G32R32F——表示一个128位浮点像素，从左开始，32位为ALPHA通道，32位分配给蓝色，32位分配给绿色，32位分配给红色。<br>想了解全部的像素格式请查看SDK文档中的D3DFORMAT部分。<br>注意：这前三种格式（D3DFMT_R8G8B8、D3DFMT_X8R8G8B8、D3DFMT_A8R8G8B8）是最常用并为大部分显卡所支持。但浮点像素格式或其它一些类型的支持并不是很广泛，在使用它们前请先检测你的显卡，看是否支持。<br>1.3.4 内存池<br>　　表面和其它一些Direct3D资源被放在多种内存池中。内存池的种类由D3DPOOL枚举类型的一个成员来指定。可用到的内存池有下列几种：</li><li>D3DPOOL_DEFAULT——表示Direct3D将根据资源的类型和用途把它们放在最合适的地方。这有可能是显存、AGP内存或者系统内存中。值得注意的是，这种内存池中的资源必须要在IDirect3DDevice9::Reset被调用之前消毁掉，并且再次使用时必须重新初始化。</li><li>D3DPOOL_MANAGED——资源将由Direct3D管理并且按设备的需要来指定放在显存还是放在AGP内存中。当应用程序访问和改变资源时它先把这些资源拷贝到系统内存中，当需要时Direct3D会自动把它们拷贝到显存里。</li><li>D3DPOOL_SYSTEMMEM——指定资源放在系统内存中。</li><li>D3DPOOL_SCRATCH——指定资源放在系统内存中，它与D3DPOOL_SYSTEMMEM不同之处在于使用这些资源不必受图形设备的限制。因此，参数使图形设备不能访问该内存池的资源，但资源可以相互拷贝。<br>1.3.5 交换链和页面切换<br>　　Direct3D通常创建2~3个表面组成一个集合，即为交换链，通常由IDirect3DSwapChain接口来表示。我们不必去了解它更详细的细节。我们也很少去管理它，通常Direct3D会自己去管理。所以我们只要大概的了解一下它就可以了。<br>　　交换链以及页面切换技巧被用在使两帧动画之间过度更平滑。图1.4展示的是一个有两个绘制表面的交换链。</li></ul><p>图1.4<br>   如图1.4，在Front Buffer中的表面将用来在屏幕上显示。显示器不能即时显示Front Buffer中表示的图像；通常情况下，它是每六十分之一秒刷新显示一次，即刷新率为60赫兹。应用程序的帧率经常与监视器的刷新率不同步（比如应用程序的渲染帧速度可能比显示器的刷新速度快）。然而，我们不能在显示器显示完成当前帧之前就更新有下一帧动画的Front Buffer内容，但是我们又不想让程序停止渲染而去等待显示器显示。因此，我们渲染另一个屏幕表面Back Buffer。当监视器将Front Buffer显示出来后，Front Buffer就被放到交换链的末端，即变成图中的Back Buffer，而Back Buffer就会变成交换链中的Front Buffer。这个过程就叫做presenting。图1.5表示了交换的整个过程。</p><p>图1.5<br>　　因此，我们绘图代码的结构就会像下面这样：<br>1． Render to back buffer<br>2． Present the back buffer<br>3． Goto (1)<br>1.3.6 深度缓冲<br>　　深度缓冲也是一个表面，但它不是用来存储图像数据的，而是用来记录像素的深度信息。它将确定哪一个像素最后被绘制出来。所以，如果要绘制640<em>480分辨率的图片，那么就会有640</em>480个深度值。<br>　　<br>　　图1.6<br>图1.6展示了一个简单的场景，在这个场景里，一个物体把将另一个物体的一部分遮住了。为了使Direct3D能确定物体的前后关系并正确的绘制出来，我们使用一种深度缓冲，又叫做z-buffering的技术。<br>　　深度缓冲为每一个像素计算深度值，并进行深度测试。通过深度测试，我们可以比较出哪个像素离照相机更近，并将它画出来。这样就可以只绘制最靠近照相机的像素，被遮住的像素就不会被画出来。<br>　　深度缓冲的格式决定着深度测试的精确性。一个24位的深度缓冲比16位的深度缓冲更精确。通常，应用程序在24位深度缓冲下就能工作的很好，但是Direct3D也同时支持32位的深度缓冲。</p><ul><li>D3DFMT_D32——表示32位深度缓冲</li><li>D3DFMT_D24S8——表示24位深度缓冲并保留8位模版缓冲（stencil buffer）</li><li>D3DFMT_D24X8——表示24位深度缓冲</li><li>D3DFMT_D24X4S4——表示24位深度缓冲并保留4位模版缓冲</li><li>D3DFMT_D16——表示16位深度缓冲<br>注意：关于模版缓冲的问题将在第八章详细说明。<br>1.3.7 顶点处理<br>　　顶点是3D图形学的基础，它能够通过两种不同的方法被处理，一种是软件方式（software vertex processing），一种是硬件方式（hardware vertex processing），前者总是被支持且永远可用，后者必须要显卡硬件支持顶点处理才可用。<br>　　使用硬件顶点处理总是首选，因为它比软件方式更快，而且不占用CPU资源，这意味CPU至少可以有更多的空闲时间进行别的计算。<br>注意：如果一块显卡支持硬件顶点处理的话，也就是说它也支持硬件几何转换和光源计算。<br>1.3.8 设备能力<br>　　Direct3D支持的每一项特性都对应于D3DCAPS9结构的一个数据成员。初始化一个D3DCAPS9实例应该以你的设备实际支持特性为基础。因此，在我们的应用程序里，我们能够通过检测D3DCAPS9结构中相对应的某一成员来检测设备是否支持这一特性。<br>　　下面将举例说明，假设我们想要检测显卡是否支持硬件顶点处理（换句话说，就是显卡是否支持硬件几何转换和光源计算）。通过查阅SDK中的D3DCAPS9结构，可以得知数据成员D3DCAPS9::DevCaps中的D3DDEVCAPS_HWTRANSFORMANDLIGHT位表示硬件是否支持硬件顶点处理即硬件几何变换和光源计算。程序如下：<br>bool supportsHardwareVertexProcessing;</li></ul><p>// 如果为真，意味着硬件设备支持它<br>if( caps.DevCaps &amp; D3DDEVCAPS_HWTRANSFORMANDLIGHT )<br>{<br>    // 支持<br>    supportsHardwareVertexProcessing = true;<br>}<br>else<br>{<br>    // 不支持<br>    hardwareSupportsVertexProcessing = false;<br>}<br>注意：DevCaps即为“device capabilities”<br>　　　下一节将学习怎样根据硬件的实际情况来初始化D3DCAPS9<br>      我们建议你阅读SDK中关于D3DCAPS9的结构，它完整的列出了Direct3D支持的特性。<br>1.4 初始化Direct3D<br>   下面几点说明怎样初始化Direct3D。根据下边的步骤你能初始化Direct3D：<br>1． 获得一个IDirect3D9接口指针。这个接口用于获得物理设备的信息和创建一个IDirect3DDevice9接口，它是一个代表我们显示3D图形的物理设备的C++对象。<br>2． 检查设备能力（D3DCAPS9），搞清楚主显卡是否支持硬件顶点处理。我们需要知道假如它能支持，我们就能创建IDirect3DDevice9接口。<br>3． 初始化一个D3DPRESENT_PARAMETERS结构实例，这个结构包含了许多数据成员允许我们指定将要创建的IDirect3DDevice9接口的特性。<br>4． 创建一个基于已经初始化好的D3DPRESENT_PARAMETERS结构的IDirect3DDevice9对象。它是一个代表我们显示3D图形的物理设备的C++对象。<br>请注意，本书使用主显示设备绘制3D图形，如果你的机子只有一块显卡，那它就是主显示设备。如果你有多个显卡，那么你当前使用的显卡将会成为主显示设备（如：用来显示Windows桌面的显卡）。<br>1.4.1获得IDirect3D9接口<br>　　Direct3D的初始化是从获得一个IDirect3D9接口指针开始的。使用一个专门的Direct3D函数来完成这个工作是非常容易的，代码如下：<br>IDirect3D9<em> _d3d9;<br>_d3d9 = Direct3DCreate9(D3D_SDK_VERSION);<br>   Direct3DCreate9的唯一一个参数总是D3D_SDK_VERSION，这可以保证应用程序通过正确的头文件被生成。如果函数调用失败，那么它将返回一个空指针。<br>   IDirect3D9对象通常有两个用途：设备列举和创建IDirect3DDevice9对象。设备列举即为查明系统中显示设备的技术特性，显示模式、格式，以及其它每一种显卡各自支持的特性。创建代表物理设备的IDirect3DDevice9对象，我们需要利用这个物理设备的显示模式结构和格式来创建它。为了找到一个工作配置，我们必须使用IDirect3D9的列举方法。<br>　　然而，设备列举实在太慢了，为了使Direct3D运行得尽可能快，我们通常不使用这个测试，除了下一节所谈到的一项测试。为了安全跳过它，我们可以选择总是被所有显卡都支持的“安全”配置。<br>1.4.2 检测硬件顶点处理<br>　　当我们创建一个IDirect3DDevice9对象来表示主显示设备时，必须要设定其顶点处理的类型。如果可以的话，当然要选用硬件顶点处理，但是由于并非所有显卡都支持硬件顶点处理，因此我们必须首先检查显卡是否支持。<br>　　首先我们要根据主显示设备的技术特性来初始化D3DCAPS9实例。可以使用如下方法：<br>HRESULT IDirect3D9::GetDeviceCaps(<br>    UINT Adapter,<br>    D3DDEVTYPE DeviceType,<br>    D3DCAPS9 </em>pCaps<br>);</p><ul><li>Adapter——指定要获得哪个显示适配器的特性</li><li>DeviceType——指定设备类型（硬件设备（D3DDEVTYPE_HAL），软件设备（D3DDEVTYPE_REF））</li><li>PCaps——返回一个已初始化的D3DCAPS9结构</li></ul><p>　　然后，我们就可以象1.3.8部分那样检测显卡的能力了。下面就是代码片段：<br>// 填充主显示设备的能力（D3DCAPS9结构）<br>D3DCAPS9 caps;<br>d3d9-&gt;GetDeviceCaps(<br>    D3DADAPTER_DEFAULT, // 主显示设备<br>    deviceType, // 设备类型，一般是D3DDEVTYPE_HAL.<br>    &amp;caps); // 返回填充后的D3DCAPS9 结构，包含主显示设备的能力</p><p>// 是否可以使用硬件顶点处理?<br>int vp = 0;<br>if( caps.DevCaps &amp; D3DDEVCAPS_HWTRANSFORMANDLIGHT )<br>{<br>    // 是，支持硬件顶点处理<br>    vp = D3DCREATE_HARDWARE_VERTEXPROCESSING;<br>}<br>else<br>{<br>    // 不，只能用软件顶点处理<br>    vp = D3DCREATE_SOFTWARE_VERTEXPROCESSING;<br>}<br>观察代码，我们使用变量vp来存储顶点处理类型。这是因为在稍后创建IDirect3DDevice9对象时要求指定其顶点处理的类型。<br>注意：标识符D3DCREATE_HARDWARE_VERTEXPROCESSING和D3DCREATE_SOFTWARE_VERTEXPROCESSING是预定义的值，它们分别代表硬件顶点处理和软件顶点处理。</p><p>技巧：若我们开发有一些新的，高级特性的程序，在使用前我们总是先检查硬件是否支持这些特性。<br>注意：如果一个应用程序在你的机子上不能运行，说明它用到的一些特性可能你的显卡并不支持，可以试试把设备类型换成REF。<br>1.4.3 填充D3DPRESENT_PARAMETERS结构<br>   初始化过程的下一步是填充一个D3DPRESENT_PARAMETERS结构的实例。这个结构用于设定我们将要创建的IDirect3DDevice9对象的一些特性，它的定义如下：<br>typedef struct _D3DPRESENT_PARAMETERS_ {<br>    UINT BackBufferWidth;<br>    UINT BackBufferHeight;<br>    D3DFORMAT BackBufferFormat;<br>    UINT BackBufferCount;<br>    D3DMULTISAMPLE_TYPE MultiSampleType;<br>    DWORD MultiSampleQuality;<br>    D3DSWAPEFFECT SwapEffect;<br>    HWND hDeviceWindow;<br>    BOOL Windowed;<br>    BOOL EnableAutoDepthStencil;<br>    D3DFORMAT AutoDepthStencilFormat;<br>    DWORD Flags;<br>    UINT FullScreen_RefreshRateInHz;<br>    UINT PresentationInterval;<br>} D3DPRESENT_PARAMETERS;<br>下面介绍其比较重要的数据成员，至于更详细的信息，请查阅SDK：<br>BackBufferWidth——后备缓冲表面的宽度（以像素为单位）<br>BackBufferHeight——后备缓冲表面的高度（以像素为单位）<br>BackBufferFormat——后备缓冲表面的像素格式（如：32位像素格式为D3DFMT——A8R8G8B8）<br>BackBufferCount——后备缓冲表面的数量，通常设为“1”，即只有一个后备表面<br>MultiSampleType——全屏抗锯齿的类型，详情请看SDK<br>MultiSampleQuality——全屏抗锯齿的质量等级，详情看SDK<br>SwapEffect——指定表面在交换链中是如何被交换的，取D3DSWAPEFFECT枚举类型中的一个成员。其中D3DSWAPEFFECT_DISCARD是最有效的<br>hDeviceWindow——与设备相关的窗口句柄，你想在哪个窗口绘制就写那个窗口的句柄<br>Windowed——BOOL型，设为true则为窗口模式，false则为全屏模式<br>EnableAutoDepthStencil——设为true，D3D将自动创建深度/模版缓冲<br>AutoDepthStencilFormat——深度/模版缓冲的格式<br>Flags——一些附加特性，设为0或D3DPRESENTFLAG类型的一个成员。下列两个最常用的标志<br>全部的标志请查阅SDK：<br>　　D3DPRESENTFLAG_LOCKABLE_BACKBUFFER——设定后备表面能够被锁定，这会降低应用程序的性能<br>　　D3DPRESENTFLAG_DISCARD_DEPTHSTENCIL——深度/模版缓冲在调用IDirect3DDevice9::present方法后将被删除，这有利于提升程序性能<br>FullScreen_RefreshRateInHz——刷新率，设定D3DPRESENT_RATE_DEFAULT使用默认刷新率<br>PresentationInterval——属于D3DPRESENT成员，又有两个常用标志，其余请查SDK：<br>         D3DPRESENT_INTERVAL_IMMEDIATE——立即交换<br>         D3DPRESENT_INTERVAL_DEFAULT——D3D选择交换速度，通常等于刷新率<br>填充示例如下：<br>D3DPRESENT_PARAMETERS d3dpp;<br>d3dpp.BackBufferWidth = 800;<br>d3dpp.BackBufferHeight = 600;<br>d3dpp.BackBufferFormat = D3DFMT_A8R8G8B8; //像素格式<br>d3dpp.BackBufferCount = 1;<br>d3dpp.MultiSampleType = D3DMULTISAMPLE_NONE;<br>d3dpp.MultiSampleQuality = 0;<br>d3dpp.SwapEffect = D3DSWAPEFFECT_DISCARD;<br>d3dpp.hDeviceWindow = hwnd;<br>d3dpp.Windowed = false; // fullscreen<br>d3dpp.EnableAutoDepthStencil = true;<br>d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8; // depth format<br>d3dpp.Flags = 0;<br>d3dpp.FullScreen_RefreshRateInHz = D3DPRESENT_RATE_DEFAULT;<br>d3dpp.PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;<br>1.4.4 创建IDirect3DDevice9对象<br>　　在填充完了D3DPRESENT_PARAMETERS结构后，我们就可以用下面的方法创建一个IDirect3DDevice9对象了：<br>HRESULT IDirect3D9::CreateDevice(<br>    UINT Adapter,<br>    D3DDEVTYPE DeviceType,<br>    HWND hFocusWindow,<br>    DWORD BehaviorFlags,<br>    D3DPRESENT_PARAMETERS <em>pPresentationParameters,<br>    IDirect3DDevice9*</em> ppReturnedDeviceInterface<br>);</p><ul><li>Adapter——指定对象要表示的物理显示设备</li><li>DeviceType——设备类型，前面说过</li><li>hFocusWindow——同我们在前面d3dpp.hDeviceWindow的相同</li><li>BehaviorFlags——设定为D3DCREATE_SOFTWARE_VERTEXPROCESSING或者D3DCREATE_HARDWARE_VERTEXPROCESSING</li><li>pPresentationParameters——指定一个已经初始化好的D3DPRESENT_PARAMETERS实例</li><li>ppReturnedDeviceInterface——返回创建的设备<br>例子：<br>IDirect3DDevice9* device = 0;<br>hr = d3d9-&gt;CreateDevice(<br>  D3DADAPTER_DEFAULT, // primary adapter<br>  D3DDEVTYPE_HAL, // device type<br>  hwnd, // window associated with device<br>  D3DCREATE_HARDWARE_VERTEXPROCESSING, // vertex processing type<br>  &amp;d3dpp, // present parameters<br>  &amp;device); // returned created device<br>if( FAILED(hr) )<br>{<br>  ::MessageBox(0, “CreateDevice() - FAILED”, 0, 0);<br>  return 0;<br>}<br>1.5 初始化Direct3D实例<br>在本章的例程中，初始化了一个Direct3D应用程序并用黑色填充显示窗口（如图1.7）。</li></ul><p>图1.7<br>   本书所有的应用程序都包含了d3dUtility.h和d3dUtility.cpp这两个文件，它们所包含的函数实现了所有Direct3D应用程序都要去做的一些常见的功能。例如：创建一个窗口、初始化Direct3D、进入程序的消息循环等。将这些功能封装在函数中能使示例程序更加突出该章的主题。另外，在我们学习本书的过程中还会在这两个文件中加上一些通用的代码。<br>1.5.1 d3dUtility.h/cpp<br>　　在开始本章的例程之前，让我们先熟悉一下d3dUtility.h/cpp所提供的函数。d3dUtility.h如下：<br>// 包含主要的Direct3DX头文件，这将包含我们需要的另外的Direct3D头文件</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <d3dx9.h></d3dx9.h></h1><p>namespace d3d<br>{<br>    bool InitD3D(<br>        HINSTANCE hInstance, // [in] 应用程序实例<br>        int width, int height, // [in] Back buffer尺寸<br>        bool windowed, // [in] 是否全屏<br>        D3DDEVTYPE deviceType, // [in] HAL 或 REF<br>        IDirect3DDevice9** device); // [out] 创建的设备</p><pre><code>int EnterMsgLoop(    bool (*ptr_display)(float timeDelta));LRESULT CALLBACK WndProc(    HWND hwnd,    UINT msg,    WPARAM wParam,    LPARAM lParam);template&lt;class T&gt; void Release(T t){    if( t )    {        t-&gt;Release();        t = 0;    }}template&lt;class T&gt; void Delete(T t){    if( t )    {        delete t;        t = 0;    }}</code></pre><p>}<br>   InitD3D——初始化一个应用程序主窗口并进行Direct3D的初始化。如果成功，则输出IDirect3DDevice9接口指针。从它的参数我们可以发现，我们能够设置窗口的大小和以窗口模式运行还是全屏模式运行。要知道它实现的细节，请看示例代码。<br>   EnterMsgLoop——这个函数封装了应用程序的消息循环。它需要输入一个显示函数的函数指针，显示函数为程序中绘制图形的代码块，这样做是为了使显示函数能够在空闲的时候被调用并显示场景，它的实现如下：<br>   int d3d::EnterMsgLoop( bool (*ptr_display)(float timeDelta) )<br>   {<br>       MSG msg;<br>          ::ZeroMemory(&amp;msg, sizeof(MSG));<br>　　　　static float lastTime = (float)timeGetTime();</p><pre><code>       while(msg.message != WM_QUIT)       {           if(::PeekMessage(&amp;msg, 0, 0, 0, PM_REMOVE))           {               ::TranslateMessage(&amp;msg);               ::DispatchMessage(&amp;msg);           }           else         {                float currTime = (float)timeGetTime();                float timeDelta = (currTime - lastTime)*0.001f;                ptr_display(timeDelta); // call display function                lastTime = currTime;         }        }         return msg.wParam;</code></pre><p>   }<br>与“time”有关的代码用于计算每次调用显示函数的时间间隔，即是每帧的时间。<br>Release——这个模版函数能方便的释放COM接口并将它们的值设为NULL<br>Delete——这个模版函数能方便的删除一个对象并将指向其的指针设为NULL<br>WndProc——应用程序主窗口的回调函数<br>1.5.2 实例框架<br>　　通过实例框架，我们形成了一种通用的方法去构造本书的示例程序。每一个例程都含有三个函数的实现，当然这不包括回调函数和WinMain主函数。这三个函数用特定的代码实现特定的功能。这三个函数是：</p><ul><li>bool Setup()——在这个函数里，我们将准备一切该程序需要用到的东西，包括资源的分配，检查设备能力，设置应用程序的状态</li><li>void Clearup()——这个函数将释放Setup()中分配的资源，如分配的内存。</li><li>bool Display(float timeDelta)——这个函数包含所有与我们绘图和显示有关的代码。参数timeDelta为每一帧的间隔时间，用来控制每秒的帧数。<br>1.5.3 D3D Init实例<br>　　这个示例程序将创建并初始化一个Direct3D应用程序，并用黑色填充屏幕。注意，我们使用了通用函数简化了初始化过程。<br>　　首先，我们要包含d3dUtility.h头文件，并为设备声明一个全局变量：<h1 id="include-“d3dUtility-h”"><a href="#include-“d3dUtility-h”" class="headerlink" title="include “d3dUtility.h”"></a>include “d3dUtility.h”</h1></li></ul><p>IDirect3DDevice9* Device = 0;<br>　　然后实现我们的框架函数：<br>bool Setup()<br>{<br>    return true;<br>}</p><p>void Cleanup()<br>{</p><p>}<br>　　在这个程序中，我们不需要使用任何资源或触发任何事件，所以这两个函数都为空。<br>bool Display(float timeDelta)<br>{<br>    if( Device )<br>    {<br>　　　　Device-&gt;Clear(0, 0, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,<br>　　　　　0x00000000, 1.0f, 0);<br>        Device-&gt;Present(0, 0, 0, 0); // 页面切换<br>    }</p><pre><code>return true;</code></pre><p>}<br>　　Display方法调用了IDirect3DDevice::Clear方法，分别用黑色和1.0填充后备表面和深度/模版缓冲。如果应用程序不停止的话，我们会一直执行这个操作。IDirect3DDevice::Clear声明如下：<br>HRESULT IDirect3DDevice9::Clear(<br>    DWORD Count,<br>    const D3DRECT* pRects,<br>    DWORD Flags,<br>    D3DCOLOR Color,<br>    float Z,<br>    DWORD Stencil<br>);</p><ul><li>Count——pRects组中的矩形的个数</li><li>pRects——将要清除的屏幕矩形的数组，这使我们可以清除屏幕的某一部分</li><li>Flags——指定在哪些表面上执行清除表面的操作<pre><code>   D3DCLEAR_TARGET——目的表面，通常为后备表面   D3DCLEAR_ZBUFFER——深度缓冲   D3DCLEAR_STENCIL——模版缓冲</code></pre></li><li>Color——使用什么颜色填充清除的表面</li><li>Z——设置深度缓冲的值</li><li>Stencil——设置模版缓冲的值<br> 屏幕被填充后，要调用IDirecte3DDevice9::Present方法进行后备表面的交换。</li></ul><p>　　Windows 回调函数为一组事件集，即，我们可按ESC键让程序退出。<br>LRESULT CALLBACK d3d::WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)<br>{<br>    switch( msg )<br>    {<br>        case WM_DESTROY:<br>        ::PostQuitMessage(0);<br>        break;</p><pre><code>    case WM_KEYDOWN:    if( wParam == VK_ESCAPE )        ::DestroyWindow(hwnd);    break;}return ::DefWindowProc(hwnd, msg, wParam, lParam);</code></pre><p>}</p><p>最后，WinMain按如下步骤运行：</p><ol><li>初始化主显示窗口和Direct3D</li><li>调用Setup进行程序的准备工作</li><li>使用Display函数作为参数进入消息循环</li><li><p>清除应用程序最后释放IDirecte3DDevice9对象<br>int WINAPI WinMain(HINSTANCE hinstance,</p><pre><code>             HINSTANCE prevInstance,             PSTR cmdLine,             int showCmd)</code></pre><p>{<br> if(!d3d::InitD3D(hinstance,    800, 600, true, D3DDEVTYPE_HAL, &amp;Device))<br> {</p><pre><code> ::MessageBox(0, &quot;InitD3D() - FAILED&quot;, 0, 0); return 0;</code></pre><p> }</p><p> if(!Setup())<br> {</p><pre><code> ::MessageBox(0, &quot;Setup() - FAILED&quot;, 0, 0); return 0;</code></pre><p> }</p><p> d3d::EnterMsgLoop( Display );</p><p> Cleanup();</p><p> Device-&gt;Release();<br> return 0;<br>}</p><p>就像你所看到的，我们的例程的模板结构是相当简洁的：有效的操作窗口函数、 Direct3D的初始化过程。这本书中的大部分程序，都是通过执行Setup, Cleanup, 和Display这三个函数来实现。</p></li></ol><p>注意：不要忘了在你的工程中加入d3d9.lib、d3dx9.lib、winmm.lib 这三个库！</p><ol><li>6摘要（略）</li></ol><p>第二章 渲染管线<br>(The Rendering Pipeline)<br>　　本章的主题是渲染管线。它是用来创建为3D世界进行几何描述的2D图形并设定一个虚拟照相机确定这个世界中哪一部分将被透视投影到屏幕上。<br>　　<br>　　图2.1<br>目标</p><ul><li>要弄清楚我们怎样在Direct3D中表示3D物体</li><li>学习怎样模拟虚拟照相机</li><li>弄懂渲染管线——这个过程是用几何学来表现3D场景和用它来产生2D图象。<br>2.1表现模型<br>　　一个场景是多个物体或模型的集合。一个物体可以用三角形网格（triangle mesh）来近似表示，如图2.2所示。由三角形网格建立一个物体，我们称之为建模。3D世界中最基本的图元就是三角形，但是Direct3D也支持点图元和线图元但我们都不常用到。不过在学到第14章的粒子系统的时候，将会用到点图元。</li></ul><p>图2.2<br>   一个多边形的两边相交的点叫做顶点。为了描述一个三角形，我们通常指定三个点的位置来对应三角形的三个顶点（如图2.3），这样我们就能够很明确的表示出这个三角形了。</p><p>图2.3<br>2.1.1 顶点格式<br>　　我们以前定义的点在数学上来说是正确的，但是当我们在Direct3D环境中使用它的时候就会觉得很不完善。这是因为在Direct3D中的顶点包含了许多附加的属性，而不再单纯的只有空间位置的信息了。例如：一个顶点可以有颜色和法线向量属性（这两个属性分别在第四章和第五章介绍）。Direct3D让我们可以灵活的构造自己的顶点格式。换句话说，我们可以自己定义顶点的成员。<br>　　为了创建一个自定义的顶点结构，我们首先要创建一个包含能存放我们选择的顶点数据的结构。例如，下面我们举出两种不同顶点数据类型的例子，一种包含了位置和颜色信息，第二种则包含了位置，法线向量，纹理坐标信息（“纹理”见第六章）。<br>　　<br>　　<br>　　<br>struct ColorVertex<br>{<br>    float _x, _y, _z; // 位置<br>    DWORD _color; // 颜色<br>};</p><p>struct NormalTexVertex<br>{<br>    float _x, _y, _z; // 位置<br>    float _nx, _ny, _nz; // 法线向量<br>    float _u, _v; // 纹理坐标<br>};<br>   一旦我们有了完整的顶点格式，我们就要使用灵活顶点格式（FVF）的组合标志来描述它。例如第一个顶点结构，我们要使用如下的顶点格式：</p><h1 id="define-FVF-COLOR-D3DFVF-XYZ-D3DFVF-DIFFUSE"><a href="#define-FVF-COLOR-D3DFVF-XYZ-D3DFVF-DIFFUSE" class="headerlink" title="define FVF_COLOR (D3DFVF_XYZ | D3DFVF_DIFFUSE)"></a>define FVF_COLOR (D3DFVF_XYZ | D3DFVF_DIFFUSE)</h1><p>   上面的顶点结构表明它包含位置和颜色属性。</p><p>   而第二种结构则要使用：</p><h1 id="define-FVF-NORMAL-TEX-D3DFVF-XYZ-D3DFVF-NORMAL-D3DFVF-TEX1"><a href="#define-FVF-NORMAL-TEX-D3DFVF-XYZ-D3DFVF-NORMAL-D3DFVF-TEX1" class="headerlink" title="define FVF_NORMAL_TEX (D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1)"></a>define FVF_NORMAL_TEX (D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1)</h1><p>   上面的顶点结构表明它包含了位置，法线向量，纹理坐标的属性（这些常量是D3D内置的）。</p><p>　　有一点要注意，你的标志的顺序必须要和你的顶点结构的顺序一一对应。如果想知道所有的D3DFVF标志，请查阅SDK文档。<br>2.1.2 三角形<br>　　三角形是构建3D物体的基本图形。为了构造物体，我们创建了三角形列表（triangle list）来描述物体的形状和轮廓。三角形列包含了我们将要画的每一个三角形的数据信息。例如为了构造一个矩形，我们把它分成两个三角形，如图2.4所示，最后指定每个三角形的顶点。<br>　　<br>　　图2.4<br>Vertex rect[6] = {v0, v1, v2, // 三角形0<br>                v0, v2, v3}; // 三角形1<br>注意：指定三角形顶点的顺序是很重要的，将会按一定顺序环绕排列，这会在2.3.4节学习相关的内容。<br>2.1.3 索引<br>　　3D物体中的三角形经常会有许多共用顶点。如图2.4所表示的矩形。虽然现在仅有两个点被重复使用，但是当要表现一个更精细更复杂的模型的时候，重复的顶点数将会变得很大。例如图2.5所示的立方体，仅有八个顶点，但是当用三角形列表示它的时候，所有的点都被重复使用。</p><p>图2.5<br>　　为了解决这个问题，我们引入索引（indices）这个概念。它的工作方式是：我们创建一个顶点列表和一个索引列表（index list）。顶点列表包含所有不重复的顶点，索引列中则用顶点列中定义的值来表示每一个三角形的构造方式。回到那个矩形的示例上来，它的顶点列表的构造方式如下：<br>Vertex vertexList[4] = {v0, v1, v2, v3};</p><p>   索引列表则定义顶点列中的顶点是如何构造这两个三角形的：<br>WORD indexList[6] = {0, 1, 2, //三角形0<br>                0, 2, 3}; //三角形1<br>   也就是说，用顶点列表中的0（vertexList[0]）、1（vertexList[1]）和2（vertexList[2]）顶点构成三角形0；用顶点列表中的0（vertexList[0]）、2（vertexList[2]）和3（vertexList[3]）顶点构成三角形1。<br>2.2虚拟照相机<br>　　照相机确定3D世界中的哪部分是可见的，因而需要将哪部分转换为2D图形。在3D世界中照相机被放置和定向，并且定义其可视体，图2.6展示了我们的照相机模型。<br>　　<br>　　图2.6<br>　　可视体是由可视角度和前裁剪面（Near Plane）与后裁剪面（Far Plane）定义的一个平截头体。之所以要选择平截头体构造可视体，是因为我们的显示器都是矩形的。在可视体中不能被看见的物体都会被删除，删除这种数据的过程就叫做“裁剪”。<br>　　投影窗口（Projection Window）是可视体内的3D几何图形投影生成的用来显示3D场景的2D图像的2D区域。重要的是要知道，我们使用min=(-1,-1)和max=(1,1)来定义投影窗口的大小。<br>　　为了简化本书接下来的部分绘制，我们使前裁剪面与投影窗口在同一平面上。并且，注意Direct3D中定义的投影平面（即投影窗口所在的平面）是Z = 1的平面。<br>2.3 渲染管线<br>　　一旦我们描述几何学上的3D场景和设置了虚拟照相机，我们要把这个场景转换成2D图象显示在显示器上。这一系列必须完成的操作就叫做渲染管线。图2.7展示了一个简化的渲染管线，随后将详细解释图中的每一部分。<br>　　<br>　　图2.7<br>   渲染管线中的许多级都是从一个坐标系到另一个坐标的几何变换。这些变换都通过矩阵变换来实现。Direct3D为我们进行变换计算并且如果显卡支持硬件变换的话那就更有利了。使用Direct3D进行矩阵变换，我们唯一要做的事就是提供从一个系统变换到另一个系统的变换矩阵就可以了。我们使用IDirect3DDevice9::SetTranform方法提供变换矩阵。它输入一个表示变换类型的参数和一个变换矩阵。如图2.7所示，为了进行一个从自身坐标系到世界坐标系的变换，我们可以这样写：<br>Device-&gt;SetTransform(D3DTS_WORLD, &amp;worldMatrix);<br>   在下面的小节我们会了解到这个方法的更多细节。<br>2.3.1自身坐标系（Local Space）<br>　　自身坐标系又叫做建模空间，这是我们定义物体的三角形列的坐标系。自身坐标系简化了建模的过程。在物体自己的坐标系中建模比在世界坐标系中直接建模更容易。例如，在自身坐标系中建模不像在世界坐标系中要考虑本物体相对于其他物体的位置、大小、方向关系。<br>　　<br>　　图2.8<br>2.3.2世界坐标系（World Space）<br>　　一旦我们构造了各种模型，它们都在自己的自身坐标系中，但是我们需要把它们都放到同一个世界坐标系中。物体从自身坐标系到世界坐标系中的换叫做世界变换。世界变换通常是用平移、旋转、缩放操作来设置模型在世界坐标系中的位置、大小、方向。世界变换就是通过各物体在世界坐标系中的位置、大小和方向等相互之间的关系来建立所有物体。<br>　　<br>　　图2.9<br>   世界变换由一个矩阵表示，并且在Direct3D中调用IDirect3DDevice9::SetTransform方法设置它，记住将转换类型设为D3DTS_WORLD。例如我们要在世界坐标系中放置一个立方体定位在（-3，2，6）和一个球体定位在（5，0，-2），我们可以这样写程序：<br>//创建立方体的世界矩阵（一个平移矩阵）<br>D3DXMATRIX cubeWorldMatrix;<br>D3DXMatrixTranslation(&amp;cubeWorldMatrix, -3.0f, 2.0f, 6.0f);</p><p>//创建球体的世界矩阵（一个平移矩阵）<br>D3DXMATRIX sphereWorldMatrix;<br>D3DXMatrixTranslation(&amp;sphereWorldMatrix, 5.0f, 0.0f, -2.0f);</p><p>// 变换立方体，然后绘制它<br>Device-&gt;SetTransform(D3DTS_WORLD, &amp;cubeWorldMatrix);<br>drawCube(); // draw the cube</p><p>// 因为球体使用一个不同的世界变换，我们必须更改世界矩阵为球体的～，<br>// 如果不更改，球体将绘制在上一个世界矩阵的位置上（立方体的世界矩阵）<br>Device-&gt;SetTransform(D3DTS_WORLD, &amp;sphereWorldMatrix);<br>drawSphere(); // 绘制球体<br>   这是个非常简单的实例，没有用到矩阵的旋转和缩放。但是一般很多物体都需要进行这些变换，不过这个例子也还是展示了世界变换是怎样进行的。<br>2.3.3视图坐标系（View Space）<br>　　世界坐标系中的几何图与照相机是相对于世界坐标系而定义的，如图2.10所示。然而在世界坐标系中当照相机是任意放置和定向时，投影和其它一些操作会变得困难或低效。为了使事情变得更简单，我们将照相机平移变换到世界坐标系的源点并把它的方向旋转至朝向Z轴的正方向，当然，世界坐标系中的所有物体都将随着照相机的变换而做相同的变换。这个变换就叫做视图坐标系变换（view space transformation）。<br>　　<br>　　图2.10<br>   视图坐标的变换矩阵可以通过如下的D3DX函数计算得到：<br>D3DXMATRIX <em>D3DXMatrixLookAtLH(<br>    D3DXMATRIX</em> pOut, // 指向返回的视图矩阵<br>    CONST D3DXVECTOR3<em> pEye, // 照相机在世界坐标系的位置<br>    CONST D3DXVECTOR3</em> pAt, // 照相机在世界坐标系的目标点<br>    CONST D3DXVECTOR3* pUp // 世界坐标系的上方向(0, 1, 0)<br>);<br>   pEye参数指定照相机在世界坐标系中的位置，pAt参数指定照相机所观察的世界坐标系中的一个目标点，pUp参数指定3D世界中的上方向，通常设Y轴正方向为上方向，即取值为（0，1，0）。<br>　　例如：假设我们要把照相机放在点（5，3，-10），并且目标点为世界坐标系的中点（0，0，0），我们可以这样获得视图坐标系变换矩阵：<br>D3DXVECTOR3 position(5.0f, 3.0f, –10.0f);<br>D3DXVECTOR3 targetPoint(0.0f, 0.0f, 0.0f);<br>D3DXVECTOR3 worldUp(0.0f, 1.0f, 0.0f);</p><p>D3DXMATRIX V;<br>D3DXMatrixLookAtLH(&amp;V, &amp;position, &amp;targetPoint, &amp;worldUp);<br>   视图坐标系变换也是通过IDirect3DDevice9::SetTransform来实现的，只是要将变换类型设为D3DTS_VIEW，如下所示：<br>Device-&gt;SetTransform(D3DTS_VIEW, &amp;V);<br>2.3.4背面拣选（Backface Culling）<br>　　一个多边形有两个表面，我们将一个标为正面，一个为背面。通常，后表面总是不可见的，这是因为场景中大多数物体是密封的。例如盒子、圆柱体、箱子、characters等，并且我们也不能把照相机放入物体的内部。因此照相机永不可能看到多边形的背面。这是很重要的，如果我们能看背面，那么背面拣选就不可能工作。<br>　　图2.11表示了一个物体在视图坐标系中的正面。一个多边形的边都是面向照相机叫正面多边形，而一个多边形的边都背对照相机叫背面多边形。<br>　　<br>　　图2.11<br>   由图2.11可知，正面多边形挡住了在它后面的背面多边形，Direct3D将通过拣选（即删除多余的处理过程）背面多边形来提高效率，这种方法就叫背面拣选。图2.12展示了背面拣选之后的多边形，从照相机的观察点来看，仍将绘制相同的场景到后备表面，那些被遮住的部分无论如何都永远不会被看见的。</p><p>　　图2.12<br>   当然，为了完成这项工作，Direct3D需要知道哪个多边形是正面，哪个是背面。Direct3D中默认顶点以顺时针方向（在观察坐标系中）形成的三角形为正面，以逆时针方向形成的三角形为背面。<br>如果我们不想使用默认的拣选状态，我们可以通过改变D3DRS_CULLMODE来改变渲染状态：<br>Device-&gt;SetRenderState(D3DRS_CULLMODE, Value);<br>Value可以是如下一个值：</p><ul><li>D3DCULL_NONE——完全不使用背面拣选</li><li>D3DCULL_CW——拣选顺时针方向环绕的三角形</li><li>D3DCULL_CCW——拣选逆时针方向环绕的三角形，这是默认值。<br>2.3.5光源（Lighting）<br>　　光源定义在世界坐标系中然后被变换到视图坐标系中。视图坐标系中光源给物体施加的光照大大增加了场景中物体的真实性，至于光照的相关函数的细节将会在第五章学习。在本书的第四部分，我们将使用可编程管线实现自己的光照。<br>2.3.6裁剪（Clipping）<br>　　我们拣选那些超出了可视体范围的几何图形的过程就叫做裁剪。这会出现三种情况：</li><li>完全包含——三角形完全在可视体内，这会保持不变，并进入下一级</li><li>完全在外——三角形完全在可视体外部，这将被拣选</li><li>部分在内（部分在外）——三角形一部分在可视体内，一部分在可视体外，则三角形将被分成两部分，可视体内的部分被保留，可视体之外的则被拣选<br>图2.13展示了上面三种情况：</li></ul><p>　　图2.13<br>2.3.7投影（Projection）<br>　　视图坐标系的主要任务就是将3D场景转化为2D图像表示。这种从n维转换成n-1维的过程就叫做投影。投影的方法有很多种，但是我们只对一种特殊的投影感兴趣，那就是透视投影。因为透视投影可以使离照相机越远的物体投影到屏幕上后就越小，这可以使我们把3D场景更真实的转化为2D图像。图2.14展示了一个3D空间中的点是如何通过透视投影到投影窗口上去的。</p><p>　　图2.14<br>   投影变换的实质就是定义可视体，并将可视体内的几何图形投影到投影窗口上去。投影矩阵的计算太复杂了，这里我们不会给出推导过程，而是使用如下的Direct3D函数通过给出平截头体的参数来求出投影矩阵。</p><p>　　图2.15<br>D3DXMATRIX <em>D3DXMatrixPerspectiveFovLH(<br>    D3DXMATRIX</em> pOut, // 返回的投影矩阵<br>    FLOAT fovY, // 用弧度表示的视野角度vertical field of view angle in radians<br>    FLOAT Aspect, // 宽高比<br>    FLOAT zn, // 前裁剪面距离<br>    FLOAT zf // 后裁剪面距离<br>);<br>　　（fovY定义镜头垂直观察范围，以弧度为单位。对于这个参数，下面是我的理解：如果定义为D3DX_PI/4（90度角），那么就是表示以摄像机的观察方向为平分线，上方45度角和下方45度角就是摄像机所能看到的垂直范围了。嗯，可以想象一下自己的眼睛，如果可以把自己眼睛的fovY值设为D3DX_PI/2（180度角），那么我们就可以不用抬头就看得见头顶的东西了。如果设为D3DX_PI的话。。。我先编译一下试试（building…）。哈哈，结果啥也看不见。很难想象如果自己能同时看到所有方向的物体，那么将是一个怎样的画面啊）<br>　　Aspect参数为投影平面的宽高比例值，由于最后都为转换到屏幕上，所以这个比例一般设为屏幕分辨率的宽和高的比值（见2.3.8节）。如果投影窗口是个正方形，而我们的显示屏一般都是长方形的，这样转换后就会引起拉伸变形。</p><p>　　我们还是通过调用IDirect3DDevice9::SetTranform方法来进行投影变换，当然，要把第一个投影类型的参数设为D3DTS_PROJECTION。下面的例子基于一个90度视角、前裁剪面距离为1、后裁剪面距离为1000的平截头体创建投影矩阵：<br>D3DXMATRIX proj;<br>D3DXMatrixPerspectiveFovLH(<br>    &amp;proj, PI * 0.5f, (float)width / (float)height, 1.0, 1000.0f);<br>Device-&gt;SetTransform(D3DTS_PROJECTION, &amp;proj);<br>2.3.8视口变换（Viewport Transform）<br>　　视口变换主要是转换投影窗口到显示屏幕上。通常一个游戏的视口就是整个显示屏，但是当我们以窗口模式运行的时候，也有可能只占屏幕的一部分或在客户区内。视口矩形是由它所在窗口的坐标系来描述的，如图2.16。<br>　　<br>　　图2.16<br>　　在Direct3D中，视口矩形通过D3DVIEWPORT9结构来表示。它的定义如下：<br>typedef struct _D3DVIEWPORT9 {<br>    DWORD X;<br>    DWORD Y;<br>    DWORD Width;<br>    DWORD Height;<br>    DWORD MinZ;<br>    DWORD MaxZ;<br>} D3DVIEWPORT9;<br>   前四个参数定义了视口矩形与其所在窗口的关系。MinZ成员指定最小深度缓冲值，MaxZ指定最大深度缓冲值。Direct3D使用的深度缓冲的范围是0~1，所以如果不想做什么特殊效果的话，将它们分别设成相应的值就可以了。<br>　　一旦我们填充完D3DVIEWPORT9结构后，就可以如下设视口：<br>D3DVIEWPORT9 vp{ 0, 0, 640, 480, 0, 1 };<br>Device-&gt;SetViewport(&amp;vp);<br>这样，Direct3D就会自动为我们处理视口变换。现在还是给出视口变换矩阵作为参考：</p><p>2.3.9光栅化（Rasterization）<br>　　在把三角形每个顶点转换到屏幕上以后，我们就画了一个2D三角形。光栅化是计算需要显示的每个三角形中每个点颜色值（如图2.17）。<br>　　<br>　　图2.17<br>　　光栅化过程是非常繁重的计算，它应该通过硬件图形处理来完成。它的处理结果就是把2D图象显示在显示器上。<br>2.4 摘要(略)</p><p>第三章 在Direct3D中绘制<br>(Drawing in Direct3D)<br>    在上一章中我们学习了创建和渲染场景的概念。这一章中我们将这些东西用于实践，同时学习怎样在Direct3D中画一些几何物体。本章中所讲的有些Direct3D接口和方法很重要，因为它们的使用会贯穿全书。<br>目标</p><ul><li>要弄清楚在Direct3D中怎样存储顶点和索引。</li><li>怎样使用渲染状态来改变渲染结果</li><li>学习怎样渲染场景</li><li>学习怎样用D3DXCreate<em>函数创建更多的复杂的3D形体<br>3.1顶点/索引缓存<br>  顶点和索引缓存有相似的接口并且共享相似的方法；因此我们把它们合在一起讲解。一个顶点缓存是一块连续的存储了顶点数据的内存。同样的，一个索引缓存是一块连续的存储了索引数据的内存。我们使用顶点和索引缓存保存我们的数据是因为它们能被放置在显存中。渲染显存中的数据要比渲染系统内存中的数据快的多。<br>  在代码中，一个顶点缓存是通过IDirect3DVertexBuffer9接口来定义的。类似的，一个索引缓存是通过IDirect3DIndexBuffer9接口来定义。<br>3.1.1创建一个顶点和索引缓存<br>　　    我们能使用下面两个方法创建一个顶点缓存和索引缓存：<br>HRESULT IDirect3DDevice9::CreateVertexBuffer(<br>  UINT Length,<br>  DWORD Usage,<br>  DWORD FVF,<br>  D3DPOOL Pool<br>  IDirect3DVertexBuffer9** ppVertexBuffer,<br>  HANDLE</em> pSharedHandle<br>);</li></ul><p>HRESULT IDirect3DDevice9::CreateIndexBuffer(<br>    UINT Length,<br>    DWORD Usage,<br>    D3DFORMAT Format,<br>    D3DPOOL Pool,<br>    IDirect3DIndexBuffer9<em>* ppIndexBuffer,<br>    HANDLE</em> pSharedHandle<br>);<br>   这两个方法大部分参数是相同的，因此我们一起介绍它们。</p><ul><li>Length —— 分配给缓存的字节大小。假如想得到一个能存储8个顶点的顶点缓存，那么我们就要在顶点结构中设置这个参数为 8 * sizeof ( Vertex ) 。</li><li>Usage —— 指定关于怎样使用缓存的额外信息。这个值可以是0，没有标记，或者是下面标记的一个或多个的组合：</li><li>D3DUSAGE_DYNAMIC——设置这个参数可以使缓存是动态的。在下一页说明静态和动态缓存。</li><li>D3DUSAGE_POINTS——这个参数指定缓存存储原始点。原始点将在第14章粒子系统中介绍。这个参数仅仅用在顶点缓冲中。</li><li>D3DUSAGE_SOFTWAREPROCESSING——使用软件顶点处理</li><li>D3DUSAGE_WRITEONLY——指定应用程序只能写缓存。它允许驱动程序分配最适合的内存地址作为写缓存。注意如果从创建好的这种缓存中读数据，将会返回错误信息。</li><li>FVF —— 存储在缓存中的顶点格式</li><li>Pool —— 缓存放置在哪一个内存池中</li><li>ppVertexBuffer ——返回创建好的顶点缓存的指针。</li><li>pSharedHandle ——没有使用；设置为0。</li><li>Format ——指定索引的大小；使用D3DFMT_INDEX16设置16位索引，使用D3DFMT_INDEX32设置32位索引。注意并非所有设备都支持32位索引；请检查设备能力。</li><li>ppIndexBuffer ——返回创建好的索引缓存的指针。<br>注意：不使用D3DUSAGE_DYNAMIC参数创建的缓存被叫做静态缓存。静态缓存通常被放置在显存中，在其中的数据能被很有效的处理。然而，对于静态缓存，从中读取和写入数据是很慢的，因为访问显存是很慢的。因为这个原因我们用静态缓存存储静态数据（不需要被经常改变的数据）。对于静态缓存地形和建筑物是很好的后选例子，因为在应用程序中他们通常不需要被改变。静态缓存应该在应用程序初始话的时候就被填充好，而不是在运行时才做。</li></ul><p>注意：使用D3DUSAGE_DYNAMIC参数创建的缓存被叫做动态缓存。动态缓存通常被放在AGP内存中，这种内存中的数据能被很快的更新。处理动态缓存中的数据不会比处理静态缓存中的数据快，因为这些数据必须在渲染前被转移到显存中，动态缓存的好处是它们能够被稍微快点地被更新（比CPU写快）。因此，假如你需要经常更新缓存中的数据，那么你就应该使用动态缓存。对于动态缓存粒子系统是很好的一个应用，因为它们是动态的，并且他们通常每一帧都会被更新。</p><p>注意：在程序中读取显存和AGP内存都是非常慢的。因此，假如你在运行时需要读取你的几何物体，最好的方案是指定一块系统内存，都在其中拷贝并且读取数据。<br>　　    下边是创建一个静态顶点缓存的例子，该缓存能存储8个顶点。<br>IDirect3DVertexBuffer9<em> vb;<br>device-&gt;CreateVertexBuffer(<br>    8 </em> sizeof( Vertex ),<br>    0,<br>    D3DFVF_XYZ,<br>    D3DPOOL_MANAGED,<br>    &amp;vb,<br>    0);<br>3.1.2 访问缓冲内存<br>　　为了访问一个顶点/索引缓存，我们需要得到一个指针。我们通过一个指针获得缓存数据必须使用Lock方法。当我们访问完缓存后必须对它解锁。一旦有一个指向内存的指针，我们就能对它进行读写。<br>HRESULT IDirect3DVertexBuffer9::Lock(<br>    UINT OffsetToLock,<br>    UINT SizeToLock,<br>    BYTE<strong> ppbData,<br>    DWORD Flags<br>);<br>HRESULT IDirect3DIndexBuffer9::Lock(<br>    UINT OffsetToLock,<br>    UINT SizeToLock,<br>    BYTE</strong> ppbData,<br>    DWORD Flags<br>);<br>　　<br>　　图3.1<br>　　这两个方法的参数都是完全相同的。</p><ul><li>OffsetToLock —— 偏移量，以字节为单位，从缓存开始位置到锁定开始位置的距离。如图3.1。</li><li>SizeToLock —— 锁定的字节数。</li><li>ppbData —— 一个指向锁定内存开始位置的指针。</li><li>Flags —— 标记描述怎样锁定内存。它可能是0或者是下面参数中的1个或多个的组合：</li><li>D3DLOCK_DISCARD——这个参数仅仅会在动态缓存时被使用。它指示硬件丢弃缓存并返回一个指向新分配的缓存的指针。这是很有用，因为当我们存取一个新分配的缓存时它允许硬件继续从丢弃的缓存渲染。这防止了硬件延迟。</li><li>D3DLOCK_NOOVERWRITE——这个参数仅仅会在动态缓存时被使用。它声明你将向缓存中添加数据。即，你不能向已经渲染的内存中写数据。这是有好处的因为他允许你在添加新数据到缓存的同时让硬件继续渲染。</li><li>D3DLOCK_READONLY——这个参数声明你锁定的缓存只能从中读取数据而不能写数据。这允许一些内在的优化。<br>  用参数D3DLOCK_DISCARD和D3DLOCK_NOOVERWRITE的地址实际上就是缓存的一部分被使用（正在渲染）时它被锁定。假如情况允许这些标记被使用，当在锁定时他们防止渲染停止。<br>  下边的例子展示了通常怎样使用Lock方法。注意当我们使用完以后要调用Unlock方法。<br>Vertex<em> vertices;<br>_vb-&gt;Lock(0, 0, (void*</em>)&amp;vertices, 0); // 锁定整个缓存<br>vertices[0] = Vertex(-1.0f, 0.0f, 2.0f); // 向缓存里写顶点<br>vertices[1] = Vertex( 0.0f, 1.0f, 2.0f);<br>vertices[2] = Vertex( 1.0f, 0.0f, 2.0f);<br>_vb-&gt;Unlock(); // 当你访问完缓存时，解锁缓存<br>3.1.3 找回顶点和索引缓存信息<br>有时我们需要得到顶点/索引缓存信息。下面的例子示范了用于获得这些信息的方法：<br>D3DVERTEXBUFFER_DESC vbDescription;<br>_vertexBuffer-&gt;GetDesc(&amp;vbDescription); // 取得顶点缓存信息</li></ul><p>D3DINDEXBUFFER_DESC ibDescription;<br>_indexBuffer-&gt;GetDesc(&amp;ibDescription); //取得索引缓存信息<br>　　<br>　　D3DVERTEXBUFFER_DESC和D3DINDEXBUFFER_DESC结构的定义如下：<br>typedef struct _D3DVERTEXBUFFER_DESC {<br>    D3DFORMAT Format;<br>    D3DRESOURCETYPE Type;<br>    DWORD Usage;<br>    D3DPOOL Pool;<br>    UINT Size;<br>    DWORD FVF;<br>} D3DVERTEXBUFFER_DESC;</p><p>typedef struct _D3DINDEXBUFFER_DESC {<br>    D3DFORMAT Format;<br>    D3DRESOURCETYPE Type;<br>    DWORD Usage;<br>    D3DPOOL Pool;<br>    UINT Size;<br>} D3DINDEXBUFFER_DESC;<br>3.2 渲染状态<br>   Direct3D提供了多种渲染状态，它影响几何物体怎样被渲染。渲染状态有默认值，因此假如你的应用程序需要不同于默认设置的渲染时，你仅仅改变它即可。一种渲染效果会一直起作用，直到你下一次改变渲染状态为止。为了设置一个渲染状态，我们使用下面的方法：<br>HRESULT IDirect3DDevice9::SetRenderState(<br>    D3DRENDERSTATETYPE State, // 更改的渲染状态<br>    DWORD Value // 新的状态值<br>);</p><p>例如，在这一章的例子中我们将使用线框模式渲染我们的物体。因此，我们设置如下的渲染状态：<br>_device-&gt;SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME);<br>注意：查看DirectX SDK中关于D3DRENDERSTATETYPE的信息。其中详细介绍了所有的渲染状态。<br>3.3 绘制准备<br>　　一旦我们创建好一个顶点缓存以及一个索引缓存（可选的）后，我们就为渲染其中的内容准备得差不多了，但是在渲染前我们还有3个步骤必须先做。<br>1、 设置资源流。设置资源流与一个顶点缓存挂钩，此流就是一个流入渲染管线的几何信息的流。<br>　　下面的方法是用于设置一个资源流：<br>HRESULT IDirect3DDevice9::SetStreamSource(<br>    UINT StreamNumber,<br>    IDirect3DVertexBuffer9* pStreamData,<br>    UINT OffsetInBytes,<br>    UINT Stride<br>);</p><ul><li>StreamNumber——确定我们的顶点缓存与哪一个资源流挂钩。在这本书中我们不使用多重流；因此我们总是使用0号流。</li><li>pStreamData——一个指向我们想与流挂钩的那个顶点缓存的指针。</li><li>OffsetInBytes——相对流开始处的偏移量。以字节为单位，它指定被填入渲染管线的顶点数据的开始位置。通过检查D3DCAPS9结构中的D3DDEVCAPS2_STREAMOFFSET标志，假如你的设备支持，那么这个参数就有一些非0值。</li><li>Stride——我们在顶点缓存中操作的每个部分的流的字节大小。<br>　　例如，假设vb是一个已经填充了顶点信息的顶点缓存：<br>_device-&gt;SetStreamSource( 0, vb, 0, sizeof( Vertex ) );</li></ul><p>2、 设置顶点格式。在这里我们指定后面用来绘图调用的顶点的顶点格式。<br>_device-&gt;SetFVF( D3DFVF_XYZ | D3DFVF_DIFFUSE | D3DFVF_TEX1 );</p><p>3、 设置索引缓存。假如我们使用了索引缓存，我们必须设置后面要用于绘制操作的索引缓存。每次我们只能使用一个索引缓存；因此假如你需要用一个不同的索引缓存绘制一个物体时，你必须转换到另一个上。下面的代码设置一个索引缓存：<br>_device-&gt;SetIndices( _ib ); // 传递一个索引缓存指针的拷贝<br>3.4用顶点/索引缓存绘制<br>　　在我们创建好顶点/索引缓存以及做好准备工作以后，我们就能绘制我们的几何物体了。这是通过使用DrawPrimitive或者DrawIndexedPrimitive传送几何信息到达渲染管线。这些方法从顶点流中获得顶点信息以及从索引缓存中获得索引信息。<br>3.4.1 IDirect3DDevice9::DrawPrimitive<br>　　这个方法不使用索引信息绘制图元。<br>HRESULT IDirect3DDevice9::DrawPrimitive(<br>    D3DPRIMITIVETYPE PrimitiveType,<br>    UINT StartVertex,<br>    UINT PrimitiveCount<br>);</p><ul><li>PrimitiveType——我们绘制的图元类型。比如，我们能绘制点和线以及三角形。以后我们使用三角形，用D3DPT_TRIANGLELIST参数。</li><li>StartVertex——索引到在顶点流中的一个元素。设置渲染顶点中的开始点。这个参数给予我们一定的机动性，可以绘制一个顶点缓存中的某部分。</li><li>PrimitiveCount——绘制图元的个数。<br>　　例子：<br>// 绘制4个三角形<br>_device-&gt;DrawPrimitive( D3DPT_TRIANGLELIST, 0, 4);<br>3.4.2 IDirect3DDevice9::DrawIndexedPrimitive<br>　　这个方法使用索引信息来绘制图元。<br>HRESULT IDirect3DDevice9::DrawIndexedPrimitive(<br>  D3DPRIMITIVETYPE Type,<br>  INT BaseVertexIndex,<br>  UINT MinIndex,<br>  UINT NumVertices,<br>  UINT StartIndex,<br>  UINT PrimitiveCount<br>);</li><li>Type——我们绘制的图元类型。比如，我们能绘制点和线以及三角形。以后我们使用三角形，用D3DPT_TRIANGLELIST参数。</li><li>BaseVertexIndex——一个基本数字，在调用中用它去加上索引。参看下面的说明。</li><li>MinIndex——将被引用的最小索引值。</li><li>NumVertices——在此调用中将被引用的顶点数。</li><li>StartIndex——索引到索引缓存中的某个位置，它标记开始渲染的开始索引点。</li><li>PrimitiveCount——绘制图元的个数。<br>　　例子：<br>_device-&gt;DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, 0, 8, 0, 12);<br>注意：BaseVertexIndex参数需要一些特别的解释。在解释过程中将会用到的图3.2。</li></ul><p>图3.2<br>   在索引缓存中定位顶点相应的也就在顶点缓存中定位了。然而，假设我们想将球，盒子，圆柱体的顶点放置到一个公共的顶点缓存中。对于每一个物体，我们将不得不再计算在公共顶点缓存中的索引。这个新的索引值是通过与一个偏移量相加得到。注意这个偏移量是标准的顶点，而不是字节。<br>    我们需要计算物体在公共顶点缓存中的索引值。Direct3D允许我们通过设置BaseVertexIndex参数得到一个顶点偏移量，随后Direct3D就能利用顶点自身的索引重新计算新的索引。<br>3.4.3 开始/结束场景<br>   最后一点就是所有绘制方法都必须在IDirect3DDevice9::BeginScene和IDirect3DDevice9::EndScene方法之间被调用。例如，我们将这样写：<br>_device-&gt;BeginScene();<br>　　// 绘制场景<br>    _device-&gt;DrawPrimitive(…);<br>_device-&gt;EndScene();<br>3.5 D3DX几何物体<br>　　通过在代码中建造每个三角形来建造3D物体是一件非常枯燥的事。幸运的是，D3DX库已经为我们提供了一些方法来产生简单3D物体的网格数据。<br>　　D3DX库提供如下6种网格生成函数。</p><ul><li>D3DXCreateBox</li><li>D3DXCreateSphere</li><li>D3DXCreateCylinder</li><li>D3DXCreateTeapot</li><li>D3DXCreatePolygon</li><li>D3DXCreateTorus</li></ul><p>图3.3<br>　　这6种函数的使用都很类似，并且使用D3DX网格数据结构ID3DXMesh就象使用ID3DXBuffer接口一样。这些接口回在第10章和11章中讲解。现在，我们忽视它们的详细信息，只需简单使用它们即可。<br>HRESULT D3DXCreateTeapot(<br>    LPDIRECT3DDEVICE9 pDevice, // 与mesh关联的设备<br>    LPD3DXMESH<em> ppMesh, // 返回的mesh<br>    LPD3DXBUFFER</em> ppAdjacency // 现在设成0<br>);<br>　　<br>　　一个使用D3DXCreateTeapot函数的例子：<br>ID3DXMesh<em> mesh = 0;<br>D3DXCreateTeapot(_device, &amp;mesh, 0);<br>　　一旦生成了网格数据，我们就能使用ID3DXMesh::DrawSubset方法绘制图形了。这个方法有一个参数，它用来识别网格的一个子集。这个网格是通过上面的D3DXCreate</em>函数中的一个子集创建的，因此可以给这个参数指定0值。一个渲染网格的例子：<br>_device-&gt;BeginScene();<br>    mesh-&gt;DrawSubset(0);<br>_device-&gt;EndScene();</p><p>   使用了网格以后，必须释放（release）它：<br>mesh-&gt;Release();<br>_mesh = 0;<br>3.6 实例程序：三角形、立方体、茶壶、D3DXCreate*<br>　　这里有4个例子。</p><ul><li>三角形——这是非常简单的应用程序，它示范了在线框模式下怎样创建并渲染一个三角形。</li><li>立方体——只比三角形稍微复杂一点，这个程序渲染一个线框立方体。</li><li>茶壶——这个程序使用D3DXCreateTeapot函数创建并渲染一个纺纱茶壶。</li><li>D3DXCreate——这个程序创建并渲染几种不同的能够使用D3DXCreate*函数创建的3D物体。<br>让我们简单讨论一下创建立方体的例子。通过对它的学习你自己就能很快地理解其他例子。<br>  这个简单的绘制和渲染立方体的程序的运行结果如图3.4。</li></ul><p>图3.4<br>　　首先我们定义下边两个全局变量来保存立方体的顶点和索引数据：<br>IDirect3DVertexBuffer9<em> VB = 0;<br>IDirect3DIndexBuffer9</em> IB = 0;<br>　　下一步，我们定义两个全局常量，由它们来指定我们的屏幕大小：<br>const int Width = 800;<br>const int Height = 600;<br>　　接下来定义我们的顶点结构以及结构中顶点的格式。在这个例子中顶点结构只保存顶点的位置信息：<br>struct Vertex<br>{<br>    Vertex(){}<br>    Vertex(float x, float y, float z)<br>    {<br>        _x = x; _y = y; _z = z;<br>    }<br>    float _x, _y, _z;<br>    static const DWORD FVF;<br>};<br>const DWORD Vertex::FVF = D3DFVF_XYZ;<br>　　让我们把它迁移到框架程序（见1.53节）上。Setup函数创建顶点和索引缓存，锁定它们，把构成立方体的顶点写入顶点缓存，以及把定义立方体的三角形的索引写入索引缓存。然后把摄象机向后移动几个单位以便我们能够看见在世界坐标系中原点处被渲染的立方体。<br>bool Setup()<br>{<br>    // 创建顶点、索引缓存<br>    Device-&gt;CreateVertexBuffer(<br>        8 * sizeof(Vertex),<br>        D3DUSAGE_WRITEONLY,<br>        Vertex::FVF,<br>        D3DPOOL_MANAGED,<br>        &amp;VB,<br>        0);</p><pre><code>Device-&gt;CreateIndexBuffer(    36 * sizeof(WORD),    D3DUSAGE_WRITEONLY,    D3DFMT_INDEX16,    D3DPOOL_MANAGED,    &amp;IB,    0);// 向立方体的顶点缓存填充数据Vertex* vertices;VB-&gt;Lock(0, 0, (void**)&amp;vertices, 0);// vertices of a unit cubevertices[0] = Vertex(-1.0f, -1.0f, -1.0f);vertices[1] = Vertex(-1.0f, 1.0f, -1.0f);vertices[2] = Vertex( 1.0f, 1.0f, -1.0f);vertices[3] = Vertex( 1.0f, -1.0f, -1.0f);vertices[4] = Vertex(-1.0f, -1.0f, 1.0f);vertices[5] = Vertex(-1.0f, 1.0f, 1.0f);vertices[6] = Vertex( 1.0f, 1.0f, 1.0f);vertices[7] = Vertex( 1.0f, -1.0f, 1.0f);VB-&gt;Unlock();// 定义立方体的三角形WORD* indices = 0;IB-&gt;Lock(0, 0, (void**)&amp;indices, 0);// 前面indices[0] = 0; indices[1] = 1; indices[2] = 2;indices[3] = 0; indices[4] = 2; indices[5] = 3;// 背面indices[6] = 4; indices[7] = 6; indices[8] = 5;indices[9] = 4; indices[10] = 7; indices[11] = 6;// 左面indices[12] = 4; indices[13] = 5; indices[14] = 1;indices[15] = 4; indices[16] = 1; indices[17] = 0;// 右面indices[18] = 3; indices[19] = 2; indices[20] = 6;indices[21] = 3; indices[22] = 6; indices[23] = 7;// 顶部indices[24] = 1; indices[25] = 5; indices[26] = 6;indices[27] = 1; indices[28] = 6; indices[29] = 2;// 底部indices[30] = 4; indices[31] = 0; indices[32] = 3;indices[33] = 4; indices[34] = 3; indices[35] = 7;IB-&gt;Unlock();// 照相机位置（视图矩阵）D3DXVECTOR3 position(0.0f, 0.0f, -5.0f);D3DXVECTOR3 target(0.0f, 0.0f, 0.0f);D3DXVECTOR3 up(0.0f, 1.0f, 0.0f);D3DXMATRIX V;D3DXMatrixLookAtLH(&amp;V, &amp;position, &amp;target, &amp;up);Device-&gt;SetTransform(D3DTS_VIEW, &amp;V);// 投影矩阵D3DXMATRIX proj;D3DXMatrixPerspectiveFovLH(    &amp;proj,    D3DX_PI * 0.5f, // 90 - degree    (float)Width / (float)Height,    1.0f,    1000.0f);Device-&gt;SetTransform(D3DTS_PROJECTION, &amp;proj);// 渲染状态（填充模式：框架填充）Device-&gt;SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME);return true;</code></pre><p>}<br>　　Display方法有两个任务；它必须更新场景并且紧接着渲染它。既然想旋转立方体，那么我们将对每一帧增加一个角度使立方体能在这一帧旋转。对于这每一帧，立方体将被旋转一个很小的角度，这样我们看起来旋转就会更平滑。接着我们使用IDirect3DDevice9::DrawIndexedPrimitive方法来绘制立方体。<br>bool Display(float timeDelta)<br>{<br>    if( Device )<br>    {<br>        // 旋转立方体<br>        D3DXMATRIX Rx, Ry;<br>        // x轴旋转45弧度<br>        D3DXMatrixRotationX(&amp;Rx, 3.14f / 4.0f);</p><pre><code>    // 每一帧中增加y轴的弧度    static float y = 0.0f;    D3DXMatrixRotationY(&amp;Ry, y);    y += timeDelta;    //当y轴旋转2周时，重新回到0弧度    if( y &gt;= 6.28f )        y = 0.0f;    // 结合x轴与y轴的旋转矩阵    D3DXMATRIX p = Rx * Ry;    Device-&gt;SetTransform(D3DTS_WORLD, &amp;p);    // 清空目标缓存和深度缓存（用0xffffffff, 1.0f）    Device-&gt;Clear(0, 0, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,      0xffffffff, 1.0f, 0);    Device-&gt;BeginScene(); // 开始绘制场景    Device-&gt;SetStreamSource(0, VB, 0, sizeof(Vertex)); // 设置资源流    Device-&gt;SetIndices(IB); // 设置索引缓存    Device-&gt;SetFVF(Vertex::FVF); // 设置顶点格式</code></pre><p>　　　　// 利用索引缓存绘制<br>        Device-&gt;DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, 0, 8, 0, 12);</p><pre><code>    Device-&gt;EndScene(); // 结束绘制场景    Device-&gt;Present(0, 0, 0, 0); // 翻转表面}return true;</code></pre><p>}<br>　　<br>　　最后，我们释放使用过的所有内存。这意味着释放顶点和索引缓存接口：<br>void Cleanup()<br>{<br>    d3d::Release<idirect3dvertexbuffer9*>(VB);<br>    d3d::Release<idirect3dindexbuffer9*>(IB);<br>}<br>3.7 摘要（略）</idirect3dindexbuffer9*></idirect3dvertexbuffer9*></p><p>第四章 色彩<br>(Color)<br>　　在上一章中我们用线框模式渲染了场景中的物体。这一章我们将学习怎样渲染有颜色的物体。<br>目标</p><ul><li>学习在Direct3D中怎样描述颜色</li><li><p>弄懂怎样给三角形赋予颜色<br>4.1 颜色表示法<br>　　在Direct3D中，颜色是使用RGB三部分来描述的。也就是说，我们要分别指定红、绿和蓝三种颜色的值。混合这三个颜色决定最终的颜色。利用这三种颜色我们能够表现数万种颜色。<br>　　我们使用两种不同的结构来存储RGB数据。这第一种是D3DCOLOR，它实际上一个DWORD即32位。在D3DCOLOR类型中的这些位按照8-bit被分为4个部分，每一部分存储的是该色的亮度值。如图4.1所示。<br>　　<br>　　图4.1<br>　　每种颜色占用内存的一个字节，各颜色亮度值的取值范围是0-255。这个值越接近0就越暗，越接近255就越亮。<br>注意：现在不要管alpha部分；它被用在alpha混合中——在第7章中会讲解。<br>　　指定其中的每一部分并且把它放到D3DCOLOR中适当的位置需要使用到一些位操作。Direct3D为我们提供了一个完成这个任务的宏D3DCOLOR_ARGB.它使用包含每种颜色以及alpha位一共4个参数。每一个参数的取值必须在0-255之间，如：<br>D3DCOLOR brightRed = D3DCOLOR_ARGB(255, 255, 0, 0);<br>D3DCOLOR someColor = D3DCOLOR_ARGB(255, 144, 87, 201);<br>  另外，我们也能使用D3DCOLOR_XRGB宏，它与刚才的宏类似只不过不必指定alpha部分；不过我们最好还是把alpha指定为0xff（255）。</p><h1 id="define-D3DCOLOR-XRGB-r-g-b-D3DCOLOR-ARGB-0xff-r-g-b"><a href="#define-D3DCOLOR-XRGB-r-g-b-D3DCOLOR-ARGB-0xff-r-g-b" class="headerlink" title="define D3DCOLOR_XRGB(r,g,b) D3DCOLOR_ARGB(0xff,r,g,b)"></a>define D3DCOLOR_XRGB(r,g,b) D3DCOLOR_ARGB(0xff,r,g,b)</h1><p>　　在Direct3D中另外一种存储颜色的结构是D3DCOLORVALUE。在这个结构中，我们分别使用一个浮点数来表示每一部分的亮度值。其取值范围是0-1，0表示没有亮度，1表示最大亮度。<br>typedef struct _D3DCOLORVALUE {<br>  float r; // the red component, range 0.0-1.0<br>  float g; // the green component, range 0.0-1.0<br>  float b; // the blue component, range 0.0-1.0<br>  float a; // the alpha component, range 0.0-1.0<br>} D3DCOLORVALUE;<br>　　另外，我们能够使用D3DXCOLOR结构，就象D3DCOLORVALUE包含同样的数据成员一样。同时提供有用的构造函数和重载操作符，这将让颜色处理更容易。D3DXCOLOR的定义如下：<br>typedef struct D3DXCOLOR<br>{</p><h1 id="ifdef-cplusplus-1"><a href="#ifdef-cplusplus-1" class="headerlink" title="ifdef __cplusplus"></a>ifdef __cplusplus</h1><p>  public:</p><pre><code>  D3DXCOLOR() {}  D3DXCOLOR( DWORD argb );  D3DXCOLOR( CONST FLOAT * );  D3DXCOLOR( CONST D3DXFLOAT16 * );  D3DXCOLOR( CONST D3DCOLORVALUE&amp; );  D3DXCOLOR( FLOAT r, FLOAT g, FLOAT b, FLOAT a );  // casting  operator DWORD () const;  operator FLOAT* ();  operator CONST FLOAT* () const;  operator D3DCOLORVALUE* ();  operator CONST D3DCOLORVALUE* () const;  operator D3DCOLORVALUE&amp; ();  operator CONST D3DCOLORVALUE&amp; () const;  // assignment operators  D3DXCOLOR&amp; operator += ( CONST D3DXCOLOR&amp; );  D3DXCOLOR&amp; operator -= ( CONST D3DXCOLOR&amp; );  D3DXCOLOR&amp; operator *= ( FLOAT );  D3DXCOLOR&amp; operator /= ( FLOAT );  // unary operators  D3DXCOLOR operator + () const;  D3DXCOLOR operator - () const;  // binary operators  D3DXCOLOR operator + ( CONST D3DXCOLOR&amp; ) const;  D3DXCOLOR operator - ( CONST D3DXCOLOR&amp; ) const;  D3DXCOLOR operator * ( FLOAT ) const;  D3DXCOLOR operator / ( FLOAT ) const;  friend D3DXCOLOR operator * (FLOAT, CONST D3DXCOLOR&amp; );  BOOL operator == ( CONST D3DXCOLOR&amp; ) const;  BOOL operator != ( CONST D3DXCOLOR&amp; ) const;</code></pre><h1 id="endif-cplusplus-1"><a href="#endif-cplusplus-1" class="headerlink" title="endif //__cplusplus"></a>endif //__cplusplus</h1><p>  FLOAT r, g, b, a;<br>} D3DXCOLOR, *LPD3DXCOLOR;<br>注意：D3DCOLORVALUE和D3DXCOLOR结构都有4个浮点数成员。这使我们的颜色处理符号能象4D向量一样。颜色向量能被加，减以及缩放。另一方面点积和叉积不能用于颜色向量，但是颜色成员相乘是可以的。因此在D3DXCOLOR类中执行的乘法就是成员相乘。它的定义如下：</p><p>  现在使用下面全局颜色常量更新我们的d3dUtility.h文件：<br>namespace d3d<br>{<br>.<br>.<br>.<br>  const D3DXCOLOR WHITE( D3DCOLOR_XRGB(255, 255, 255) );<br>  const D3DXCOLOR BLACK( D3DCOLOR_XRGB( 0, 0, 0) );<br>  const D3DXCOLOR RED( D3DCOLOR_XRGB(255, 0, 0) );<br>  const D3DXCOLOR GREEN( D3DCOLOR_XRGB( 0, 255, 0) );<br>  const D3DXCOLOR BLUE( D3DCOLOR_XRGB( 0, 0, 255) );<br>  const D3DXCOLOR YELLOW( D3DCOLOR_XRGB(255, 255, 0) );<br>  const D3DXCOLOR CYAN( D3DCOLOR_XRGB( 0, 255, 255) );<br>  const D3DXCOLOR MAGENTA( D3DCOLOR_XRGB(255, 0, 255) );<br>}<br>4.2 顶点颜色<br>  图元的颜色是由构成它的顶点的颜色决定的。因此，我们必须把一个颜色成员加入到我们的顶点数据结构中。注意D3DCOLORVALUE类型不能用在这里，因为Direct3D希望用一个32位的值来描述顶点的颜色。（通过使用顶点着色器我们能为顶点颜色使用4D颜色向量，它能提供一个128位的颜色，但是对于我们现在的水平来说那太超前了。顶点着色器将在17章中介绍。）<br>struct ColorVertex<br>{<br>  float _x, _y, _z;<br>  D3DCOLOR _color;<br>  static const DWORD FVF;<br>}<br>const DWORD ColorVertex::FVF = D3DFVF_XYZ | D3DFVF_DIFFUSE;<br>4.3 着色处理<br>  着色处理发生在光栅化和指定图元上的顶点颜色怎样被计算成像素颜色之间。目前这里有2种着色处理模式可用：平面着色（flat shading）和高洛德着色（Gouraud shading）。<br>  平面着色，图元像素的颜色是均匀的，且就是指定图元第一个顶点的颜色。因此一旦三角形的第一个顶点被指定成红色，那么它的其他三个顶点也将会是红色。通过使用平面着色来为第二和第三个顶点着色。<br>ColorVertex t[3];<br>t[0]._color = D3DCOLOR_XRGB(255, 0, 0);<br>t[1]._color = D3DCOLOR_XRGB(0, 255, 0);<br>t[2]._color = D3DCOLOR_XRGB(0, 0, 255);<br>  平面着色使物体呈现是斑驳的，因为没有从一个颜色到另一个颜色的平滑过渡。一个更好的着色模式叫做高洛德着色（也被叫做平滑着色）。高洛德着色，图元表面的颜色是由每个顶点通过线性插值来赋予。图4.2显示了分别使用平面着色和高洛德着色处理的红色三角形。</p></li></ul><p>图4.2<br>就象Direct3D中很多东西一样，着色处理模式是受Direct3D设置状态决定的。<br>// set flat shading<br>Device-&gt;SetRenderState(D3DRS_SHADEMODE, D3DSHADE_FLAT);<br>// set Gouraud shading<br>Device-&gt;SetRenderState(D3DRS_SHADEMODE, D3DSHADE_GOURAUD);<br>4.4 实例程序：彩色三角形<br>    这个实例程序展示了分别使用本章中的平面着色和高洛德着色处理的三角形。渲染出的图片如图4.2所示。首先我们定义如下的全局变量：<br>D3DXMATRIX World;<br>IDirect3DVertexBuffer9<em> Triangle = 0;<br>    我们包含一个D3DXMATRIX，它将存储我们将要绘制的三角形在世界坐标中的变换信息。Triangle变量是存储三角形顶点数据的顶点缓存。注意，我们只需要存储一个三角形，因为我们能用它在世界坐标系中不同位置绘制若干次。<br>    Setup方法创建顶点缓存同时填充上带颜色信息的三角形顶点数据。三角形的第一个顶点填充为全亮度红色（255）第二个填充全亮度绿色（255），第三个填充全亮度蓝色（255）。最后，在这个例子中我们屏蔽掉灯光。值得注意的是该例子使用的是一个新的ColorVertex结构，就象在4.2节中说明的一样。<br>bool Setup()<br>{<br>    // create vertex buffer<br>    Device-&gt;CreateVertexBuffer(<br>        3 </em> sizeof(ColorVertex),<br>        D3DUSAGE_WRITEONLY,<br>        ColorVertex::FVF,<br>        D3DPOOL_MANAGED,<br>        &amp;Triangle,<br>        0);</p><pre><code>// fill the buffers with the triangle dataColorVertex* v;Triangle-&gt;Lock(0, 0, (void**)&amp;v, 0);v[0] = ColorVertex(-1.0f, 0.0f, 2.0f, D3DCOLOR_XRGB(255, 0,    0));v[1] = ColorVertex( 0.0f, 1.0f, 2.0f, D3DCOLOR_XRGB( 0, 255, 0));v[2] = ColorVertex( 1.0f, 0.0f, 2.0f, D3DCOLOR_XRGB( 0, 0, 255));Triangle-&gt;Unlock();// set projection matrixD3DXMATRIX proj;D3DXMatrixPerspectiveFovLH(    &amp;proj,    D3DX_PI * 0.5f, // 90 - degree    (float)Width / (float)Height,    1.0f,    1000.0f);Device-&gt;SetTransform(D3DTS_PROJECTION, &amp;proj);// set the render statesDevice-&gt;SetRenderState(D3DRS_LIGHTING, false);return true;</code></pre><p>}<br>    Display函数使用不同的着色模式在两个不同的地方分别绘制2个Triangle。每个三角形的位置由世界矩阵World来决定。<br>bool Display(float timeDelta)<br>{<br>    if( Device )<br>    {<br>        Device-&gt;Clear(0, 0, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,    0xffffffff, 1.0f, 0);<br>        Device-&gt;BeginScene();</p><pre><code>    Device-&gt;SetFVF(ColorVertex::FVF);    Device-&gt;SetStreamSource(0, Triangle, 0, sizeof(ColorVertex));    // draw the triangle to the left with flat shading    D3DXMatrixTranslation(&amp;World, -1.25f, 0.0f, 0.0f);    Device-&gt;SetTransform(D3DTS_WORLD, &amp;World);    Device-&gt;SetRenderState(D3DRS_SHADEMODE, D3DSHADE_FLAT);    Device-&gt;DrawPrimitive(D3DPT_TRIANGLELIST, 0, 1);    // draw the triangle to the right with gouraud shading    D3DXMatrixTranslation(&amp;World, 1.25f, 0.0f, 0.0f);    Device-&gt;SetTransform(D3DTS_WORLD, &amp;World);    Device-&gt;SetRenderState(D3DRS_SHADEMODE, D3DSHADE_GOURAUD);    Device-&gt;DrawPrimitive(D3DPT_TRIANGLELIST, 0, 1);    Device-&gt;EndScene();    Device-&gt;Present(0, 0, 0, 0);}return true;</code></pre><p>}<br>4.5 摘要(略)</p><p>第五章 灯光<br>(Lighting)<br>    为了提高场景的真实性，我们可以为其加入灯光。灯光也能帮助表现物体的立体感以及物体的体积。当使用灯光时，我们不再自己指定顶点的颜色；Direct3D中每个顶点都通过灯光引擎来计算顶点颜色，该计算是基于定义的灯光资源，材质以及灯光资源关心的表面方向。通过灯光模型计算顶点颜色会得到更真实的场景。<br>目标</p><ul><li>学习Direct3D支持的灯光资源，以及它们照射出的灯光类型。</li><li>弄懂怎样定义灯光去影响其照射的表面。</li><li>找出怎样算术描述三角形的方向以便我们能够确定灯光照射到三角形的角度。<br>5.1灯光的组成<br>  在Direct3D灯光模型中，灯光是通过灯光资源的三个成员之一来照射的，即有三种灯光。</li><li>环境光（Ambient Light）——这种类型的灯光将被其他所有表面反射且被用在照亮整个场景。例如，物体的各部分都被照亮，对于一个角度，甚至穿过不在光源直接照射的地方他们都能被照亮。环境光的使用是粗略的，便宜的，它模仿反射光。</li><li>漫反射（Diffuse Reflection）——这种灯光按照特殊方向传播。当它照射到一个表面，它将在所有方向上均匀的反射。因为漫射光在所有方向上都均匀的反射，被反射的光线将到达眼睛而与观察点无关，因此我们不必为观察者考虑。因而，漫射光仅仅需要考虑灯光方向和表面的姿态。这种灯光将成为你的资源中照射的普通灯光。</li><li>镜面反射（Specular Reflection）——这种灯光按照特殊方向传播。当它照射到一个表面时，它严格地按照一个方向反射。这将产生一个明亮的光泽，它能在某角度被看见。因为这种灯光在一个方向反射。明显的观察点，必须考虑灯光的方向和表面姿态，且必须按照镜面灯光等式来考虑。镜面灯光被用在物体上产生高光的地方，这种光泽只有在灯光照射在磨光的表面上才会产生。<br>　　镜面光比其他灯光类型要求更多的计算；因此，Direct3D提供了一个开关选择。实际上，它默认是被关闭的；要使用镜面光你必须设置D3DRS_SPECULARENABLE渲染状态。<br>Device-&gt;SetRenderState(D3DRS_SPECULARENABLE, true);<br>　　每一种灯光都是通过D3DCOLORVALUE结构或者描述灯光颜色的D3DXCOLOR来描绘的。这里有几个灯光颜色的例子：<br>D3DXCOLOR redAmbient(1.0f, 0.0f, 0.0f, 1.0f);<br>D3DXCOLOR blueDiffuse(0.0f, 0.0f, 1.0f, 1.0f);<br>D3DXCOLOR whiteSpecular(1.0f, 1.0f, 1.0f, 1.0f);<br>　　注意：在D3DXCOLOR类中的alpha值用在描述灯光颜色时是被忽略的。<br>5.2材质<br>　　在现实世界中我们看到的物体颜色将由物体反射回来的灯光颜色来决定。比如，一个红色的球是红色的，因为它吸收所有的灯光颜色除了红色光。红色光是被球反射回来进入我们眼睛的，因此我们看到的球是红色的。Direct3D通过我们定义的物体材质来模拟这些所有的现象。材质允许我们定义表面反射灯光的百分比。在代码中通过D3DMATERIAL9结构描述一个材质。<br>typedef struct _D3DMATERIAL9 {<br>  D3DCOLORVALUE Diffuse, Ambient, Specular, Emissive;<br>  float Power;<br>} D3DMATERIAL9;</li><li>Diffuse——指定此表面反射的漫射光数量。</li><li>Ambient——指定此表面反射的环境光数量。</li><li>Specular——指定此表面反射的镜面光数量</li><li>Emissive——这个是被用来给表面添加颜色，它使得物体看起来就象是它自己发出的光一样。</li><li><p>Power——指定锐利的镜面高光；它的值是高光的锐利值。<br>　　举例，想得到一个红色的球。我们将定义球的材质来只反射红光吸收其他颜色的所有光：<br>D3DMATERIAL9 red;<br>::ZeroMemory(&amp;red, sizeof(red));<br>red.Diffuse = D3DXCOLOR(1.0f, 0.0f, 0.0f, 1.0f); // red<br>red.Ambient = D3DXCOLOR(1.0f, 0.0f, 0.0f, 1.0f); // red<br>red.Specular = D3DXCOLOR(1.0f, 0.0f, 0.0f, 1.0f); // red<br>red.Emissive = D3DXCOLOR(0.0f, 0.0f, 0.0f, 1.0f); // no emission<br>red.Power = 5.0f;<br>　　这里我们设置绿色和蓝色的值为0，这表明材质反射0%此颜色的光。我们设置红色为1，表示材质反射100%的红光。注意，我们能够控制每种灯光反射的颜色（环境、漫射和镜面光）。<br>　　同样假如我们定义一个只发出蓝色光的光源，对球的光照将失败因为蓝色光将被全部吸收而没有红光被反射。当物体吸收了所有光以后，物体看起来就为黑色。同样的，当物体反射100%的红、绿和蓝光，物体就将呈现为白色。<br>　　因为手工填充一个材质结构将是乏味的工作，我们添加下列有用的函数和全局材质常数到d3dUtility.h/cpp文件中：<br>D3DMATERIAL9 d3d::InitMtrl(D3DXCOLOR a, D3DXCOLOR d,<br>D3DXCOLOR s, D3DXCOLOR e, float p)<br>{<br>  D3DMATERIAL9 mtrl;<br>  mtrl.Ambient = a;<br>  mtrl.Diffuse = d;<br>  mtrl.Specular = s;<br>  mtrl.Emissive = e;<br>  mtrl.Power = p;<br>  return mtrl;<br>}<br>namespace d3d<br>{<br>  .<br>  .<br>  .<br>  D3DMATERIAL9 InitMtrl(D3DXCOLOR a, D3DXCOLOR d, D3DXCOLOR s, D3DXCOLOR e, float p);</p><p>  const D3DMATERIAL9 WHITE_MTRL = InitMtrl(WHITE, WHITE, WHITE, BLACK, 8.0f);</p><p>  const D3DMATERIAL9 RED_MTRL = InitMtrl(RED, RED, RED, BLACK, 8.0f);</p><p>  const D3DMATERIAL9 GREEN_MTRL = InitMtrl(GREEN, GREEN, GREEN, BLACK, 8.0f);</p><p>  const D3DMATERIAL9 BLUE_MTRL = InitMtrl(BLUE, BLUE,    BLUE, BLACK, 8.0f);</p><p>  const D3DMATERIAL9 YELLOW_MTRL = InitMtrl(YELLOW, YELLOW, YELLOW, BLACK, 8.0f);<br>}<br>　　顶点结构没有材质属性；一个通用的材质必须被设置。设置它我们使用IDirect3DDevice9::SetMaterial(CONST D3DMATERIAL9*pMaterial)方法。<br>　　假设我们想渲染几个不同材质的物体；我们将按照如下的写法去做：<br>D3DMATERIAL9 blueMaterial, redMaterial;</p></li></ul><p>…// set up material structures</p><p>Device-&gt;SetMaterial(&amp;blueMaterial);<br>drawSphere(); // blue sphere</p><p>Device-&gt;SetMaterial(&amp;redMaterial);<br>drawSphere(); // red sphere<br>5.3顶点法线<br>    面法线（face normal）是描述多边形表面方向的一个向量（如图5.1）。</p><p>图5.1<br>　　顶点法线（Vertex normals）也是基于同样的概念，但是我们与其指定每个多边形的法线，还不如为每个顶点指定（如图5.2）。<br>　　<br>　　图5.2<br>　　Direct3D需要知道顶点法线以便它能够确定灯光照射到物体表面的角度，并且一旦计算了每个顶点的灯光，Direct3D需要知道每个顶点的表面方向。注意顶点法线不一定和面法线相同。球体/环形物就是很好的实物例子，它们的顶点法线和三角形法线是不相同的（如图5.3）。<br>　　<br>　　图5.3<br>　　为了描述顶点的顶点法线，我们必须更新原来的顶点结构：：<br>struct Vertex<br>{<br>    float _x, _y, _z;<br>    float _nx, _ny, _nz;<br>    static const DWORD FVF;<br>}<br>const DWORD Vertex::FVF = D3DFVF_XYZ | D3DFVF_NORMAL;<br>　　注意，我们已经将上一章中使用的颜色成分去除了。这是因为我们将使用灯光来计算顶点的颜色。<br>　　作为一个简单的物体比如立方体和球体，我们能够通过观察看见顶点法线。对于更多复杂的网格，我们需要一个更多的机械方法。假设一个由p0,p1,p2构成的三角形，我们需要计算每个顶点的法线n0,n1,n2。<br>　　简单的步骤，我们列举它是为了找到由三个点构成的三角形的面法线，同时使用面法线作为顶点法线。首先计算三角形上的两个向量：<br>　　<br>　　那么面法线是：<br>　　<br>　　每个顶点的法线和面法线是相等的：<br>　　<br>　　下面是一个C函数，它通过三角形的三个顶点计算三角形的面法线。注意这个函数的三个顶点是按照顺时针方向指定的。假如不是这样，那么法线方向将是相反的。<br>void ComputeNormal(D3DXVECTOR3<em> p0,<br>                D3DXVECTOR3</em> p1,<br>                D3DXVECTOR3<em> p2,<br>                D3DXVECTOR3</em> out)<br>{<br>    D3DXVECTOR3 u = <em>p1 - </em>p0;<br>    D3DXVECTOR3 v = <em>p2 - </em>p0;<br>    D3DXVec3Cross(out, &amp;u, &amp;v);<br>    D3DXVec3Normalize(out, out);<br>}<br>　　当用三角形近似表示曲面时，使用面法线作为顶点法线不能表现一个平滑的结果。一个更好的方法是找到顶点法线的平均法线。为了找到顶点v的顶点法线vn，我们找到网格模型中所有三角形的面法线记为顶点v。vn是通过计算他们的平均面法线得到的。这里有一个例子，假设有3个三角形它们的面法线分别是n0，n1，n2，指定为顶点v。那么vn的平均法线就是：<br>　　<br>通过改变“舞台”，把顶点法线变为non-normal,这是有可能的。因此这样最好是安全的且在通过D3DRS_NORMALIZENORMALS设置渲染状态来改变“舞台”后，Direct3D从新规格化所有法线。<br>Device-&gt;SetRenderState(D3DRS_NORMALIZENORMALS, true);<br>5.4光源<br>　　Direct3D支持三种类型的光源。</p><ul><li>点光源——这种光源在世界坐标中有一个位置且向所有方向上都照射光线。</li></ul><p>图5.4</p><ul><li>方向光源——这种光源没有位置但是向指定方向发出平行光线。</li></ul><p>图5.5</p><ul><li>聚光灯——这种类型的光源和手电筒的光类似；它有位置并且发出的光在指定方向上按照圆锥形照射。这个圆锥形有两个角度，θ和φ。角度θ描述内圆锥，φ描述外圆锥。</li></ul><p>图5.6<br>　　在代码中一个灯光资源是通过D3DLIGHT9结构来表现的。<br>typedef struct _D3DLIGHT9 {<br>    D3DLIGHTTYPE Type;<br>    D3DCOLORVALUE Diffuse;<br>    D3DCOLORVALUE Specular;<br>    D3DCOLORVALUE Ambient;<br>    D3DVECTOR Position;<br>    D3DVECTOR Direction;<br>    float Range;<br>    float Falloff;<br>    float Attenuation0;<br>    float Attenuation1;<br>    float Attenuation2;<br>    float Theta;<br>    float Phi;<br>} D3DLIGHT9;</p><ul><li>Type——定义灯光类型，我们能够使用下面三种类型之一：D3DLIGHT_POINT, D3DLIGHT_SPOT, D3DLIGHT_DIRECTIONAL</li><li>Diffuse——此光源发出的漫射光颜色。</li><li>Specular——此光源发出的镜面光颜色。</li><li>Ambient——此光源发出的环境光颜色。</li><li>Position——用一个向量来描述的光源世界坐标位置。这个值对于灯光的方向是无意义的。</li><li>Direction——用一个向量来描述的光源世界坐标照射方向。这个值不能用在点光源上。</li><li>Range——灯光能够传播的最大范围。这个值不能比大。且不能用于方向光源。</li><li>Falloff——这个值只能用在聚光灯上。它定义灯光在从内圆锥到外圆锥之间的强度衰减。它的值通常设置为1.0f。</li><li><p>Attenuation0, Attenuation1, Attenuation2——这些衰减变量被用来定义灯光强度的传播距离衰减。它们只被用于点光源和聚光灯上。Attenuation0定义恒定衰减，Attenuation1定义线性衰减，Attenuation2定义二次衰减。适当的使用这个公式，D是代表到光源的距离，A0,A1,A2与Attenuation0，1，2相匹配。</p></li><li><p>Theta——只用于聚光灯；指定内圆锥的角度，单位是弧度。</p></li><li><p>Phi——只用于聚光灯；指定外圆锥的角度，单位是弧度。<br>　　就象初始化D3DMATERIAL9结构一样，初始化D3DLIGHT9结构是一件单调乏味的工作。我们添加下面的函数到d3dUtility.h/cpp文件中用于初始化简单灯光。<br>namespace d3d<br>{<br>  … …<br>  D3DLIGHT9 InitDirectionalLight(D3DXVECTOR3<em> direction, D3DXCOLOR</em> color);</p><p>  D3DLIGHT9 InitPointLight(D3DXVECTOR3<em> position, D3DXCOLOR</em> color);</p><p>  D3DLIGHT9 InitSpotLight(D3DXVECTOR3<em> position, D3DXVECTOR3</em> direction, D3DXCOLOR<em> color);<br>}<br>　　使用这些函数是非常简单的。我们现在只是演示怎样使用InitDirectionalLight。其他的也很类似：<br>D3DLIGHT9 d3d::InitDirectionalLight(D3DXVECTOR3</em> direction, D3DXCOLOR<em> color)<br>{<br>  D3DLIGHT9 light;<br>  ::ZeroMemory(&amp;light, sizeof(light));<br>  light.Type = D3DLIGHT_DIRECTIONAL;<br>  light.Ambient = </em>color <em> 0.4f;<br>  light.Diffuse = </em>color;<br>  light.Specular = <em>color </em> 0.6f;<br>  light.Direction = *direction;<br>  return light;<br>}<br>　　然后创建一个方向光源，它沿着x轴正方向照射白色灯光。我们按照下面的方法来做：<br>D3DXVECTOR3 dir(1.0f, 0.0f, 0.0f);<br>D3DXCOLOR c = d3d::WHITE;<br>D3DLIGHT9 dirLight = d3d::InitDirectionalLight(&amp;dir, &amp;c);<br>　　在把D3DLIGHT9初始化好以后，我们需要用Direct3D内在支持的灯光来注册。就象这样做：<br>Device-&gt;SetLight(<br>  0, // element in the light list to set, range is 0-maxlights<br>  &amp;light);// address of the D3DLIGHT9 structure to set<br>　　一旦灯光注册了，我们就能使用下面的列举的例子来开或关灯光了：<br>Device-&gt;LightEnable(<br>  0, // the element in the light list to enable/disable<br>  true); // true = enable, false = disable<br>5.5实例程序：灯光<br>  这一章的例子是创建如图5.7所显示的场景。它示范了怎样指定顶点法线，怎样创建材质，以及怎样创建和使用一个方向灯光。注意在这个示例程序中我们不会使用在文件d3dUtility.h/cpp中的材质和灯光函数。因为我们想展示怎样手动来做这些设置。</p></li></ul><p>图5.7<br>    给场景增加灯光的步骤是：<br>1、 允许使用灯光。<br>2、 为每个物体创建材质并且在渲染相应物体前应将材质附予物体。<br>3、 创建一个或多个光源，设置它们，把它们设为可用。<br>4、 将其他附加光源设为可用，比如镜面高光。<br>　　首先我们初始化一个全局顶点缓存用他来存储“金字塔”的顶点：<br>IDirect3DVertexBuffer9<em> Pyramid = 0;<br>　　Setup函数包含本章的所有代码，因此我们忽略其他函数。它执行刚才讨论的步骤来给场景加入灯光。Setup方法首先允许使用灯光，当然这不是必须的因为默认设置就是允许使用灯光的。<br>bool Setup()<br>{<br>    Device-&gt;SetRenderState(D3DRS_LIGHTING, true);<br>　　下一步，我们创建顶点缓存，锁定，并且把“金字塔”的三角形顶点放入其中。顶点法线是利用5.3节中的运算法则预先计算好的。注意三角形共享顶点，但它们的法线不能共享；因此对这个物体使用索引列表并不是最有利的。例如，所有三角形都共享顶点（0,1,0）；然而，对每个三角形，它们的顶点法线是不相同的。<br>    Device-&gt;CreateVertexBuffer(<br>                12 </em> sizeof(Vertex),<br>                D3DUSAGE_WRITEONLY,<br>                Vertex::FVF,<br>                D3DPOOL_MANAGED,<br>                &amp;Pyramid,<br>                0);<br>    // fill the vertex buffer with pyramid data<br>    Vertex<em> v;<br>    Pyramid-&gt;Lock(0, 0, (void*</em>)&amp;v, 0);</p><pre><code>// front facev[0] = Vertex(-1.0f, 0.0f, -1.0f, 0.0f, 0.707f, -0.707f);v[1] = Vertex( 0.0f, 1.0f, 0.0f, 0.0f, 0.707f, -0.707f);v[2] = Vertex( 1.0f, 0.0f, -1.0f, 0.0f, 0.707f, -0.707f);// left facev[3] = Vertex(-1.0f, 0.0f, 1.0f, -0.707f, 0.707f, 0.0f);v[4] = Vertex( 0.0f, 1.0f, 0.0f, -0.707f, 0.707f, 0.0f);v[5] = Vertex(-1.0f, 0.0f, -1.0f, -0.707f, 0.707f, 0.0f);// right facev[6] = Vertex( 1.0f, 0.0f, -1.0f, 0.707f, 0.707f, 0.0f);v[7] = Vertex( 0.0f, 1.0f, 0.0f, 0.707f, 0.707f, 0.0f);v[8] = Vertex( 1.0f, 0.0f, 1.0f, 0.707f, 0.707f, 0.0f);// back facev[9] = Vertex( 1.0f, 0.0f, 1.0f, 0.0f, 0.707f, 0.707f);v[10] = Vertex( 0.0f, 1.0f, 0.0f, 0.0f, 0.707f, 0.707f);v[11] = Vertex(-1.0f, 0.0f, 1.0f, 0.0f, 0.707f, 0.707f);Pyramid-&gt;Unlock();</code></pre><p>　　为物体产生了顶点数据以后，我们描述利用灯光表现各自材质的物体间是怎样相互影响的。在这个例子中，“金字塔”反射出白光，自身不发光，且会产生一些高光。<br>D3DMATERIAL9 mtrl;<br>mtrl.Ambient = d3d::WHITE;<br>mtrl.Diffuse = d3d::WHITE;<br>mtrl.Specular = d3d::WHITE;<br>mtrl.Emissive = d3d::BLACK;<br>mtrl.Power = 5.0f;<br>Device-&gt;SetMaterial(&amp;mtrl);<br>　　接着，我们创建一个方向光并将其设为可用。方向光是沿着x轴的正方向照射的。灯光照射最强的白色漫射光（dir.Diffuse = WHITE），较弱的白色镜面光（dir.Specular = WHITE <em> 0.3f）以及一个中等强度的白色环境光（dir.Ambient = WHITE </em>0.6f）。<br>D3DLIGHT9 dir;<br>::ZeroMemory(&amp;dir, sizeof(dir));<br>dir.Type = D3DLIGHT_DIRECTIONAL;<br>dir.Diffuse = d3d::WHITE;<br>dir.Specular = d3d::WHITE <em> 0.3f;<br>dir.Ambient = d3d::WHITE </em> 0.6f;<br>dir.Direction = D3DXVECTOR3(1.0f, 0.0f, 0.0f);<br>Device-&gt;SetLight(0, &amp;dir);<br>Device-&gt;LightEnable(0, true);<br>　　最后，我们设置状态使法线从新规格化且把镜面高光设置为可用。<br>    Device-&gt;SetRenderState(D3DRS_NORMALIZENORMALS, true);<br>    Device-&gt;SetRenderState(D3DRS_SPECULARENABLE, true);<br>    // … code to set up the view matrix and projection matrix<br>    // omitted<br>    return true;<br>}<br>5.6附加实例<br>　　这一章中还有三个附加的例子。它们使用D3DXCreate<em>函数来创建组成场景的3D物体。D3DXCreate</em>函数创建的顶点数据是D3DFVF_XYZ | D3DFVF_NORMAL格式。在增加的函数中为我们的网格模型的每个顶点计算了顶点法线。这些实例演示了怎样使用方向光，点光源，以及聚光灯。图5.8显示的是方向光实例中的一个场景图。<br>　　<br>　　图5.8<br>5.7摘要(略)</p><p>第六章 纹理<br>(Texturing)<br>　　纹理映射是一种允许我们为三角形赋予图象数据的技术；这让我们能够更细腻更真实地表现我们的场景。例如，我们能够创建一个立方体并且通过对它的每个面创建一个纹理来把它变成一个木箱（如图6.1）。<br>　　<br>　　图6.1<br>　　在Direct3D中一个纹理是通过IDirect3DTexture9接口来表现的。一个纹理是一个类似像素矩阵的表面它能够被映射到三角形上。<br>目标</p><ul><li>学习怎样指定纹理到三角形上。</li><li>弄懂怎样创建一纹理。</li><li>学习怎样通过过滤纹理来创建一个更光滑的图象。<br>6.1 纹理坐标<br>　　Direct3D使用一个纹理坐标系统，它是由用水平方向的u轴和竖直方向v轴构成。由u,v坐标决定纹理上的元素，它被叫做texel。注意v轴是向下的（如图6.2）。<br>　　<br>　　图6.2<br>　　同样，注意规格化的坐标间隔，[0，1]，它被使用是因为它给Direct3D一个固定的范围用于在不同尺寸的纹理上工作。<br>　　对每一个3D三角形，我们都希望在给它贴图的纹理上定义一个用相应的三角形。（如图6.3）。<br>　　<br>　　图6.3<br>　　    我们再一次修改原来的顶点结构，添加一个用于在纹理上定位的纹理坐标。<br>struct Vertex<br>{<br>  float _x, _y, _z;<br>  float _nx, _ny, _nz;<br>  float _u, _v; // texture coordinates<br>  static const DWORD FVF;<br>};<br>const DWORD Vertex::FVF = D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1;<br>　　我们在顶点格式中添加了一个D3DFVF_TEX1，它是说我们的顶点结构中包含了一个纹理坐标。<br>　　现在每个三角形都通过顶点的三个对象来建立，同时也通过纹理坐标定义了一个相应的纹理三角形。<br>6.2创建并赋予材质<br>　　纹理数据通常是从存储在磁盘中的图片文件中读取的，且被读进IDirect3DTexture9对象中。我们能够使用下面的D3DX函数完成这项工作：<br>HRESULT D3DXCreateTextureFromFile(<br>  LPDIRECT3DDEVICE9 pDevice, // device to create the texture<br>  LPCSTR pSrcFile, // filename of image to load<br>  LPDIRECT3DTEXTURE9<em> ppTexture // ptr to receive the created texture<br>);<br>这个函数能够读取下面图片格式中的任意一种：BMP,DDS,DIB,JPG,PNG,TGA。<br>　　例如，用一个名为stonewall.bmp的图片创建一个纹理，我们将按照下面的例子来写：<br>IDirect3Dtexture9</em> _stonewall;<br>D3DXCreateTextureFromFile(_device, “stonewall.bmp”, &amp;_stonewall);<br>　　设置当前纹理，我们使用下面的方法：<br>HRESULT IDirect3DDevice9::SetTexture(<br>  DWORD Stage, // A value in the range 0-7 identifying the texture<pre><code>          // stage – see note on Texture Stages</code></pre>  IDirect3DBaseTexture9* pTexture // ptr to the texture to set<br>);<br>　　例子：<br>Device-&gt;SetTexture(0, _stonewall);<br>注意：在Direct3D中，你能够设置八个纹理，它们能够组合起来创建更多细节的图象。这又被叫做多重纹理。在本书的第四部分以前我们不会使用多重纹理；因此现在我们总是设置stage为0。<br>　　为了销毁一个纹理，我们设置pTexture为0。例如，假如不想用一个纹理来渲染物体，那么我们就这样写：<br>Device-&gt;SetTexture(0, 0);<br>renderObjectWithoutTexture();<br>假如场景中有使用不同纹理的三角形，我们就必须添加与下面类似的一些代码：<br>Device-&gt;SetTexture(0, _tex0);<br>drawTrisUsingTex0();</li></ul><p>Device-&gt;SetTexture(0, _tex1);<br>drawTrisUsingTex1();<br>6.3过滤器<br>    就象以前提及的，纹理被映射到屏幕中的三角形上。通常纹理三角形和屏幕三角形是不一样大的。当纹理三角形比屏幕三角形小时，纹理三角形会被适当放大。当纹理三角形比屏幕三角形大时，纹理三角形会被适当缩小。这两种情况，变形都将会出现。过滤（Filtering）是一种Direct3D用它来帮助这些变形变的平滑的技术。<br>    Direct3D提供了三种不同的过滤器；每种都提供了一个不同的品质级别。越好的品质越慢，因此你必须在品质与速度之间取得一个平衡。纹理过滤器是用IDirect3DDevice9::SetSamplerState方法来设置的。</p><ul><li>Nearest point sampling——这是默认的过滤方法且返回最差的效果，但是它的计算是最快的。下面的代码就是设置Nearest point sampling作为缩小放大的过滤器：<br>Device-&gt;SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_POINT);<br>Device-&gt;SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_POINT);</li><li>Linear filtering——这种过滤产生还算比较好的效果，在今天的硬件上处理它还是非常快的。它是被推荐使用的。下面的代码就是设置Linear filtering作为缩小放大的过滤器。<br>Device-&gt;SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);<br>Device-&gt;SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);</li><li>Anisotropic filtering——这种过滤产生最好的效果，但是处理时间也是最长的。下面的代码就是设置Anisotropic filtering作为缩小放大的过滤器。<br>Device-&gt;SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_ANISOTROPIC);<br>Device-&gt;SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_ANISOTROPIC);<br>当使用Anisotropic filtering时，我们必须设置D3DSAMP_MAXANISOTROPY等级，它决定处理的质量。该值越高处理的效果越好。检查D3DCAPS9结构确认你的显卡是否支持此功能。下面的代码设置该值为4：<br>Device-&gt;SetSamplerState(0, D3DSAMP_MAXANISOTROPY, 4);<br>6.4 Mipmaps<br>　　就象6.3节所说的，在屏幕上的三角形和纹理三角形通常是不一样大的。为了使这个大小差异变小，我们为纹理创建mipmaps链。也就是说将一个纹理创建成连续的变小的纹理，但是对它们等级进行定制过滤，因此对我们来说保存细节是很重要的（如图6.4）。<br>　　<br>　　图6.4<br>6.4.1 Mipmaps过滤器<br>  mipmap过滤器是被用来控制Direct3D使用mipmaps的。设置mipmap过滤器，你可以这样写：<br>Device-&gt;SetSamplerState(0, D3DSAMP_MIPFILTER, Filter);<br>在Filter处你能用下面三个选项中的一个：</li><li>D3DTEXF_NONE——不使用mipmap。</li><li>D3DTEXF_POINT——通过使用这个过滤器，Direct3D将选择与屏幕三角形大小最接近的mipmap等级。一旦等级选定了，Direct3D就将按照指定的过滤器进行缩小和放大过滤。</li><li>D3DTEXF_LINEAR——通过使用这个过滤器，Direct3D将选择两个最接近的mipmap等级，缩小和放大过滤每个等级，然后线性联合计算它们两个等级来得到最终的颜色值。<br>6.4.2 Direct3D中使用Mipmaps<br>  在Direct3D中使用Mipmaps是很简单的。假如你的显卡支持Mipmaps，那么使用D3DXCreateTextureFromFile将为你产生一个Mipmap链。Direct3D自动选择与屏幕三角形最匹配的Mipmap。因此Mipmap有非常广泛的应用，且它能被自动设置。<br>6.5 寻址模式<br>  以前，我们规定纹理坐标必须指定在[0，1]之间。从技术上来说这是不正确的；他们能够超出这个范围。纹理坐标也可以在[0，1]的范围之外，它通过Direct3D的寻址模式来定义。这里有四种寻址模式：环绕纹理寻址模式、边框颜色纹理寻址模式、截取纹理寻址模式、镜像纹理寻址模式，这里分别给出了它们的示意图6.5，6.6，6.7，6.8。</li></ul><p>图6.5（环绕）                          图6.6（边框）</p><p>图6.7（截取）                          图6.8（镜像）<br>在这些图片中，纹理坐标通过（0,0）（0,3）（3,0）（3,3）顶点来定义。在u轴和v轴上方块又被分成子块放进3×3的矩阵中。假如，你想让纹理按5×5的方格来平铺，你就应该指定环绕纹理寻址模式并且纹理坐标因该设置为（0,0）（0,5）（5,0）（5,5）。<br>    下面的代码片段列举的是怎样设置这四种寻址模式：<br>// set wrap address mode<br>if( ::GetAsyncKeyState(‘W’) &amp; 0x8000f )<br>{<br>    Device-&gt;SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_WRAP);<br>    Device-&gt;SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_WRAP);<br>}<br>// set border color address mode<br>if( ::GetAsyncKeyState(‘B’) &amp; 0x8000f )<br>{<br>    Device-&gt;SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_BORDER);<br>    Device-&gt;SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_BORDER);<br>    Device-&gt;SetSamplerState(0, D3DSAMP_BORDERCOLOR, 0x000000ff);<br>}<br>// set clamp address mode<br>if( ::GetAsyncKeyState(‘C’) &amp; 0x8000f )<br>{<br>    Device-&gt;SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP);<br>    Device-&gt;SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP);<br>}<br>// set mirror address mode<br>if( ::GetAsyncKeyState(‘M’) &amp; 0x8000f )<br>{<br>    Device-&gt;SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_MIRROR);<br>    Device-&gt;SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_MIRROR);<br>}<br>6.6实例程序：有纹理的方块<br>    这个例子是怎样为方块加上纹理以及设置一个纹理过滤器（如图6.9）。假如你的显卡支持，通过D3DXCreateTextureFromFile函数一个mipmap链将被自动创建。</p><p>图6.9<br>注意：还提供了其他两个例子大家就自己看看了。<br>为一个场景增加纹理的必要步骤是：</p><ol><li>用纹理坐标指定的，创建物体的顶点。</li><li>用D3DXCreateTextureFromFile函数读取一个纹理到IDirect3DTexture9接口中。</li><li>设置缩小倍数，放大倍数以及mipmap过滤器。</li><li><p>在你绘制一个物体前，用IDirect3DDevice9::SetTexture设置与物体关联的纹理。<br>我们先定义几个全局变量；一个是顶点缓存，它存储方块的顶点。另外一个是我们为方块映射的纹理：<br>IDirect3DVertexBuffer9<em> Quad = 0;<br>IDirect3DTexture9</em>      Tex  = 0;<br>Setup程序是很容易读懂的；我们用已经定义了纹理坐标的两个三角形创建一个方块。然后把文件dx5_logo.bmp读进IDirect3DTexture9接口中。接着使用SetTexture方法赋予纹理。最后设置缩小和放大过滤器进行线性过滤，我们也可以设置mipmap过滤器来进行D3DTEXF_POINT:<br>bool Setup()<br>{<br> //<br> // Create the quad vertex buffer and fill it with the<br> // quad geoemtry.<br> //</p><p> Device-&gt;CreateVertexBuffer(</p><pre><code> 6 * sizeof(Vertex),  D3DUSAGE_WRITEONLY, Vertex::FVF, D3DPOOL_MANAGED, &amp;Quad, 0);</code></pre><p> Vertex<em> v;<br> Quad-&gt;Lock(0, 0, (void*</em>)&amp;v, 0);</p><p> // quad built from two triangles, note texture coordinates:<br> v[0] = Vertex(-1.0f, -1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 0.0f, 1.0f);<br> v[1] = Vertex(-1.0f,  1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f);<br> v[2] = Vertex( 1.0f,  1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 1.0f, 0.0f);</p><p> v[3] = Vertex(-1.0f, -1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 0.0f, 1.0f);<br> v[4] = Vertex( 1.0f,  1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 1.0f, 0.0f);<br> v[5] = Vertex( 1.0f, -1.0f, 1.25f, 0.0f, 0.0f, -1.0f, 1.0f, 1.0f);</p><p> Quad-&gt;Unlock();</p><p> //<br> // Create the texture and set filters.<br> //</p><p> D3DXCreateTextureFromFile(</p><pre><code> Device, &quot;dx5_logo.bmp&quot;, &amp;Tex);</code></pre><p> Device-&gt;SetTexture(0, Tex);</p><p> Device-&gt;SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);<br> Device-&gt;SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);<br> Device-&gt;SetSamplerState(0, D3DSAMP_MIPFILTER, D3DTEXF_POINT);</p><p> //<br> // Don’t use lighting for this sample.<br> //<br> Device-&gt;SetRenderState(D3DRS_LIGHTING, false);</p><p> //<br> // Set the projection matrix.<br> //</p><p> D3DXMATRIX proj;<br> D3DXMatrixPerspectiveFovLH(</p><pre><code>     &amp;proj,     D3DX_PI * 0.5f, // 90 - degree     (float)Width / (float)Height,     1.0f,     1000.0f);</code></pre><p> Device-&gt;SetTransform(D3DTS_PROJECTION, &amp;proj);</p><p> return true;<br>}<br>我们现在可以渲染方块了，且通常已经为它赋予了纹理：<br>bool Display(float timeDelta)<br>{<br> if( Device )<br> {</p><pre><code> Device-&gt;Clear(0, 0, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xffffffff, 1.0f, 0); Device-&gt;BeginScene(); Device-&gt;SetStreamSource(0, Quad, 0, sizeof(Vertex)); Device-&gt;SetFVF(Vertex::FVF); Device-&gt;DrawPrimitive(D3DPT_TRIANGLELIST, 0, 2); Device-&gt;EndScene(); Device-&gt;Present(0, 0, 0, 0);</code></pre><p> }<br> return true;<br>}</p></li><li>7摘要(略)</li></ol><p>第七章 混合<br>(Blending)<br>　　在这一章里我们介绍一种叫做混合（blending）的技术，它允许我们混合像素，我们通常用已经光栅化的像素光栅化同一位置的像素。换句话说就是我们在图元上混合图元。这种技术允许我们完成多种特效。<br>目标</p><ul><li>弄懂怎样混合以及怎样使用它。</li><li>学习Direct3D支持的不同类型的混合方式。</li><li>弄懂alpha混合能够被用来控制图元的透明度。<br>7.1混合因素<br>　　观察图7.1，我们将一个红色的茶壶绘制在一个木质背景上。<br>　　<br>　　图7.1<br>　　假设想让茶壶有一个透明度，以便我们能够透过茶壶看见背景（如图7.2）。<br>　　<br>　　图7.2<br>　　我们怎样才能实现这个效果呢？我们只需要在木箱子上光栅化茶壶三角形，我们需要结合像素颜色，就象通过茶壶显示木箱那样来计算茶壶的像素颜色。结合像素值的意思就是用以前写过的目标像素值去估算源像素值这被叫做混合。注意混合的效果不仅仅象是玻璃透明一样。我们有很多选项来指定颜色是怎样被混合的，就象7.2部分中看到的一样。<br>　　这是很重要的，认识三角形普遍利用以前写入后缓存中的像素来与之混合来光栅化。在示例图片中，木箱图片首先被画出来且它的像素在后缓存中。我们然后绘制茶壶，以便用木箱的像素来混合茶壶的像素。因此，当使用混合时，下面的规则将被遵循：<br>　　规则：首先不使用混合绘制物体。然后根据物体离摄象机的距离使用混合对物体拣选；这是非常有效的处理，假如物体是在视图坐标中，那么你能够利用z分量简单地拣选。最后使用从后到前的顺序混合绘制物体。<br>　　下面的公式是用来混合两个像素值的：<br>　　<br>　　上面的所有变量都是一个4D颜色向量（r,g,b,a），并且符号是表示分量相乘。</li><li>OutputPixel——混合后的像素结果。</li><li>SourcePixel——通常被计算的像素，它是利用在后缓存中的像素来被混合的。</li><li>SourceBlendFactor——在[0，1]范围内的一个值。它指定源像素在混合中的百分比。</li><li>DestPixel——在后缓存中的像素。</li><li>DestBlendFactor——在[0，1]范围内的一个值。它指定目的像素在混合中的百分比。<br>　　源和目的混合要素使我们能够按照多种途径改变原始源和目的像素，允许实现不同的效果。7.2节列举了能够被使用的预先确定的值。<br>　　混合默认是被关闭的；你能够通过设置D3DRS_ALPHABLENDENABLE渲染状态为true来开启它：<br>Device-&gt;SetRenderState(D3DRS_ALPHABLENDENABLE, true);<br>7.2混合要素<br>　　通过设置不同的源和目的要素，我们能够创造很多不同的混合效果。通过实验，使用不同的组合看看它们到底能实现什么效果。你能够通过设置D3DRS_SRCBLEND和D3DRS_DESTBLEND渲染状态来分别设置源混合要素和目的混合要素。例如我们可以这样写：<br>Device-&gt;SetRenderState(D3DRS_SRCBLEND, Source);<br>Device-&gt;SetRenderState(D3DRS_DESTBLEND, Destination);<br>　　这里Source和Destination能够使用下面混合要素中的一个：</li><li>D3DBLEND_ZERO——blendFactor=(0, 0, 0, 0)</li><li>D3DBLEND_ONE——blendFactor=(1, 1, 1, 1)</li><li>D3DBLEND_SRCCOLOR——blendFactor=(rs, gs, bs, as)</li><li>D3DBLEND_INVSRCCOLOR——blendFactor=(1-rs, 1-gs, 1-bs, 1-as)</li><li>D3DBLEND_SRCALPHA——blendFactor=(as, as, as, as)</li><li>D3DBLEND_INVSRCALPHA——blendFactor=(1-as, 1-as, 1-as, 1-as)</li><li>D3DBLEND_DESTALPHA——blendFactor=(ad, ad, ad, ad)</li><li>D3DBLEND_INVDESTALPHA——blendFactor=(1-ad, 1-ad, 1-ad, 1-ad)</li><li>D3DBLEND_DESTCOLOR——blendFactor=(rd, gd, bd, ad)</li><li>D3DBLEND_INVDESTCOLOR——blendFactor=(1-rd, 1-gd, 1-bd, 1-ad)</li><li>D3DBLEND_SRCALPHASAT——blendFactor=(f, f, f, 1)  ,  f=min(as, 1 – ad)</li><li>D3DBLEND_BOTHINVSRCALPHA——这种混合模式设置源混合要素为（1-as, 1-as, 1-as, 1-as,）以及目的混合要素为（as,as,as,as）。这种混合模式仅对D3DRS_SRCBLEND有效。<br>　　源和目的混合要素的默认值分别是D3DBLEND_SRCALPHA和D3DBLEND_INVSRCALPHA。<br>7.3透明度<br>  在以前的章节中我们忽略了颜色顶点和材质中的alpha部分，那是因为当时它并不是必须的。现在它首先被用在混合中。<br>  Alpha部分主要是用来指定像素的透明等级。我们为每个像素的alpha部分保留8位，alpha的有效值在[0,255]范围内，[0,255]代表不透明度[0%,100%]。因此，像素的alpha为0时，表示完全透明，像素的alpha为128时，表示50%透明，像素的alpha为255时，表示完全不透明。<br>  为了让alpha部分描述像素的透明等级，我们必须设置源混合要素为D3DBLEND_SRCALPHA以及目的混合要素为D3DBLEND_INVSRCALPHA。这些值碰巧也是被默认设置的。<br>7.3.1Alpha通道<br>　　代替使用Alpha部分来计算遮影，我们能够从纹理的alpha通道中得到alpha信息。Alpha通道是额外的设置位，用它来保存每一个点的alpha值。当一个纹理被映射到一个图元上时，在alpha通道中的alpha信息也被映射，并且它们利用alpha信息为每个像素赋予纹理。图7.3显示了一个带8位alpha通道的图片。<br>　　<br>　　图7.3<br>　　图7.4显示的是一个利用alpha通道指定透明度来渲染的一个纹理方块。<br>　　<br>　　图7.4<br>7.3.2指定Alpha资源<br>　　默认情况下，假如设置一个有alpha通道的纹理，alpha值从在alpha通道中获得。假如没有alpha通道，那么alpha值是通过顶点颜色获得。然而，你能够通过下面的渲染状态来指定使用哪一个资源：<br>// compute alpha from diffuse colors during shading<br>Device-&gt;SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);<br>Device-&gt;SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);<br>// take alpha from alpha channel<br>Device-&gt;SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);<br>Device-&gt;SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);<br>7.4使用DirectX纹理工具创建Alpha通道<br>  绝大多数普通图象文件格式没有存储alpha信息。在这一部分我们给你演示怎样使用DirectX纹理工具来创建一个带alpha通道的DDS文件。DDS文件是一个为DirectX应用程序和纹理设置的图象格式。DDS文件能够利用D3DXCreateTextureFromFile被读进纹理中，就象bmp和jpg文件一样。DirectX纹理工具被放在你的DXSDK目录下的\Bin\DXUtils文件夹下（我是放在C:\Program Files\Microsoft DirectX 9.0 SDK (February 2005)\Utilities\Bin\x86下的，文件名是DxTex.exe）。<br>  打开DirectX纹理工具，并且把本章中示例文件夹下的crate.jpg文件用工具打开。木箱被自动的按照24位RGB纹理被读取。它包含8位红色，8位绿色，以及8位蓝色。我们需要将该纹理增加为32位ARGB纹理，增加的是额外的8位alpha通道。从菜单中选择Format，选择Change Surface Format。一个象图7.5的对话框将被弹出。选择A8R8G8B8格式点击OK。</li></ul><p>图7.5<br>    它创建了一个32位颜色深度的图象，它的每个象素都有8位alpha通道，8位红色，8位绿色，8位蓝色。我们下一步是向alpha通道中写入数据。我们将图7.3中的8位灰色图片信息写进alpha通道中。选择菜单中的File，选择Open Onto Alpha Channel Of This Texture。一个对话框将弹出让你选择包含你想要写入alpha通道中数据信息的图片。选择alphachannel.bmp文件。图7.6显示的是程序已经插入了alpha通道数据。</p><p>图7.6<br>    现在用你选择的文件名存储纹理；我们使用cratewalpha.dds文件名。<br>7.5实例程序：透明度<br>    这个实例程序是在一个木箱背景上绘制一个透明的茶壶，就象图7.2所显示的一样。在这个例子中alpha值是从材质中得到。应用程序允许我们通过按A或S键来增加/减少alpha的值。<br>    使用混合的必要步骤是：</p><ol><li>设置混合要素D3DRS_SRCBLEND 和 D3DRS_DESTBLEND。</li><li>假如你使用alpha部分，指定资源（材质或alpha通道）。</li><li>允许alpha混合渲染状态。<br>　　对于这个例子，我们定义下面的全局变量：<br>ID3DXMesh* Teapot = 0; // the teapot<br>D3DMATERIAL9 TeapotMtrl; // the teapot’s material</li></ol><p>IDirect3DVertexBuffer9<em> BkGndQuad = 0; // background quad - crate<br>IDirect3DTexture9</em> BkGndTex = 0; // crate texture<br>D3DMATERIAL9 BkGndMtrl; // background material<br>　　Setup方法设置很多东西；我们省略了很多与本章无关的代码。关心混合，Setup方法指定alpha值的获取资源。在这个例子中，我们通过材质指定alpha值。注意我们设置茶壶的材质alpha部分为0.5，也就是说茶壶将按照50%的透明度被渲染。我们在这里也要设置混合要素。要注意的是在这个方法中我们不能将alpha混合设置为启用。理由是alpha混合要进行额外的处理并且应该仅在需要用时才被使用。举例，在这个例子中只有茶壶需要用允许alpha混合来被渲染——而方块不需要。因此，我们在Display函数中启用alpha混合。<br>bool Setup()<br>{<br>    TeapotMtrl = d3d::RED_MTRL;<br>    TeapotMtrl.Diffuse.a = 0.5f; // set alpha to 50% opacity<br>    BkGndMtrl = d3d::WHITE_MTRL;</p><pre><code>D3DXCreateTeapot(Device, &amp;Teapot, 0);...// Create background quad snipped    ...// Light and texture setup snipped// use alpha in material&#39;s diffuse component for alphaDevice-&gt;SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);Device-&gt;SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);// set blending factors so that alpha// component determines transparencyDevice-&gt;SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);Device-&gt;SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);...// view/projection matrix setup snippedreturn true;</code></pre><p>}<br>　　在Display函数中，我们检测假如A或S键被按下那么就通过增加或减少材质的alpha值来反馈。注意这个方法要保证alpha值不会超出[0,1]的范围。我们然后渲染背景。最后，我们启用alpha混合，利用alpha混合来渲染茶壶，关闭alpha混合。<br>bool Display(float timeDelta)<br>{<br>    if( Device )<br>    {<br>        //<br>        // Update<br>        //<br>        // increase/decrease alpha via keyboard input<br>        if( ::GetAsyncKeyState(‘A’) &amp; 0x8000f )<br>            TeapotMtrl.Diffuse.a += 0.01f;<br>        if( ::GetAsyncKeyState(‘S’) &amp; 0x8000f )<br>            TeapotMtrl.Diffuse.a -= 0.01f;<br>        // force alpha to [0, 1] interval<br>        if(TeapotMtrl.Diffuse.a &gt; 1.0f)<br>            TeapotMtrl.Diffuse.a = 1.0f;<br>        if(TeapotMtrl.Diffuse.a &lt; 0.0f)<br>            TeapotMtrl.Diffuse.a = 0.0f;<br>        //<br>        // Render<br>        //<br>        Device-&gt;Clear(0, 0, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,<br>                        0xffffffff, 1.0f, 0);<br>        Device-&gt;BeginScene();</p><pre><code>    // Draw the background    D3DXMATRIX W;    D3DXMatrixIdentity(&amp;W);    Device-&gt;SetTransform(D3DTS_WORLD, &amp;W);    Device-&gt;SetFVF(Vertex::FVF);    Device-&gt;SetStreamSource(0, BkGndQuad, 0, sizeof(Vertex));    Device-&gt;SetMaterial(&amp;BkGndMtrl);    Device-&gt;SetTexture(0, BkGndTex);    Device-&gt;DrawPrimitive(D3DPT_TRIANGLELIST, 0, 2);    // Draw the teapot    Device-&gt;SetRenderState(D3DRS_ALPHABLENDENABLE, true);    D3DXMatrixScaling(&amp;W, 1.5f, 1.5f, 1.5f);    Device-&gt;SetTransform(D3DTS_WORLD, &amp;W);    Device-&gt;SetMaterial(&amp;TeapotMtrl);    Device-&gt;SetTexture(0, 0);    Teapot-&gt;DrawSubset(0);    Device-&gt;SetRenderState(D3DRS_ALPHABLENDENABLE, false);    Device-&gt;EndScene();    Device-&gt;Present(0, 0, 0, 0);}return true;</code></pre><p>}<br>　　注意：在本章中有另一个使用纹理通道来演示alpha混合的例子texAlpha。与上边的代码不同之处仅仅在于得到alpha值是从纹理而不是从材质。<br>// use alpha channel in texture for alpha<br>Device-&gt;SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);<br>Device-&gt;SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);<br>    这个应用程序读取的是一个在7.4节中用DX Tex Tool工具创建的带有alpha通道的DDS文件。<br>7.6摘要(略)</p><p>第八章 模版<br>(Stenciling)<br>    这一章将带我们学习模版缓存，同时这也将结束第二部分的学习。模版缓存是一个远离屏幕的缓存，我们能够用它来完成一些特效。模版缓存与后缓存和深度缓存有相同的定义，因此在模版缓存中的ijth像素与后缓存和深度缓存中的ijth像素是相协调的。就象名字所说，模版缓存就象一个模版它允许我们印刷渲染后缓存的某个部分。<br>    举例，当要实现一个镜子时，我们只需要简单地反射一个物体细节到镜子平面上；然而，我们仅仅想只绘制镜子里的反射结果。我们能用模版缓存来印制渲染它。图8.1清楚的显示了这一点。</p><p>图8.1<br>模版缓存是Direct3D中的一小部分，它是通过一个简单的表面而被约束的。就象混合，这个简单的表面提供了可变的强大的设置能力。有效地学习使用模版缓存最好的方法是通过学习实际的应用程序。一旦你学懂了一点应用程序中的模版缓存，你将会得到一个更好的用于你自己需要特效的主意。<br>正因为这个原因，这一章我们特别安排学习两个使用模版缓存的应用程序。<br>目标</p><ul><li>理解模版缓存是怎样工作的，怎样创建一个模版缓存以及怎样控制它。</li><li>学习怎样实现一个镜面效果，使用模版缓存来防止绘制反射到不在镜子表面上的物体。</li><li>利用模版缓存怎样渲染阴影和防止“双倍混合”。<br>8.1使用模版缓存<br>　　为了使用模版缓存，我们在初始化Direct3D时必须首先请求一个，然后必须启用它。我们在8.1.1中讲述怎样请求一个模版缓存。为了启用模版缓存，我们必须设置D3DRS_STENCILENABLE渲染状态并且指定它为true（关闭它即可指定为false）。下面的代码是启用和关闭模版缓存的代码：<br>Device-&gt;SetRenderState(D3DRS_STENCILENABLE, true);<br>… // do stencil work<br>Device-&gt;SetRenderState(D3DRS_STENCILENABLE, false);<br>我们可以使用IDirect3DDevice9::Clear方法来清除模版缓存并让其拥有默认值。回忆一下，同样的方法被用在清除后缓存和深度缓存中。<br>Device-&gt;Clear(0, 0,<br>  D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL,<br>  0xff000000, 1.0f, 0 );<br>注意我们已经添加了D3DCLEAR_STENCIL到第三个参数中，它表示我们想把模版缓存和目标（后缓存）以及深度缓存一起清除。有6种值可以用来指定清除后的模版缓存；在这个例子中我们将它清除为0。<br>8.1.1请求一个模版缓存<br>　　在我们创建深度缓存的同时一个模版缓存能够被创建。当指定深度缓存格式的时候，我们同时指定模版缓存的格式。这样，模版缓存和深度缓存分享同一个离屏表面缓存，但是每个像素被指定到各自缓存内存片段中。下面列出了3种深度/模版缓存的格式：</li><li>D3DFMT_D24S8—这种格式是说创建一个32位深度/模版缓存，其中24位为深度缓存，8位为模版缓存。</li><li>D3DFMT_D24X4S4—这种格式是说创建一个32位深度/模版缓存，其中24位为深度缓存，4位为模版缓存，还有4位留着不用。</li><li>D3DFMT_D15S1—这种格式是说创建一个16位深度/模版缓存，其中15位为深度缓存，1位为模版缓存。<br>注意，还有一些格式没有分配任何位给模版缓存。例如，D3DFMT_D32格式是说只创建一个32位深度缓存。<br>  同样，不同硬件对模版缓存的支持也是不同的。例如有些显卡就不支持8位模版缓存。<br>8.1.2模版测试<br>  如前所述，我们能够使用模版缓存来阻止渲染后缓存中的某些部分。阻止特殊像素被写是通过模版测试（stencil test）来决定的，这是通过下面的表达式来完成的：<br>(ref &amp; mask) ComparisonOperation (value &amp; mask)<br>模版测试是对每个像素进行的，假设模版是被允许。将有两个操作：</li><li>左手边操作数（LHS=ref&amp;mask）</li><li>右手边操作数（RHS=value&amp;mask）<br>模版测试比较LHS和RHS，通过比较运算来指定。全部的运算都得到一个布尔值（true/false）。假如测试的结果是true，那么我们把像素写入后缓存。假如测试的结果是false,我们就阻止像素被写入后缓存。当然，如果像素不能被写入后缓存，那么它也不能被写入深度缓存。<br>8.1.3控制模版测试<br>  Direct3D允许我们控制变量用于模版测试。换句话说，我们可以指定参考值（stencil reference）和掩码(mask value)，以便进行比较运算。虽然我们不能明确地设定模版值（stencil value）,但是我们能够控制写入模版缓存的值。<br>8.1.3.1模版参考值（Reference Value）<br>　　模版参考值ref的默认值为0，但是我们能够通过设置D3DRS_STENCILREF渲染状态来改变它。例如，下面的代码就是设置模版参考值为1：<br>Device-&gt;SetRenderState(D3DRS_STENCILREF, 0x1);<br>注意我们往往使用16进制，因为这让它看起来比整数更容易象一个位队列，并且当我们做位操作时这样看起来更有用，比如相加。<br>8.1.3.2模版掩码<br>　　模版掩码值mask是被用来掩饰（隐藏）在ref和value变量中的位。它的默认值是0xffffffff，也就是没有掩饰任何位。我们能够通过设置D3DRS_STENCILMASK渲染状态来改变它。下面的例子就是掩饰高16位：<br>Device-&gt;SetRenderState(D3DRS_STENCILMASK, 0x0000ffff);<br>8.1.3.3模版值（Stencil Value）<br>　　作为以前的规定，在模版缓存中我们进行模版测试的当前像素。例如，假如我们对ijth像素进行模版测试，那么该值将被写入ijth模版缓存。我们不能明确地设置个别模版值，但是可以清除模版缓存。我们能够使用模版渲染状态来控制将什么写入模版缓存。<br>8.1.3.4比较运算<br>　　我们能够通过设置D3DRS_STENCILFUNC渲染状态来设置比较运算。这个比较运算能够被D3DCMPFUNC的任何成员类型列举：<br>typedef enum _D3DCMPFUNC {<br>  D3DCMP_NEVER = 1,<br>  D3DCMP_LESS = 2,<br>  D3DCMP_EQUAL = 3,<br>  D3DCMP_LESSEQUAL = 4,<br>  D3DCMP_GREATER = 5,<br>  D3DCMP_NOTEQUAL = 6,<br>  D3DCMP_GREATEREQUAL = 7,<br>  D3DCMP_ALWAYS = 8,<br>  D3DCMP_FORCE_DWORD = 0x7fffffff<br>} D3DCMPFUNC;</li><li>D3DCMP_NEVER——模版测试永不成功。</li><li>D3DCMP_LESS——假如LHS &lt; RHS，那么模版测试成功。</li><li>D3DCMP_EQUAL——假如LHS = RHS，那么模版测试成功。</li><li>D3DCMP_LESSEQUAL——假如LHS &lt;= RHS，那么模版测试成功。</li><li>D3DCMP_GREATER——假如LHS &gt; RHS，那么模版测试成功。</li><li>D3DCMP_NOTEQUAL——假如LHS &lt;&gt; RHS，那么模版测试成功。</li><li>D3DCMP_GREATEREQUAL——假如LHS &gt;= RHS，那么模版测试成功。</li><li>D3DCMP_ALWAYS——模版测试总是成功。<br>8.1.3更新模版缓存<br>除了决定是否写或阻止一个特殊像素被写入后缓存以外，我们能够定义模版缓存基于三种可能的案例怎样被更新：</li><li>对于ijth像素模版测试失败。我们能够定义怎样更新在模版缓存中的ijth，通过设置D3DRS_STENCILFAIL渲染状态来适应这种情形：<br>Device-&gt;SetRenderState(D3DRS_STENCILFAIL, StencilOperation);</li><li>对于ijth像素深度测试失败。我们能够定义怎样更新在模版缓存中的ijth，通过设置D3DRS_STENCILZFAIL渲染状态来适应这种情形：<br>Device-&gt;SetRenderState(D3DRS_STENCILZFAIL, StencilOperation);</li><li>对于ijth像素模版测试和深度测试都成功。我们能够定义怎样更新在模版缓存中的ijth，通过设置D3DRS_STENCILPASS渲染状态来适应这种情形：<br>Device-&gt;SetRenderState(D3DRS_STENCILPASS, StencilOperation);<br>其中StencilOperation能够是下面预先定义的常数：</li><li>D3DSTENCILOP_KEEP——指定不改变模版缓存。</li><li>D3DSTENCILOP_ZERO——指定设置模版缓存入口为0。</li><li>D3DSTENCILOP_REPLACE——指定用模版参考值（reference value）来替换模版缓存入口。</li><li>D3DSTENCILOP_INCRSAT——指定增加模版缓存入口。假如增加的值超过了允许的最大值，我们就设置它为最大值。</li><li>D3DSTENCILOP_DECRSAT——指定减少模版缓存入口。假如减少后的值小于了0，我们就设置它0。</li><li>D3DSTENCILOP_INVERT——指定按位取反模版缓存入口。</li><li>D3DSTENCILOP_INCR——指定增加模版缓存入口。假如增加的值超过了允许的最大值，我们就设置它为0。</li><li>D3DSTENCILOP_DECR——指定减少模版缓存入口。假如减少后的值小于了0，我们就设置它为允许的最大值。<br>8.1.4模版写掩码<br>　　除了已经提及的模版渲染状态之外，我们能够设置一个写掩码（write mask）它将掩饰我们写进模版缓存的任何值的位。我们能够通过D3DRS_STENCILWRITEMASK渲染状态来设置写掩码。它的默认值是0xffffffff。下面的例子是掩饰高16位：<br>Device-&gt;SetRenderState(D3DRS_STENCILWRITEMASK, 0x0000ffff);<br>8.2实例程序：镜子<br>　　在自然界中的很多表面象镜子一样允许我们通过它的反射来看物体。这一部分讲了我们怎样用3D应用程序来模拟镜子。注意为了简单我们只模拟平面镜。举点例子，一辆擦亮的小汽车能够反射；然而，小车的车身是光滑的，圆的，不是一个平面。我们渲染反射是这些，象光滑的大理石地板、挂在墙上的镜子。换句话说就是在一个平面的镜子。<br>　　实现镜子的程序需要我们解决两个问题。第一，我们必须学习沿着一个面怎样反射一个物体以便能够正确地绘制反射结果。第二，我们必须只能在一个镜子范围内显示反射结果。即，我们必须掩饰一个表面作为一个镜子，且只渲染那些在镜子里物体。图8.1就是说的这个内容。<br>　　第一个问题只需要用一些几何向量就可以简单解决。我们能够利用模版缓存解决第二个问题。下两小节分别介绍怎样解决这两个问题。第三小节把它们柔和在一起并且介绍一下本章的第一个应用程序实例代码——镜子。<br>8.2.1反射数学<br>　　我们现在演示怎样计算点V=（Vx, Vy, Vz）被平面n<em>p+d=0反射的点V’=（V’x, V’y, V’z）。图8.2贯穿整个讨论。<br>　　<br>　　图8.2<br>　　根据Part I中的“平面”部分，我们能够知道q=v-kn,这里k是有符号的从v到平面的距离。下面是v相对与平面（n，d）的反射推导：<br>　　<br>　　我们用下面的矩阵来实现从v到v’的转换：<br>　　<br>　　在D3DX库中用下面的函数来创建反射矩阵R。<br>D3DXMATRIX </em>D3DXMatrixReflect(<br>  D3DXMATRIX <em>pOut, // The resulting reflection matrix.<br>  CONST D3DXPLANE </em>pPlane // The plane to reflect about.<br>);<br>一旦我们说到反射变换的话题，就让我们看看其他3种特殊的反射变换。它们是关于三个坐标平面的反射—yz平面，xz平面，和xy平面—它们分别通过下面三个矩阵来表现：</li></ul><p>通过yz平面反射一个点，我们只需要简单的将x分量取反就可以了。同样的，通过xz平面反射一个点，我们只需要简单的将y分量取反。通过xy平面反射一个点，我们只需要简单的将z分量取反。这种反射是非常容易理解的。<br>8.2.2镜面实现流程<br>当实现一个镜面，一个物体假如在一面镜子前那么它就会被反射。然而，我们不想测试空间假如一个物体在一面镜子前，要做它是非常复杂的。因此，为了简化事情，我们总是反射物体并且无限制地渲染它。但是这样就有一个象本章开头的图8.1一样的问题。即，物体反射被渲染到了没有镜子的表面。我们能够用模版缓存来解决这个问题，因为模版缓存允许我们阻止渲染在后缓存中的特定区域。因此，我们使用模版缓存来阻止渲染被反射的不在镜子里的茶壶。下面的步骤简要的说明了怎样实现：<br>1、 正常渲染所有的场景——地板，墙，镜子和茶壶——不包含反射的茶壶。注意这一步没有修改模版缓存。<br>2、 清除模版缓存为0。图8.3显示了后缓存和模版缓存。</p><p>图8.3<br>3、 渲染只有镜子部分的图元到模版缓存中。设置模版测试总是成功，并且假如测试成功就指定模版缓存入口为1。我们仅仅渲染镜子，在模版缓存中的所有像素都将为0，除了镜子部分为1以外。图8.4显示了更新以后的模版缓存。也就是说，我们在模版缓存中对镜子像素做了标记。</p><p>图8.4<br>4、 现在我们渲染被反射的茶壶到后缓存和模版缓存中。但是假如模版测试通过，我们就只渲染后缓存。假如在模版缓存中的值为1，那么我们设置模版测试通过。这样，茶壶就仅仅被渲染到模版缓存为1的地方了。因为只有镜子对应的模版缓存值为1，所以反射的茶壶就只能被渲染到镜子里。<br>8.2.3代码和解释<br>　　这个例子的相关代码在RenderMirror函数中，它首先渲染镜子图元到模版缓存，然后渲染那些能被渲染到镜子里的反射茶壶。我们现在一行一行的分析RenderMirror函数的代码，并解释为什么要这么做。<br>　　假如你想使用8.2.2部分的步骤实现代码，注意我们从第3步开始，因为对模版缓存来说1和2步已经没有什么事做了。同样我们通过这个解释来讨论通过镜子渲染的信息。<br>　　注意我们将分成几个部分来讨论它。<br>8.2.3.1第一部分<br>　　我们通过允许模版缓存和设置渲染状态来开始：<br>void RenderMirror()<br>{<br>    Device-&gt;SetRenderState(D3DRS_STENCILENABLE, true);<br>    Device-&gt;SetRenderState(D3DRS_STENCILFUNC, D3DCMP_ALWAYS);<br>    Device-&gt;SetRenderState(D3DRS_STENCILREF, 0x1);<br>    Device-&gt;SetRenderState(D3DRS_STENCILMASK, 0xffffffff);<br>    Device-&gt;SetRenderState(D3DRS_STENCILWRITEMASK,0xffffffff);<br>    Device-&gt;SetRenderState(D3DRS_STENCILZFAIL, D3DSTENCILOP_KEEP);<br>    Device-&gt;SetRenderState(D3DRS_STENCILFAIL, D3DSTENCILOP_KEEP);<br>     Device-&gt;SetRenderState(D3DRS_STENCILPASS, D3DSTENCILOP_REPLACE);<br>　　这是非常容易理解的。我们设置模版比较运算为D3DCMP_ALWAYS,这就是说让所有模版测试都通过。<br>　　假如深度测试失败了，我们指定D3DSTENCILOP_KEEP，它表明不更新模版缓存入口。即，我们保存当前值。这样做的原因是假如深度测试失败了，那么就意味着像素被“模糊”了。我们不想渲染被“模糊”的反射像素。<br>　　同样假如模版测试失败了，我们也指定D3DSTENCILOP_KEEP。但是在这里这样做不是必须的，因为我们指定的是D3DCMP_ALWAYS，当然这样的测试也就永远不会失败。然而，我们只改变比较运算的一位，那么设置模版失败渲染状态是必须的。我们现在就这样做。<br>　　假如深度测试和模版测试都通过了，我们就指定D3DSTENCILOP_REPLACE，更新模版缓存入口，设置模版参考值为0x1。<br>8.2.3.2第二部分<br>　　这下一步阻止渲染镜子代码，除了模版缓存。我们通过设置D3DRS_ZWRITEENABLE并指定为false来阻止写深度缓存。我们能够防止更新后缓存，混合和设置源混合要素为D3DBLEND_ZERO目的混合要素为D3DBLEND_ONE。将这些混合要素代入混合等式，我们得到后缓存是不会改变的：</p><pre><code>// disable writes to the depth and back buffersDevice-&gt;SetRenderState(D3DRS_ZWRITEENABLE, false);Device-&gt;SetRenderState(D3DRS_ALPHABLENDENABLE, true);Device-&gt;SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ZERO);Device-&gt;SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE);// draw the mirror to the stencil bufferDevice-&gt;SetStreamSource(0, VB, 0, sizeof(Vertex));Device-&gt;SetFVF(Vertex::FVF);Device-&gt;SetMaterial(&amp;MirrorMtrl);Device-&gt;SetTexture(0, MirrorTex);D3DXMATRIX I;D3DXMatrixIdentity(&amp;I);Device-&gt;SetTransform(D3DTS_WORLD, &amp;I);Device-&gt;DrawPrimitive(D3DPT_TRIANGLELIST, 18, 2);// re-enable depth writes Device-&gt;SetRenderState(D3DRS_ZWRITEENABLE, true);</code></pre><p>8.2.3.3第三部分<br>　　在模版缓存中，符合镜子可视像素的为0x1，因此对已经渲染的镜子区域做记号。我们现在准备渲染被反射的茶壶。回忆一下，我们仅仅想渲染镜子范围内的反射像素。我们现在可以很容易的做到了，因为在模版缓存中这些像素已经被做了记号。<br>　　我们设置下面的渲染状态：<br>    Device-&gt;SetRenderState(D3DRS_STENCILFUNC, D3DCMP_EQUAL);<br>     Device-&gt;SetRenderState(D3DRS_STENCILPASS, D3DSTENCILOP_KEEP);<br>　　用一个新的比较运算设置，我们进行下面的模版测试：<br>    (ref &amp; mask == (value &amp; mask)<br>    (0x1 &amp; 0xffffffff) == (value &amp; 0xffffffff)<br>     (0x1)== (value &amp; 0xffffffff)<br>　　这说明了只有当value=0x1时模版测试才成功。因为在模版缓存中只有镜子相应位置的值才是0x1，若我们渲染这些地方那么测试将会成功。因此，被反射的茶壶只会在镜子里绘制而不会在镜子以外的表面上绘制。<br>　　注意我们已经将渲染状态由D3DRS_STENCILPASS变为了D3DSTENCILOP_KEEP，简单的说就是假如测试通过那么就保存模版缓存的值。因此，在下一步的渲染中，我们不改变模版缓存的值。我们仅仅使用模版缓存来对镜子相应位置的像素做标记。<br>8.2.3.4第四部分<br>　　RenderMirror函数的下一部分就是计算在场景中反射位置的矩阵：<br>    // position reflection<br>    D3DXMATRIX W, T, R;<br>    D3DXPLANE plane(0.0f, 0.0f, 1.0f, 0.0f); // xy plane<br>    D3DXMatrixReflect(&amp;R, &amp;plane);<br>    D3DXMatrixTranslation(&amp;T,<br>        TeapotPosition.x,<br>        TeapotPosition.y,<br>        TeapotPosition.z);<br>     W = T * R;<br>　　注意我们首先确定没有反射的茶壶位置，然后就通过xy平面来反射。这种变换规则是通过矩阵相乘来指定的。<br>8.2.3.5第五部分<br>　　我们已经为渲染反射茶壶做好了准备。然而，假如我们现在就渲染它，它是不会被显示的。为什么呢？因为被反射的茶壶的深度比镜子的深度大，因此镜子的图元将把被反射茶壶的图元弄模糊。为了避免这种情况，我们清除深度缓存：<br>     Device-&gt;Clear(0, 0, D3DCLEAR_ZBUFFER, 0, 1.0f, 0);<br>　　并不是所有问题都解决了。假如我们简单的清除深度缓存，被反射的茶壶会被绘制到镜子的前面，物体看起来就不对了。我们想做的是清除深度缓存并且要混合被反射的茶壶和镜子。这样，被反射的茶壶看起来就象在镜子里了。我们能够通过下面的混合等式来混合被反射的茶壶和镜子：</p><p>　　因为原像素（sourcePixel）来自被反射的茶壶，目的像素（DestPixel）来自镜子，我们能够通过这个等式明白它们是怎么被混合到一起的。我们有如下的代码：<br>    Device-&gt;SetRenderState(D3DRS_SRCBLEND, D3DBLEND_DESTCOLOR);<br>     Device-&gt;SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ZERO);<br>　　最后，我们准备绘制被反射的茶壶：<br>    Device-&gt;SetTransform(D3DTS_WORLD, &amp;W);<br>    Device-&gt;SetMaterial(&amp;TeapotMtrl);<br>    Device-&gt;SetTexture(0, 0);<br>    Device-&gt;SetRenderState(D3DRS_CULLMODE, D3DCULL_CW);<br>     Teapot-&gt;DrawSubset(0);<br>　　回顾一下8.2.3.4部分的W，它能够正确的将被反射的茶壶变换到场景中恰当的位置。同样，我们也要改变背面拣选模式。必须这样做的原因是当一个物体被反射以后，它的正面和背面将会被交换。因此为了改变这种情况，我们必须改变背面拣选模式。<br>    Device-&gt;SetRenderState(D3DRS_ALPHABLENDENABLE, false);<br>    Device-&gt;SetRenderState( D3DRS_STENCILENABLE, false);<br>    Device-&gt;SetRenderState(D3DRS_CULLMODE, D3DCULL_CCW);<br>} // end RenderMirror()<br>8.3实例程序：平面阴影<br>在场景中被灯光照射的地方会产生阴影，这将使场景变的更真实。在这一部分我们将演示怎样实现平面阴影，即在平面上的阴影（如图8.5）。</p><p>图8.5<br>注意这种阴影是“快砍”，虽然它们增强了场景效果，但是这并不是现实中的阴影。阴影值是一个高级的概念，要深入研究它已经超出了本书的范围。然而，特别值得提及的是在DirectX SDK中有一个示例程序演示了阴影值。<br>　　为了实现平面阴影，我们首先必须找到物体投射到平面上的阴影并进行几何建模以便我们能够渲染它。用一些3D数学就能很容易的实现它。我们然后用50%透明度的黑色材质来渲染描述阴影的多边形。渲染阴影时可能出现“双倍混合”，我们将用一小部分进行解释。我们使用模版缓存来防止双倍混合发生。<br>8.3.1平行光阴影</p><p>图8.6<br>图8.6显示了物体在平行光照射下得到的阴影。光线是从平行光源放射出的，它的方向是L,通过顶点p得到r（t） = p + tL。光线r（t）和平面n * p + d = 0 相交得到 s 。交点s 通过射线和平面相交测试是非常容易得到的：<br>把r(t)带进平面等式<br>求解t</p><p>那么：</p><p>8.3.2点光源阴影</p><p>图8.7<br>图8.7显示了物体在点光源照射下得到的阴影。点光源的位置是L。光线通过顶点p，则得到 r(t) = p + t ( p – L )。光线r（t）和平面n <em> p + d = 0 相交得到 s 。用8.3.1同样的方法我们可以得到s。<br>注意：在点光源和平行光中的L是不同的。对于点光源，我们用L来表示点光源的位置。而对于平行光，我们则是用L来表示平行光的照射方向。<br>8.3.3阴影矩阵<br>　　注意图8.6中所示的平行光，影子本质上是把物体按照灯光照射方向平行地投射到平面n</em>p+d=0之上。同样的，图8.7中所示的点光源，影子本质上是把物体按照透视画法从光源投射到平面n<em>p+d=0之上。<br>　　我们能够使用一个矩阵来表示从一个顶点p变换到平面n</em>p=d=0上的s的变化。而且，我们能够用同一个矩阵来表现正交投影和透视投影。<br>　　我们用一个4D向量（nx, ny, nz, d）来表示将要用于投射阴影平面的平面等式中的各个系数。让4D向量L=（Lx, Ly, Lz, Lw）来表示平行光的照射方向或点光源的位置。我们用w来区别：<br>１． 假如w＝０，那么L表示平行光的照射方向。<br>２． 假如w＝1 ，那么L表示点光源的位置。<br>规格化的平面是非常不逊的，我们让k＝（nx, ny, nz, d）*（Lx, Ly, Lz, Lw）= nxLx+nyLy+nzLz+dLw<br>那么我们就可得到表示点p到点s的变换矩阵，即阴影矩阵：</p><p>因为在其他地方已经被推导出来了，对于我们来说推导它并没有重大的意义，在这里我们就不再演示推导怎样得到这个矩阵的过程了。但是对与感兴趣的读者可以自己到网上查找相应的信息。<br>　　　　在D3DX库中已经给我们提供了一个建立阴影矩阵的函数。其中当w＝０时表示平行光，当w＝１时表示点光源：<br>D3DXMATRIX <em>D3DXMatrixShadow(<br>    D3DXMATRIX </em>pOut,<br>    CONST D3DXVECTOR4 <em>pLight, // L<br>    CONST D3DXPLANE </em>pPlane // plane to cast shadow onto<br>);<br>8.3.4用模版缓存防止双倍混合<br>　　几何学上，当我们将一个物体投影到一个平面上时，很可能会有两个或者更多的投影三角形被重叠到一起。若我们就这样渲染，那么有重叠三角形的地方就会被多次混合以至这些地方将会变得更黑。图8.8就是这种情况。<br>　　<br>　　图8.8<br>　　我们能够使用模版缓存来解决这个问题。我们设置模版测试为允许像素第一次被渲染。即，当把影子像素渲染到后缓存时，我们同时在模版缓存中做好标记。然后，如果试图把像素向一个已经渲染过的地方写，那么模版测试将会失败。这样，我们就防止了重复写像素也就是防止了双倍混合的发生。<br>8.3.5代码和解释<br>　　下面的代码就是讲解影子例子。本例的相关代码都在RenderShadow函数中。注意我们假设模版缓存都已经被清除为０了。<br>　　首先设置模版渲染状态。将模版比较运算设为D3DCMP_EQUAL且将D3DRS_STENCILREF渲染状态设置为0x0，因此假如在模版缓存中相应的值为0x0，那么就指定渲染阴影到后缓存中。<br>　　因为模版缓存是被清除为0x0的，所以我们第一次将影子像素写入的时候总是正确的；不过因为我们设置D3DRS_STENCILPASS为D3DSTENCILOP_INCR,假如你试图将已经写过的像素写入的话，这个测试将会失败。在第一次写入的时候模版像素已经被写成了0x1，因此假如你再一次写入，模版测试将会失败。因此，我们避免了重复写像素，也避免了双倍混合。<br>void RenderShadow()<br>{<br>    Device-&gt;SetRenderState(D3DRS_STENCILENABLE, true);<br>    Device-&gt;SetRenderState(D3DRS_STENCILFUNC, D3DCMP_EQUAL);<br>    Device-&gt;SetRenderState(D3DRS_STENCILREF, 0x0);<br>    Device-&gt;SetRenderState(D3DRS_STENCILMASK, 0xffffffff);<br>    Device-&gt;SetRenderState(D3DRS_STENCILWRITEMASK, 0xffffffff);<br>    Device-&gt;SetRenderState(D3DRS_STENCILZFAIL, D3DSTENCILOP_KEEP);<br>    Device-&gt;SetRenderState(D3DRS_STENCILFAIL, D3DSTENCILOP_KEEP);<br>　　Device-&gt;SetRenderState(D3DRS_STENCILPASS, D3DSTENCILOP_INCR);<br>　　下一步，我们计算阴影变换并将它放置到场景中适当的位置。<br>    // compute the transformation to flatten the teapot into a shadow.<br>    D3DXVECTOR4 lightDirection(0.707f, -0.707f, 0.707f, 0.0f);<br>    D3DXPLANE groundPlane(0.0f, -1.0f, 0.0f, 0.0f);<br>    D3DXMATRIX S;<br>    D3DXMatrixShadow(&amp;S, &amp;lightDirection, &amp;groundPlane);<br>    D3DXMATRIX T;<br>    D3DXMatrixTranslation(&amp;T, TeapotPosition.x, TeapotPosition.y,<br>    TeapotPosition.z);<br>    D3DXMATRIX W = T * S;<br>     Device-&gt;SetTransform(D3DTS_WORLD, &amp;W);<br>　　最后，我们设置一个50%透明度的黑色材质，关闭深度测试，渲染阴影，然后开启深度缓存同时关闭alpha混合和模版测试。我们关闭深度缓存来防止z-fighting，它是当两个不同的表面在深度缓存中有同样的深度值时出现的虚拟物体；深度缓存不知道那一个是在前面，此时就会产生讨厌的闪动。因为阴影和地板是在同一个平面上，z-fighting很可能就会出现。通过先渲染地板然后用深度测试屏蔽阴影，这样我们就能够保证阴影将绘制在地面只之上。<br>    Device-&gt;SetRenderState(D3DRS_ALPHABLENDENABLE, true);<br>    Device-&gt;SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);<br>    Device-&gt;SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);<br>    D3DMATERIAL9 mtrl = d3d::InitMtrl(d3d::BLACK, d3d::BLACK,<br>    d3d::BLACK, d3d::BLACK, 0.0f);<br>    mtrl.Diffuse.a = 0.5f; // 50% transparency.<br>    // Disable depth buffer so that z-fighting doesn’t occur when we<br>    // render the shadow on top of the floor.<br>    Device-&gt;SetRenderState(D3DRS_ZENABLE, false);<br>    Device-&gt;SetMaterial(&amp;mtrl);<br>    Device-&gt;SetTexture(0, 0);<br>    Teapot-&gt;DrawSubset(0);<br>    Device-&gt;SetRenderState(D3DRS_ZENABLE, true);<br>    Device-&gt;SetRenderState(D3DRS_ALPHABLENDENABLE, false);<br>    Device-&gt;SetRenderState(D3DRS_STENCILENABLE, false);<br>}//end RenderShadow()<br>8.4摘要(略)</p><p>第三部分 实用的Direct3D<br>(Applied Direct3D)<br>第九章 字体<br>(Fonts)<br>　　在游戏中，我们常常需要显示一写文本信息给用户。这一章讨论三种在Direct3D中能够产生和输出文字的方法。每一种方法都有一个对应的实例程序。<br>目标</p><ul><li>学习怎样使用ID3DXFont接口来渲染文字。</li><li>学习怎样使用CD3DFont类来渲染文字。</li><li>学习怎样计算渲染帧率。</li><li>学习怎样使用D3DXCreateText函数来创建和渲染3D文字。<br>9.1 ID3DXFont<br>　　在D3DX库中提供了一个ID3DXFont接口，它能被用于在Direct3D应用程序中绘制文字。这个接口是使用GDI来绘制文字的，因此我们能够使用这个接口来执行这个操作。无论如何，因为ID3DXFont使用的是GUI，所以它能够联合字体句柄和格式化字体。<br>9.1.1创建一个ID3DXFont<br>　　我们能够使用D3DXCreateFontIndirect函数来创建一个ID3DXFont接口。<br>HRESULT D3DXCreateFontIndirect(<br>  LPDIRECT3DDEVICE9 pDevice, // device to be associated with the font<br>  CONST LOGFONT<em> pLogFont, // LOGFONT structure describing the font<br>  LPD3DXFONT</em> ppFont // return the created font<br>);<br>　　下面的代码片段显示了怎样使用这个函数：<br>LOGFONT lf;<br>ZeroMemory(&amp;lf, sizeof(LOGFONT));<br>lf.lfHeight = 25; // in logical units<br>lf.lfWidth = 12; // in logical units<br>lf.lfWeight = 500; // boldness, range 0(light) - 1000(bold)<br>lf.lfItalic = false;<br>lf.lfUnderline = false;<br>lf.lfStrikeOut = false;<br>lf.lfCharSet = DEFAULT_CHARSET;<br>strcpy(lf.lfFaceName, “Times New Roman”); // font style<br>ID3DXFont* font = 0;<br>D3DXCreateFontIndirect(Device, &amp;lf, &amp;font);<br>　　我们必须填充一个LOGFONT结构来描述想创建的字体类型。<br>　　注意：你也能够使用D3DXCreateFont函数来获得一个ID3DXFont接口指针。<br>9.1.2绘制文本<br>　　一旦我们获得了ID3DXFont接口指针，绘制文本就是很简单的事情了，我们只要调用ID3DXFont::DrawText方法就可以实现了。<br>INT ID3DXFont::DrawText(<br>  LPCSTR pString,<br>  INT Count,<br>  LPRECT pRect,<br>  DWORD Format,<br>  D3DCOLOR Color<br>);</li><li>pString — 指向要绘制的文字。</li><li>Count — 字符串中特征字符的数量。假如字符是以null结束的字符串则可将其指定为-1。</li><li>pRect — 指向一个RECT结构，它定义一个文字被绘制在屏幕上的范围。</li><li>Format — 可选参数，指定文字怎样被格式化；要获得更详细的信息请查看SDK文档。</li><li>Color — 文字的颜色。<br>　　例子：<br>Font-&gt;DrawText(<br>  “Hello World”, // String to draw.<br>  -1, // Null terminating string.<br>  &amp;rect, // Rectangle to draw the string in.<br>  DT_TOP | DT_LEFT, // Draw in top-left corner of rect.<br>   0xff000000<br>   ); // Black.<br>9.1.3计算每秒的渲染帧数<br>　　这一章的ID3DXFont和Cfont例子是计算和显示每秒渲染的帧数（FPS）。这一部分说明怎样计算FPS。<br>　　首先，我们定义如下三个全局变量：<br>DWORD FrameCnt; // The number of frames that have occurred.<br>float TimeElapsed; // The time that has elapsed so far.<br>float FPS; // The frames rendered per second.<br>　　我们计算每一秒的FPS；它给我们一个很好的平均。另外，在同一秒中内只保存一个FPS，这给了我们足够时间来读取它，在它再一次改变之前。<br>　　因此每一帧我们增加FrameCnt并且把从上一帧到现在流逝的时间写进TimeElapsed：<br>FrameCnt++;<br>TimeElapsed += timeDelta;<br>这里timeDelta是两帧之间的时间。<br>　　    在一秒种结束以后，我们能够用下面的公式来计算FPS：<br>FPS = (float)FrameCnt / TimeElapsed;<br>我们从新设置FrameCnt和TimeElapsed为计算下一秒的FPS做准备。下面就是合在一起的代码：<br>void CalcFPS(float timeDelta)<br>{<br>  FrameCnt++;<br>  TimeElapsed += timeDelta;<br>  if(TimeElapsed &gt;= 1.0f)<br>  {<pre><code>  FPS = (float)FrameCnt / TimeElapsed;  TimeElapsed = 0.0f;  FrameCnt = 0;</code></pre>  }<br>}<br>9.2 CD3DFont<br>　　DirectX SDK给我们提供了一些很有用的代码，它们在你的DXSDK目录下的\Samples\C++\Commond下。CD3DFont类代码是使用纹理三角形和Direct3D。因为CD3DFont使用Direct3D代替GDI来渲染， 这比ID3DXFont快的多。然而，CD3DFont不能够联合字体句柄和格式化ID3DXFont。假如你追求速度和只需要一些简单的字体，CD3DFont类就能满足你的要求了。<br>　　使用CD3DFont类，你需要添加下列文件到你的程序中：d3dfont.h, d3dfont.cpp, d3dutil.h, d3dutil.cpp, dxutil.h和dxutil.cpp。这些文件可以在刚才所说目录下的Include和Src目录下。<br>9.2.1创建一个CD3DFont<br>　　为了创建一个CD3DFont实例，我们只需要简单地象一般的C++对象那样实例化就可以了；下面是它的构造原型：<br>CD3DFont(const TCHAR* strFontName, DWORD dwHeight, DWORD dwFlags=0L);</li><li>strFontName — 以null结束的字符串，它指定字体类型。</li><li>dwHeight — 字体的高度。</li><li>dwFlags — 可选参数；你能设置该参数为0或者用下面参数；D3DFONT_BOLD, D3DFONT_ITALIC, D3DFONT_ZENABLE。<br>　　实例化一个CD3DFont对象以后，我们必须调用下面的方法来初始化字体：<br>Font = new CD3DFont(“Times New Roman”, 16, 0); // instantiate<br>Font-&gt;InitDeviceObjects( Device );<br>Font-&gt;RestoreDeviceObjects();<br>9.2.2绘制文本<br>　　现在我们已经创建和初始化了一个CD3DFont对象，这已经为绘制文字做好了准备。绘制文字是使用下面的方法：<br>HRESULT CD3DFont::DrawText(FLOAT x, FLOAT y, DWORD dwColor,<br>  const TCHAR* strText, DWORD dwFlags=0L);</li><li>x — 文字在屏幕上开始绘制的x坐标。</li><li>y —文字在屏幕上开始绘制的y坐标。 </li><li>dwColor — 文字的颜色。</li><li>strText — 要绘制的文字。</li><li>dwFlags — 可选参数；你能设置该参数为0或者用下面参数；D3DFONT_CENTERED, D3DFONT_TWOSIDED, D3DFONT_FILTERED。<br>　　例子：<br>   Font-&gt;DrawText(20, 20, 0xff000000, “Hello, World”);<br>9.2.3 清除<br>　　在删除一个CD3DFont对象之前，我们必须首先调用一些清除程序，就象下面列举的代码片段：<br>Font-&gt;InvalidateDeviceObjects();<br>Font-&gt;DeleteDeviceObjects();<br>delete Font;<br>9.3 D3DXCreateText<br>　　最后的函数是被用来创建一个3D 文字网格。图9.1显示了本章FontMes3D实例渲染的3D文字网格。</li></ul><p>图9.1<br>　　该函数的原型是：<br>HRESULT D3DXCreateText(<br>    LPDIRECT3DDEVICE9 pDevice,<br>    HDC hDC,<br>    LPCTSTR pText,<br>    FLOAT Deviation,<br>    FLOAT Extrusion,<br>    LPD3DXMESH<em> ppMesh,<br>    LPD3DXBUFFER</em> ppAdjacency,<br>    LPGLYPHMETRICSFLOAT pGlyphMetrics<br>);<br>这个函数如果调用成功则返回D3D_OK。</p><ul><li>pDevice — 和mesh关联的device。</li><li>hDC — 我们将要用来产生mesh的包含描述字体的设备环境句柄。 </li><li>pText — 指向以null结束的字符串的指针，此字符串是用来指定创建什么文字mesh。</li><li>Deviation — 字型轮廓段数间距。该值必须大于等于0。当它为0时，段数等于字体原始设计单位（该值越接近0，那么字体就越光滑）。</li><li>Extrusion — 文字在z轴方向的深度。</li><li>ppMesh — 返回创建的mesh。</li><li>ppAdjacency — 返回创建mesh的相关信息。假如你不需要它可以将其指定为null。</li><li>pGlyphMetrics — 一个指向LPGLYPHMETRICSFLOAT结构数组的指针，它包含了字型米数据。假如你不关心此数据，你可以把它设置为0。<br>　　 下面的示例代码展示的是使用这个函数来创建一个文字3D 网格模型。<br>// Obtain a handle to a device context.<br>HDC hdc = CreateCompatibleDC( 0 );</li></ul><p>// Fill out a LOGFONT structure that describes the font’s properties.<br>LOGFONT lf;<br>ZeroMemory(&amp;lf, sizeof(LOGFONT));</p><p>lf.lfHeight = 25; // in logical units<br>lf.lfWidth = 12; // in logical units<br>lf.lfWeight = 500; // boldness, range 0(light) - 1000(bold)<br>lf.lfItalic = false;<br>lf.lfUnderline = false;<br>lf.lfStrikeOut = false;<br>lf.lfCharSet = DEFAULT_CHARSET;<br>strcpy(lf.lfFaceName, “Times New Roman”); // font style</p><p>// Create a font and select that font with the device context.<br>HFONT hFont;<br>HFONT hFontOld;<br>hFont = CreateFontIndirect(&amp;lf);<br>hFontOld = (HFONT)SelectObject(hdc, hFont);</p><p>// Create the 3D mesh of text.<br>ID3DXMesh* Text = 0;<br>D3DXCreateText(_device, hdc, “Direct3D”, 0.001f, 0.4f, &amp;Text, 0, 0);</p><p>// Reselect the old font, and free resources.<br>SelectObject(hdc, hFontOld);<br>DeleteObject( hFont );<br>DeleteDC( hdc );<br>　　现在你便能简单地调用mesh的DrawSubset方法来渲染一个3D文字：<br>Text-&gt;DrawSubset(0);<br>9.4摘要(略)</p><p>第十章 网格模型I<br>(Meshes Part I)<br>　　我们已经在D3DXCreate*程序中使用ID3DXMesh接口工作过了；在这一章我们更详细地介绍这个接口。这一章主要介绍ID3DXMesh接口的数据和方法。<br>　　注意ID3DXMesh接口的主要功能继承自ID3DXBaseMesh父接口。了解这些是很重要的，其它一些mesh接口如ID3DXPMesh也是继承自ID3DXBaseMesh。因此在这章中讲的知识也适用于其它的mesh类型。<br>目标</p><ul><li>学习ID3DXMesh对象的内在数据组织。</li><li>学习怎样创建一个ID3DXMesh对象。</li><li>学习怎样优化一个ID3DXMesh对象。</li><li>学习怎样渲染一个ID3DXMesh对象。<br>10.1 几何信息<br>　　ID3DXBaseMesh接口包含一个用来存储网格顶点的顶点缓存和一个用来定义这些顶点怎样连接在一起组成网格三角形的索引缓存。我们能够通过使用下面的方法来得到这些缓存的指针：<br>HRESULT ID3DXMesh::GetVertexBuffer(LPDIRECT3DVERTEXBUFFER9<em> ppVB);<br>HRESULT ID3DXMesh::GetIndexBuffer(LPDIRECT3DINDEXBUFFER9</em> ppIB);<br>　　这里有一些使用这些方法的例子：<br>IDirect3DVertexBuffer9<em> vb = 0;<br>Mesh-&gt;GetVertexBuffer( &amp;vb );<br>IDirect3DIndexBuffer9</em> ib = 0;<br>Mesh-&gt;GetIndexBuffer( &amp;ib );<br>　　假如想锁定这些缓存来读写数据，那么我们能够使用下面的方法。注意这些方法锁定整个顶点/索引缓存。<br>HRESULT ID3DXMesh::LockVertexBuffer(DWORD Flags, BYTE<strong> ppData);<br>HRESULT ID3DXMesh::LockIndexBuffer(DWORD Flags, BYTE</strong> ppData);<br>　　Flags参数描述怎样锁定它。这些Flags参数在第三章中我们介绍过。ppData是函数返回的指向锁定内存的指针的地址。<br>　　当然在你锁定以后一定要记得解锁：<br>HRESULT ID3DXMesh::UnlockVertexBuffer();<br>HRESULT ID3DXMesh::UnlockIndexBuffer();<br>　　下面是另外一些与mesh几何结构有关的ID3DXMesh接口方法：</li><li>DWORD GetFVF() — 返回顶点的格式</li><li>DWORD GetNumVertices() — 返回顶点缓存中的顶点数</li><li>DWORD GetNumBytesPerVertex() — 返回一个顶点所占的字节数</li><li>DWORD GetNumFaces() — 返回在mesh中的面（三角形）数<br>10.2 子集和属性缓存<br>　　一个mesh由一个或数个子集组成。一个子集（subset）是在mesh中的使用相同属性渲染的一组三角形。这里的属性是指材质，纹理和渲染状态。图10.1显示了一座房子mesh可能被分成的几个子集。<br>　　<br>图10.1<br>我们通过给每个子集指定一个唯一非负整数来标识子集。这个值可以是存储在一个DWORD中的任意数值。例如，在图10.1中我们用0，1，2和3来标识子集。<br>　　在mesh中的每个三角形都与一个属性ID相关联，表示该三角形属于该子集。例如，图10.1中组成地板的三角形具有属性ID0，它表示这些三角形属于子集0。同样，组成墙的三角形具有属性ID1，它表示这些三角形属于子集1。<br>　　三角形的属性ID存储在mesh的属性缓存中，它是一个DWORD数组。因为每个面对应属性缓存中的一项，所以属性缓存中的项目数等于mesh中的面的个数。属性缓存中的项目和索引缓存中定义的三角形一一对应。即，属性缓存中的第i项和索引缓存中的第i个三角形相对应。三角形i由下面三个索引缓存中的索引项定义：<br>　　A = i <em> 3<br>　　B = i </em> 3 + 1<br>　　C = i * 3 + 2<br>图10.2显示了这个对应关系：</li></ul><p>图10.2<br>　　我们可以锁定属性缓存，就象下面的代码片段：<br>DWORD<em> buffer = 0;<br>Mesh-&gt;LockAttributeBuffer(lockingFlags, &amp;buffer);<br>// Read or write to attribute buffer…<br>Mesh-&gt;UnlockAttributeBuffer();<br>10.3 绘制<br>　　ID3DXMesh接口提供了DrawSubset（DWORD AttribId）方法来绘制AttribId指示的子集中的各个三角形。例如，要绘制子集0中的所有三角形，我们将这样写：<br>Mesh-&gt;DrawSubset(0);<br>　　为了绘制整个mesh，我们必须绘制mesh的所有子集。这是非常方便的用0，1，2，…，n-1来标识子集，这里的n是子集的总数。且有一个相对应的材质和纹理数组，即子集i与材质和纹理数组的第i项对应。这就使我们能够简单的用循环来渲染mesh：<br>for(int i = 0; i &lt; numSubsets; i++)<br>{<br>    Device-&gt;SetMaterial( mtrls[i] );<br>    Device-&gt;SetTexture( 0, textures[i] );<br>    Mesh-&gt;DrawSubset(i);<br>}<br>10.4 优化<br>　　Mesh的顶点和索引能够被重组以便能更有效的渲染mesh。当我们这样做时，我们说我们优化了一个mesh。我们可以使用下面的方法来进行优化：<br>HRESULT ID3DXMesh::OptimizeInplace(<br>    DWORD Flags,<br>    CONST DWORD</em> pAdjacencyIn,<br>    DWORD<em> pAdjacencyOut,<br>    DWORD</em> pFaceRemap,<br>    LPD3DXBUFFER* ppVertexRemap<br>);</p><ul><li>Flags — 表示执行什么类型的优化方法。它可以是下面的一个或几个的组合：</li><li>D3DXMESHOPT_COMPACT — 从mesh中移除没有用的顶点和索引项。</li><li>D3DXMESHOPT_ATTRSORT — 根据属性给三角形排序并调整属性表，这将使DrawSubset执行更有效（参见10.5节）。</li><li>D3DXMESHOPT_VERTEXCACHE — 增加顶点缓存的命中率。</li><li>D3DXMESHOPT_STRIPREORDER — 重组顶点索引使三角带尽可能的长。</li><li>D3DXMESHOPT_IGNOREVERTS — 只优化索引信息；忽略顶点信息。<br>注意：D3DXMESHOPT_VERTEXCACHE和D3DXMESHOPT_STRIPREORDER不能同时使用。</li><li>pAdjacencyIn — 指向没有优化的mesh的邻接数组。</li><li>pAdjacencyOut — 指向一个DWORD数组，它被用来填充优化好了的mesh邻接信息。该数组必须有ID3DXMesh::GetNumFaces() * 3个元素。如果不需要该信息，可以将其设置为0。</li><li>pFaceRemap —指向一个DWORD数组，它被用来填充面重影射信息。该数组必须不小于ID3DXMesh::GetNumFaces()。当一个mesh被优化时，由索引缓存定义的面可能被移动；也就是说，在pFaceRemap中的第i项表示第i个原始面被移动到的面索引值。如果不需要该信息，可以将其设置为0。</li><li>ppVertexRemap — 指向ID3DXBuffer指针的地址（参见11.1节），它被用来填充顶点重影射信息。这个缓存应该包含ID3DXMesh::GetNumVertices()个顶点。当一个mesh被优化后，顶点可能被移动。顶点重影射信息用来说明原来的顶点被移动到新位置；也就是说，在ppVertexRemap中的第i项表示原来的第i个顶点的新位置。如果不需要该信息，可以将其设置为0。<br>　　例子：<br>// Get the adjacency info of the non-optimized mesh.<br>DWORD adjacencyInfo[Mesh-&gt;GetNumFaces() * 3];<br>Mesh-&gt;GenerateAdjacency(0.0f, adjacencyInfo);</li></ul><p>// Array to hold optimized adjacency info.<br>DWORD optimizedAdjacencyInfo[Mesh-&gt;GetNumFaces() * 3];</p><p>Mesh-&gt;OptimizeInplace(<br>    D3DXMESHOPT_ATTRSORT |<br>    D3DXMESHOPT_COMPACT |<br>    D3DXMESHOPT_VERTEXCACHE,<br>    adjacencyInfo,<br>    optimizedAdjacencyInfo,<br>    0,<br>     0);<br>　　一个更简单的方法是Optimize方法，它输出一个优化的mesh，而不是在原来mesh的基础上进行优化：<br>HRESULT ID3DXMesh::Optimize(<br>    DWORD Flags,<br>    CONST DWORD<em> pAdjacencyIn,<br>    DWORD</em> pAdjacencyOut,<br>    DWORD<em> pFaceRemap,<br>    LPD3DXBUFFER</em> ppVertexRemap,<br>    LPD3DXMESH* ppOptMesh // the optimized mesh to be output<br>);<br>10.5 属性表<br>　　当一个mesh被使用D3DXMESHOPT_ATTRSORT参数来优化后，mesh的几何信息将按照属性进行排序，这样各个子集的顶点/索引将组成连续的块（如图10.3）。</p><p>图10.3<br>　　除了进行几何信息的排序外，D3DXMESHOPT_ATTRSORT优化项还将创建一个属性表。该表是D3DXATTRIBUTERANGE结构的一个数组。在属性表中的每一项对应mesh的一个子集并指示顶点/索引缓存中的一个连续连续内存块，这个子集的几何信息就包含在这个块中。D3DXATTRIBUTERANGE结构的定义如下：<br>typedef struct _D3DXATTRIBUTERANGE {<br>    DWORD AttribId;<br>    DWORD FaceStart;<br>    DWORD FaceCount;<br>    DWORD VertexStart;<br>    DWORD VertexCount;<br>} D3DXATTRIBUTERANGE;</p><ul><li>AttribId — 子集的ID。</li><li>FaceStart — 该子集的面的起始值，FaceStart*3就是起始三角形在索引缓存中的序号。</li><li>FaceCount — 在子集中的面（三角形）数。</li><li>VertexStart — 该子集的起始顶点在顶点缓存中的序号。</li><li>VertexCount — 在子集中的顶点数。<br>　　我们能够很容易的明白D3DXATTRIBUTERANGE结构的各个成员，如图10.3。在图10.3中mesh的属性表有三项——它们和各个子集一一对应。<br>　　建立了属性表以后，渲染一个子集就很容易了。仅仅查一下属性表就能找出自己的几何信息。注意如果没有属性表，每渲染一个子集就需要对属性缓存进行一次线性搜索来找出子集包含的几何信息。<br>　　可以使用下面的方法来访问mesh的属性表：<br>HRESULT ID3DXMesh::GetAttributeTable(<br>  D3DXATTRIBUTERANGE<em> pAttribTable,<br>  DWORD</em> pAttribTableSize<br>);<br>　　这个方法能够做两件事情：它可以返回属性表的属性数，也可以用属性数据来填充一个D3DXATTRIBUTERANGE结构数组。<br>　　要得到属性表的元素个数，可以就将第一个参数设置为0：<br>DWORD numSubsets = 0;<br>Mesh-&gt;GetAttributeTable(0, &amp;numSubsets);<br>　　一旦我们知道了属性表的元素个数，我们就能够通过写属性表来填充一个D3DXATTRIBUTERANGE结构数组：<br>D3DXATTRIBUTERANGE table = new D3DXATTRIBUTERANGE [numSubsets];<br>Mesh-&gt;GetAttributeTable( table, &amp;numSubsets );<br>　　我们能够使用ID3DXMesh::SetAttributeTable方法来直接设置属性表。下面的代码就是设置一个有12个子集的属性表：<br>D3DXATTRIBUTERANGE attributeTable[12];<br>// …fill attributeTable array with data<br>Mesh-&gt;SetAttributeTable( attributeTable, 12);<br>10.6 邻接信息<br>　　对于mesh的某些操作，如优化，有必要了解的是三角形之间的邻接信息。Mesh的邻接数组存储了这些信息。<br>　　邻接数组是一个DWORD数组，其中的每一项对应了mesh中的一个三角形。例如，第i项对应的三角形由以下三个索引值定义：<br>A = i ??3<br>B = i ??3 + 1<br>C = i ??3 + 2<br>注意，使用ULONG_MAX = 4294967295表示该边没有邻接三角形。我们也可以用-1来表示，因为-1转换成DWORD就是ULONG_MAX。回想一下，DWORD就是一个unsigned32-bit整数。<br>　　因为每个三角形都有三条边，所以他就有三个邻接三角形（如图10.4）。<br>　　<br>　　图10.4<br>　　因此，邻接数组必须有三项（ID3DXBaseMesh::GetNumFaces()<em>3）—— 在mesh中每个三角形都可能有三个邻接三角形。<br>　　很多D3Dxmesh创造函数都能输出邻接信息，但我们也可以使用下面的方法：<br>HRESULT ID3DXMesh::GenerateAdjacency(<br>  FLOAT fEpsilon,<br>  DWORD</em> pAdjacency<br>);</li><li>fEpsilon — 指示当两个点距离有多近时，可以认为是一个点。当两点间的距离小于epsilon时，可认为它们是同一个点。</li><li>pAdjacency — 一个指向填充了邻接信息的DWORD数组指针。<br>　　例子：<br>DWORD adjacencyInfo[Mesh-&gt;GetNumFaces() <em> 3];<br>Mesh-&gt;GenerateAdjacency(0.001f, adjacencyInfo);<br>10.7 复制<br>　　有时我们需要将一个mesh中的数据拷贝到另一个之中。我们可以使用ID3DXBaseMesh::CloneMeshFVF方法。<br>HRESULT ID3DXMesh::CloneMeshFVF(<br>  DWORD Options,<br>  DWORD FVF,<br>  LPDIRECT3DDEVICE9 pDevice,<br>  LPD3DXMESH</em> ppCloneMesh<br>);</li><li>Options — 用来创建mesh的一个或多个创建标志。要了解所有标志信息请查看sdk文档。现在列出一部分：</li><li>D3DXMESH_32BIT — mesh使用32位索引。</li><li>D3DXMESH_MANAGED — mesh数据将被放在受控的内存中。</li><li>D3DXMESH_WRITEONLY — mesh数据只能执行写操作，不能执行读操作。</li><li>D3DXMESH_DYNAMIC — mesh缓存将是动态的。</li><li>FVF — 创建复制mesh的灵活顶点格式。</li><li>pDevice — 与复制mesh有关的设备。</li><li>ppCloneMesh — 输出复制的mesh。<br>　　注意这个方法允许指定与原mesh不同的options和FVF。例如我们有顶点格式为D3DFVF_XYZ的mesh，现在想复制一个顶点格式为D3DFVF_XYZ|D3DFVF_NORMAL的mesh。我们可以这样写：<br>// 假设_mesh和device是有效的<br>ID3DXMesh<em> clone = 0;<br>Mesh-&gt;CloneMeshFVF(<br>  Mesh-&gt;GetOptions(), // 使用与源模型同样的选项<br>  D3DFVF_XYZ | D3DFVF_NORMAL,// 指定克隆的FVF<br>  Device,<br>  &amp;clone<br>);<br>10.8 创建一个Mesh（D3DXCreateMeshFVF）<br>　　我们可以使用D3DXCreate</em>函数来创建mesh物体。然而，我们也可以使用    D3DXCreateMeshFVF函数来创建一个空mesh。所谓空mesh是指我们已经指定了顶点数和面数，函数D3DXCreateMeshFVF也分配了适当大小的内存给顶点、顶点索引、属性缓冲区。有了这些缓冲区后，就可以手动填写上下文数据了（需要分别向顶点缓存，索引缓存、属性缓存提供顶点、索引、属性数据）。<br>　　我们使用D3DXCreateMeshFVF函数来创建空mesh：<br>HRESULT D3DXCreateMeshFVF(<br>  DWORD NumFaces,<br>  DWORD NumVertices,<br>  DWORD Options,<br>  DWORD FVF,<br>  LPDIRECT3DDEVICE9 pDevice,<br>  LPD3DXMESH* ppMesh<br>);</li><li>NumFaces — mesh将拥有的面数。该值必须大于0。</li><li>NumVertices — mesh将拥有的顶点数。该值必须大于0。</li><li>Options —用来创建mesh的一个或多个创建标志。要了解所有标志信息请查看sdk文档。现在列出一部分：</li><li>D3DXMESH_32BIT — mesh使用32位索引。</li><li>D3DXMESH_MANAGED — mesh数据将被放在受控的内存中。</li><li>D3DXMESH_WRITEONLY — mesh数据只能执行写操作，不能执行读操作。</li><li>D3DXMESH_DYNAMIC — mesh缓存将是动态的。</li><li>FVF — mesh的顶点格式。</li><li>pDevice — 与mesh相关的设备。</li><li>ppMesh — 输出创建好的mesh。<br>　　下一节将给出实例程序，它演示了用这个函数怎样创建一个mesh以及手动填充mesh的数据内容。<br>　　另外，你也可以使用D3DXCreateMesh来创建空mesh。它的原型是：<br>HRESULT D3DXCreateMesh(<br>  DWORD NumFaces,<br>  DWORD NumVertices,<br>  DWORD Options,<br>  CONST LPD3DVERTEXELEMENT9<em> pDeclaration,<br>  LPDIRECT3DDEVICE9 pDevice,<br>  LPD3DXMESH</em> ppMesh<br>);<br>　　这些参数和D3DXCreateMeshFVF的参数是非常相似的，除了第四个。作为替代指定的FVF，我们指定一个D3DVERTEXELEMENT9结构，它描述了顶点格式。<br>HRESULT D3DXDeclaratorFromFVF(<br>  DWORD FVF, // input format<br>  D3DVERTEXELEMENT9 Declaration[MAX_FVF_DECL_SIZE]//output format<br>);<br>注意：D3DVERTEXELEMENT9将在第17章中讨论。<br>　　这个函数通过输入一个FVF返回一个D3DVERTEXELEMENT9结构的数组。注意MAX_FVF_DECL_SIZE的定义如下：<br>typedef enum {<br>  MAX_FVF_DECL_SIZE = 18<br>} MAX_FVF_DECL_SIZE;<br>10.9 实例程序：创建和渲染Mesh<br>这一章的实例程序是渲染一个立方体（如图10.5）</li></ul><p>图10.5<br>它演示了这一章中的大部分功能，包括如下一些操作：</p><ul><li>创建一个空mesh。</li><li>用一个立方体几何信息来填充mesh。</li><li>根据mesh的每个面指定子集。</li><li>产生mesh的邻接信息。</li><li>优化mesh。</li><li>绘制mesh。<br>　　注意，我们忽略一些无关的代码来讨论本例。你能在叫做D3DXCreateMeshFVF的例子中找到全部的代码。<br>　　另外，为了更容易调试和研究mesh的构成，我们执行如下的函数来将内在内容放进文件中：<br>void dumpVertices(std::ofstream&amp; outFile, ID3DXMesh<em> mesh);<br>void dumpIndices(std::ofstream&amp; outFile, ID3DXMesh</em> mesh);<br>void dumpAttributeBuffer(std::ofstream&amp; outFile, ID3DXMesh<em> mesh);<br>void dumpAdjacencyBuffer(std::ofstream&amp; outFile, ID3DXMesh</em> mesh);<br>void dumpAttributeTable(std::ofstream&amp; outFile, ID3DXMesh<em> mesh);<br>　　这些函数的名字就显示了它们的功能。执行这些函数是非常简单的，我们在这里讨论时忽略它们（可以看程序的原代码）。在这一节我们只展示一个dumpAttributeTable函数。<br>　　我们首先来浏览一下该例子，看看如下的一些全局变量：<br>ID3DXMesh</em> Mesh = 0;<br>const DWORD NumSubsets = 3;<br>IDirect3DTexture9* Textures[3] = {0, 0, 0};// texture for each subset<br>std::ofstream OutFile; // used to dump mesh data to file<br>　　这里我们定义了一个mesh对象的指针，我们以后要创建的。我们也定义了mesh拥有的子集数——三。在这个例子中，每个子集都用一个不同的纹理来渲染；纹理数组包含每个子集的纹理，如第i个纹理对应mesh的第i个子集。最后，Outfile变量被用来把mesh的内容输出为一个文本文件。<br>　　这个例子的大部分工作是在setup函数中进行。我们首先创建一个空的mesh：<br>bool Setup()<br>{<br>  HRESULT hr = 0;<br>  hr = D3DXCreateMeshFVF(<pre><code>  12,  24,  D3DXMESH_MANAGED,  Vertex::FVF,  Device,   &amp;Mesh);</code></pre>这里我们分配一个有12个面和24个顶点的mesh，这是描述一个盒子所必须的。<br>　　这样的话，mesh是空的，因此我们需要将组成盒子的顶点和索引分别写入顶点缓存和索引缓存。锁定顶点/索引缓存并手动写入数据这是很容易的：<br>// Fill in vertices of a box<br>Vertex<em> v = 0;<br>Mesh-&gt;LockVertexBuffer(0, (void**)&amp;v);<br>// fill in the front face vertex data<br>v[0] = Vertex(-1.0f, -1.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f);<br>v[1] = Vertex(-1.0f, 1.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 1.0f);<br>.<br>.<br>.<br>v[22] = Vertex( 1.0f, 1.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f);<br>v[23] = Vertex( 1.0f, -1.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f);<br>Mesh-&gt;UnlockVertexBuffer();<br>// Define the triangles of the box<br>WORD</em> i = 0;<br>Mesh-&gt;LockIndexBuffer(0, (void<em>*)&amp;i);<br>// fill in the front face index data<br>i[0] = 0; i[1] = 1; i[2] = 2;<br>i[3] = 0; i[4] = 2; i[5] = 3;<br>.<br>.<br>.<br>// fill in the right face index data<br>i[30] = 20; i[31] = 21; i[32] = 22;<br>i[33] = 20; i[34] = 22; i[35] = 23;<br>Mesh-&gt;UnlockIndexBuffer();<br>　　一旦mesh的几何信息被写入，我们必须指定每个三角形在哪个子集中。回想一下属性缓存就是存储的在mesh中每个三角形所属的子集信息。在这个例子中，我们指定索引缓存中的前四个三角形子集为0，接着的四个三角形子集为1，最后四个三角形子集为2。代码如下：<br>DWORD</em> attributeBuffer = 0;<br>Mesh-&gt;LockAttributeBuffer(0, &amp;attributeBuffer);<br>for(int a = 0; a &lt; 4; a++) // triangles 1-4<br>  attributeBuffer[a] = 0; // subset 0<br>for(int b = 4; b &lt; 8; b++) // triangles 5-8<br>  attributeBuffer[b] = 1; // subset 1<br>for(int c = 8; c &lt; 12; c++) // triangles 9-12<br>  attributeBuffer[c] = 2; // subset 2<br>Mesh-&gt;UnlockAttributeBuffer();<br>　　现在我们已经创建了一个包含有效数据的mesh。在这一小部分我们将渲染mesh，不过首先还是先将其优化一下。注意虽然这对于一个盒子mesh来说，优化mesh数据没有真正的效果，但是我们还是用ID3DXMesh接口方法来实践一下。为了优化一个mesh，我们首先需要计算mesh的邻接信息：<br>std::vector<dword> adjacencyBuffer(Mesh-&gt;GetNumFaces() * 3);<br>Mesh-&gt;GenerateAdjacency(0.0f, &amp;adjacencyBuffer[0]);<br>　　然后我们就能够优化mesh了：<br>hr = Mesh-&gt;OptimizeInplace(<pre><code>  D3DXMESHOPT_ATTRSORT |  D3DXMESHOPT_COMPACT |  D3DXMESHOPT_VERTEXCACHE,  &amp;adjacencyBuffer[0],   0, 0, 0);</code></pre>　　设置好了mesh以后，我们就为渲染它做好了准备。不过在setup函数中还有最后一个问题，也就是在前面我们说的将mesh的内在数据内容写入文件的函数。这能够检查mesh的数据，它能帮助我们调试和学习mesh的结构。<br>OutFile.open(“Mesh Dump.txt”);<br>dumpVertices(OutFile, Mesh);<br>dumpIndices(OutFile, Mesh);<br>dumpAttributeTable(OutFile, Mesh);<br>dumpAttributeBuffer(OutFile, Mesh);<br>dumpAdjacencyBuffer(OutFile, Mesh);<br>OutFile.close();<br>…Texturing loading, setting render states, etc., snipped<br>return true;<br>} // end Setup()<br>　　例如，dumpAttributeTable函数将属性表的数据写入文件。它的具体实现如下：<br>void dumpAttributeTable(std::ofstream&amp; outFile, ID3DXMesh* mesh)<br>{<br>  outFile &lt;&lt; “Attribute Table:” &lt;&lt; std::endl;<br>  outFile &lt;&lt; “————————“ &lt;&lt; std::endl &lt;&lt; std::endl;<br>  // number of entries in the attribute table<br>  DWORD numEntries = 0;<br>  mesh-&gt;GetAttributeTable(0, &amp;numEntries);<br>  std::vector<d3dxattributerange> table(numEntries);<br>  mesh-&gt;GetAttributeTable(&amp;table[0], &amp;numEntries);<br>  for(int i = 0; i &lt; numEntries; i++)<br>  {<pre><code>  outFile &lt;&lt; &quot;Entry &quot; &lt;&lt; i &lt;&lt; std::endl;  outFile &lt;&lt; &quot;------&quot; &lt;&lt; std::endl;  outFile &lt;&lt; &quot;Subset ID: &quot; &lt;&lt; table[i].AttribId &lt;&lt; std::endl;  outFile &lt;&lt; &quot;Face Start: &quot; &lt;&lt; table[i].FaceStart &lt;&lt; std::endl;  outFile &lt;&lt; &quot;Face Count: &quot; &lt;&lt; table[i].FaceCount &lt;&lt; std::endl;  outFile &lt;&lt; &quot;Vertex Start: &quot; &lt;&lt; table[i].VertexStart &lt;&lt; std::endl;  outFile &lt;&lt; &quot;Vertex Count: &quot; &lt;&lt; table[i].VertexCount &lt;&lt; std::endl;  outFile &lt;&lt; std::endl;</code></pre>  }<br>  outFile &lt;&lt; std::endl &lt;&lt; std::endl;<br>}<br>　　下面的文本文件来自于通过dumpAttributeTable函数得到的mesh Dump.txt文件。<br>Attribute Table:</d3dxattributerange></dword></li></ul><hr><h2 id="Entry-0"><a href="#Entry-0" class="headerlink" title="Entry 0"></a>Entry 0</h2><p>Subset ID: 0<br>Face Start: 0<br>Face Count: 4<br>Vertex Start: 0<br>Vertex Count: 8</p><h2 id="Entry-1"><a href="#Entry-1" class="headerlink" title="Entry 1"></a>Entry 1</h2><p>Subset ID: 1<br>Face Start: 4<br>Face Count: 4<br>Vertex Start: 8<br>Vertex Count: 8</p><h2 id="Entry-2"><a href="#Entry-2" class="headerlink" title="Entry 2"></a>Entry 2</h2><p>Subset ID: 2<br>Face Start: 8<br>Face Count: 4<br>Vertex Start: 16<br>Vertex Count: 8<br>我们能够了解到我们为mesh所指定的相匹配的数据——有三个子集且每个子集有4个三角形。建议你去看看本例子Dump.txt的完整信息。该文件在本示例文件目录下。<br>　　最后，我们使用下面的代码就能够非常容易地渲染mesh了；我们只需要循环每个子集，设置相关联的纹理然后在绘制子集即可。这是非常容易的，因为我们已经为每个子集指定的下标如0，1，2，…，n-1，这里的n就是子集的个数。<br>bool Display(float timeDelta)<br>{<br>    if( Device )<br>    {<br>        //…update frame code snipped<br>        Device-&gt;Clear(0, 0, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,0x00000000, 1.0f, 0);<br>        Device-&gt;BeginScene();<br>        for(int i = 0; i &lt; NumSubsets; i++)<br>        {<br>            Device-&gt;SetTexture( 0, Textures[i] );<br>            Mesh-&gt;DrawSubset( i );<br>        }<br>        Device-&gt;EndScene();<br>        Device-&gt;Present(0, 0, 0, 0);<br>    }<br>    return true;<br>}<br>10.10 摘要(略)</p><p>第十一章 网格模型II<br>(Building a Flexible Camera Class)<br>　　在这一章我们继续学习mesh相关的接口和结构，以及D3DX库提供的函数。在上一章的基础上，我们能够学习到更多有趣的技巧，比如读取和渲染一个存储在硬盘上的复杂3D模型，并且通过渐进网格接口来控制我们网格细节的等级。<br>目标</p><ul><li>学习怎样从一个Xfile中读取数据来形成一个ID3DXMesh对象。</li><li>更进一步理解使用渐进网格的好处以及学习怎样用渐进网格接口ID3DXPMesh。</li><li>学习关于界线容器，为什么它们是有用的，以及怎样用D3DX函数来创建它们。<br>11.1 ID3DXBuffer<br>　　对ID3DXBuffer接口的一些参考是在上一章，这里我们不会详细讲解。在D3DX库中到处都能看见这个接口，因此大概介绍一下该接口还是很有必要的。<br>　　ID3DXBuffer接口是一个很普通的数据结构， D3DX用它将数据存储到邻接内存块中。它只有两个方法：</li><li>LPVOID GetBufferPointer()——返回一个指向开始数据的指针。</li><li>DWORD GetBufferSize()——返回在缓存中的字节大小。<br> 为了保持结构特性，它使用一个空指针。也就是说它让我们知道被存储的数据的类型。例如，D3DXLoadMeshFromX使用一个ID3DXBuffer来返回mesh的邻接信息。因为邻接信息是被存储在DWORD数组中的，所以当我们希望使用缓存中的邻接信息时，我们不得不将缓存转换为DWORD数组。<br>　　例如：<br>DWORD<em> info =(DWORD</em>)adjacencyInfo-&gt;GetBufferPointer();<br>D3DXMATERIAL<em> mtrls = (D3DXMATERIAL</em>)mtrlBuffer-&gt;GetBufferPointer();<br>　　因为ID3DXBuffer是一个COM对象，当你使用完以后就必须释放它以防止内存泄漏：<br>adjacencyInfo-&gt;Release();<br>mtrlBuffer-&gt;Release();<br>　　我们能够使用下面的方法来创建一个空的ID3DXBuffer：<br>HRESULT D3DXCreateBuffer(<br>  DWORD NumBytes, // Size of the buffer, in bytes.<br>  LPD3DXBUFFER <em>ppBuffer // Returns the created buffer.<br>);<br>　　下面的例子是创建一个能包含4个整数的缓存：<br>ID3DXBuffer</em> buffer = 0;<br>D3DXCreateBuffer( 4 <em> sizeof(int), &amp;buffer );<br>11.2 X文件<br> 迄今为止，我们已经使用过了简单的几何物体，如球体，圆柱体，立方体等，它们都是用D3DXCreate</em>函数来创建的。假如你想通过手工指定顶点来创建你自己的3D物体，你能，不用怀疑，不过这是非常枯燥乏味的事情。为了减轻建造3D物体数据的工作，专门的应用程序已经被开发出来了，我们把它们叫做3D建模工具。它们允许我们在一个虚拟的拥有丰富工具的交互环境下建造复杂的真实的mesh，在这建造这些模型都是非常容易的。例如在游戏开发中常用到的有3DSMax（www.discreet.com）,LightWave 3D（www.newtek.com）,以及Maya（www.aliaswavefront.com）。<br> 这些工具，当然能够输出创建好的mesh数据到文件中。因此，我们也能够写一个文件来提取在我们的3D应用程序中要用到的mesh数据。这的确是一种可行的解决办法。不过，还存在一个更方便的解决方案。它是一种叫做X文件的特殊mesh文件格式（扩展名为.X）。很多3D建模软件都能输出这种格式，当然这里存在一个将其他流行的mesh文件转换为X文件的过程。是什么使X文件这么便利呢？因为它是DirectX定义的格式，并且D3DX库很容易地支持X文件。D3DX库提供了读和写X文件的函数。因此，如果我们使用这种格式就避免了还要自己写程序文件来读/写模型文件了。<br> 注意：你能够下载DirectX9 SDK Extra——你能从MSDN（www.msdn.microsoft.com）上得到一些已经开发好的针对3DMax,LightWave,Maya软件导出.X文件的Direct3D工具包。<br>11.2.1读取X文件<br> 我们使用下面的函数来读取存储在X文件中的mesh数据。注意这个方法创建一个ID3DXMesh对象，且从X文件中读取几何信息数据填入其中。<br>HRESULT D3DXLoadMeshFromX(<br>  LPCSTR pFilename,<br>  DWORD Options,<br>  LPDIRECT3DDEVICE9 pDevice,<br>  LPD3DXBUFFER <em>ppAdjacency,<br>  LPD3DXBUFFER </em>ppMaterials,<br>  LPD3DXBUFFER<em> ppEffectInstances,<br>  PDWORD pNumMaterials,<br>  LPD3DXMESH </em>ppMesh<br>);</li><li>pFilename — 读取的X文件的文件名。</li><li>Options — 用来创建mesh的一个或多个创建标志。要了解所有标志信息请查看sdk文档。现在列出一部分：</li><li>D3DXMESH_32BIT — mesh使用32位索引。</li><li>D3DXMESH_MANAGED — mesh数据将被放在受控的内存中。</li><li>D3DXMESH_WRITEONLY — mesh数据只能执行写操作，不能执行读操作。</li><li>D3DXMESH_DYNAMIC — mesh缓存将是动态的。</li><li>pDevice — 与复制mesh有关的设备。</li><li>ppAdjacency — 返回一个ID3DXBuffer包含一个DWORD数组，描述mesh的邻接信息。</li><li>ppMaterials — 返回一个ID3DXBuffer包含一个D3DXMATERIAL结构的数组，存储了mesh的材质数据。我们在下一节介绍mesh材质。</li><li>ppEffectInstances — 返回一个ID3DXBuffer包含一个D3DXEFFECTINSTANCE结构的数组。我们现在通过指定0值来忽略这个参数。</li><li>pNumMaterials — 返回mesh的材质数。</li><li>ppMesh — 返回填充了X文件几何信息的ID3DXMesh对象。<br>11.2.2 X文件的材质<br>　　D3DXLoadMeshFromX的第七个参数返回的是mesh包含的材质数，第五个参数返回的是包含着材质数据的一个D3DXMATERIAL结构数组。D3DXMATERIAL结构的定义如下：<br>typedef struct D3DXMATERIAL {<br>  D3DMATERIAL9 MatD3D;<br>  LPSTR pTextureFilename;<br>} D3DXMATERIAL;<br>　　这是一个简单的结构；它包含一个基本的D3DMATERAIL9结构和一个用来指定与之相关联的纹理文件名的一个以null结束的字符串指针。一个X文件是不能插入纹理数据的；它只能插入文件名。因此，在使用D3DXLoadMeshFromX读取一个X文件以后，我们还必须从纹理文件中读取纹理数据。我们将在下一节中说明怎样具体实现。<br>　　D3DXLoadMeshFromX函数读取X文件数据以便在返回的D3DXMATERIAL数组中的第i项与第i个子集相对应。因此，子集是使用0，1，2，…，n-1标记的，n是子集和材质的数目。这也就允许使用简单的循环来渲染mesh了。<br>11.2.3 实例程序：X文件<br>　　我们现在演示本章中的第一个实例（X文件）的相关代码。该例子调用一个叫做bigship1.x的x文件，你可以在DirectX SDK下的media文件夹下找到它。完整原代码可以在相应的文件中找到。图11.1是该实例的一个截图。</li></ul><p>图11.1<br>　　该实例使用下面的全局变量：<br>ID3DXMesh<em>                      Mesh = 0;<br>std::vector<d3dmaterial9>       Mtrls(0);<br>std::vector&lt;IDirect3DTexture9</d3dmaterial9></em>&gt; Textures(0);<br>   这里有一个ID3DXMesh对象，它被用来存储从X文件中读取的mesh数据。也有一个材质vector和纹理vector,我们用它们来分别存储mesh的材质和纹理。<br>　　我们首先在Setup函数中操作。首先，我们读取X文件：<br>bool Setup()<br>{<br>    HRESULT hr = 0;<br>    //<br>    // Load the XFile data.<br>    //<br>    ID3DXBuffer<em> adjBuffer  = 0;<br>    ID3DXBuffer</em> mtrlBuffer = 0;<br>    DWORD        numMtrls   = 0;<br>    hr = D3DXLoadMeshFromX(<br>        “bigship1.x”,<br>        D3DXMESH_MANAGED,<br>        Device,<br>        &amp;adjBuffer,<br>        &amp;mtrlBuffer,<br>        0,<br>        &amp;numMtrls,<br>        &amp;Mesh);<br>    if(FAILED(hr))<br>    {<br>        ::MessageBox(0, “D3DXLoadMeshFromX() - FAILED”, 0, 0);<br>        return false;<br>     }<br>　　读取完X文件数据以后，我们必须遍历D3DXMATERIAL数组来读取mesh中所使用的所有纹理：<br>    //<br>    // Extract the materials, and load textures.<br>    //<br>    if( mtrlBuffer != 0 &amp;&amp; numMtrls != 0 )<br>    {<br>        D3DXMATERIAL<em> mtrls = (D3DXMATERIAL</em>)mtrlBuffer-&gt;GetBufferPointer();<br>        for(int i = 0; i &lt; numMtrls; i++)<br>        {<br>            // the MatD3D property doesn’t have an ambient value set<br>            // when its loaded, so set it now:<br>            mtrls[i].MatD3D.Ambient = mtrls[i].MatD3D.Diffuse;<br>            // save the ith material<br>            Mtrls.push_back( mtrls[i].MatD3D );<br>            // check if the ith material has an associative texture<br>            if( mtrls[i].pTextureFilename != 0 )<br>            {<br>                // yes, load the texture for the ith subset<br>                IDirect3DTexture9<em> tex = 0;<br>                D3DXCreateTextureFromFile(<br>                    Device,<br>                    mtrls[i].pTextureFilename,<br>                    &amp;tex);<br>                // save the loaded texture<br>                Textures.push_back( tex );<br>            }<br>            else<br>            {<br>                // no texture for the ith subset<br>                Textures.push_back( 0 );<br>            }<br>        }<br>    }<br>　　d3d::Release&lt;ID3DXBuffer</em>&gt;(mtrlBuffer); // done w/ buffer<br>    .<br>    . // Snipped irrelevant code to this chapter (e.g., setting up lights,<br>    . // view and projection matrices, etc.)<br>    .<br>    return true;<br>} // end Setup()<br>　　在Display函数中我们让mesh在每一帧中都旋转一个小角度。我们使用简单的循环，Mesh便能够被渲染了：<br>bool Display(float timeDelta)<br>{<br>    if( Device )<br>    {<br>        //<br>        // Update: Rotate the mesh.<br>        //</p><pre><code>    static float y = 0.0f;    D3DXMATRIX yRot;    D3DXMatrixRotationY(&amp;yRot, y);    y += timeDelta;    if( y &gt;= 6.28f )        y = 0.0f;    D3DXMATRIX World = yRot;    Device-&gt;SetTransform(D3DTS_WORLD, &amp;World);    //    // Render    //    Device-&gt;Clear(0, 0, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xffffffff, 1.0f, 0);    Device-&gt;BeginScene();    for(int i = 0; i &lt; Mtrls.size(); i++)    {        Device-&gt;SetMaterial( &amp;Mtrls[i] );        Device-&gt;SetTexture(0, Textures[i]);        Mesh-&gt;DrawSubset(i);    }        Device-&gt;EndScene();    Device-&gt;Present(0, 0, 0, 0);}return true;</code></pre><p>}<br>11.2.4 产生顶点法线<br>   一个X文件不包含顶点法线数据，这是很有可能的。假如是这种情况，那么手动计算顶点法线以便我们能够使用灯光这是很有必要的。在第5章中我们简要的介绍了一下怎么做。然而，现在我们知道了ID3DXMesh接口和它的父接口ID3DXBaseMesh，我们能够使用下面的函数来产生任何mesh的顶点法线：<br>HRESULT D3DXComputeNormals(<br>    LPD3DXBASEMESH pMesh, // Mesh to compute normals of.<br>    const DWORD <em>pAdjacency // Input adjacency info.<br>);<br>   这个函数通过使用平均法线的方法来产生顶点法线。假如有邻接信息，那么重复的顶点是被忽略的。假如没有邻接信息，那么重复的顶点也会被重复计算。了解这些是很重要的，我们检查pMash必须有一个包含D3DFVF_NORMAL标记的顶点格式。<br>   注意假如X文件不包含顶点法线数据，那么通过D3DXLoadMeshFromX创建的ID3DXMesh对象在它的顶点格式中没有指定的D3DFVF_NORMAL标记。因此，在我们能够使用D3DXComputeNormals之前，我们必须复制mesh并且为其指定包含D3DFVF_NORMAL的顶点格式。下面就是相应的代码：<br>// does the mesh have a D3DFVF_NORMAL in its vertex format?<br>if ( !(pMesh-&gt;GetFVF() &amp; D3DFVF_NORMAL) )<br>{<br>    // no, so clone a new mesh and add D3DFVF_NORMAL to its format:<br>    ID3DXMesh</em> pTempMesh = 0;<br>    pMesh-&gt;CloneMeshFVF(<br>        D3DXMESH_MANAGED,<br>        pMesh-&gt;GetFVF() | D3DFVF_NORMAL, // add it here<br>        Device,<br>        &amp;pTempMesh );</p><pre><code>// compute the normals:D3DXComputeNormals( pTempMesh, 0 );pMesh-&gt;Release(); // get rid of the old meshpMesh = pTempMesh; // save the new mesh with normals</code></pre><p>}<br>11.3渐进网格（Progressive Meshes）<br>   渐进网格，它通过ID3DXPMesh接口来表现，允许我们通过简化边缩减转换（edge collapse transformations，ECT）来简化mesh。每执行一次ECT就移除一个顶点和一或2个面。因为每个ECT是可逆的（它的逆过程叫顶点分裂），我们能够逆转简化过程并且恢复mesh为它的原始状态。当然，我们不可能得到比原始情况还要精细的网格。我们仅仅只能简化然后恢复简化操作。图11.2显示了同一个mesh的三种不同精细级别（levels of detail，LOD）：高，中，低。</p><p>图11.2<br>   渐进网格和mipmaps纹理非常相似。当使用纹理时，我们已经注意到在一个小或远的图元上使用高分辨率的纹理简直就是浪费。对于mesh也是同样的道理；一个小或远的mesh不需要太多三角形，多了也是浪费。因此，我们不会花费渲染高三角形模型的时间来渲染一个只需要表现小的低三角形模型。<br>   我们可以使用渐进网格来根据模型距离摄象机的距离来调整模型的LOD。也就是说，当距离减少时，我们增加mesh的细节，当距离增加时我们减少mesh的细节。<br>   注意我们还没有讨论渐进网格是怎样被实现的；这里我们只讲解怎样使用ID3DXPMesh接口。对此感兴趣的读者可以到渐进网格的原始页面Hoppe上查看。Hoppe的网址：<a href="http://research.microsoft.com/~hoppe/。" target="_blank" rel="noopener">http://research.microsoft.com/~hoppe/。</a><br>11.3.1 产生一个渐进网格<br>   我们能够使用下面的函数来创建一个ID3DXPMesh对象：<br>HRESULT D3DXGeneratePMesh(<br>    LPD3DXMESH pMesh,<br>    CONST DWORD <em>pAdjacency,<br>    CONST LPD3DXATTRIBUTEWEIGHTS pVertexAttributeWeights,<br>    CONST FLOAT </em>pVertexWeights,<br>    DWORD MinValue,<br>    DWORD Options,<br>    LPD3DXPMESH *ppPMesh<br>);</p><ul><li>pMesh— 输入原始mesh，它包含了我们想要生成的渐进网格的mesh数据。</li><li>pAdjacency — 指向一个包含pMesh邻接信息的DWORD数组。</li><li>pVertexAttributeWeights — 指向一个D3DXATTRIBUTEWEIGHTS数组，它的大小是pMesh-&gt;GetNumVertices（）。它的第i项与pMesh中的第i个顶点相对应并且指定的是它的品质权重。品质权重被用来确定一个顶点被删除的可能性大小。你能够将此参数设置为null，对于每个顶点一个默认的顶点品质权重将被设置。在11.3.2节中有关于顶点品质权重和D3DXATTRIBUTEWEIGHTS结构的更多信息。</li><li>pVertexWeights — 指向一个float数组，它的大小是pMesh-&gt;GetNumVertices（），它的第i项与pMesh中的第i个顶点相对应并且指定的是它的顶点权重。顶点权重越高被删除的可能性越小。你能够将此参数设置为null，对于每个顶点一个默认的顶点品质权重1.0将被设置。</li><li>MinValue — 我们想要简化到的最小顶点或面数。注意该值是必须的，而且与顶点/品质权重有关，最终可能达不到该值。</li><li>Options — 只能取D3DXMESHSIMP枚举类型中的一个值：</li><li>D3DXMESHSIMP_VERTEX — 指定在上一个参数MinValue中提到的数为顶点数。</li><li>D3DXMESHSIMP_FACE —指定在上一个参数MinValue中提到的数为面数。</li><li><p>ppPMesh — 返回生成好的渐进网格。<br>11.3.2 顶点品质权重<br>typedef struct _D3DXATTRIBUTEWEIGHTS {<br>  FLOAT Position;<br>  FLOAT Boundary;<br>  FLOAT Normal;<br>  FLOAT Diffuse;<br>  FLOAT Specular;<br>  FLOAT Texcoord[8];<br>  FLOAT Tangent;<br>  FLOAT Binormal;<br>} D3DXATTRIBUTEWEIGHTS;<br>　　顶点权重结构允许我们为每个顶点属性指定一个权值。0.0表示该属性没有权重。顶点属性的权重越高在简化过程中被移除的可能性越小。默认的权值如下：<br>D3DXATTRIBUTEWEIGHTS AttributeWeights;<br>AttributeWeights.Position = 1.0;<br>AttributeWeights.Boundary = 1.0;<br>AttributeWeights.Normal = 1.0;<br>AttributeWeights.Diffuse = 0.0;<br>AttributeWeights.Specular = 0.0;<br>AttributeWeights.Tex[8] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};<br>　　默认的权值是被推荐的，除非你的应用程序有一个重要的理由而不使用它。<br>11.3.3 ID3DXPMesh方法<br> ID3DXPMesh接口是继承自ID3DXBaseMesh接口。因此它拥有以前所学习过的ID3DXMesh的所有函数，下面是一些额外的方法：<br>DWORD GetMaxFaces(VOID)——返回渐进网格能够被设置的最大面数。<br>DWORD GetMaxVertices(VOID)——返回渐进网格能够被设置的最大顶点数。<br>DWORD GetMinFaces(VOID)——返回渐进网格能够被设置的最小面数。<br>DWORD GetMinVertices(VOID)——返回渐进网格能够被设置的最小顶点数。<br>HRESULT SetNumFaces(DWORD Faces)——这个方法允许我们设置面的个数，以便让mesh简化/复杂化。例如，假设mesh目前有50个面，我们现在想将它简化到30个面；我们将写成：<br>pmesh-&gt;SetNumFaces(30);<br> 注意调整后的面数可能并不是我们设定的面数。假如面数小于了GetMinFaces（），那么面数将为GetMinFaces（）。同样的，假如面数大于了GetMaxFaces（），那么面数将为GetMaxFaces（）。<br>HRESULT SetNumVertices(DWORD Vertices)——这个方法允许我们设置顶点的个数，以便让mesh简化/复杂化。例如，假设mesh目前有20个顶点，我们现在想将它增加到40个；我们将写成：<br>pmesh-&gt;SetNumVertices(40);<br> 注意调整后的顶点数可能并不是我们设定的数。假如顶点数小于了GetMinVertices（），那么顶点数将为GetMinVertices（）。同样的，假如顶点数大于了GetMaxVertices（），那么顶点数将为GetMaxVertices（）。<br>HRESULT TrimByFaces(<br>DWORD NewFacesMin,<br>DWORD NewFacesMax,<br>DWORD <em>rgiFaceRemap, // Face remap info.<br>DWORD </em>rgiVertRemap // Vertex remap info.<br>);<br> 这个方法允许我们设置新的最小和最大面数，分别通过NewFacesMin和NewFacesMax指定。注意新的最小和最大值必须在现有最小和最大面数之间；也就是说，必须在[GetMinFaces（），GetMaxFaces（）]之中。该函数也返回面和顶点的重影射信息。重影射信息参见10.4节。<br>HRESULT TrimByVertices(<br>DWORD NewVerticesMin,<br>DWORD NewVerticesMax,<br>DWORD <em>rgiFaceRemap, // Face remap info.<br>DWORD </em>rgiVertRemap // Vertex remap info.<br>);<br> 这个方法允许我们设置新的最小和最大顶点数，分别通过NewVerticesMin和NewVerticesMax指定。注意新的最小和最大值必须在现有最小和最大顶点数之间；也就是说，必须在[GetMinVertices（），GetMaxVertices（）]之中。该函数也返回面和顶点的重影射信息。重影射信息参见10.4节。<br>11.3.4实例程序：渐进网格<br> 渐进网格例子与X文件例子很相似，除了实际上我们创建和渲染的是一个渐进网格，通过ID3DXPMesh接口来表现。我们允许用户通过键盘输入进行交互式地改变渐进网格。你能通过按A键来增加mesh的面数，按S键来减少mesh的面数。<br> 在这个例子中使用的全局变量和X文件例子中的是一样的，不过我们增加了一个用来存储渐进网格的变量：<br>ID3DXMesh<em>                      SourceMesh = 0;<br>ID3DXPMesh</em>                     PMesh      = 0; // progressive mesh<br>std::vector<d3dmaterial9>       Mtrls(0);<br>std::vector<idirect3dtexture9*> Textures(0);<br> 回想一下，为了得到一个渐进网格我们必须输入一个包含了数据信息的源mesh。因此，我们首先读取一个X文件数据到ID3DXMesh对象SourceMesh之中，然后再产生渐进网格：<br>bool Setup()<br>{<br>  HRESULT hr = 0;<br>  // …Load XFile data into SourceMesh snipped.<br>  //<br>　　// …Extracting materials and textures snipped.<br> 因为这一部分代码和X文件例子中的是完全一样的，在这里我们就把它省略了。一但有了源mesh，我们就能够象下面一样来生成渐进网格了：<br>  //<br>  // Generate the progressive mesh.<br>  //<br>  hr = D3DXGeneratePMesh(</idirect3dtexture9*></d3dmaterial9></p><pre><code>  SourceMesh,  (DWORD*)adjBuffer-&gt;GetBufferPointer(), // adjacency  0,                  // default vertex attribute weights  0,                  // default vertex weights  1,                  // simplify as low as possible  D3DXMESHSIMP_FACE,  // simplify by face count  &amp;PMesh);</code></pre><p>  d3d::Release<id3dxmesh*>(SourceMesh);  // done w/ source mesh<br>  d3d::Release<id3dxbuffer*>(adjBuffer); // done w/ buffer</id3dxbuffer*></id3dxmesh*></p><p>  if(FAILED(hr))<br>  {</p><pre><code>  ::MessageBox(0, &quot;D3DXGeneratePMesh() - FAILED&quot;, 0, 0);  return false;</code></pre><p>   }<br>　　注意，因为顶点/品质权值的缘故，很难将Mesh简化到只有一个面，但是，如果将其指定为1，则可以将Mesh简化到最低。<br>　　在这一点上，渐进网格已经被产生了，但是假如你现在就渲染它，它将以最简化的方式来渲染。以为我们想开始渲染最高精度的mesh，所以我们设置它为：<br>  // set to original detail<br>  DWORD maxFaces = PMesh-&gt;GetMaxFaces();<br>   PMesh-&gt;SetNumFaces(maxFaces);<br> 在Display函数中，我们测试A键和S键并将结果输入。<br>bool Display(float timeDelta)<br>{<br>  if( Device )<br>  {</p><pre><code>  //  // Update: Mesh resolution.  //  // Get the current number of faces the pmesh has.  int numFaces = PMesh-&gt;GetNumFaces();  // Add a face, note the SetNumFaces() will  automatically  // clamp the specified value if it goes out of bounds.  if( ::GetAsyncKeyState(&#39;A&#39;) &amp; 0x8000f )  {      // Sometimes we must add more than one face to invert      // an edge collapse transformation      PMesh-&gt;SetNumFaces( numFaces + 1 );      if( PMesh-&gt;GetNumFaces() == numFaces )          PMesh-&gt;SetNumFaces( numFaces + 2 );  }  // Remove a face, note the SetNumFaces() will  automatically  // clamp the specified value if it goes out of bounds.  if( ::GetAsyncKeyState(&#39;S&#39;) &amp; 0x8000f )</code></pre><p>　　　　　　　　PMesh-&gt;SetNumFaces( numFaces - 1 );<br> 这是很简单的，但是要注意当增加面时我们有时必须增加两个面来完成ECT。<br>　　最后，我们就能象渲染ID3DXMesh对象一样来渲染ID3DXPMesh对象。另外，为了更加直观的观察网格的三角形数的变化情况，使用黄色材质在线框模式（Wireframe Mode）下渲染Mesh的三角形。</p><pre><code>  Device-&gt;Clear(0, 0, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xffffffff, 1.0f, 0);  Device-&gt;BeginScene();  for(int i = 0; i &lt; Mtrls.size(); i++)  {      // draw pmesh      Device-&gt;SetMaterial( &amp;Mtrls[i] );      Device-&gt;SetTexture(0, Textures[i]);      PMesh-&gt;DrawSubset(i);      // draw wireframe outline      Device-&gt;SetMaterial(&amp;d3d::YELLOW_MTRL);      Device-&gt;SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME);      PMesh-&gt;DrawSubset(i);      Device-&gt;SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);  }      Device-&gt;EndScene();  Device-&gt;Present(0, 0, 0, 0);</code></pre><p>  }<br>  return true;<br>}<br>　　<br>图11.3<br>11.4 界线容积（Bounding Volumes）<br>　　有时我们需要计算mesh的界线容积（边界范围）。常用的有两种类型：立方体和球。也有使用其它方法的，如圆柱体，椭球体，菱形体，胶囊形。图11.4演示了对同一个mesh分别使用立方体和球体类型。这一节我们只讨论立方体和球体两种边界形式。<br>　　<br>　　图11.4<br>　　边界盒/球常常被用来加速可见性测试，碰撞检测等。例如，假如一个mesh的边界盒/球不可见，那么我们就说mesh不可见。一个盒/球可见性测试是比分别测试mesh中的每个三角形要廉价的多。对于一个碰撞检测例子，如果一枚导弹点火起飞，我们需要检测它是否击中了同一场景中的目标。由于这些物体都是由大量三角形构成，我们可以依次检测每个对象的每个三角形，来测试导弹（可以用射线数学模型）是否碰撞到了这些三角形。这个方法需要进行多次的射线/三角形交点的运算。一个更好的方法是使用边界盒或边界球，计算射线与场景中的每个对象的边界盒/边界球的交点。如果射线与对象的边界范围相交，可以认为该对象被击中了。这是一个公平的近似方法，如果需要更高的精度，可以用边界范围法先去除那些明显不会相撞的对象，然后用更精确地方法检测很可能相撞的对象。如果边界范围检测发现相撞，则该对象就很有可能相撞。<br>　　D3DX库提供了计算mesh的边界盒和边界球的函数。这些函数使用顶点数组作为输入计算边界盒/球。这些函数本来就是设计的很灵活的，它们可以使用各种顶点格式：<br>HRESULT D3DXComputeBoundingSphere(<br>  LPD3DXVECTOR3 pFirstPosition,<br>  DWORD NumVertices,<br>  DWORD dwStride,<br>  D3DXVECTOR3<em> pCenter,<br>  FLOAT</em> pRadius<br>);</p></li><li>pFirstPosition——指向在顶点数组中第一个顶点的向量，描述顶点位置。</li><li>NumVertices——在顶点数组中的的顶点数。</li><li>dwStride——每个顶点的字节大小。这是很需要的，因为顶点结构可能有一些额外信息如法向量和纹理坐标，这些信息对计算边界又没有用，函数需要知道应该跳过多少字节来得到下一个顶点的位置。</li><li>pCenter——返回边界球的中心。</li><li>pRadius——返回边界球的半径。<br>HRESULT D3DXComputeBoundingBox(<br>  LPD3DXVECTOR3 pFirstPosition,<br>  DWORD NumVertices,<br>  DWORD dwStride,<br>  D3DXVECTOR3<em> pMin,<br>  D3DXVECTOR3</em> pMax<br>);<br>前三个参数和D3DXComputeBoundingSphere的前三个参数是完全一样的。最后两个参数分别用来返回边界盒的最小和最大点。<br>11.4.1一些新的特殊常量<br>让我来介绍两个常量，它们在本书中是经常要用到的。我们把它们添加到d3d名称空间中：<br>namespace d3d<br>{<br>  …<br>  const float INFINITY = FLT_MAX;<br>  const float EPSILON = 0.001f;<br>常量INFINITY是用来表示一个浮点数所能存储的最大数。因为我们找不到一个比FLT_MAX还要大的浮点数，我们可以将它视为无穷大。常量EPSILON是一个很小的值，我们这样定义它，凡是比它小的数就视为0。这也是很有必要的，因为得到的浮点是不精确的，一个被读作0的数可能有一点点小偏差。因此，让它和0比较相等肯定会失败。我们因此可以通过把该值与0的差值与EPSILON比较来确定是否相等：<br>bool Equals(float lhs, float rhs)<br>{<br>  // if lhs == rhs their difference should be zero<br>  return fabs(lhs - rhs) &lt; EPSILON ? true : false;<br>}<br>11.4.2界线容积类型<br> 为了更容易的使用边界盒和边界球，我们将它们分别封装到两个类中。现在在d3d名称空间中定义类：<br>struct BoundingBox<br>{<br>  BoundingBox();<br>  bool isPointInside(D3DXVECTOR3&amp; p);<br>  D3DXVECTOR3 _min;<br>  D3DXVECTOR3 _max;<br>};<br>struct BoundingSphere<br>{<br>  BoundingSphere();<br>  D3DXVECTOR3 _center;<br>  float _radius;<br>};<br>d3d::BoundingBox::BoundingBox()<br>{<br>  // infinite small bounding box<br>  _min.x = d3d::INFINITY;<br>  _min.y = d3d::INFINITY;<br>  _min.z = d3d::INFINITY;<br>  _max.x = -d3d::INFINITY;<br>  _max.y = -d3d::INFINITY;<br>  _max.z = -d3d::INFINITY;<br>}<br>bool d3d::BoundingBox::isPointInside(D3DXVECTOR3&amp; p)<br>{<br>  // is the point inside the bounding box?<br>  if(p.x &gt;= _min.x &amp;&amp; p.y &gt;= _min.y &amp;&amp; p.z &gt;= _min.z &amp;&amp;<pre><code>  p.x &lt;= _max.x &amp;&amp; p.y &lt;= _max.y &amp;&amp; p.z &lt;= _max.z)</code></pre>  {<pre><code>  return true;</code></pre>  }<br>  else<br>  {<pre><code>  return false;</code></pre>  }<br>}<br>d3d::BoundingSphere::BoundingSphere()<br>{<br>  _radius = 0.0f;<br>}<br>11.4.3实例程序：界线容积<br>　　在这一章中被叫做界线容积的实例程序主要是演示使用D3DXComputeBoundingSphere和D3DXComputeBoundingBox。程序读取一个X文件并且计算该mesh的边界球。它创建两个ID3DXMesh对象，一个用来作为边界球模型一个用来作为边界盒模型。X文件生成的mesh被渲染，其中的边界球或边界盒不可见（如图11.5）。你能够通过敲空格键来再边界球和边界盒之间切换。</li></ul><p>图11.5<br>　　这个例子是非常简单的，我们列出你要学习的代码。我们实现的两个函数是用来计算网格的边界球和边界盒的：<br>bool ComputeBoundingSphere(<br>        ID3DXMesh<em> mesh, // mesh to compute bounding sphere for<br>        d3d::BoundingSphere</em> sphere) // return bounding sphere<br>{<br>    HRESULT hr = 0;</p><pre><code>BYTE* v = 0;mesh-&gt;LockVertexBuffer(0, (void**)&amp;v);hr = D3DXComputeBoundingSphere(        (D3DXVECTOR3*)v,        mesh-&gt;GetNumVertices(),        D3DXGetFVFVertexSize(mesh-&gt;GetFVF()),        &amp;sphere-&gt;_center,        &amp;sphere-&gt;_radius);mesh-&gt;UnlockVertexBuffer();if( FAILED(hr) )    return false;return true;</code></pre><p>}</p><p>bool ComputeBoundingBox(<br>        ID3DXMesh<em> mesh, // mesh to compute bounding box for<br>        d3d::BoundingBox</em> box) // return bounding box<br>{<br>    HRESULT hr = 0;</p><pre><code>BYTE* v = 0;mesh-&gt;LockVertexBuffer(0, (void**)&amp;v);hr = D3DXComputeBoundingBox(        (D3DXVECTOR3*)v,        mesh-&gt;GetNumVertices(),        D3DXGetFVFVertexSize(mesh-&gt;GetFVF()),        &amp;box-&gt;_min,        &amp;box-&gt;_max);mesh-&gt;UnlockVertexBuffer();if( FAILED(hr) )    return false;return true;</code></pre><p>}<br>　　注意，类型转换(D3DXVECTOR3*)v假定顶点位置成员是被存储在我们所使用的顶点结构的开始位置。同样要注意我们能够使用D3DXGetFVFVertexSize函数来得到顶点结构的大小。<br>11.5 摘要(略)</p><p>第十二章 创建灵活的摄像机类<br>(Building a Flexible Camera Class)<br>　　迄今，我们已经使用过D3DXMatrixLookAtLH函数来计算视图空间变换矩阵。这个函数对于在固定位置布置和对准摄像机是非常好用的，不过它的用户接口对于要响应用户输入来实现摄像机移动就不那么好用了。这就激发我们用我们自己的方法来解决。在这一章我们展示了怎样实现一个Camera类，它使我们能够比D3DXMatrixLookAtLH函数更好地操作摄像机，并且可以用来作为飞行模拟摄像机和第一人称视角摄像机。<br>目标</p><ul><li>学习怎样实现一个灵活的摄像机类，它可以用作飞行模拟摄像机和第一人称视角摄像机。<br>12.1 摄像机设计<br>　　我们定义一个相对于世界坐标系的位置和摄像机的方向，这里使用四个摄像机向量：right vector ,  up vector, look vector 以及 position vector, 如图12.1所示。这些向量用来为摄像机定义一个坐标系来描述在世界坐标中的对应关系。因为 right ，up 和 look 向量定义了摄像机在世界中的方向，我们有时把它们三个向量一起称为方向向量（orientation vectors）。方向向量必须被标准化。假如彼此互相垂直且都是单位长度，那么我们就称它们是正交标准化向量。我们做这些限制是因为等一会儿我们要将方向向量插入到一个行矩阵中。因为行向量是正交标准化的，所以该矩阵也就是直交矩阵。回忆一下，直交矩阵有一个特性就是它的逆矩阵等于它的转置矩阵。这在等一下的12.2.1.2节中是很有用的。</li></ul><p>图12.1<br>　　有了这四个向量来描述摄像机，我们的摄像机就能够按照下面六种方式变化了：</p><ul><li>围绕right向量旋转（pitch倾斜）</li><li>围绕up向量旋转（yaw 偏航）</li><li>围绕look向量旋转（roll 滚转）</li><li>沿着right向量平移（strafe）</li><li>沿着up向量飞行（fly）</li><li><p>沿着look向量移动（move）<br>通过这六种操作，我们能够沿着三个轴移动以及饶着三个轴旋转，这给了我们一个六度的自由。下面的Camera类定义了我们要的描述数据以及想要的方法：<br>class Camera<br>{<br>public:<br>  enum CameraType { LANDOBJECT, AIRCRAFT };<br>  Camera();<br>  Camera(CameraType cameraType);<br>  ~Camera();</p><p>  void strafe(float units); // left/right<br>  void fly(float units);    // up/down<br>  void walk(float units);   // forward/backward<br>  void pitch(float angle); // rotate on right vector<br>  void yaw(float angle);   // rotate on up vector<br>  void roll(float angle);  // rotate on look vector</p><p>  void getViewMatrix(D3DXMATRIX<em> V);<br>  void setCameraType(CameraType cameraType);<br>  void getPosition(D3DXVECTOR3</em> pos);<br>  void setPosition(D3DXVECTOR3<em> pos);<br>  void getRight(D3DXVECTOR3</em> right);<br>  void getUp(D3DXVECTOR3<em> up);<br>  void getLook(D3DXVECTOR3</em> look);<br>private:<br>  CameraType  _cameraType;<br>  D3DXVECTOR3 _right;<br>  D3DXVECTOR3 _up;<br>  D3DXVECTOR3 _look;<br>  D3DXVECTOR3 _pos;<br>};<br>在类中我们定义了一个还没有讨论的CameraType枚举类型。目前，我们的摄像机支持两种摄像机模式，LANDOBJECT模式和AIRCRAFT模式。AIRCRAFT模式允许我们在空间中完全自由的移动。不过，在有些游戏中，比如第一人称设计游戏，人是不能飞的；因此我们必须限制它在某些轴上的运动。指定为LANDOBJECT模式的摄像机就限制了这些，你可以在下一部分看见。<br>12.2 执行详细资料<br>12.2.1计算视图矩阵<br>　　我们现在演示怎样根据摄像机向量来计算视图矩阵变换的。让 p = (px, py, pz), r = (rx, ry, rz), u = (ux, uy, uz) 以及 d = (dx, dy, dz) 分别表示 position, right, up 以及 look 向量。<br>　　回忆第二章我们所说的，视图空间变换是指在世界坐标系中进行几何变换以便将照相机平移变换到坐标系的源点并把它的方向旋转至朝向Z轴的正方向（如图12.2）。</p></li></ul><p>图12.2<br>因此，我们希望有一个象这样的变换矩阵V ：</p><ul><li>pV = (0, 0, 0)—矩阵V能将摄像机移动到原点。</li><li>rV = (1, 0, 0)—矩阵V能将摄像机的right向量与世界坐标系中的x轴对齐。</li><li>uV = (0, 1, 0)—矩阵V能将摄像机的up向量与世界坐标系中的y轴对齐。</li><li>dV = (0, 0, 1)—矩阵V能将摄像机的look向量与世界坐标系中的z轴对齐。<br>我们能将变换任务分为两个部分：1）平移部分，将摄像机的位置移动到原点；2）旋转部分，将摄像机的方向向量与世界坐标系的轴对齐。<br>12.2.1.1 第一部分：平移<br>　　平移只需要利用 –p 就可简单地将 p 移动到原点，因为 p–p=0。因此我们能够用下面的矩阵来描述视图变换中的平移部分：<br>　　<br>12.2.1.2 第二部分：旋转<br>　　矫正摄像机的三个方向向量使其与世界坐标系的轴对齐需要更多的工作。我们需要一个3<em>3的旋转矩阵A ，它能将right，up和look分别与x-，y-以及z轴对齐。这个矩阵将满足如下三个等式：<br>　　<br>注意：我们在这里使用3</em>3矩阵来工作是因为现在不需要额外的信息来表现旋转。等一下我们将它增加到常用的4<em>4矩阵。<br>　　因为这三个等式都有一个相同系数矩阵A ，所以我们能够把它们合在一起。我们把它们从新写到一起来：<br>　　<br>　　求A有很多方法，但是我们知道A是B逆矩阵因为BA = BB-1 = I。因为B 是一个直交矩阵（它的行向量是正交标准化的），我们知道它的逆矩阵就是它的转置矩阵。因此，将方向向量和世界坐标系中的坐标轴对齐的变换如下：<br>　　<br>12.2.1.3 将两部分合并<br>　　最后，将A增加为4</em>4矩阵，同时将平移部分合并到旋转部分形成的视图变换矩阵V：</li></ul><p>我们在Camera::getViewMatrix方法中建立这个矩阵：<br>void Camera::getViewMatrix(D3DXMATRIX* V)<br>{<br>    // Keep camera’s axes orthogonal to eachother<br>    D3DXVec3Normalize(&amp;_look, &amp;_look);<br>    D3DXVec3Cross(&amp;_up, &amp;_look, &amp;_right);<br>    D3DXVec3Normalize(&amp;_up, &amp;_up);<br>    D3DXVec3Cross(&amp;_right, &amp;_up, &amp;_look);<br>    D3DXVec3Normalize(&amp;_right, &amp;_right);</p><pre><code>// Build the view matrix:float x = -D3DXVec3Dot(&amp;_right, &amp;_pos);float y = -D3DXVec3Dot(&amp;_up, &amp;_pos);float z = -D3DXVec3Dot(&amp;_look, &amp;_pos);(*V)(0,0) = _right.x; (*V)(0, 1) = _up.x; (*V)(0, 2) = _look.x; (*V)(0, 3) = 0.0f;(*V)(1,0) = _right.y; (*V)(1, 1) = _up.y; (*V)(1, 2) = _look.y; (*V)(1, 3) = 0.0f;(*V)(2,0) = _right.z; (*V)(2, 1) = _up.z; (*V)(2, 2) = _look.z; (*V)(2, 3) = 0.0f;(*V)(3,0) = x;        (*V)(3, 1) = y;     (*V)(3, 2) = z;       (*V)(3, 3) = 1.0f;</code></pre><p>}<br>你可能想知道方法中前面几行代码是干什么的。在几次旋转后，摄像机的方向向量可能变的不相互垂直了。因此，每当该函数被调用时，我们根据look向量从新计算up和right向量，使它们保持相互垂直。新的up向量是这样计算的up = look × right。 接着新的right向量是这样计算的right = up × look。<br>12.2.2围绕任意轴旋转<br>为了实现我们的摄像机旋转方法，我们需要能够绕着任意轴旋转。D3DX库提供下面的函数来解决这个问题：<br>D3DXMATRIX <em>D3DXMatrixRotationAxis(<br>    D3DXMATRIX </em>pOut, // returns rotation matrix<br>    CONST D3DXVECTOR3 *pV, // axis to rotate around<br>    FLOAT Angle // angle, in radians, to rotate<br>);<br>　　<br>　　图12.3<br>例如，假如我们想绕向量（0.707, 0.707, 0）轴旋转π/2角度。我们可以这样写：<br>D3DXMATRIX R;<br>D3DXVECTOR3 axis(0.707f, 0.707f, 0.0f);<br>D3DXMatrixRotationAxis(&amp;R, &amp;axis, D3DX_PI / 2.0f);<br>D3DXMatrixRotationAxis的变换矩阵的来源你可以在Eric Lengyel的 Mathematics for 3D Game Programming &amp;Computer Graphics中找到。<br>12.2.3 Pitch、Yaw和Roll<br>因为方向向量描述了摄像机相对于世界坐标系的方向，我们必须考虑在使用倾斜（pitch）、偏航（yaw）和滚转（roll）时及时更新方向向量。这其实也是非常简单的。图12.4，12.5，12.6分别显示了摄像机的倾斜、偏航和滚转操作。</p><p>图12.4</p><p>图12.5</p><p>图12.6<br>当倾斜（pitch）时，我们需要将up和look向量绕着right向量旋转一定角度。同样的，当偏航（yaw）时，我们需要将look和right向量绕着up向量旋转一定角度。最后，当滚转（roll）时，我们需要将up和right向量绕着look向量旋转一定角度。<br>　　我们现在明白了为什么D3DXMatrixRotationAxis函数是非常必要的，因为这三个向量中的任何一个都可能围绕世界坐标系中的任意轴旋转。<br>　　对于倾斜（pitch）、偏航（yaw）和滚转（roll）的执行我们已经讨论了。然而，对于LANDOBJECT模式就有一些限制。我们在偏航（yaw）方法中只围绕y轴旋转，我们完全屏蔽滚转（roll）。当然你可以根据你的程序需要来改变Camera类。我们这里只是一个示例而已。<br>倾斜（pitch）、偏航（yaw）和滚转（roll）方法代码的具体实现如下：<br>void Camera::pitch(float angle)<br>{<br>    D3DXMATRIX T;<br>    D3DXMatrixRotationAxis(&amp;T, &amp;_right,    angle);</p><pre><code>// rotate _up and _look around _right vectorD3DXVec3TransformCoord(&amp;_up,&amp;_up, &amp;T);D3DXVec3TransformCoord(&amp;_look,&amp;_look, &amp;T);</code></pre><p>}</p><p>void Camera::yaw(float angle)<br>{<br>    D3DXMATRIX T;</p><pre><code>// rotate around world y (0, 1, 0) always for land objectif( _cameraType == LANDOBJECT )    D3DXMatrixRotationY(&amp;T, angle);// rotate around own up vector for aircraftif( _cameraType == AIRCRAFT )    D3DXMatrixRotationAxis(&amp;T, &amp;_up, angle);// rotate _right and _look around _up or y-axisD3DXVec3TransformCoord(&amp;_right,&amp;_right, &amp;T);D3DXVec3TransformCoord(&amp;_look,&amp;_look, &amp;T);</code></pre><p>}</p><p>void Camera::roll(float angle)<br>{<br>    // only roll for aircraft type<br>    if( _cameraType == AIRCRAFT )<br>    {<br>        D3DXMATRIX T;<br>        D3DXMatrixRotationAxis(&amp;T, &amp;_look,    angle);</p><pre><code>    // rotate _up and _right around _look vector    D3DXVec3TransformCoord(&amp;_right,&amp;_right, &amp;T);    D3DXVec3TransformCoord(&amp;_up,&amp;_up, &amp;T);}</code></pre><p>}<br>12.2.4 Walking、Strafing和Flying<br>当提到walking时，我们的意思是在我们观察的方向上移动位置（也就是说，沿着look向量）。Strafing是说在我们观察方向的左右移动，也就是沿着right向量移动。最后，我们说flying就是沿着up向量移动。为了沿着这些轴移动，我们只需要简单地加一个向量就可以了（如图12.7）。</p><p>图12.7<br>就象旋转一样，我们需要对移动作一些限制。例如，LANDOBJECT不允许飞起来。因此我们把移动限制在xz平面。然而，因为LANDOBJECT能够允许爬楼梯和登山，所以，我们设置Camera::setPosition方法，它允许你手动设置你的摄像机位置来达到你的高度和位置。<br>    移动（walk）、平移（strafe）和飞行（fly）方法代码的具体实现如下：<br>void Camera::walk(float units)<br>{<br>    // move only on xz plane for land object<br>    if( _cameraType == LANDOBJECT )<br>        _pos += D3DXVECTOR3(_look.x, 0.0f, _look.z) <em> units;<br>    if( _cameraType == AIRCRAFT )<br>        _pos += _look </em> units;<br>}<br>void Camera::strafe(float units)<br>{<br>    // move only on xz plane for land object<br>    if( _cameraType == LANDOBJECT )<br>        _pos += D3DXVECTOR3(_right.x, 0.0f, _right.z) <em> units;<br>    if( _cameraType == AIRCRAFT )<br>        _pos += _right </em> units;<br>}<br>void Camera::fly(float units)<br>{<br>    // move only on y-axis for land object<br>    if( _cameraType == LANDOBJECT )<br>        _pos.y += units;<br>    if( _cameraType == AIRCRAFT )<br>        _pos += _up * units;<br>}<br>12.3实例程序：摄像机<br>　　这一章的实例程序是创建和渲染一个如图12.8所示的场景。你能够通过键盘输入在场景中自由地飞行。下面是相应键盘设置：</p><ul><li>W/S—向前/向后移动</li><li>A/D—向左/向右平移</li><li>R/F—向上/向下飞行</li><li>Up/Down方向键—倾斜</li><li>Left/Right方向键—偏航</li><li>N/M—滚转</li></ul><p>图12.8<br>　　例子的执行是非常简单的，因为所有工作都包含在摄像机类中了，这些我们都已经讨论过了。我们在Display函数中获得键盘的输入。记住，我们在全局域中实例化了一个摄像机类对象TheCamera。同样注意我们使用时间变化量来控制移动摄像机；这可以排除帧速度的影响而稳定地移动。<br>bool Display(float timeDelta)<br>{<br>    if( Device )<br>    {<br>        //<br>        // Update: Update the camera.<br>        //</p><pre><code>    if( ::GetAsyncKeyState(&#39;W&#39;) &amp; 0x8000f )        TheCamera.walk(4.0f * timeDelta);    if( ::GetAsyncKeyState(&#39;S&#39;) &amp; 0x8000f )        TheCamera.walk(-4.0f * timeDelta);    if( ::GetAsyncKeyState(&#39;A&#39;) &amp; 0x8000f )        TheCamera.strafe(-4.0f * timeDelta);    if( ::GetAsyncKeyState(&#39;D&#39;) &amp; 0x8000f )        TheCamera.strafe(4.0f * timeDelta);    if( ::GetAsyncKeyState(&#39;R&#39;) &amp; 0x8000f )        TheCamera.fly(4.0f * timeDelta);    if( ::GetAsyncKeyState(&#39;F&#39;) &amp; 0x8000f )        TheCamera.fly(-4.0f * timeDelta);    if( ::GetAsyncKeyState(VK_UP) &amp; 0x8000f )        TheCamera.pitch(1.0f * timeDelta);    if( ::GetAsyncKeyState(VK_DOWN) &amp; 0x8000f )        TheCamera.pitch(-1.0f * timeDelta);    if( ::GetAsyncKeyState(VK_LEFT) &amp; 0x8000f )        TheCamera.yaw(-1.0f * timeDelta);                if( ::GetAsyncKeyState(VK_RIGHT) &amp; 0x8000f )        TheCamera.yaw(1.0f * timeDelta);    if( ::GetAsyncKeyState(&#39;N&#39;) &amp; 0x8000f )        TheCamera.roll(1.0f * timeDelta);    if( ::GetAsyncKeyState(&#39;M&#39;) &amp; 0x8000f )        TheCamera.roll(-1.0f * timeDelta);    // Update the view matrix representing the cameras     // new position/orientation.    D3DXMATRIX V;    TheCamera.getViewMatrix(&amp;V);    Device-&gt;SetTransform(D3DTS_VIEW, &amp;V);    //    // Render    //    Device-&gt;Clear(0, 0, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0);    Device-&gt;BeginScene();    d3d::DrawBasicScene(Device, 1.0f);    Device-&gt;EndScene();    Device-&gt;Present(0, 0, 0, 0);}return true;</code></pre><p>}<br>注意：我们已经用一个新的函数DrawBasicScene更新了d3d名称空间。这个函数绘制了如图12.8的场景。我们已经将其添加进了d3d名称空间，这是因为对于建立一个基本的场景它是一个非常方便的函数。以后的例子我们就可以集中精力在例子代码中而不需要关注这些不相关的绘制场景的代码了。它是在d3dUtility.h中被声明的：<br>    // Function references “desert.bmp” internally.  This file must<br>    // be in the working directory.<br>    bool DrawBasicScene(<br>        IDirect3DDevice9* device,// Pass in 0 for cleanup.<br>        float scale);            // uniform scale<br>如果该函数不能任何东西也就是什么都显示不出来，你就需要看看相应的代码了。你可以在本章的代码中找到它。注意这个函数需要调用一张desert.bmp图片用作纹理。当然该文件也可以在同一个文件夹下找到。<br>12.4 摘要<br>   我们以四个向量来描述在世界坐标系中照相机的位置和方向：right、up、look、position向量，藉由这个描述, 我们能轻易的实现一个自由的六角度照相机，为游戏中的模拟飞行器、第一人称视角的游戏玩家提供了一个灵活的照相机接口。</p><p>第十三章 地形渲染基础<br>(Basic Terrain Rendering)<br>   实际上，地形网格不比三角形网格复杂，图13.1.(a)所示，网络的每个顶点指定了高度，格子模型用这种方式显示从山脉到河流的平滑过渡。图13.1 (b)，模拟自然地形。当然，我们可以用漂亮的纹理表现沙石地，绿色的山丘。图13.1.(c)雪山效果。</p><p>图 13.1: (a) 三角网格. (b) 平滑高度过渡的三角网格. (c) 光和纹理，我们在这一章节中写的例子的一个屏幕截图。<br>   这一章的内容是实现一个Terrain（地形）类。这个类的功能很强。我们的意思是，它只是储存整个地形的顶点/索引数据，然后渲染它。因为如果游戏需要一个小的地形，那么它能够在现代图形卡支持的硬件顶点处理下工作。然而实际上，游戏需要大量的地形，你必须对细节做某种（级别）程度的捡选，因为模型需要大量的几何数据，这样大的地形对于再强大的处理方法也是无法处理的。</p><p>目标 </p><ul><li>学习怎样生成地形的高度信息，它能使山丘、河流等地带的平滑的过度，模拟自然界的地形。</li><li>了解怎样生成地形的顶点和三角形数据。</li><li>学习使用地形的纹理和光照.</li><li>找到控制地形上照相机位置的方法，以便模拟在地形上走动。</li></ul><p>13.1 Heightmaps（高度图）<br>   我们使用高度图去描述地形上的山丘、河流。高度图是一个数组，数组中的每个成员指定地形顶点描述中的高度信息。我们经常把高度图想像成一个矩阵，因为每个元素都一一对应于每个地形网格中的顶点。<br>   当我们保存高度图到磁盘上时，我们通常为高度图的每个元素分配1个byte的内存，所以高度的范围是0..255，0..255的范围对于地形的高度之间保持平滑过渡是足够用的。但为了在我们的程序中匹配3D世界中的物体，可能需要的范围在0..255以外。例如，我们在3D世界中的测量单位是英尺，那么0..255的范围对于表现任何有趣的东西是不够的。因此，当我们读取数据进应用程序时，给每个高度元素分配一个整型数（或浮点型），它允许我们很好的缩放0..255范围之外的任何大小的物品。<br>   高度图图形表示法这一是灰度图(grayscale map)。较黑的值表示地形中较低的地方，较白的值表现地形中较高的地方。</p><pre><code> 图13.2: 高度图的灰度图表示</code></pre><p>13.1.1 创建高度图（Heightmap）<br>   高度图不是用程序生成就是用图像编辑器生成，比如：Adobe Photoshop。使用图像编辑器大概是最容易的方法了。当你想生成地形时，可以交互式的可视化的创建。你可以利用图像编辑器的功能，比如：过滤器，创建一个有趣的高度图，图13.3显示了一个用Adobe Photoshop图像编辑器的工具创建的金字塔形的高度图。注意：当创建图像时我们指定一个灰度图类型。</p><pre><code> 图13.3 一幅用Adobe Photoshop创建的灰度图 一但你画完了你的高度图，你必须将它保存为一个8bit的RAW文件。RAW文件只图像的逐个字节。我们的应用程序可以非常容易的读这样的图像。你的软件可能告诉你保存的RAW文件是有文件头的还是没有文件头的。 注意：用RAW格式保存高度信息不是必须的；你可以用符合你需要的任何格式。RAW格式是我们能使用的的格式之一。我决定使用RAW格式是因为很多流行的图像编辑器支持导出这种格式，而且应用程序读取RAW文件的数据非常简单。这章中有使用8-bit RAW文件的例子。</code></pre><p>13.1.2 读取RAW文件<br>   RAW文件与一段连续的bit内存块没什么分别。我们能用很简单的方法读取这段内存块，注意：变量_heightmap是Terrain类的一个成员，定义如下 ：<br>std::vector<int> _heightmap;<br>bool Terrain::readRawFile(std::string fileName)<br>{<br>     // A height for each vertex<br>     std::vector<byte> in(  numVertices );<br>     std::ifstream inFile(fileName.c_str(), std::ios_base::binary);<br>     if( inFile == 0 )<br>          return false;<br>     inFile.read(<br>          (char*)&amp;in[0], // buffer<br>          in.size());// number of bytes to read into buffer<br>     inFile.close();</byte></int></p><pre><code> // copy BYTE vector to int vector _heightmap.resize( _numVertices ); for(int i = 0; i &lt; in.size(); i++)      _heightmap[i] = in[i]; return true;</code></pre><p>}<br>   我们COPY一个bytes向量到一个整形向量，这样做我们能够缩放 [0,255]以外的高度。这个方法唯一限制是：RAW文件必须读入至少与地形的顶点数一样多的高度信息。因此，如果你读取一个256x256 的RAW文件，你的地形也必须包含256x256个顶点。</p><p>13.1.3 访问与修改Heightmap<br>     Terrain类提供以下2个方法访问和修改Heightmap的入口。<br>int Terrain::getHeightmapEntry(int row, int col)<br>{<br>      return _heightmap[row * _numVertsPerRow + col];<br>}</p><p>void Terrain::setHeightmapEntry(int row, int col, int value)<br>{<br>     _heightmap[row * _numVertsPerRow + col] = value;<br>}<br>   这些方法允许我们以行和列来访问入口，并且隐藏方法。当使用它去描述矩阵时，我们必须将一个线性数组编入索引。<br>（These methods allow us to refer to an entry by row and column and hide the way we must index a linear array when using it to describe a matrix）</p><p>13.2 生成地形几何数据<br>   图13.4显示Terrain类的一些属性、词汇和我们提到的一些关键点。我们定义地形的大小，指定每行、每列顶点的数量，和单元的间隔。传递这些值到Terrain类的构造器中。另外，也传递地形所关联的设备，一个包含高度图数据的字符串文件名，一个用来缩放高度图成员的高度缩放值。</p><pre><code>     图13.4：三角形网络的属性，延着方格线上的点是地形的顶点。</code></pre><p>class Terrain<br>{<br>public:<br>     Terrain(<br>          IDirect3DDevice9* device,<br>          std::string heightmapFileName,<br>          int numVertsPerRow,<br>          int numVertsPerCol,<br>          int cellSpacing,    // space between cells<br>          float heightScale); // value to scale heights by</p><pre><code> ... methods snipped</code></pre><p>private:<br>     …device/vertex buffer etc snipped</p><pre><code> int _numVertsPerRow; int _numVertsPerCol; int _cellSpacing; int _numCellsPerRow; int _numCellsPerCol; int _width; int _depth; int _numVertices; int _numTriangles; float _heightScale;</code></pre><p>};<br>   Terrain类定义的全部的源代码，实在是太多了，无法在这里全部包含进来。根据传递给构造器的值，我们能够计算Terrain类的其他变量：<br>_numCellsPerRow  = _numVertsPerRow - 1;<br>_numCellsPerCol  = _numVertsPerCol - 1;<br>_width           = _numCellsPerRow <em> _cellSpacing;<br>_depth           = _numCellsPerCol </em> _cellSpacing;<br>_numVertices     = _numVertsPerRow <em> _numVertsPerCol;<br>_numTriangles    = _numCellsPerRow </em> _numCellsPerCol * 2;</p><p>   Terrain类定义的顶点结构：<br>struct TerrainVertex<br>{<br>     TerrainVertex(){}<br>     TerrainVertex(float x, float y, float z, float u, float v)<br>     {<br>          _x = x; _y = y; _z = z; _u = u; _v = v;<br>     }<br>     float _x, _y, _z;<br>     float _u, _v;</p><pre><code> static const DWORD FVF;</code></pre><p>};<br>   注意：TerrainVertex是Terrain类内部的一个嵌套类（译者：看样子是结构啊？），之所以这么做，是因为它在Terrain类外部基本没有什么用处。<br>13.2.1 计算顶点<br>   在图13.4中，计算三角形网格上的顶点，我们只是在开始产生顶点的地方，一行一行的生成顶点数据，直到结束为止。单元格的顶点与顶点之间有一块空白区域，这会让我们取得x、z坐标，但y坐标是什么呢？得到y坐标很容易，当读取高度图数据结构时会找到对应的入口。<br>   注意：这个操作使用一个巨大的顶点缓存去保存所有地形上的所有顶点。这可能会引起硬件局限性的问题。例如：一个原始计数界限的最大值和3D设备设定的最大的顶点索引界限。检查MaxPrimitiveCount和D3DCAPS9结构的MaxVertexlndex成员，查看你的设备的限定值，在13.7节讨论，使用顶点缓存时存在问题和解决方法。<br>   计算纹理坐标，看图13.5，给我们一个简单的设定，允许我们用(u, v)纹理坐标去对应地形顶点坐标。</p><p>   图13.5：地形顶点与纹理顶点之间一一对应。<br>   u = j uCoordIncrementSize<br>   v = i vCoordIncrementSize<br>   And where:</p><p>   最后，用代码生成顶点：<br>bool Terrain::computeVertices()<br>{<br>     HRESULT hr = 0;</p><pre><code> hr = _device-&gt;CreateVertexBuffer(      _numVertices * sizeof(TerrainVertex),      D3DUSAGE_WRITEONLY,      TerrainVertex::FVF,      D3DPOOL_MANAGED,      &amp;_vb,      0); if(FAILED(hr))      return false; // 对应第一个生成的顶点坐标 int startX = -_width / 2; int startZ =  _depth / 2; // 对应最后一个生成的顶点坐标 int endX =  _width / 2; int endZ = -_depth / 2; // compute the increment size of the texture coordinates // from one vertex to the next. float uCoordIncrementSize = 1.0f / (float)_numCellsPerRow; float vCoordIncrementSize = 1.0f / (float)_numCellsPerCol; TerrainVertex* v = 0; _vb-&gt;Lock(0, 0, (void**)&amp;v, 0); int i = 0; for(int z = startZ; z &gt;= endZ; z -= _cellSpacing) {      int j = 0;      for(int x = startX; x &lt;= endX; x += _cellSpacing)      {           // compute the correct index into the vertex buffer           // and heightmap based on where we are in the nested           // loop.           int index = i * _numVertsPerRow + j;           v[index] = TerrainVertex(                (float)x,                (float)_heightmap[index],                (float)z,                (float)j * uCoordIncrementSize,                (float)i * vCoordIncrementSize);           j++; // next column      }      i++; // next row } _vb-&gt;Unlock(); return true;</code></pre><p>}</p><p>13.2.2 计算索引-定义三角形<br>   计算三角形网格的索引，只需要循环访问每一个格子，从左上到右下，如图13.4，并且计算组成格子的2个三角形。</p><p>这里的技巧是：提取出计算第ij格子的2个三角形的公式。用图13.6去推导公式，找到第ij的格子：</p><p>?ABC = {i · numVertsPerRow + j i·numVertsPerRow + j + 1 (i + 1). numVertsPerRow + j}<br>?CBD = {(i + 1) numVertsPerRow + j i·numVertsPerRow + j + 1 (i·l) numVertsPerRow + j + 1} </p><p>图13.6 方格的顶点</p><p>代码生成索引：<br>bool Terrain::computeIndices()<br>{<br>     HRESULT hr = 0;</p><pre><code> hr = _device-&gt;CreateIndexBuffer(      _numTriangles * 3 * sizeof(WORD), // 每个三角形有3个索引      D3DUSAGE_WRITEONLY,      D3DFMT_INDEX16,      D3DPOOL_MANAGED,      &amp;_ib,      0); if(FAILED(hr))      return false; WORD* indices = 0; _ib-&gt;Lock(0, 0, (void**)&amp;indices, 0); // 将组成一个方格的2个三角形的一组6个索引的开始位置编入索引 int baseIndex = 0; // 从头到尾计算每一个格子中的三角形 for(int i = 0; i &lt; _numCellsPerCol; i++) //行循环 {      for(int j = 0; j &lt; _numCellsPerRow; j++) //列循环      {           indices[baseIndex]     =   i   * _numVertsPerRow + j;           indices[baseIndex + 1] =   i   * _numVertsPerRow +                                                 j + 1;           indices[baseIndex + 2] = (i+1) * _numVertsPerRow + j;           indices[baseIndex + 3] = (i+1) * _numVertsPerRow + j;           indices[baseIndex + 4] =   i   * _numVertsPerRow +                                                 j + 1;           indices[baseIndex + 5] = (i+1) * _numVertsPerRow +                                                 j + 1;           // next quad           baseIndex += 6;      } } _ib-&gt;Unlock(); return true;</code></pre><p>}<br>;</p><p>13.3 纹理<br>   Terrain类提供2个方法去处理地形的纹理。最简单的方法是简单地读取一个已经制作好的纹理文件并使用它，下面的方法使用Terrain类实现将一个文件读取纹理到_tex成员中，然后指向一个IDirect3DTexture9接口的指针。关键是，在地形渲染之前先用Terrain: :draw方法设置_tex。<br>   到目前为止，书中的实现对于读者来说还是比较容易的。<br>bool Terrain::loadTexture(std::string fileName)<br>{<br>     HRESULT hr = 0;</p><pre><code> hr = D3DXCreateTextureFromFile(      _device,      fileName.c_str(),      &amp;_tex); if(FAILED(hr))      return false; return true;</code></pre><p>}</p><p>13.3.1 程序上的处理方法<br>   一个可选择的方法是用程序计算地形的纹理，就是说，我们创建一个空纹理，根据定义的参数用代码计算每一个部分的颜色，在例子中，参数是地形的高度。<br>   我们用Terrain::genTexture方法用程序去生成纹理，首先用D3DXCreateTexture方法创建一个空的纹理，锁定高度级别（top level，纹理图的一个成员，有多个级别），不断的循环每一个texel（图素）并给它上色，texel的颜色取决于与方格对应的高度（近似高度）。我们的想法是：地形中较低的地方是沙滩色，中间的地方像是绿色的小山丘，较高的地方颜色好像雪山。我们定义的高度是方格中左上角的近似高度。<br>   一旦每个texel都有了颜色，我们想让每一个texel变暗或是变亮，这基于光打在格子中对应的texel上的角度，由Terrain::lightTerrain方法实现。（Once we have a color for each texel, we want to darken or brighten each texel based on the angle at which sunlight (modeled by a directional light) strikes the cell to which the texel corresponds. This is done in the Terrain::lightTerrain method）<br>   Terrain::genTexture方法通过计算lower mipmap级别的texels来得出结论，它是通过D3DXFilterTexture函数实现。用代码生成纹理：<br>bool Terrain::genTexture(D3DXVECTOR3* directionToLight)<br>{<br>     // Method fills the top surface of a texture procedurally. Then<br>     // lights the top surface. Finally, it fills the other mipmap<br>     // surfaces based on the top surface data using<br>     // D3DXFilterTexture.</p><pre><code> HRESULT hr = 0; // texel for each quad cell int texWidth  = _numCellsPerRow; int texHeight = _numCellsPerCol; // create an empty texture hr = D3DXCreateTexture(      _device,      texWidth, texHeight,  // dimensions      0,                    // create a complete mipmap chain      0,                    // usage - none      D3DFMT_X8R8G8B8,      // 32-bit XRGB format      D3DPOOL_MANAGED,      // memory pool      &amp;_tex); if(FAILED(hr))      return false; D3DSURFACE DESC textureDesc; _tex-&gt;GetLevelDesc(0 /*level*/, &amp;textureDesc); // make sure we got the requested format because our code // that fills the texture is hard coded to a 32-bit pixel depth. if( textureDesc.Format != D3DFMT_X8R8G8B8 )      return false; D3DLOCKED_RECT lockedRect; _tex-&gt;LockRect(0/*lock top surface*/, &amp;lockedRect,       0 /* lock entire tex*/, 0/*flags*/); // fill the texture DWORD* imageData = (DWORD*)lockedRect.pBits; for(int i = 0; i &lt; texHeight; i++) {      for(int j = 0; j &lt; texWidth; j++)      {      D3DXCOLOR c;      // get height of upper-left vertex of quad.      float height = (float)getHeightmapEntry(i, j)/_heightScale;      // set the color of the texel based on the height      // of the quad it corresponds to.      if( (height) &lt; 42.5f )       c = d3d::BEACH SAND;      else if( (height) &lt; 85.0f )  c = d3d::LIGHT YELLOW GREEN;      else if( (height) &lt; 127.5f ) c = d3d::PUREGREEN;      else if( (height) &lt; 170.0f ) c = d3d::DARK YELLOW GREEN;      else if( (height) &lt; 212.5f ) c = d3d::DARKBROWN;      else                         c = d3d::WHITE;      // fill locked data, note we divide the pitch by four      // because the pitch is given in bytes and there are      // 4 bytes per DWORD.      imageData[i * lockedRect.Pitch / 4 + j] = (D3DCOLOR)c;      } } _tex-&gt;UnlockRect(0); // light the terrain if(!lightTerrain(directionToLight)) {       ::MessageBox(0, &quot;lightTerrain() - FAILED&quot;, 0, 0);       return false; } // fill mipmaps hr = D3DXFilterTexture(      _tex,// texture to fill mipmap levels      0,   // default palette       0,   // use top level as source for lower levels       D3DX_DEFAULT); // default filter if (FAILED (hr)) {       ::MessageBox(0, &quot;D3DXFilterTexture() - FAILED&quot;, 0, 0);       return false; } return true;</code></pre><p>}</p><p>注意：颜色常量BEACH_SAND等定义在d3dUtility.h.文件中。</p><p>13.4 光照<br>   Terrain::genTexture方法会调用Terrain::lightTerrain，顾名思义，光照使地形更接近于现实。当我们已经计算完地形纹理以后，我们只需要计算阴影系数（shade factor），使一个定义了光源的地形区域变亮或变暗。在这一节中，我们检验这样一个技巧，你会惊讶于为什么我们照亮地图却没有让Direct3D来做。我们自己来计算有三个好处：</p><ul><li>内存中不必保存顶点法线。</li><li>因为纹理是静态的，所以不能随意的移动光源。虽然我们可以重新计算光源，但因此采用Direct3D实时的照亮地形是很耗时的。</li><li>我们获得了一些数学上的经验，熟悉了一些基本的光照概念，并且是用Direct3D函数实践的。</li></ul><p>13.4.1概览(OVERVIEW)<br>   光照是计算地形阴影（shade）的一个最基本的技巧之一，一般认为的光是漫射光（diffuse lighting），我们定义一个平行光源，指定光的方向，延着光线的相反方向是散发平行光的光源。因此，如果我们想让光线从空中笔直落下，那么lightRaysDirection = (0, -1, 0)，按相反的方向：directionToLight = (0, 1, 0)。注意：创建光照向量要使用单位向量。<br>   注意：虽然指定方向的光是从光源发射出来的，这么说更直接一点，指定方向的光在计算上要比漫谢光更合得来。<br>   对于地形中的每个方格，我们计算光的向量与方格的面法线之间的角度。<br>   在图13.7中我们看到，当角度变得比较大时，方格的面离光源越来越远，接收的光越少。反过来说，角度变小，方格的面则离光源越来越近，相应的会接收更多的光。注意：一旦光向量与法线角度大于90度，表面就接收不到光。</p><p>   图13.7 光向量与平面法线的关系，我们能够创建一个阴影（shading） 标量，用0..1之间的范围来表示表面能接收到光的多少。使用阴影标量，角度大则标量接近于0。当颜色与一个阴影标量接近0的值相乘时，得到的结果是：颜色变暗。相反，乘以一个阴影标量的值接近1的值时，颜色则接近于原始亮度。</p><p>13.4.2 计算方格的阴影（Shade）<br>   光源的方向是一个单位向量，为了计算光源方向与面法线间的夹角，首先需要找到面法线，这是叉积的一小部分应用，但首先必须在方格里找到二个共面的非0并且不平行的向量。看图 13.8有两个这样的向量：</p><p>   图13.8: 计算在同一方格中的共面的二个向量</p><p>u = (cellSpacing, by - ay, 0)<br>v = (0, cy, -ay, -cellSpacing) </p><p>关于u和v，方格的法线N = u × v，当然要把N标准化：</p><p>找到光线与法线的夹角，回忆一下点积，是二个3维空间中的单位向量组成的夹角的余弦。</p><p>   它的标量是在-1..1的范围，因为-1..0的sin值符合夹角角度且大于90度，在图13.7中接受不到光照，如果它在-1..0之间那么夹角是0度。<br>float cosine = D3DXVec3Dot(&amp;n, directionToLight);</p><p>if(cosine &lt; 0.0f)<br>     cosine = 0.0f;</p><p>   现在s的夹角大于90度，s的阴影标量将在0..1之间。因为光线与法线的角度从0增加到90度时，s的值将从1到降到0。这是我们想要的结果，具体讲解请看13.4.1节。<br>   给指定的格子计算阴影系数用Terrain::computeShade方法，它需要参数：行和列来确定方格，还有平行方向光的光源。<br>float Terrain::computeShade(int cellRow, int cellCol,<br>                            D3DXVECTOR3* directionToLight)<br>{<br>     // 取得方格中三个顶点的高度（从高度图中）<br>     float heightA = getHeightmapEntry(cellRow,   cellCol);<br>     float heightB = getHeightmapEntry(cellRow,   cellCol+1);<br>     float heightC = getHeightmapEntry(cellRow+1, cellCol);</p><pre><code> // 创建方格中的二个顶点 D3DXVECTOR3 u( cellSpacing, heightB - heightA, 0.0f); D3DXVECTOR3 v(0.0f, heightC - heightA, - cellSpacing); //用方格中的二个向量的叉积找到面法线 D3DXVECTOR3 n; D3DXVec3Cross(&amp;n, &amp;u, &amp;v); D3DXVec3Normalize(&amp;n, &amp;n); float cosine = D3DXVec3Dot(&amp;n, directionToLight); if(cosine &lt; 0.0f)      cosine = 0.0f; return cosine;</code></pre><p>}</p><p>13.4.3 地形阴影（Shading）<br>   一旦知道了如何给指定的方格加阴影，我们就能给地形上所有的方格加阴影。只要遍例每一个方格，计算方格的阴影值，并测量方格对应的texel颜色。光照少则方格会变暗。下面一段代码展示了Terrain::lightTerrain方法的重要部分：</p><p>DWORD<em> imageData = (DWORD</em>)lockedRect.pBits;<br>for(int i = 0; i &lt; textureDesc.Height; i++)<br>{<br>     for(int j = 0; j &lt; textureDesc.Width; j++)<br>     {<br>          int index = i * lockedRect.Pitch / 4 + j;</p><pre><code>      // get current color of cell      D3DXCOLOR c( imageData[index] );      // shade current cell      c *= computeShade(i, j, lightDirection);;      // save shaded color      imageData[index] = (D3DCOLOR)c; }</code></pre><p>}</p><p>13.5 在地形上“行走”<br>   构造了一个地形以后，我们想要有移动照相机的能力，以便模拟在地形上行走的效果。我们需要调整照相机的高度，这依赖于地形部分的知识，好的，我们继续往下看。我们首先需要找到照相机所在的方格的位置，并给出x轴和z轴坐标，Terrain::getHeight函数能做到这些，它能提供x轴、y轴坐标参数，返回照相机需要被设置在地形上的高度值，现在看实现部分。<br>float Terrain::getHeight(float x, float z)<br>{<br>     // Translate on xz-plane by the transformation that takes<br>     // the terrain START point to the origin.<br>     x = ((float) width / 2.0f) + x;<br>     z = ((float) depth / 2.0f) - z;</p><pre><code> // Scale down by the transformation that makes the // cellspacing equal to one. This is given by // 1 / cellspacing since cellspacing * 1 / cellspacing = 1. x /= (float) cellSpacing; z /= (float)_cellSpacing;</code></pre><p>   我们首先转换地形的起始点为原点，然后，我们按反方向去测量空间变量（we scale by the inverse of the cell spacing variable），设置单元空间间隔为1。我们切换到一个新的参考框架，z轴正方向是向下的。当然，没有代码转换参考框架，但现在我们知道+z是向下的。图13.9显示了这些步骤：</p><p>图13.9：地形网格在转换前的第一个点，转换后为原点。单元格的空间为1，转换z轴。<br>我们看到我们转换的坐标系统与矩阵的行和列相对应，也就是说左上为原点，列数的增加向右，行数的增加向下。因此，在图13.9中我们知道了单元格的空间是1，通过以下的方法我们马上就能得到单元格行和列：<br>float col = ::floorf(x);<br>float row = ::floorf(z);</p><p>换句话说，在x轴部分列是整数，z轴部分行也是整数。回忆floor(t)函数，。<br>现在我们将取得方格的四个顶点的高度。<br>        //  A   B<br>        //  <em>—</em><br>        //  | / |<br>        //  <em>—</em><br>        //  C   D<br>float A = getHeightmapEntry(row,   col);<br>float B = getHeightmapEntry(row,   col+1);<br>float C = getHeightmapEntry(row+1, col);<br>float D = getHeightmapEntry(row+1, col+1);</p><p>   现在我们知道了方格的四个顶点的高度，我们需要找到照相机所在的位置的方格的高度，因为一个方格可能同时向几个方向倾斜，这可能会稍微难一点，见图 13.10:</p><p>图13.10: 照相机所在的位置的方格的高度<br>   为了找到高度，我们需要知道我们在方格中的哪个三角形里。方格是由二个三角形渲染成的，找到我们所在的三角形，我们要取得我们所在的方格并且转换它，它的左上点是原点。<br>   自从用行和列来描述我们所在的方格左上顶点的位置以来，我们必须转换列x轴与行z轴，转换x、z坐标：<br>   float dx = x - col;<br>   float dz = z - row;</p><p>图13.11: 我们所在的方格在转换前与转换后，左上顶点变成了原点。<br>   .现在解释当我们在方格中的上三角形时如何找到高度，这和在下三角形是相似的。马上你会看到这两种情况的代码。在上三角形时，构造2个向量：u = (cellSpacing, B -A, 0) and v = (0, C - A, - cellSpacing)，三角形的边上并且在矢量q = (qx, A, qz)终点点开始的地方，如图13.12(a)。</p><p>   图13.12 (a) 计算三角形的邻边和对边这两个向量。 (b)使用线性差值创建高度<br>   注意：我们只关心改变的高度值，我们只修改y值，忽视其他部分，因此，Height=sum A + dxuy + dzvy<br>   以下是Terrian::getHeight函数的实现代码：<br>   （Note that since we are only concerned about the interpolated height value, we can just interpolate the y-components and ignore the other components. Thus, the height is obtained by the sum A + dxuy + dzvy.）<br>if(dz &lt; 1.0f - dx) // upper triangle ABC<br>     {<br>          float uy = B - A; // A-&gt;B<br>          float vy = C - A; // A-&gt;C</p><pre><code>      height = A + d3d::Lerp(0.0f, uy, dx) +                   d3d::Lerp(0.0f, vy, dz) ; } else // lower triangle DCB {      float uy = C - D; // D-&gt;C      float vy = B - D; // D-&gt;B      height = D + d3d::Lerp(0.0f, uy, 1.0f - dx) +                   d3d::Lerp(0.0f, vy, 1.0f - dz); }    return height;</code></pre><p>}</p><p>   Lerp函数是一个沿着一维直线的基本线性插值算法，实现如下：<br>float d3d::Lerp(float a, float b, float t)<br>{<br>     return a - (a<em>t) + (b</em>t);<br>}</p><p>13.6 例子程序: Terrain<br>   这章的例子是用一个包含高度信息的RAW文件创建一个地形，纹理和光源。用方向键在地形上行走。注意，下列函数中不相关的代码被省略了，被省略的代码用(…)表示，依赖你的硬件，这个例子可能运行得很慢，请偿试运行一个小地形。<br>   首先，增加全局变量：地形、照相机、每秒帧数。<br>Terrain<em> TheTerrain = 0;<br>Camera   TheCamera(Camera::LANDOBJECT);<br>FPSCounter</em> FPS = 0;</p><p>   下面是框架函数：<br>bool Setup()<br>{<br>     D3DXVECTOR3 lightDirection(0.0f, -1.0f, 0.0f);<br>     TheTerrain = new Terrain(Device, “coastMountain256.raw”,<br>                              256, 256, 10, 1.0f);<br>     TheTerrain-&gt;genTexture();<br>     TheTerrain-&gt;lightTerrain(&amp;directionToLight);<br>     …</p><pre><code> return true;</code></pre><p>}</p><p>void Cleanup()<br>{<br>     d3d::Delete<terrain*>(TheTerrain);<br>     d3d::Delete<fpscounter*>(FPS);<br>}</fpscounter*></terrain*></p><p>bool Display(float timeDelta)<br>{<br>     if( Device )<br>     {<br>          // Update the scene:<br>          …[snipped input checking]</p><pre><code>      // Walking on the terrain: Adjust camera&#39;s height so we      // are standing 5 units above the cell point we are      // standing on.      D3DXVECTOR3 pos;      TheCamera.getPosition(&amp;pos);      float height = TheTerrain-&gt;getHeight( pos.x, pos.z );      pos.y = height + 5.0f;      TheCamera.setPosition(&amp;pos);      D3DXMATRIX V;      TheCamera.getViewMatrix(&amp;V);      Device-&gt;SetTransform(D3DTS VIEW, &amp;V);      // Draw the scene:      Device-&gt;Clear(0, 0, D3DCLEAR TARGET | D3DCLEAR ZBUFFER,                    0xff000000, 1.0f, 0);      Device-&gt;BeginScene();      D3DXMATRIX I;      D3DXMatrixIdentity(&amp;I);      if( TheTerrain )          TheTerrain-&gt;draw(&amp;I, false);      if( FPS )          FPS-&gt;render(0xffffffff, timeDelta);      Device-&gt;EndScene();      Device-&gt;Present(0, 0, 0, 0); } return true;</code></pre><p>}</p><p>13.7 一些改进<br>   Terrain读取顶点数据到一个很大的缓存，在多重的顶点缓存中划分地形结构，在速度和可测量性方面都十分有利。为我们提出一个问题：顶点缓存最大支持多大？回答是，这依赖于你的硬件。所以你必须先检测。<br>   将地图划分为许多小的顶点缓存是重要的练习，然后将类似矩阵的数据结构编入索引，并且管理数据，这不需要引入新的概念。我们不必详细讨论它。简单的说，你基本上站在地形中一个我们叫做“blocks”的矩阵上,每个block是地形的一个矩形区域。另外，每个block区域（在它自己的顶点索引缓存中）的下方包含地形中的几何信息，为了画它在地形中的位置。<br>   另外，你可以读取地形到一个很大的ID3DXMesh接口。使用D3D函数D3DXSplitMesh划分地形为许多小的Mesh, 以下是D3DXSplitMesh函数原型：<br>void D3DXSplitMesh(<br>    const LPD3DXMESH pMeshIn,<br>    const DWORD <em>pAdjacencyIn,<br>    const DWORD MaxSize,<br>    const DWORD Options,<br>    DWORD </em>pMeshesOut,<br>    LPD3DXBUFFER <em>ppMeshArrayOut,<br>    LPD3DXBUFFER </em>ppAdjacencyArrayOut,<br>    LPD3DXBUFFER <em>ppFaceRemapArrayOut,<br>    LPD3DXBUFFER </em>ppVertRemapArrayOut<br>);<br>       这个函数将一个源Mesh划分多个小的Mesh,，pMeshIn参数是一个指针，指向想划分的Mesh，pAdjacencyIn指向一个邻接数组，MaxSize参数指定作为结果返回的最大顶点数，为返回的Meshe使用指定的创建标记，pMeshesOut参数返回ppMeshArrayOut数组中的Mesh数量，最后3个参数是可选的（可以指定为null），返回邻接信息的数组。<br>13.8 摘要</p><ul><li>我们能用三角形网格和不同的高度值来模拟地形，创建山丘、河流。</li><li>Heightmap数据包含地形顶点的高度值。</li><li>我们能通过程序使用磁盘上的图像文件生成地形上的纹理。</li><li>我们能照亮地形，通过计算阴影系数来使每个格子变亮或变暗，阴影系数是由光照在格子上的角度决定的。</li><li>使照相机在地形上走动，我们需要找到我们站立的三角形。我们计算三角形上的邻边和对边这两个向量，高度是通过…（线性插值在这些向量中每个使用x、z对应的单位向量，以左高顶点为原点为参数。）找到的。<br>（The height is then found by linearly interpolating on each of these vectors using the x- and z-coordinates in a normalized cell with an upper-left vertex at the origin as parameters.）</li></ul><p>第十四章 粒子系统<br>(Particle Systems)<br>   许多自然现象是由很多小的小颗粒组成的，它们有相似的行为。（例如，雪花落下，闪烁的火焰，冲出枪管的“子弹”），粒子系统用来模拟这种现象。<br>目标：</p><ul><li>学习我们给定的粒子属性，如何描述D3D中的粒子。</li><li>设计一个灵活的粒子基系统的基类，包括一般的粒子系统都有的属性和方法。</li><li>模拟3个具体的粒子系统，雪、爆炸、粒子枪。<br>14.1 粒子和点精灵（Point Sprite）<br> 粒子是一个很小的对象，它通常用来模拟数学中的一个点。点元是用来显示粒子的很好的方案。可是点元被光栅化成一个简单的像素。这没给我们多少灵活性，因为我们想有各种大小不同的粒子，并且把整个纹理平滑映射到这些粒子上。在Direct3D 8.0,以前，因为点元方法的局限性而完全不使用他们。代替的方法是，程序员将使用公告板去显示粒子，一个板是一个方格，世界矩阵用它来确定方向，使它总是朝向照相机。<br> Direct3D 8.0引入一个特殊的点元叫点精灵，多数时候被应用在粒子系统中。与一般的点元不同的是，点精灵有纹理映射并能改变大小。与公告板不同的是，能用一个简单的点描述一个点精灵，节省内存和处理时间，因为我们只是必须保存和处理一个点，而公告板则是四个。</li></ul><p>14.1.1 结构的格式<br>   我们使用下面的顶点结构来描述粒子的位置和颜色：<br>struct Particle<br>{<br>     D3DXVECTOR3 _position;<br>     D3DCOLOR    _color;<br>     static const DWORD FVF;<br>};<br>const DWORD Particle::FVF = D3DFVF_XYZ | D3DFVF_DIFFUSE;<br>   这个结构只保存粒子的位置和颜色，这取决于你程序的需要，你能够用同样的结构去保存一套纹理坐标，我们在下一节讨论给点精灵赋予纹理。<br>   增加一个浮点变量给Particle结构去指定粒子的大小是可能的。我们必须增加一个D3DFVF_PSIZE标记给我们的灵活的顶点格式，以反映这个变化。每个粒子维护自己的大小很有用，因为它允许我们以具体情况指定并改变粒子的大小。可是，大多数的图形卡不支持控制粒子的大小，因此我们不使用它。（检查D3DFVFCAPS_PSIZE在D3 DCAPS9结构的FVFCaps成员）代替的方法是：用渲染状态（render states）去控制粒子的大小，就像你很快看到的，有尺寸成员的顶点结构的例子：<br>strict Particle<br>{<br>     D3DXVECTOR3 _position;<br>     D3DCOLOR    _color;<br>     float       _size;<br>     static const DWORD FVF;<br>};<br>const DWORD Particle::FVF = D3DFVF XYZ | D3DFVF DIFFUSE |<br>  D3DFVF_PSIZE;<br>   注意：通过vertex shader，能够获取每个粒子的大小，即使你的硬件不支持D3DFVFCAPS_PSIZE。Vertex shaders的内容在本书的第IV部分。</p><p>14.1.2点精灵（Point Sprite）渲染状态<br>   点精灵的行为大部分由渲染状态（render states）来控制，现在让我们来看一下这些渲染状态：<br>D3DRS_POINTSPRITEENABLE—A Boolean value. The default value is false.<br>True表示将当前的纹理全部映射到点精灵上。<br>False 表示用指定的纹理坐标映射到点精灵的点（图素）上。<br>_device-&gt;SetRenderState(D3DRS_POINTSPRITEENABLE, true);</p><p>D3DRS_POINTSCALEENABLE—A Boolean value. The default value is false.<br>True表示用视图空间单位来解释点的大小。视图空间单位的3D空间点在照相机中，点精灵将会自动缩放，这取决到它有多远, 像其他对象一样，离照相机近的粒子比离照相机远的粒子要小。<br>False 表示点的大小将用屏幕空间单位来解释。屏幕空间单位是屏幕上的像素单位。. 因此如果你指定false, 例如, 设置点精灵的尺寸为3, 则点精灵在屏幕区域中的尺寸为3×3像素。.<br>_device-&gt;SetRenderState(D3DRS_POINTSCALEENABLE, true);</p><p>D3DRS_POINTSIZE—表示点精灵的尺寸. 这个值可以任意指定视图空间或屏幕空间的点精灵的尺寸, 取决于D3DRS_POINTSCALEENABLE 状态如何设置. 下面的代码段设置点的尺寸为2.5个单位。:<br>_device-&gt;SetRenderState( D3DRS_POINTSIZE, d3d::FtoDw(2.5f) );</p><p>d3d::FtoDw 是我们新加进 d3dUtility.h/cpp 文件中的一个函数，它将float型转换为 DWORD型。 我们必须这么做是因为所有的IDirect3DDevice9::SetRenderState 都要一个 DWORD 型的值而不是float型。<br>DWORD d3d::FtoDw(float f)<br>{<br>     return <em>((DWORD</em>)&amp;f);<br>}</p><p>D3DRS_POINTSIZE_MIN—表示点精灵的最小尺寸。例子，将设置最小值为0.2：<br>_device-&gt;SetRenderState(D3DRS_POINTSIZE_MIN, d3d::FtoDw(0.2f));</p><p>D3DRS_POINTSIZE_MAX—表示点精灵的最大尺寸。例子，将设置最大值为5.0:<br>_device-&gt;SetRenderState(D3DRS_POINTSIZE_MAX, d3d::FtoDw(5.0f));</p><p>D3DRS_POINTSCALE_A, D3DRS_POINTSCALE_B, D3DRS_POINTSCALE_C—这3个常量表示如何根据距离控制点精灵的尺寸—这个距离是点精灵到照相机的距离。</p><p>D3D用以下的公式去计算点精灵的最终尺寸，这取决于距离和这3个常量。</p><p>其中：<br>FinalSize：距离计算后，点精灵的最后尺寸。<br>ViewportHeight：视口的高度。<br>Size：分别为D3DRS_POINTSCALE_A, D3DRS_POINTSCALE_B, and D3DRS_POINTSCALE_C值。<br>D：在视图空间中点精灵与照相机的距离。因为照相机被放置在视图空间中的原点，这个值是：，也是点精灵所在的位置。</p><p>   下面代码设置点精灵的距离常量，因此远处的点精灵将变小。<br>_device-&gt;SetRenderState(D3DRS_POINTSCALE_A, d3d::FtoDw(0.0f));<br>_device-&gt;SetRenderState(D3DRS_POINTSCALE_B, d3d::FtoDw(0.0f));<br>_device-&gt;SetRenderState(D3DRS_POINTSCALE_C, d3d::FtoDw(1.0f));</p><p>14.1.3 粒子和他们的属性<br>    一个粒子系统是由除了位置、颜色以外的更多的属性组成，例如，一个粒子有某些速度。然而，这些额外的属性对于渲染粒子来说不是必须的。因此，我们在单独的结构中保存渲染粒子所必须的数据和属性。当我们创建、显示或更新粒子时，我们使用属性来工作。当我们准备渲染时，我们从Particle（粒子）结构中COPY位置和颜色。<br>   对于我们模拟的具体粒子系统，粒子的属性也是不同的。因此我们能够归纳一些通用的属性，一面的结构例子中包含一些通用的属性，大多数系统用不上这么多，一些系统需要的属性这里可能还没有。<br>struct Attribute<br>{<br>     D3DXVECTOR3 _position;<br>     D3DXVECTOR3 _velocity;<br>     D3DXVECTOR3 _acceleration;<br>     float       _lifeTime;<br>     float       _age;<br>     D3DXCOLOR   _color;<br>     D3DXCOLOR   _colorFade;<br>     bool        _isAlive;<br>};<br>_position—粒子在世界空间中的位置<br>_velocity—粒子的速度，每秒多少个单位。<br>_acceleration—粒子的加速度, 每秒多少个单位。<br>_lifeTime—粒子的生命周期. 例如,当一个时间段后，我们可以杀死一个激光柱的粒子.<br>_age—粒子的当前年龄。<br>_color—粒子的颜色。<br>_colorFade—粒子随时间的变化而褪去的颜色。<br>_isAlive—True 表示粒子活着;false 表示粒子死了。 </p><p>14.2 粒子系统的组成<br>   粒子系统是粒子的集合，用来保存和显示这些粒子。粒子系统维护所有粒子的全部属性，影响系统中的所有粒子：粒子的尺寸，起始的位置及应用在粒子上的纹理等。粒子系统的方法负责更新、显示、杀死和创建粒子。<br>   虽然不同的具体（与抽象是相对的）粒子系统有不同的行为，我们归纳并找到一些所有的粒子系统共有的基本属性，我们把这些公共的属性放到一个抽象的Psystem基类，它是我们所有的具体粒子系统的父类，现在让我们看一下Psystem类：<br>class PSystem<br>{<br>public:<br>     PSystem();<br>     virtual ~PSystem();</p><pre><code> virtual bool init(IDirect3DDevice9* device, char* texFileName); virtual void reset(); virtual void resetParticle(Attribute* attribute) = 0; virtual void addParticle(); virtual void update(float timeDelta) = 0; virtual void preRender(); virtual void render(); virtual void postRender(); bool isEmpty(); bool isDead();</code></pre><p>protected:<br>     virtual void removeDeadParticles();</p><p>protected:<br>     IDirect3DDevice9<em>       _device;<br>     D3DXVECTOR3             _origin;<br>     d3d::BoundingBox        _boundingBox;<br>     float                   _emitRate;<br>     float                   _size;<br>     IDirect3DTexture9</em>      _tex;<br>     IDirect3DVertexBuffer9* _vb;<br>     std::list<attribute>    _particles;<br>     int                     _maxParticles;</attribute></p><pre><code> DWORD _vbSize; DWORD _vbOffset; DWORD _vbBatchSize;</code></pre><p>};</p><p>   一些数据成员：</p><ul><li>_origin—粒子系统的原点， 这是粒子系统产生时的位置。</li><li>_boundingBox—创建粒子系统使用的边界盒，用于限制粒子的活动范围。例如，假如我们让雪系统只落在一个围绕高山的峰顶的体积内； 我们会定义一个包括这个体积的边界盒, 出界的粒子将会被杀死。</li><li>_emitRate—新增加到系统中的粒子的速度。 通常的标准是每秒。</li><li>_size—系统中所有粒子的尺寸。</li><li>_particles—系统中粒子属性的一个列表。 我们用这个列表创建，释放及更新粒子。 当我们准备画粒子时, 我们COPY列表节点的一部分到顶点缓存并画粒子。 当我们COPY另外一批时绘制这批粒子，然后重复这一过程直到绘制完所有粒子。 这有点太简单了，我们将在section 14.2.1节详细的解释绘制的过程。</li><li>_maxParticles—在给定的时间内，系统中允许的粒子最大数。例如, 如果创建粒子的速度比释放快的话, 随着时间的增长粒子的数量将会是巨大的，这个成员将避免出现这样的问题。</li><li>_vbSize—在给定的时间内顶点缓存中能够保存的粒子的数量，这个值与实际的粒子系统中的粒子数量无关。<br>注意：member _vbOffset和_vbBatchSize数据成员在渲染粒子系统时使用，我们在稍后的section 14.2.1节讨论。</li></ul><p>方法：</p><ul><li>PSystem/ ~PSystem—用来初始化默认值的构造器/用来释放设备接口的析构器 (vertex buffer, texture)。</li><li>init—这个方法做与设备无关的初始化工作, 比如创建用来保存点精灵的顶点缓存或创建纹理。 顶点缓存的创建包括一些标记，现在我们都已经讨论过了，但还没有用:<br>hr = device-&gt;CreateVertexBuffer(<br>   _vbSize * sizeof(Particle),<br>   D3DUSAGE DYNAMIC | D3DUSAGE POINTS | D3DUSAGE WRITEONLY,<br>   Particle::FVF,<br>   D3DPOOL_DEFAULT,<br>   &amp;_vb,<br>   0) ;</li><li>o 注意： 我们使用动态的顶点缓存（D3DUSAGE DYNAMIC）。 因为我们需要在每帧中更新我们的粒子,意思是我们将会去存取顶点缓存的内存，回想一下，访问一个静态的顶点缓存慢得不可接受， 所以我们使用动态的顶点缓存。<br>o 查看我们用过的 D3DUSAGE_POINTS 标记,它说明顶点缓存将保存点精灵。<br>o 顶点缓存的尺寸是由_vbSize预先确定的，而且与系统中粒子的数量无关。 也就是说, _vbSize 将小于等于系统中粒子的数量。 这是因为渲染粒子系统是一批一批的，不是一次渲染全部。 我们将在section 14.2.1节中解释渲染过程。<br>o 我们使用默认的内存池(pool)代替通常使用的托管内存池，因为动态顶点缓存不能用在托管内存池中。</li><li>reset—这个方法重新设置系统中每个粒子的属性:<br>void PSystem::reset()<br>{<br>   std::list<attribute>::iterator i;<br>   for(i = _particles.begin(); i != _particles.end(); i++)<br>   {<pre><code>    resetParticle( &amp;(*i) );</code></pre>   }<br>}</attribute></li><li>resetParticle—这个方法重新设置粒子的属性。如何重设粒子的属性，这依赖于具体粒子系统的特性。因此我们定义这个方法为虚拟的，等待子类去实现。</li><li>addParticle—这个方法用来在系统中增加一个粒子。在增加它到粒子列表之前，使用resetParticle 方法先初始化粒子:<br>void PSystem::addParticle()<br>{<br>   Attribute attribute;<br>   resetParticle(&amp;attribute);<br>   _particles.push_back(attribute);<br>}<br>void PSystem::addParticle()</li><li>update—这个方法更新系统中所有的粒子。因为这个的方法的执行取决于具体粒子系统的特性, 因此我们定义这个方法为抽象的，等待子类去实现。</li><li>render—这个方法用来显示系统中所有的粒子。 执行起来很复杂，我们将在14.2.1 节讨论。</li><li><p>preRender—用它来初始化渲染状态， 在渲染前设置。 因为系统与系统之间是不同的,所以我们定义它为虚拟的。 默认将执行下列代码:<br>void PSystem::preRender()<br>{<br>_device-&gt;SetRenderState(D3DRS_LIGHTING, false);<br>_device-&gt;SetRenderState(D3DRS_POINTSPRITEENABLE, true);<br>_device-&gt;SetRenderState(D3DRS_POINTSCALEENABLE, true);<br>_device-&gt;SetRenderState(D3DRS_POINTSIZE, d3d::FtoDw( size));<br>_device-&gt;SetRenderState(D3DRS_POINTSIZE MIN, d3d::FtoDw(0.0f));</p><p>// control the size of the particle relative to distance<br>_device-&gt;SetRenderState(D3DRS_POINTSCALE A, d3d::FtoDw(0.0f));<br>_device-&gt;SetRenderState(D3DRS_POINTSCALE B, d3d::FtoDw(0.0f));<br>_device-&gt;SetRenderState(D3DRS_POINTSCALE C, d3d::FtoDw(1.0f));</p><p>// use alpha from texture<br>_device-&gt;SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_<br>   TEXTURE);<br>_device-&gt;SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_<br>   SELECTARG1);</p><p>_device-&gt;SetRenderState(D3DRS_ALPHABLENDENABLE, true);<br>_device-&gt;SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);<br>_device-&gt;SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);<br>}</p></li><li>注意：我们使用alpha混合渲染，以便设置纹理的alpha通道，来设置纹理像素的透明度。 用它产生多种效果；一种特殊的情况是：获得象纹理那样的非矩形的粒子。例如， 获得一个圆形“雪球形”的粒子, 我们使用一个简单的带有alpha通道的纹理， 它看上去是背景为黑色的带有白色圆形的样子。因此，显示出来时只是一个白圆，这比白色的矩形纹理要好。</li><li>postRender—用它去保存所有渲染状态，它是一个特殊的粒子系统可能有的设置。因为系统与系统间是不同的,所以我们定义它为虚拟的。默认将执行下列代码:<br>void PSystem::postRender()<br>{<br>_device-&gt;SetRenderState(D3DRS_LIGHTING,          true);<br>_device-&gt;SetRenderState(D3DRS_POINTSPRITEENABLE, false);<br>_device-&gt;SetRenderState(D3DRS_POINTSCALEENABLE,  false);<br>_device-&gt;SetRenderState(D3DRS_ALPHABLENDENABLE,  false);<br>}</li><li>isEmpty—如果为True 则在当前的系统中没有粒子， 否则为false.</li><li>isDead—如果为True 则系统中的所有粒子都是死的，否则为false。 注意： 系统中所有粒子状态为idDead时并不意味着isEmpty. 空意思着系统中没有粒子。 Dead的意思是系统中有粒子，但都是死的。.</li><li>removeDeadParticles—搜索属_particle性表，从表中杀死并删除粒子。<br>14.2.1 绘制粒子系统<br> 因为粒子系统是动态的，在每一个帧中我们需要更新系统中的粒子，对于渲染粒子系统的一种直观但效率低下的方法如下:</li><li><p>创建一个足够大的顶点缓存保存最大数量的粒子。</p><pre><code>   每一帧里执行：</code></pre><p>A. 更新所有粒子。<br>B. COPY所有活着的粒子到顶点缓存。<br>C. 绘制顶点缓存。<br> 这个方法正确，不过不是最有效率的。第一，顶点缓冲必须足够大以保存系统中所有粒子。但是非常重要的是，当我们从列表拷贝所有粒子到顶点缓冲（步骤B）时，显卡却什么也不做。举个例子，假设我们系统有10,000个粒子，首先我们需要一个能容纳10,000个粒子的顶点缓冲，这是一个很大的内存。另外显卡将停着什么也不做直到列表中的10,000个粒子拷到顶点缓冲，并且我们调用DrawPrimitive。这个特定情况是CPU与显卡不同时工作的一个很好的例子。</p><pre><code> 更好的办法（SDK中点精灵例程中用到的方法）就象这样：</code></pre><p> 提示：这是一个简单的描述，但它说明了这一思想。它假定我们总是有500个粒子以填充一个缓存片段，但是这是不可能发生的，因为我们经常杀死并创建粒子，所以从一帧到另一帧粒子数量是变化的。举个例子，假设我们只剩下200个粒子要在当前帧拷贝并渲染。因为200个粒子不能填充整个缓存片段，我们用代码处理这个特定情形。这个特定情形只有在最后的缓存片段中才会出现，因为如果不是最后的片断，就意味着必然有500个粒子将被移到下一缓存片段。</p><p> 创建一个合适尺寸的顶点缓存（能够保存2000个粒子），然后我们划分顶点缓存为几个小的块，就像这个例子，我们设置每个缓存片断的尺寸为500个粒子。</p></li></ul><ul><li>然后创建一个全局变量 i = 0 ，用来记录片段。<pre><code>   每一帧里执行:</code></pre>A. 更新所有粒子。<br>B. 直到所有粒子渲染完毕。:</li></ul><ol><li>如果顶点缓存没有满：<br>a 用D3DLOCK_NOOVERWRITE标记锁定缓存片段i<br>b COPY 500个粒子到片段i</li><li><p>如果顶点缓存满了：<br>a 从起始的地方开始顶点缓冲: i=0<br>b 用D3DLOCK_NOOVERWRITE标记锁定缓存段i<br>c COPY 500个粒子到片段i </p></li><li><p>渲染片段i. </p></li><li><p>下一片段： i+ +<br>备注：顶点缓存是动态的， 因此我们能利用动态锁定标记D3DLOCK_NOOVERWRITE 和 D3DLOCK_DISCARD。这两个标记允许我们锁定顶点缓存的某一部分。当顶点缓存中的其他部分被渲染时，它是不能渲染的。例如，假如我们正在使用D3DLOCK_NOOVERWRITE标记渲染片段0时， 当渲染片段0的时候我们能锁定并填充片段1。这样可以防止渲染的延迟。</p><p>这个方法更有效率。首先，我们减少顶点缓存的尺寸；然后， CPU与显卡在协调的工作。也就是说，当我们绘制一小批粒子时(graphics card work)，同时拷贝另一小批粒子到顶点缓存 (CPU work)。这个动作是连续执行的，直到所有的粒子都被渲染完毕，就像你了解的一样， 显卡在全部顶点缓存被填充的时候是不用处于空闲状态的。<br>我们现在将注意力转向这一个渲染方案的实现，为了方便使用这个粒子系统的渲染方案, 我们使用 PSystem 类中的下列数据成员:</p></li></ol><ul><li>_vbSize—在给定时间内我们的顶点缓存能够保存的粒子数量。这个值与实际的粒子系统中的粒子数无关。</li><li>_vbOffset—这个变量是在顶点缓存中的偏移，在顶点缓存里我们将用它开始COPY下一批粒子，例如，如果第一批在缓存中是0到499，偏移到第二批COPY的开始处将是500。</li><li>_vbBatchSize—定义一批缓存中的粒子数量。</li><li>我们现在介绍渲染方法的代码：<br>void PSystem::render()<br>{<br>if( !_particles.empty() )<br>{<br>   // set render states<br>   preRender();<br>   _device-&gt;SetTexture(0, _tex);<br>   _device-&gt;SetFVF(Particle::FVF);<br>   _device-&gt;SetStreamSource(0, _vb, 0, sizeof(Particle));</li></ul><p>// start at beginning if we’re at the end of the vb<br>     if(_vbOffset &gt;= _vbSize)<br>          _vbOffset = 0;</p><pre><code> Particle*v =0; _vb-&gt;Lock(      _vbOffset    * sizeof( Particle ),      _vbBatchSize * sizeof( Particle ),      (void**)&amp;v,      _vbOffset ? D3DLOCK_NOOVERWRITE : D3DLOCK_DISCARD); DWORD numParticlesInBatch = 0; // // Until all particles have been rendered. // std::list&lt;Attribute&gt;::iterator i; for(i = _particles.begin(); i != _particles.end(); i++) {      if( i-&gt;_isAlive )      {           //           // Copy a batch of the living particles to the           // next vertex buffer segment           //           v-&gt;_position = i-&gt;_position;           v-&gt;_color = (D3DCOLOR)i-&gt;_color;           v++; // next element;           numParticlesInBatch++; //increase batch counter           // is this batch full?           if(numParticlesInBatch == _vbBatchSize)           {                //                // Draw the last batch of particles that was                // copied to the vertex buffer.                //                _vb-&gt;Unlock();                _device-&gt;DrawPrimitive(                     D3DPT_POINTLIST,                     _vbOffset,                     _vbBatchSize);           //           // While that batch is drawing, start filling the           // next batch with particles.           //           // move the offset to the start of the next batch           _vbOffset += _vbBatchSize;           // don&#39;t offset into memory thats outside the vb&#39;s           // range. If we&#39;re at the end, start at the beginning.           if(_vbOffset &gt;= _vbSize)                _vbOffset = 0;           _vb-&gt;Lock(                _vbOffset    * sizeof( Particle ),                _vbBatchSize * sizeof( Particle ),                (void**)&amp;v,                _vbOffset ? D3DLOCK_NOOVERWRITE :                   D3DLOCK_DISCARD);           numParticlesInBatch = 0; // reset for new batch      }//end if   }//end if }//end for _vb-&gt;Unlock(); // it&#39;s possible that the LAST batch being filled never // got rendered because the condition // (numParticlesInBatch == _vbBatchSize) would not have // been satisfied.  We draw the last partially filled batch now. if( numParticlesInBatch ) {       _device-&gt;DrawPrimitive(            D3DPT_POINTLIST,            _vbOffset,            numParticlesInBatch); } // next block _vbOffset += _vbBatchSize; postRender(); }//end if</code></pre><p>}// end render()</p><p>14.2.2 随机<br>   这有一个随机的粒子系统。例如，如果我们模拟雪花，不能让所有雪花以完全相同的方式落下。我们要让它们按相似的方式落下而不是完全相同的方式。为了使粒子系统的随机功能更简单，我们增加了下列两个函数到d3dUtility.h/cpp文件。<br>   第一个函数在[lowBound, highBound]区间内随机的返回一个Float类型值：<br>float d3d::GetRandomFloat(float lowBound, float highBound)<br>{<br>     if( lowBound &gt;= highBound ) // bad input<br>          return lowBound;</p><pre><code> // get random float in [0, 1] interval float f = (rand() % 10000) * 0.0001f; // return float in [lowBound, highBound] interval. return (f * (highBound - lowBound)) + lowBound;</code></pre><p>}<br>   第二个函数在边界盒的范围内，输出一个随机的向量。<br>void d3d::GetRandomVector(<br>       D3DXVECTOR3<em> out,<br>       D3DXVECTOR3</em> min,<br>       D3DXVECTOR3* max)<br>{<br>       out-&gt;x = GetRandomFloat(min-&gt;x, max-&gt;x);<br>       out-&gt;y = GetRandomFloat(min-&gt;y, max-&gt;y);<br>       out-&gt;z = GetRandomFloat(min-&gt;z, max-&gt;z);<br>}</p><p>   注意：记得用srand()去seed随机数生成器。<br>14.3 具体的粒子系统：雪、火、粒子枪<br>现在让我们用Psystem类开始一个具体的粒子系统，为了说明用意，这些系统的设计很简单，没有用到Psystem类所提供的所有灵活性。我们实现雪、火、粒子枪系统。这些系统的名字基本上概括了他们的模型。雪系统模拟下落的雪花，火系统模拟看上去像火焰的爆炸，粒子枪系统从照相机位置向对面发射出粒子（用键盘）。<br>注意：照例，用全部的工程代码来说明这些系统，你能够在本章找到这些文件。</p><p>14.3.1 例子程序：雪</p><p>图14.2 雪系统例子的屏幕截图</p><p>雪系统类定义如下：<br>class Snow : public PSystem<br>{<br>public:<br>     Snow(d3d::BoundingBox<em> boundingBox, int numParticles);<br>     void resetParticle(Attribute</em> attribute);<br>     void update(float timeDelta);<br>};<br>备注：因为父类做了大部分的工作，所以雪系统的接口非常简单。事实上，我们在这一节中实现的这三个粒子系统，接口简单并相对容易实现。<br>   构造器提供一个点给边界盒结构，边界盒是粒子系统的成员。边界盒描述雪花在哪个范围内（体积范围）下落，如果雪花出了边界盒，它将被杀死并再生。这样，雪系统始终能保存有同样数量的激粒子，构造器的实现：<br>Snow::Snow(d3d::BoundingBox<em> boundingBox, int numParticles)<br>{<br>     _boundingBox   = </em>boundingBox;<br>     _size          = 0.8f;<br>     _vbSize        = 2048;<br>     _vbOffset      = 0;<br>     _vbBatchSize   = 512;<br>     for(int i = 0; i &lt; numParticles; i++)<br>          addParticle();<br>}<br>   同样注意：我们指定顶点缓存的尺寸，每一批的尺寸和开始的偏移。<br>   ResetParticle方法创建一个雪花，在x、z轴随机的位置并在边界盒的范围内。设置y轴高度为边界盒的顶部。如果给雪花一个速度，以便让雪花下落时稍稍向左倾斜。雪花是白色的。<br>void Snow::resetParticle(Attribute* attribute)<br>{<br>     attribute-&gt;_isAlive = true;</p><pre><code> // get random x, z coordinate for the position of the snowflake. d3d::GetRandomVector(      &amp;attribute-&gt;_position,      &amp;_boundingBox._min,      &amp;_boundingBox._max); // no randomness for height (y-coordinate). Snowflake // always starts at the top of bounding box. attribute-&gt;_position.y = _boundingBox._max.y; // snowflakes fall downward and slightly to the left attribute-&gt;_velocity.x = d3d::GetRandomFloat(0.0f, 1.0f)*-3.0f; attribute-&gt;_velocity.y = d3d::GetRandomFloat(0.0f, 1.0f)*-10.0f; attribute-&gt;_velocity.z = 0.0f; // white snowflake attribute-&gt;_color = d3d::WHITE;</code></pre><p>}<br>   Update方法更新粒子和粒子间的位置，并且测试粒子是否在系统的边界盒之外，如果它已经跳出边界盒，就再重新创建。<br>void Snow::update(float timeDelta)<br>{<br>     std::list<attribute>::iterator i;<br>     for(i = _particles.begin(); i != _particles.end(); i++)<br>     {<br>          i-&gt;_position += i-&gt;_velocity * timeDelta;</attribute></p><pre><code>      // is the point outside bounds?      if( _boundingBox.isPointInside( i-&gt;_position ) == false )      {           // nope so kill it, but we want to recycle dead           // particles, so respawn it instead.           resetParticle( &amp;(*i) );      } }</code></pre><p>}</p><p>14.3.2 例子程序：火</p><p>图14.3 火粒子系统例子的屏幕截图<br>火系统类定义如下：<br>class Firework : public PSystem<br>{<br>public:<br>     Firework(D3DXVECTOR3<em> origin, int numParticles);<br>     void resetParticle(Attribute</em> attribute);<br>     void update(float timeDelta); void preRender();<br>     void postRender();<br>};<br>   构造器需要提供一个点作为粒子系统中的原点，和系统中的粒子数，原点是火焰爆发的那个点。<br>ResetParticle方法在原点位置初始化粒子系统，并在边界球内创建一个随机的速度，粒子系统中的每个例子有一个随机的颜色，我们定义粒子只能存活2秒。<br>void Firework::resetParticle(Attribute* attribute)<br>{<br>     attribute-&gt;_isAlive = true;<br>     attribute-&gt;_position = _origin;</p><pre><code> D3DXVECTOR3 min = D3DXVECTOR3(-1.0f, -1.0f, -1.0f); D3DXVECTOR3 max = D3DXVECTOR3( 1.0f,  1.0f,  1.0f); d3d::GetRandomVector(      &amp;attribute-&gt;_velocity,      &amp;min,      &amp;max); // normalize to make spherical D3DXVec3Normalize(      &amp;attribute-&gt;_velocity,      &amp;attribute-&gt;_velocity); attribute-&gt;_velocity *= 100.0f; attribute-&gt;_color = D3DXCOLOR(      d3d::GetRandomFloat(0.0f, 1.0f),      d3d::GetRandomFloat(0.0f, 1.0f),      d3d::GetRandomFloat(0.0f, 1.0f),      1.0f); attribute-&gt;_age      = 0.0f; attribute-&gt;_lifeTime = 2.0f; // lives for 2 seconds</code></pre><p>}</p><p>   Update方法更新每个粒子的位置，并在粒子超出自己的生活周期时杀死它。注意：这个系统不能移除死掉的粒子，这么做是因为我们想产生一个新的火焰的时候，我们只要简单的重新设置已经存在的死了的火焰系统就可以了。这样为我们不必频繁的去产生和释放粒子。<br>void Firework::update(float timeDelta)<br>{<br>     std::list<attribute>::iterator i;</attribute></p><pre><code> for(i = _particles.begin(); i != _particles.end(); i++) {      // only update living particles      if( i-&gt;_isAlive )      {           i-&gt;_position += i-&gt;_velocity * timeDelta;           i-&gt;_age += timeDelta;           if(i-&gt;_age &gt; i-&gt;_lifeTime) // kill                i-&gt;_isAlive = false;      } }</code></pre><p>}<br>当渲染时，火系统使用不同的方法渲染像素。进一步讲，它不写深度缓存，我们可以简单的改变混合像素，通过重写PSystem::preRender方法和PSystem::postRender方法，下面是重写的实现：<br>void Firework::update(float timeDelta)<br>{<br>     std::list<attribute>::iterator i;<br>void Firework::preRender()<br>{<br>     PSystem::preRender();</attribute></p><pre><code> _device-&gt;SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE); _device-&gt;SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE); // read, but don&#39;t write particles to z-buffer _device-&gt;SetRenderState(D3DRS_ZWRITEENABLE, false);</code></pre><p>}</p><p>void Firework::postRender()<br>{<br>     PSystem::postRender();</p><pre><code> _device-&gt;SetRenderState(D3DRS_ZWRITEENABLE, true);</code></pre><p>}<br>注意：这两个方法调用父类版本，这样，我们仍能重新使用父类的一些功能，做一些小的改变就变成了火焰系统。<br>14.3.3 例子程序：粒子枪</p><p>图14.4 激光枪系统的截图<br>下面是粒子枪系统的定义：<br>class ParticleGun : public PSystem<br>{<br>public:<br>     ParticleGun(Camera<em> camera);<br>     void resetParticle(Attribute</em> attribute);<br>     void update(float timeDelta);</p><p>private:<br>     Camera<em> _camera;<br>};<br>   构造器需要提供一个照相机的位置点，这是因为系统需要知道照相机的位置及朝向，以决定在哪创建一个粒子。<br>   ResetParticle方法设置粒子的位置为当前照相机的位置，并且设置方向上的速度，在照像机视角的100个单位。这样，子弹将射向我们正在看的方向，粒子颜色为绿色。<br>void ParticleGun::resetParticle(Attribute</em> attribute)<br>{<br>     attribute-&gt;_isAlive  = true;</p><pre><code> D3DXVECTOR3 cameraPos; _camera-&gt;getPosition(&amp;cameraPos); D3DXVECTOR3 cameraDir; _camera-&gt;getLook(&amp;cameraDir); // change to camera position attribute-&gt;_position = cameraPos; attribute-&gt;_position.y -= 1.0f; // slightly below camera so it&#39;s                                 // like we&#39;re carrying gun // travels in the direction the camera is looking attribute-&gt;_velocity = cameraDir * 100.0f; // green attribute-&gt;_color = D3DXCOLOR(0.0f, 1.0f, 0.0f, 1.0f); attribute-&gt;_age      = 0.0f; attribute-&gt;_lifeTime = 1.0f; // lives for 1 seconds</code></pre><p>}</p><p>   Update方法更新粒子的位置，并且杀死超过其生命周期的粒子，然后，我们搜索粒子列表删除已经死了的粒子。<br>{<br>     std::list<attribute>::iterator i;</attribute></p><pre><code> for(i = _particles.begin(); i != _particles.end(); i++) {      i-&gt;_position += i-&gt;_velocity * timeDelta;      i-&gt;_age += timeDelta;      if(i-&gt;_age &gt; i-&gt;_lifeTime) // kill           i-&gt;_isAlive = false; } removeDeadParticles();</code></pre><p>}</p><p>14.4 摘要</p><ul><li>用点精灵来显示一个粒子是方便且灵活的，它可能改变粒子尺寸、给粒子赋予纹理。此外，能够使用简单的顶点（vertex）来描述它们。</li><li>粒子系统维护一个粒子的集合，并负责创建、释放、更新和显示粒子。</li><li>还有一些其他粒子系统的概念，是你能够实现的：烟，火箭的轨迹，喷泉/河水车效果，火，光，爆炸，和雨。</li></ul><p>第十五章 选取<br>(Picking)<br>概览(OVERVIEW)<br>   如果用户点击了屏幕上的点 s = (x, y)。 从图15.1 我们能看到用户选取了茶壶。 无论如何，应用程序无法根据给定的s点就立即确定茶壶是被选取。所以，我们必须拿出计算这个动作技巧来，叫做选取技巧。</p><p>   图15.1 用户正在选择茶壶</p><p>   我们知道一些知识：关于茶壶和它的关联点s，茶壶投影在围绕s点的区域，更准确的说是：它投影到投影窗口上围绕p点的区域，与它对应的屏幕点是s。因为这个问题依赖于3D物体与它的投影之间的关系，我们看图15.2就可以了解。</p><p>图15.2放射线穿过点p点将会相交于围绕p点投影的对象。 注意：在投影窗口上的点 p与荧屏上被按下了点s相关联。</p><p>   图15.2我们看到如果我们发射一条选取射线，从原点发出，经过点p，会与围绕p点投影的对象相交，即茶壶。所以一旦我们计算选取射线，我们可以遍例场景中的每个对象并测试，看射线是否与它相交。与射线相交的对象即是用户选择的对象，在这个例子中用户选取的对象是茶壶。<br>   上面的例子讲解了点s与茶壶的关系。通常我们任意点击屏幕上的点，我们遍例场景中的每个对象，如果对象与射线相交，那么这个对象就是用户选取的对象。例如，图15.1中，如果用户没有点击5个对象中的一个，而是点击了白色的背景区域，射线将不能相交任何对象。因此，结论是：如果射线没有与场景中的任何对象相交，则用户没有点击任何一个对象，其它的我们不关心。<br>   “选取”适用于所有种类的游戏和3D程序。例如，玩家通过用鼠标点击来影响3D世界中的不同对象，玩家可能点击向敌人射击，或点击拾取物品。好的程序会适当做出反应，程序需要知道哪个对象被选取（是敌人还是物品），和在3D空间中的位置（开枪会击中哪？或玩家将要移动到哪去拾取物品？）。选取回答了我们这些问题。</p><p>目标<br>学习如何计算选取算法并了解它是如何工作的，我们将选取分解成四步：<br>1) 给一个屏幕点s，找出它在投影窗口上相交的点，即p。<br>2) 计算射线，它是从原点出发并经过点p。<br>3) 转换射线与模型到同一空间。<br>4) 测试与射线相交的对象，相交的对象即是屏幕上点击的对象。<br>15.1 屏幕到投影窗口的转换<br>首先，转换屏幕点到投影窗口，视口变换矩阵是：</p><p>根据屏幕上的点s = (sx, sy)，通过视口转换，得到在投影窗口上的点p = (px, py, pz)：</p><p>回忆一下2D图形部分：视口转换后z轴是不用保存的，而被保存在z缓存中。<br>给出屏幕点s，我们要找到点p，使用下列公式：</p><p>假定视口成员x和y都是0，通常我们能进一步得到：</p><p>因为前面的定义，投影窗口就是z=1的平面，所以pz = 1。</p><p>可是我们还什么都没做，投影矩阵缩放投影窗口上的点，来模拟不同的视角。为了返回缩放前的点值，我们必须用与缩放相反的操作来转换点。P是投影矩阵，因为P00 和 P11转换距阵缩放点的x和y坐标，我们得到：</p><p>15.2 计算射线<br>   回忆一下，射线能够描述参数方程：p(t) = p0 + tu。其中p0是射线的起点，用来描述它的位置，u是向量，用来描述它的方向。<br>   如图15.2，我们知道射线的起点总是视图空间的原点，所以p0 = (0, 0, 0)，如果p是射线穿过投影窗口上的点，方向向量u给出：u = p - p0 = (px, py, 1) - (0, 0, 0) = p。<br>   下面的方法用来计算选取射线（从屏幕空间点击的点所对应的视图空间的点x、y坐标）：<br>d3d::Ray CalcPickingRay(int x, int y)<br>{<br>     float px = 0.0f;<br>     float py = 0.0f;</p><pre><code> D3DVIEWPORT9 vp; Device-&gt;GetViewport(&amp;vp); D3DXMATRIX proj; Device-&gt;GetTransform(D3DTS_PROJECTION, &amp;proj); px = ((( 2.0f*x) / vp.Width)  - 1.0f) / proj(0, 0); py = (((-2.0f*y) / vp.Height) + 1.0f) / proj(1, 1); d3d::Ray ray; ray._origin    = D3DXVECTOR3(0.0f, 0.0f, 0.0f); ray._direction = D3DXVECTOR3(px, py, 1.0f); return ray;</code></pre><p>}<br>where Ray is defined as:<br>struct Ray<br>{<br>     D3DXVECTOR3 _origin;<br>     D3DXVECTOR3 _direction;<br>};<br>   我们更新d3dUtility.h文件，在d3d命名空间中加入选取射线Ray。</p><p>15.3 变换射线<br>   上一节讲到，选取射线的计算被描述在视图空间，为了完成射线的相交的测试，射线和对象必须在同一个坐标系统。通常转换射线到世界空间（甚至对象在本地空间）要好于将所有对象转换到视图空间。<br>   我们能够将一个变换矩阵转换为一条原点为p0，方向为u的射线r(t) = p0 + tu，注意：原点转换为一个点，方向转换为一个向量，在本章的选取例子中，下列函数转换一条射线：<br>void TransformRay(d3d::Ray<em> ray, D3DXMATRIX</em> T)<br>{<br>      // transform the ray’s origin, w = 1.<br>      D3DXVec3TransformCoord(<br>           &amp;ray-&gt;_origin,<br>           &amp;ray-&gt;_origin,<br>           T);</p><pre><code>  // transform the ray&#39;s direction, w = 0.  D3DXVec3TransformNormal(       &amp;ray-&gt;_direction,       &amp;ray-&gt;_direction,       T);  // normalize the direction  D3DXVec3Normalize(&amp;ray-&gt;_direction, &amp;ray-&gt;_direction);</code></pre><p>}<br>   D3DXVec3TransformCoord和D3DXVec3TransformNormal接受一个Ray类型参数（包含二个3D向量成员）。 D3DXVec3TransformCoord函数中，射线的原点（_origin）向量的第四部分w = 1。相反，函数D3DXVec3TransformNormal中，射线的方向（_direction）向量的第四部分w = 0。<br>   这样，当我们向世界空间转换时，能够用D3DXVec3TransformCoord转换一个点，用D3DXVec3TransformNormal转换一个向量。</p><p>15.4 射线－对象 交点<br>   我们将射线和对象转换到同一坐标系统后，准备测试哪个对象与射线相交。因为我们将对象描述为三角形组成的网络，下面详细说明这种方法。遍例场景中每个对象的三角形列表并测试，如果射线相交于一个三角形，它就与三角形所在的对象相交。<br>   然而，通过遍例场景中的每个三角形来实现射线相交在计算上会增加时间，一种比较快的方法，虽然准确性会差一点。它将每个对象围成一个近似的球形（边界球），这样我们就能通过遍例每个边界球来测试射线相交。用边界球来描述相交的对象。<br>   注意：射线可能相交多个对象，然而离照相机近的对象会被选取。因为近距离对象遮挡了后面的对象。<br>   给出一个边界球的圆心c和半径r，使用下列恒等式能够测试点p是否在边界球上：<br>   ||p-c||-r = 0<br>   如果恒等式满足，则点p在边界球上。如图15.3</p><p>   图15.3 向量p到c的长度表示为：||p - c||，如果等于半径则表示点p在边界球上。注意：我们使用边界球是为了方便，但这将扩展出三个种情况。<br>   假定射线p(t) = p0 + tu相交于边界球，我们将射线代入球的恒等式中，使参数t满足了球的恒等式，给出了满足相交点的参数。</p><p>将射线p(t) = p0 + tu代入球的恒等式：<br>||p(t) - c|| - r = 0   —&gt;   ||p0 + tu - c|| - r = 0</p><p>通过以上推导，我们得到二次方程：<br>At2 + Bt + C = 0</p><p>其中A = u · u, B = 2(u · (p0 - c))，而C = (p0 - c) . (p0 - c) – r 2。<br>如果u是标准化的，那么A = 1。<br>因为u是标准化的，我们解t0 和 t1：</p><p>   图15.4显示可能返回的t0 和 t1，并显示了一些返回值的几何意义：</p><p>   图15.4 (a)射线从球边上擦过；(b)射线在球前；(c)射线在球的内部；(d)射线相交于球；(e)射线是球的切线。<br>   下列方法射线通过并与边界球相交，返回true；射线错过边界球，返回false。<br> bool PickApp::raySphereIntersectionTest(Ray<em> ray,<br>                                        BoundingSphere</em> sphere)<br>{<br>     D3DXVECTOR3 v = ray-&gt;_origin - sphere-&gt;_center;<br>     float b = 2.0f <em> D3DXVec3Dot(&amp;ray-&gt;_direction, &amp;v);<br>     float c = D3DXVec3Dot(&amp;v, &amp;v) - (sphere-&gt;_radius </em> sphere-&gt;<br>                                      _radius);</p><pre><code> // find the discriminant float discriminant = (b * b) - (4.0f * c); // test for imaginary number if( discriminant &lt; 0.0f )      return false; discriminant = sqrtf(discriminant); float s0 = (-b + discriminant) / 2.0f; float s1 = (-b - discriminant) / 2.0f; // if a solution is &gt;= 0, then we intersected the sphere if( s0 &gt;= 0.0f || s1 &gt;= 0.0f )      return true; return false;</code></pre><p>}<br>   当然，我们已经准备了一个边界球，为了便于理解我们再次显示它的定义：<br>bool PickApp::raySphereIntersectionTest(Ray<em> ray,<br>                                        BoundingSphere</em> sphere)<br>{<br>struct BoundingSphere<br>{<br>     BoundingSphere();</p><pre><code> D3DXVECTOR3 _center; float       _radius;</code></pre><p>};</p><p>15.5 例子程序：选取<br>图15.5显示了本章例子程序的屏幕截图，茶壶绕着屏幕移动，你可以用鼠标试着点击它。如果你点击到茶壶的边界球上，一个消息框将弹出，表示你点中了。我们通过测试WM_LBUTTONDOWN消息来处理鼠标点击事件：<br>case WM_LBUTTONDOWN:</p><p>// compute the ray in view space given the clicked screen point<br>d3d::Ray ray = CalcPickingRay(LOWORD(lParam), HIWORD(lParam));</p><p>// transform the ray to world space<br>D3DXMATRIX view;<br>Device-&gt;GetTransform(D3DTS_VIEW, &amp;view);</p><p>D3DXMATRIX viewInverse;<br>D3DXMatrixInverse(&amp;viewInverse, 0, &amp;view);</p><p>TransformRay(&amp;ray, &amp;viewInverse);</p><p>// test for a hit<br>if( RaySphereIntTest(&amp;ray, &amp;BSphere) )<br>     ::MessageBox(0, “Hit!”, “HIT”, 0);</p><p>break;</p><p>图15.5 这章例子程序的屏幕截图</p><p>15.6 摘要</p><ul><li>选取技巧通过鼠标点击，来确定与3D对象对应的屏幕上显示的2D投影对象。</li><li>选取线是一个射线，源自视图空间的原点，穿过投影窗口上的点关联到屏幕上点击的点。</li><li>我们能够变换一个射线r(t) = p0 + tu，通过变换原点p0和通过矩阵变换得到方向u。注意：原点变换自一个（w=1）的点，方向是（w=0）的向量。</li><li>测试射线与对象相交，我们能测试射线是否相交于组成对象的三角形，或测试射线是否相交于围绕对象的一个体积，比如边界球。</li></ul><p>第四部分 着色器和特效<br>(Shaders and Effects)<br>第十六章 高级着色器语言入门<br>(Introduction to the High-Level Shading Language)<br>   在这一章里我们描述高级着色器语言（High-Level Shading Language ，简称HLSL），在下三章里我们用它去编写顶点和像素着色器。简单的说，在我们写的程序里顶点和像素是很小的对象，它们由GPU来执行，是固定功能管线的一部分。用我们自己写的着色器程序替换一部分固定功能管线，在绘制效果上我们获得很大的灵活性。我们不再局限于预定义的”固定”操作。<br>   为了编写着色器程序，我们需要一种语言。 在DirectX 8.x,中，着色器是用低级着色器汇编语言编写的。幸运的是，我们不必再用汇编语言来写着色器了，DirectX 9支持一种高级着色器语言来xyna写。用HLSL在汇编语言来写着色器程序与使用高级语言有同样的优势，像C++，它超越了汇编语言，即：</p><ul><li>增加生产力—用高级语言比用低级语言写程序更快、更容易。 我们可以花费更多的时间关注于算法而不是代码。</li><li>增加可读性—用高级语言写的程序更易读，这意味着用高级语言编程更易于调试和维护。</li><li>大多数情况下，编译器产生的汇编代码比手写有效率。</li><li>使用HLSL 编译器，我们可以编译我们的代码到任何可用shader版本，使用汇编语言我们将不得不为每个需要的版本移植代码。</li></ul><p>HLSL 同C和C++语法很类似, 所以缩短了学习曲线。<br>   最后，如果你的显卡不支持顶点和像素着色器的话，为了执行着色器的例子程序你将需要转换REF设备。使用REF设备意味着着色器例子运行的会很慢，但它至少能显示结果，让我们去检查是否代码可以被执行。</p><p>提示：顶点shaders可以用软件来模拟 ―― D3DCREATE_SOFTWARE_VERTEX-PROCESSING。16.1 </p><p>目标</p><ul><li>学习如何定、编译一个HLSL 着色器程序。</li><li>学习如何将程序中的数据传送到着色器程序。</li><li><p>熟悉语法、类型，和HLSL的内建函数。<br>16.1 编写HLSL 着色器<br> 我们可以在程序源文件中用长字符串直接编写HLSL 着色器代码，然而更方便、更模块化的方法是把它与程序代码分离出来。因此，我们在记事本中编写着色器并保存成一般的ASCII文本文件，然后可以用D3DXCompileShaderFromFile函数(section 16.2.2)来编译它们。<br> 作为介绍，下面是用HLSL编写的一个简单的顶点着色器，用记事本生成并保存成文本文件“Transform.txt”。全部工程都在标题为Transform的目录下，顶点着色器用组合视图和投影矩阵转换顶点，并设置顶点漫射光为蓝色。</p><p> 注意：这是一个顶点着色器的例子，不必关心顶点着色器做了什么，这是下一章包含的内容，现在的目标是熟悉HLSL编程的语法和格式。<br>// File: transform.txt<br>// Author: Frank D. Luna (C) All Rights Reserved<br>// System: AMD Athlon 1800+ XP, 512 DDR, Geforce 3, Windows XP,<br>// MSVC++ 7.0</p></li></ul><p>// Desc: 顶点着色器用组合视图和投影矩阵转换顶点，并设置顶点漫射光为蓝色.</p><p>//全局变量<br>//用来保存视图和投影的组合矩阵，在程序中初始化变量<br>matrix ViewProjMatrix;</p><p>// 初始化颜色变量（蓝色）<br>vector Blue = {0.0f, 0.0f, 1.0f, 1.0f};</p><p>// 结构<br>// Input结构用来描述输入到着色器的顶点，这个Input顶点只包含一个位置成员<br>struct VS_INPUT<br>{<br>     vector position  : POSITION;<br>};</p><p>//Output结构用来描述从着色器输出的顶点，这个Output顶点包含位置和颜色成员<br>struct VS_OUTPUT<br>{<br>     vector position : POSITION;<br>     vector diffuse  : COLOR;<br>};</p><p>//主入口点，这个main函数接收一个Input顶点的拷贝作为参数，返回一个Output顶点的拷贝<br>VS_OUTPUT Main(VS_INPUT input)<br>{<br>     // 将output结构所有成员初始化<br>     VS_OUTPUT output = (VS_OUTPUT)0;<br>     // 将位置变换到投影空间<br>     output.position  = mul(input.position, ViewProjMatrix);<br>     // 设置顶点颜色<br>     output.diffuse = Blue;<br>     //Output the projected and colored vertex.<br>     return output;<br>}</p><p>16.1.1 全局变量<br>首先是2个全局变量：<br>matrix ViewProjMatrix;<br>vector Blue = {0.0f, 0.0f, 1.0f, 1.0f};<br>   第1个变量ViewProjMatrix是矩阵类型，它是一个在HLSL 内创建的4×4的矩阵类型。这个变量保存视图与投影的组合矩阵，它描述两者的变换。使用这种方法我们只要做一个向量和矩阵的乘法（而不是二个）。注意，在着色器源代码的任何地方都没有初始化这个变量，因为它是我们在应用程序的源代码里设置的，而不是在着色器中。从应用程序向着色器程序通讯是常用的操作，例子在16.2.1节。<br>   第二个变量Blue是built-in（内建）类型的4D向量，我们简单的将它初始化成蓝色，它是个RGBA的颜色向量。</p><p>16.1.2 输入和输出结构<br>   在全局变量定义之后，定义2个特殊的结构，我们调用输入和输出结构。对于顶点着色器而言，这些结构定义了顶点的数据，分别是：<br>struct VS_INPUT<br>{<br>     vector position : POSITION;<br>};</p><p>struct VS_OUTPUT<br>{<br>     vector position : POSITION;<br>     vector diffuse  : COLOR;<br>};<br>注意：给像素着色器的结构定义输入和输出像素数据。</p><p>   在例子中，INPUT 顶点着色器只包含位置成员（POSITION），OUTPUT顶点着色器包含位置和颜色成员（POSITION and COLOR）。<br>   特殊的冒号是一种语义，用于是声明变量。这与vertex结构中的自由顶点格式（FVF）相似。例如，在VS_INPUT中有成员：vector position : POSITION;<br>   “: COLOR”是说顶点的漫射光是用VS_OUTPUT结构的COLOR成员来说明的。在下一章中对于顶点和像素着色器中向量的标识符用法，我们将会有更多的讨论。<br>   注意：从底层来说，着色器变量的语义和语法同硬件寄存器是相关联的。即，input变量与input寄存器关联，output变量与output寄存器关联。例如，VS_INPUT中的position成员与顶点input的position寄存器相关联。同样，diffuse与顶点的output 的color寄存器关联。</p><p>16.1.3 函数的入口点<br>   在C++程序中，每个HLSL程序有一个入口点。在我们的着色器例子中，我们调用入口点函数main。然而名字不是强制的。入口点函数名可以是任何有效的函数名，入口点函数必须有一个input结构参数，它通过input顶点进入着色器。入口点函数必须返回一个output结构实例，在着色器中使用output操作顶点。<br>VS_OUTPUT Main(VS_INPUT input)<br>{</p><p>   注意：实际上，使用input、output结构不是强制的。例如，有时你将会看到使用类似下面的语法，特别是在像素着色器中：<br>float4 Main(in float2 base : TEXCOORD0,<br>            in float2 spot : TEXCOORD1,<br>            in float2 text : TEXCOORD2) : COLOR<br>{<br>…<br>}</p><p>   例子中，输入到着色器中的参数是3个纹理坐标。着色器输出（返回）一个颜色，COLOR语句在函数的声明以后。这种定义是类似于：<br>struct INPUT<br>{<br>     float2 base : TEXCOORD0;<br>     float2 spot : TEXCOORD1;<br>     float2 text : TEXCOORD2;<br>};</p><p>struct OUTPUT<br>{<br>     float4 c : COLOR;<br>};</p><p>OUTPUT Main(INPUT input)<br>{<br>…<br>}</p><p>   输入点函数负责根据给定的input顶点计算output顶点。例子中的着色器简单的变换input顶点到视图空间和投影空间，设置顶点颜色为蓝色，并返回结果顶点。首先我们定义VS_OUTPUT的实例并初始化所有成员为0。<br>VS_OUTPUT output = (VS_OUTPUT)0; // zero out all members<br>   然后着色器变换input顶点位置用ViewProjMatrix变量，使用mul 函数。它是一个built-in（内建）函数，实现向量与矩阵相乘，或矩阵与矩阵相乘。我们保存结果变换的向量（在output实例的position成员中）。<br>// 变换后为投影空间的位置<br>output.position = mul(input.position, ViewProjMatrix);<br>   然后设置output的成员diffuse的颜色为蓝色：<br>// 设置顶点颜色<br>output.diffuse = Blue;<br>   最后返回结果向量：<br>return output;<br>}<br>16.2 编译HLSL 着色器<br>16.2.1 常量表<br>   每个着色器有一个常量表，用来保存它的变量。D3DX库通过ID3DXConstantTable接口，提供给应用程序访问着色器的常量表。通过这个接口我们能够在应用程序中设置着色器源代码中的变量。<br>   我们现在描述一个被节选了的ID3DXConstantTable接口的方法列表的实现，全部的列表请查阅Direct3D文档。<br>16.2.1.1 取得常量句柄<br>   为了在应用程序中设置着色器中的一个特定变量，需要有一种方法去引用它，我们能够在应用程序中用D3DXHANDLE引用一个在着色器中的变量，下面的方法返回一个着色器中的变量的D3DXHANDLE，使用时，需要传递一个变量的名字作为参数：<br>D3DXHANDLE ID3DXConstantTable::GetConstantByName(<br>     D3DXHANDLE hConstant, // scope of constant<br>     LPCSTR pName          // name of constant<br>);</p><ul><li>Hconstant——我们要取得的父结构中变量句柄的D3DXHANDLE标识。例如，如果我们想获得一个特定数据结构中单一数据成员的句柄，我们可以传递结构实例的句柄。如果我们获得一个顶级变量的句柄，给这个参数设为0。</li><li>PName——我们想获得的句柄的着色器代码中的变量的名字。</li></ul><p>例如，如果在着色器中变量的名字为ViewProjMatrix，并且这是顶级变量，我们这么写：<br>// 取得着色器中ViewProjMatrix变量的句柄<br>D3DXHANDLE h0;<br>h0 = ConstTable-&gt;GetConstantByName(0, “ViewProjMatrix”);</p><p>16.2.1.2 设置常量<br>   一旦应用程序有了一个D3DXHANDLE，要引用着色器代码中的具体变量，我们可以在应用程序中使用ID3DXConstantTable::SetXXX方法设置变量。如果我们想设置一个向量数组类型的变量，方法名是SetVectorArray。<br>   ID3DXConstantTable::SetXXX的一般语法是：<br>HRESULT ID3DXConstantTable::SetXXX(<br>     LPDIRECT3DDEVICE9 pDevice,<br>     D3DXHANDLE hConstant,<br>     XXX value<br>);</p><ul><li>PDevice：常量表所关联的设备的指针。</li><li>HConstant：我们正在设置的变量句柄的引用。</li><li><p>Value：我们要把变量设置成的值，XXX是我们设置的要替换的变量类型名，对于有些类型（bool, int, float），传递变量值的COPY，另外一些类型（vectors, matrices, structures），传递值的指针。</p><p> 下面列表描述了我们能用ID3DXConstantTable接口设置的类型列表。这里假定我们有一个有效的设备，和一个有效句柄。<br>SetBool—Used to set a Boolean value. Sample call:<br>bool b = true;<br>ConstTable-&gt;SetBool(Device, handle, b);</p></li></ul><p>SetBoolArray—Used to set a Boolean array. Sample call:<br>bool b[3] = {true, false, true};<br>ConstTable-&gt;SetBoolArray(Device, handle, b, 3);</p><p>SetFloat—Used to set a float. Sample call:<br>float f = 3.14f;<br>ConstTable-&gt;SetFloat(Device, handle, f);</p><p>SetFloatArray—Used to set a float array. Sample call:<br>float f[2] = {1.0f, 2.0f};<br>ConstTable-&gt;SetFloatArray(Device, handle, f, 2);</p><p>SetInt—Used to set an integer. Sample call:<br>int x = 4;<br>ConstTable-&gt;SetInt(Device, handle, x);</p><p>SetIntArray—Used to set an integer array. Sample call:<br>int x[4] = {1, 2, 3, 4};<br>ConstTable-&gt;SetIntArray(Device, handle, x, 4);</p><p>SetMatrix—Used to set a 4 × 4 matrix. Sample call:<br>D3DXMATRIX M(…);<br>ConstTable-&gt;SetMatrix(Device, handle, &amp;M);</p><p>SetMatrixArray—Used to set a 4 × 4 matrix array. Sample call:<br>D3DXMATRIX M[4];<br>// …Initialize matrices<br>ConstTable-&gt;SetMatrixArray(Device, handle, M, 4);</p><p>SetMatrixPointerArray—Used to set an array of 4 × 4 matrix pointers. Sample call:<br>D3DXMATRIX* M[4];<br>// …Allocate and initialize matrix pointers<br>ConstTable-&gt;SetMatrixPointerArray(Device, handle, M, 4);</p><p>SetMatrixTranspose—Used to set a transposed 4 × 4 matrix. Sample call:<br>D3DXMATRIX M(…);<br>D3DXMatrixTranspose(&amp;M, &amp;M);<br>ConstTable-&gt;SetMatrixTranspose(Device, handle, &amp;M);</p><p>SetMatrixTransposeArray—Used to set an array of 4 × 4 transposed matrices. Sample call:<br>D3DXMATRIX M[4];<br>// …Initialize matrices and transpose them.<br>ConstTable-&gt;SetMatrixTransposeArray(Device, handle, M, 4);</p><p>SetMatrixTransposePointerArray—Used to set an array of pointers to 4 × 4 transposed matrices. Sample call:<br>D3DXMATRIX* M[4];<br>// …Allocate,initialize matrix pointers and transpose them.<br>ConstTable-&gt;SetMatrixTransposePointerArray(Device, handle, M, 4);</p><p>SetVector—Used to set a variable of type D3DXVECTOR4. Sample call:<br>D3DXVECTOR4 v(1.0f, 2.0f, 3.0f, 4.0f);<br>ConstTable-&gt;SetVector(Device, handle, &amp;v);</p><p>SetVectorArray—Used to set a variable that is a vector array. Sample call:<br>D3DXVECTOR4 v[3];<br>// …Initialize vectors<br>ConstTable-&gt;SetVectorArray(Device, handle, v, 3);</p><p>SetValue—Used to set an arbitrarily sized type, such as a structure. In the sample call, we use SetValue to set a D3DXMATRIX:<br>D3DXMATRIX M(…);<br>ConstTable-&gt;SetValue(Device, handle, (void*)&amp;M, sizeof(M));</p><p>16.2.1.3 设置常量默认值<br>   下一个方法就是设置常量的默认值，这些默认值在声明时初始化。这个方法应该在应用程序建立（setup）期间被一次性调用（called once）。<br>   HRESULT ID3DXConstantTable::SetDefaults(<br>        LPDIRECT3DDEVICE9 pDevice<br>   );<br>   pDevice——关联到常量表的设备的指针。</p><p>16.2.2 编译HLSL着色器<br>   我们可以编译一个着色器——用我们已保存的着色器的文本文件——使用下列函数：<br>   HRESULT D3DXCompileShaderFromFile(<br>        LPCSTR               pSrcFile,<br>        CONST D3DXMACRO<em>     pDefines,<br>        LPD3DXINCLUDE        pInclude,<br>        LPCSTR               pFunctionName,<br>        LPCSTR               pTarget,<br>        DWORD                Flags,<br>        LPD3DXBUFFER</em>        ppShader,<br>        LPD3DXBUFFER<em>        ppErrorMsgs,<br>        LPD3DXCONSTANTTABLE</em> ppConstantTable<br>   );</p><ul><li>pSrcFile——要编译的包含着色器源代码的文本文件的文件名</li><li>pDefines——参数可选，本书中指定为空。</li><li>pInclude——ID3DXInclude接口指针。这个接口被设计成由应用程序实现，所以我们可以重载默认include的行为。通常，默认行为就可以了，而且我们可以通过将其指定为空忽略此参数。</li><li>pFunctionName——指定入口点函数名的字符串。例如，如果着色器的入口点函数叫做Main，我们可以给此参数传递“Main”。</li><li><p>pTarget——指定要编译成的HLSL着色器源文件的版本的字符串。有效的顶点着色器版本是：vs_1_1, vs_2_0, vs_2_sw。有效的像素着色器版本是2.0，我们可以给此参数传递vs_2_0。</p><p> 备注：有编译不同版本着色器的能力，是HLSL与汇编语言比的主要优势。用HLSL我们只需为需要的目标简单的重新编译，便可快速移植着色器到不同的版本。使用汇编，我们可能需要手动移植代码。</p></li><li>Flags——可选的编译标记，指定为0标识没有标记。有效的选项是：</li><li>D3DXSHADER_DEBUG——通知编译器写入调试信息</li><li>D3DXSHADER_SKIPVALIDATION——通知编译器不要做任何代码检查。此项仅用于你已知着色器能够工作时</li><li>D3DXSHADER_SKIPOPTIMIZATION——通知编译器不要执行任何代码优化。实践中，这个选项应该仅用于调试，因为这种情况下你不希望编译器以任何方式修改代码。</li><li>ppShader——返回已编译的着色器代码的ID3DXBuffer指针。这个已编译过的着色器代码将作为另一个实际创建顶点/像素着色器函数的参数</li><li>ppErrorMsgs——返回包含错误码和错误消息字符串的ID3DXBuffer指针</li><li><p>ppConstantTable——返回包含此着色器常量表数据的ID3DXConstantTable指针</p><p> 这里是一个调用D3DXCompileShaderFromFile的例子：<br> // Compile shader</p><p> ID3DXConstantTable<em> TransformConstantTable = 0;<br> ID3DXBuffer</em> shader      = 0;<br> ID3DXBuffer* errorBuffer = 0;</p><p> hr = D3DXCompileShaderFromFile(</p><pre><code>  &quot;transform.txt&quot;,      // shader filename  0,  0,  &quot;Main&quot;,               // entry point function name  &quot;vs 2 0&quot;,             // shader version to compile to  D3DXSHADER_DEBUG,     // debug compile  &amp;shader,  &amp;errorBuffer,  &amp;TransformConstantTable);</code></pre><p> // output any error messages<br> if( errorBuffer )<br> {</p><pre><code>  ::MessageBox(0, (char*)errorBuffer-&gt;GetBufferPointer(), 0, 0);  d3d::Release&lt;ID3DXBuffer*&gt;(errorBuffer);</code></pre><p> }</p><p> if (FAILED (hr))<br> {</p><pre><code>  ::MessageBox(0, &quot;D3DXCreateEffectFromFile() - FAILED&quot;, 0, 0);  return false;</code></pre><p> }</p></li></ul><p>16.3 变量类型<br>   注意：除了下列各小节中描述的类型外，HLSL还有一些内建的对象类型（如：纹理对象）。但是，由于这些对象类型主要用于效果框架，我们将对其延迟到第19章讨论。</p><p>16.3.1 数值类型<br>HLSL支持下列数值类型（scalar type）：</p><ul><li>bool—True or false value. Note that HLSL provides the true and false keywords.</li><li>int—32-bit signed integer</li><li>half—16-bit floating-point number</li><li>float—32-bit floating-point number</li><li>double—64-bit floating-point number<br> 注意：一些平台不支持int, half, and double类型，这时我们使用 float类型模拟。</li></ul><p>16.3.2 向量类型<br>HLSL有下列内建的向量类型（vector type）：</p><ul><li>vector——各分量为float类型的4D向量</li><li><p>vector<t, n>——一个n维向量，其每个分量都为T类型。n维必须在1到4之间。这里是一个2D double向量的例子：<br>vector<double, 2> vec2;</double,></t,></p><p> 我们可以使用数组下标的语法访问向量的一个分量。例如，要设置向量vec的第i个分量，我们可以写成：<br>vec[i] = 2.0f;</p><p> 此外，我们可以像访问结构的成员一样访问向量vec的一个分量，使用已定义的分量名x，y，z，w，r，g，b和a。<br>vec.x = vec.r = 1.0f;<br>vec.y = vec.g = 2.0f;<br>vec.z = vec.b = 3.0f;</p></li></ul><p>vec.w = vec.a = 4.0f;</p><p>   名称为r，g，b和a的分量分别对应x，y，z和w的分量。当使用向量来表示颜色时，RGBA符号是更适合的，因为它加强了向量所表示的颜色。</p><p>   作为选择，我们可以使用其它一些预定义类型，分别用来代表2D，3D和4D向量的类型：<br>float2 vec2;<br>float3 vec3;<br>float4 vec4;</p><p>   考虑向量u = (ux, uy, uz, uw)，假设我们要拷贝u的所有分量到一个像v = (ux, uy, uy, uw)这样的向量v。最直接的方法可能是逐个从u往v拷贝每个分量。但不管怎样，HLSL提供了一种特殊的语法做这些无序的拷贝，它叫做“鸡尾酒”（swizzles）：<br>vector u = {l.0f, 2.0f, 3.0f, 4.0f};<br>vector v = {0.0f, 0.0f, 5.0f, 6.0f};<br>v = u.xyyw; // v = {1.0f, 2.0f, 2.0f, 4.0f}</p><p>拷贝数组时，我们不必拷贝每个分量。例如，我们可以仅拷贝x和y分量，代码段举例如下：<br>vector u = {1.0f, 2.0f, 3.0f, 4.0f};<br>vector v = {0.0f, 0.0f, 5.0f, 6.0f};<br>v.xy = u; // v = {l.0f, 2.0f, 5.0f, 6.0f}</p><p>16.3.3 矩阵类型<br>HLSL有下列内建矩阵类型：</p><ul><li>matrix——一个4×4矩阵，其各项类型为float</li><li>matrix<t, m, n>——一个m×n矩阵，其每个成员为类型T。矩阵维数m和n必须在1至4之间。</t,></li></ul><p>这里是一个2×2整型矩阵的例子：<br>matrix<int, 2 2,> m2x2;</int,></p><p>作为选择，我们可以定义一个m×n矩阵，其m和n在1至4之间，使用下列语法：<br>floatmxn matmxn;<br>实例：<br>float2x2 mat2x2;<br>float3x3 mat3x3;<br>float4x4 mat4x4;<br>float2x4 mat2x4;<br>注意：类型不必是float类型——我们可以使用其它类型。举例来说，我们可以用整型，写成这样：<br>int2x2 i2x2;<br>int2x2 i3x3;<br>int2x2 i2x4;</p><p>我们可以用二维数组的下标语法访问矩阵中的项。例如，要设置矩阵M的第i，j个项，我们可以写成：<br>M[i] [j] = value;</p><p>此外，我们可以像访问结构的成员那样访问矩阵M的项。下列条目已定义：<br>以1为基数的：<br>M._11 = M._12 = M._13 = M._14 = 0.0f;<br>M._21 = M._22 = M._23 = M._24 = 0.0f;<br>M._31 = M._32 = M._33 = M._34 = 0.0f;<br>M._41 = M._42 = M._43 = M._44 = 0.0f;</p><p>以0为基数的：<br>M._m00 = M._m01 = M._m02 = M._m03 = 0.0f;<br>M._m10 = M._m11 = M._m12 = M._m13 = 0.0f;<br>M._m20 = M._m21 = M._m22 = M._m23 = 0.0f;<br>M._m30 = M._m31 = M._m32 = M._m33 = 0.0f;</p><p>有时，我们想要访问矩阵中一个特定的行。我们可以用一维数组的下标语法来做。例如，要引用矩阵M中第i行的向量，我们可以写：<br>vector ithRow = M[i]; // get the ith row vector in M</p><p>注意：可以使用两种语法在HLSL中初始化变量：<br>vector u = {0.6f, 0.3f, 1.0f, 1.0f};<br>vector v = {1.0f, 5.0f, 0.2f, 1.0f};</p><p>也可以，等价的，使用构造风格的语法：<br>vector u = vector(0.6f, 0.3f, 1.0f, 1.0f);<br>vector v = vector(1.0f, 5.0f, 0.2f, 1.0f);</p><p>其它一些例子:<br>float2x2 f2x2 = float2x2(1.0f, 2.0f, 3.0f, 4.0f);<br>int2x2 m = {1, 2, 3, 4};<br>int n = int(5);<br>int a = {5};<br>float3 x = float3(0, 0, 0);</p><p>16.3.4 数组<br>我们可以用类似C++的语法声明特定类型的一个数组。例如：<br>float  M[4][4];<br>half   p[4];<br>vector v[12];</p><p>16.3.5 结构<br>结构的定义和在C++里一样。但是，HLSL里的结构不能有成员函数。这是一个HLSL里的结构的例子：<br>struct MyStruct<br>{<br>     matrix T;<br>     vector n;<br>     float  f;<br>     int    x;<br>     bool   b;<br>};<br>MyStruct s; // instantiate<br>s.f = 5.0f; // member access</p><p>16.3.6 typedef关键字<br>   HLSL的typedef关键字功能和C++里的完全一样。例如，我们可以给类型vector<float, 3>用下面的语法命名：<br>typedef vector<float, 3> point;<br>然后，不用写成：<br>vector<float, 3> myPoint;<br>……我们只需这样写：<br>point myPoint;</float,></float,></float,></p><p>这里是另外两个例子，它展示了如何对常量和数组类型使用typedef关键字：<br>typedef const float CFLOAT;<br>typedef float point2[2];</p><p>1.3.7 变量前缀<br>下列关键字可以做变量声明的前缀：</p><ul><li><p>static——如果带static关键字前缀，那它是全局变量。就表示它不是暴露于着色器之外的。换句话说，它是着色器局部的。如果一个局部变量以static关键字为前缀，它就和C++中static局部变量有相同的行为。也就是说，该变量在函数首次执行时被一次性初始化，然后在所有函数调用中维持其值。如果变量没有被初始化，它就自动初始化为0。static int x = 5;</p></li><li><p>uniform——如果变量以uniform关键字为前缀，就意味着此变量在着色器外面被初始化，比如被C++应用程序初始化，然后再输入进着色器。</p></li><li><p>extern——如果变量以extern关键字为前缀，就意味着该变量可在着色器外被访问，比如被C++应用程序。仅全局变量可以以extern关键字为前缀。不是static的全局变量默认就是extern。</p></li><li><p>shared——如果变量以shared关键字为前缀，就提示效果框架（参见19章）：变量将在多个效果间被共享。仅全局变量可以以shared为前缀。</p></li><li><p>volatile——如果变量以volatile关键字为前缀，就提示效果框架（参见19章）：变量将被时常修改。仅全局变量可以以volatile为前缀。</p></li><li><p>const——HLSL中的const关键字和C++里的意思一样。也就是说，如果变量以const为前缀，那此变量就是常量，并且不能被改变。const float pi = 3.14f;<br>16.4关键字、语句和强制转换<br>16.4.1 关键字<br>为便于参考，这里给出一个HLSL定义的关键字列表：<br>asm        bool        compile       const          decl         do<br>double      else        extern         false          float         for<br>half        if           in            inline         inout         int<br>matrix      out         pass           pixelshader    return        sampler<br>shared      static       string          struct         technique     texture<br>true        typedef     uniform        vector         vertexshader   void<br>volatile     while</p></li></ul><p>下面的集合显示了被保留并且未使用但是将来可能成为关键字的标识符：<br>auto            break        case           catch         char          class<br>const_cast       continue      default         delete        dynamic cast   enum<br>explicit         friend         goto           long         mutable       namespace<br>new            operator       private         protected     public         register<br>reinterpret_cast   short         signed          sizeof        static_cast     switch<br>template         this          throw          try           typename     union<br>unsigned         using        virtual </p><p>16.4.2 基本程序流程<br>HLSL支持很多与C++相似的选择、重复、和一般程序流程语句。这些语句的语法和C++极为相似。<br>return语句：<br>return (expression);<br>if和if…else语句：<br>if( condition )<br>{<br>     statement(s);<br>}</p><p>if( condition )<br>{<br>     statement(s);<br>}<br>else<br>{<br>     statement(s);<br>}</p><p>for语句：<br>for(initial; condition; increment)<br>{<br>     statement(s);<br>}</p><p>while语句：<br>while( condition )<br>{<br>     statement(s);<br>}</p><p>do…while语句：<br>do<br>{<br>     statement(s);<br>}while( condition );</p><p>16.4.3 强制转换（casting）<br>   HLSL支持一种非常自由的强制转换设计。HLSL中强制转换的语法和C程序语言中的一样。例如要把float转换到matrix，我们写：<br>float f = 5.0f;<br>matrix m = (matrix)f;</p><p>   从本书的例子中，你就能推断出这个转换语法的意思。但是，如果想要得到更详细的受支持的转换的信息，那么在DirectX SDK里，Content（内容）标签页下，看DirectX Graphics\Reference\Shader Reference\High Level Shading Language\Type就可以了。</p><p>16.5 操作符<br>   HLSL支持很多类似C++的操作符。除了很少一些底下注释的例外以外，他们的用法和C++里的完全一样。下表列出了HLSL的操作符：<br>[]<br>?<br>&gt;<br>&lt;<br>&lt; =</p><blockquote><p>=<br>! =<br>= =<br>!<br>&amp;&amp;<br>?<br>?:<br>+</p><ul><li>=<br>-</li></ul><ul><li>=<br><em></em>=<br>/<br>/=<br>%<br>%=</li></ul><h2 id><a href="#" class="headerlink" title="+ +"></a>+ +</h2><p>=<br>()<br>‘</p></blockquote><p>   虽然操作符的行为和C++很相似，但是也有一些差异。第一，求模%运算符对整型和浮点型都起作用。为了使用求模操作符，左边的值和右边的值都必须有相同的正负号（如：左边和右边必须都是正或者负）。</p><p>   第二，要注意HLSL操作是以每个分量为基础的。这是由于实际上向量和矩阵是语言内建的，并且这些类型是由若干个分量组成。通过将这些操作施加在分量级别之上，我们可以像使用数值类型一样完成诸如向量/矩阵的加法，减法和相等测试这些操作（），见下例：</p><p>注意：操作符的行为正如对数值操作一样（也就是说，按一般C++的方式）。<br>vector u = {1.0f, 0.0f, -3.0f, 1.0f};<br>vector v = {-4.0f, 2.0f, 1.0f, 0.0f};<br>// adds corresponding components<br>vector sum = u + v; // sum = (-3.0f, 2.0f, -2.0f, 1.0f)</p><p>增量一个向量就是增量其每个分量：<br>// before increment: sum = (-3.0f, 2.0f, -2.0f, 1.0f)<br>sum++; // after increment: sum = (-2.0f, 3.0f, -1.0f, 2.0f)</p><p>向量相乘也是按分量的：<br>vector u = {1.0f, 0.0f, -3.0f, 1.0f};<br>vector v = {-4.0f, 2.0f, 1.0f, 0.0f};</p><p>// multiply corresponding components<br>vector sum = u * v; // product = (-4.0f, 0.0f, -3.0f, 0.0f)</p><p>比较操作也是按分量进行的，并且返回一个每个分量都为bool类型的向量或者数组。作为结果的“bool”向量包含了每个分量比较的结果。例如：<br>vector u = { 1.0f, 0.0f, -3.0f, 1.0f};<br>vector v = {-4.0f, 0.0f, 1.0f, 1.0f};<br>vector b = (u == v); // b = (false, true, false, true)</p><p>最后，我们以讨论二元操作的变量提升（promotion）作为结束：</p><ul><li>对于二元操作，如果（操作符的）左边和右边维数不同，则维数较少的一边提升（强制转换）到具有和维数较大的一边相同的维数。例如，如果x的类型为float，而y的类型为float3，在表达式(x + y)中变量x被提升到float3，并且计算出来的表达式的值的类型也为float3。提升使用已定义的转换完成。注意，若转换未定义则提升也是未定义的。例如，我们不能转换float2到float3，因为没有定义这个转换。</li><li>对于二元操作，如果左边和右边类型不同，那么较低精度的类型（the lower type resolution）被提升（强制转换）到具有同类型的较高精度的类型（the higher type resolution）。例如，如果x类型为int，y类型为half，则表达式(x + y)中的变量x被提升到half，并且计算出来的表达式的值的类型也为half。</li></ul><p>16.6 用户定义函数<br>HLSL中的函数有下例属性：</p><ul><li>函数使用类似C++的语法</li><li>参数总是按值传递</li><li>递归不被支持</li><li>函数总是inline的</li></ul><p>此外，函数还加上了一些用于其上的额外的关键字。例如，考虑一个写在HLSL中的下面这个函数：<br>bool foo(in const bool b,   // input bool<br>         out int r1,        // output int<br>         inout float r2)    // input/output float<br>{<br>     if( b )               // test input value<br>     {<br>          r1 = 5;          // output a value through r1<br>     }<br>     else<br>     {<br>          r1 = 1;          // output a value through r1<br>     }</p><pre><code> // since r2 is inout we can use it as an input // value and also output a value through it r2 = r2 * r2 * r2; return true;</code></pre><p>}</p><p>函数几乎和C++函数是一样的，除了in，out和inout关键字：</p><ul><li>in——指定型参（argument，特指传递给实参的变量）应该在函数开始前被拷贝给实参。传入参数不必强制指定，因为实参默认是in的。例如，下面两段是等价的：<br>float square(in float x)<br>{<br>   return x * x;<br>}</li></ul><p>也可以不强制指定in：<br>float square(float x)<br>{<br>     return x * x;<br>}</p><ul><li><p>out——指定实参应该在函数返回时被拷贝给型参。这样可以通过参数返回值。out关键字是必须的，因为HLSL不允许传递一个引用或一个指针。我们要注意：如果实参标记为out，在函数开始前，型参就不拷贝给实参。换句话说，out实参仅可以被用于输出数据——它不能用于输入。<br>void square(in float x, out float y)<br>{<br>   y = x * x;<br>}<br>这里，我们输入了要被乘方的数x，并且通过参数y返回了x的乘方。</p></li><li><p>inout——这是一个指示实参既用于输入又用于输出的快捷方法。如果要使用实参同时用作输入和输出，就指定inout。<br>void square(inout float x)<br>{<br>   x = x * x;<br>}<br>这里，我们输入了要被乘方的数x，同时又通过x返回了的x的乘方。</p></li></ul><p>16.7内建函数<br>   HLSL有一个丰富的内建函数的集合，它们对3D图形来说非常有用。下表是一个删减了的列表。在下两章中，我们会使用这些函数中的一些进行实践。而现在，熟悉它们就够了。</p><p>注意：要得到更多的参考，可以参看DirectX文档中内建HLSL函数的完整列表，在Content页下，然后到DirectX Graphics\Reference\Shader Reference\High Level Shader Language\Intrinsic Functions。</p><p>译者注：以下表格中，//<variable>//表示变量variable的模（例如向量的绝对值）。<br>函数<br>描述<br>abs(x)<br>返回 |x|<br>ceil(x)<br>返回 ≥ x 的最小整数<br>clamp(x, a, b)<br>clamp(x, a, b)<br>clamp(x, a, b)<br>clamp(x, a, b)<br>cross(u, v)<br>返回 u × v（叉积）<br>degrees(x)<br>转换 x 从弧度到角度<br>determinant(M)<br>返回矩阵M的行列式det(M)<br>distance(u, v)<br>返回u点和v点之间的距离||v - u||<br>dot(u, v)<br>返回 u · v（点积）<br>floor(x)<br>返回 ≤ x 的最大整数<br>length(v)<br>返回 ||v||<br>lerp(u, v, t)<br>在u和v之间线性插值，根据参数 t ? [0, 1 ]<br>log(x)<br>返回 ln(x)<br>log10(x)<br>返回 log10(x)<br>log2(x)<br>返回 log2(x)<br>max(x, y)<br>如果x ≥ y，则返回 x；否则返回 y<br>min(x, y)<br>如果 x ≤ y，返回x；否则返回 y<br>mul(M, N)<br>返回矩阵乘积 MN. 注意：矩阵乘积必须是已定义的. 如果M是一个向量，它被作为一个行向量，则向量－矩阵（vector-matrix）乘法是已定义的。类似的,如果N 是一个向量，他被作为一个列向量，则矩阵－向量（matrix-vector）乘法是已定义的<br>normalize(v)<br>返回 v/∥v∥<br>pow(b, n)<br>返回 bn<br>radians(x)<br>转换 x 从 角度 到 弧度<br>reflect(v, n)<br>给定向量v和表面法线n，计算其反射向量<br>refract(v,n, eta)<br>给定向量v、表面法线n和两种材质的两个索引的比率eta，计算其折射向量. 翻看一下物理书中Snell的规则或者在互联网上搜索一下关于refraction（反射）的信息<br>rsqrt(x)<br>返回x的平方根的倒数<br>saturate(x)<br>返回clamp(x, 0.0, 1.0)<br>sin(x)<br>返回x的正弦,其中x单位为弧度<br>返回x的正弦,其中x单位为弧度<br>返回x的正弦和余弦，其中x单位为弧度<br>sqrt(x)<br>返回x的平方根<br>tan(x)<br>返回x的正切,其中 x 单位为弧度<br>transpose(M)<br>返回MT的转置</variable></p><p>   大多数函数已经重载以使其可以对所有内建类型有意义。例如，abs对所有数值类型有意义，所以它为所有这些数值类型进行了重载。又例如，叉积的叉乘仅对3D向量有意义，所以它对所有类型的3D向量（比如：int，float，double的3D向量）进行了重载。另一方面，线性插值——lerp，对于数值、2D、3D和4D向量有意义，因此重载了这些类型。</p><p>注意：如果你传递进去一个非数值类型到一个（要求）数值类型的函数，也就是一个仅能对数值类型进行操作的函数（比如：cos(x)），那么这个函数会对传进去的每个分量进行操作。例如，你写：<br>floats v = float3 (0.0f, 0.0f, 0.0f);<br>v = cos(v);</p><p>那么函数将会对每个分量进行操作：v=(cos(x),cos(y),cos(z))。<br>下例展示了这些固有的函数可能被调用的方式：<br>float x = sin(1.0f);       // sine of 1.0f radian.<br>float y = sqrt(4.0f);      // square root of 4.</p><p>vector u = {1.0f, 2.0f, -3.0f, 0.0f};<br>vector v = {3.0f, -1.0f, 0.0f, 2.0f};<br>float  s = dot(u, v);      // compute dot product of u and v.</p><p>float3 i = {1.0f, 0.0f, 0.0f};<br>float3 j = {0.0f, 1.0f, 0.0f};<br>float3 k = cross(i, j);    // compute cross product of i and j.</p><p>matrix<float, 2 2,> M = {1.0f, 2.0f, 3.0f, 4.0f};<br>matrix<float, 2 2,> T = transpose(M); // compute transpose</float,></float,></p><p>16.8 摘要</p><ul><li>我们在ASCII文本文件中编写了HLSL程序，并且在我们的应用程序中使用D3DXCompileShaderFromFile函数编译了它们。</li><li>ID3DXConstantTable接口允许我们在应用程序中对着色器程序中的变量进行设置。这种通信是必须的，因为被着色器使用的变量可以按一帧一帧的变化而改变。例如，如果应用程序中的视图矩阵发生了改变，我们需要使用新的视图矩阵更新着色器的视图矩阵变量。我们可以用ID3DXConstantTable完成这种更新。</li><li>对于每个着色器，我们必须定义一个输入和一个输出结构，这些结构分别描述了着色器中输入和输出数据的格式。</li><li>每个着色器有一个入口点函数，它有一个输入结构参数用于传递数据进着色器。此外，每个着色器返回一个输出结构的实例，它用于从着色器输出数据。</li></ul><p>第十七章 顶点着色器入门<br>(Introduction to Vertex Shaders)<br>概览<br>   顶点着色器（vertex shader）是一个在图形卡的GPU上执行的程序，它替换了固定功能管线（fixed function pipeline）中的变换（transformation）和光照（lighting）阶段。（这不是百分之百的正确，因为顶点着色器可以被Direct3D运行时（Direct3D runtime）以软件模拟，如果硬件不支持顶点着色器的话）。图16.1说明了管线中顶点着色器替换的部件。</p><p>图16.1：顶点着色器替换固定功能管线的光照和变形阶段</p><p>   从图16.1，我们知道，顶点以局部坐标输入到顶点着色器，并且必须输出齐次剪裁空间的有颜色的顶点。（为了保持简单，本书中我们没有深入研究投影变换的细节。但是经投影矩阵变换顶点后的空间称作齐次剪裁空间（homogeneous clip space）。因此，要把一个顶点从局部空间变换到齐次坐标空间，我们必须应用下列变换序列：世界变换（world transformation），视图变换（view transformation）和投影变换（projection transformation），它们分别由世界矩阵，视图矩阵和投影矩阵来完成。）对于点元（point primitive），顶点着色器也被用于操作每个顶点的顶点大小。</p><p>   由于顶点着色器是我们（在HLSL中）写的一个自定义程序，因此我们在图形效果方面获得了我们能够达到的极大的自由性。我们不再受限于Direct3D的固定光照算法。此外，应用程序操纵顶点位置的能力也有了多样性，例如：cloth simulation，粒子系统的点大小操纵，还有顶点混合/morphing。此外，我们的顶点数据结构更自由了，并且可以在可编程管线中包含比在固定功能管线中多得多的数据。</p><p>   顶点着色器仍然是相对新的特性，并且许多图形卡不支持它们，特别是随DirectX 9发布的较新版本的顶点着色器。通过检查D3DCAPS9结构的VertexShaderVersion成员，可以测试顶点着色器的版本。下列代码段展示了这一点：<br>// If the device’s supported version is less than version 2.0<br>if( caps.VertexShaderVersion &lt; D3DVS VERSION(2, 0) )<br>     // Then vertex shader version 2.0 is not supported on this device.</p><p>我们看到D3D_VERSION的两个参数分别接收主和次版本号。现在，D3DXCompileShaderFromFile函数支持顶点着色器版本1.1和2.0。</p><p>目标</p><ul><li>学习如何在可编程管线中定义顶点结构的分量</li><li>了解顶点分量的不同用法</li><li>学习如何创建、设置和销毁一个顶点着色器</li><li>学习如何使用顶点着色器实现卡通动画渲染效果</li></ul><p>17.1顶点声明<br>   到现在为止，我们已经使用自由顶点格式（flexible vertex format，FVF）来描述顶点结构中的各分量。但是，在可编程管线中，顶点数据包含的数据比用FVF所能表达的多很多。因此，我们通常使用更具表达性并且更强大的顶点声明（vertex declaration）。</p><p>注意：如果FVF能够描述我们的顶点格式 我们仍然可以在可编程管线中使用它。不管用何种方法，只是为了方便，同样FVF会在内部被转换为一个顶点声明。</p><p>17.1.1 描述顶点声明<br>   我们将一个顶点声明描述为一个D3DVERTEXELEMENT9结构的数组。D3DVERTEXELEMENT9数组中的每个成员描述了一个顶点的分量。所以，如果你的顶点结构有三个分量（例如：位置、法线、颜色），那么其相应的顶点声明将描述3个D3DVERTEXELEMENT9结构的数组。这个D3DVERTEXELEMENT9结构定义如下：<br>typedef struct _D3DVERTEXELEMENT9 {<br>     BYTE Stream;<br>     BYTE Offset;<br>     BYTE Type;<br>     BYTE Method;<br>     BYTE Usage;<br>     BYTE UsageIndex;<br>} D3DVERTEXELEMENT9;</p><ul><li>Stream——指定关联到顶点分量的流</li><li>Offset——偏移，按字节，相对于顶点结构成员的顶点分量的开始。例如，如果顶点结构是：<br>struct Vertex<br>{<br>   D3DXVECTOR3 pos;<br>   D3DXVECTOR3 normal;<br>};<br>……pos分量的偏移是0，因为它是第一个分量；normal分量的偏移是12，因为sizeof(pos) == 12。换句话说，normal分量以Vertex的第12个字节为开始。</li><li>Type——指定数据类型。它可以是D3DDECLTYPE枚举类型的任意成员；完整列表请参见文档。常用类型如下：</li><li>D3DDECLTYPE_FLOAT1——浮点数值</li><li>D3DDECLTYPE_FLOAT2——2D浮点向量</li><li>D3DDECLTYPE_FLOAT3——3D浮点向量</li><li>D3DDECLTYPE_FLOAT4——4D浮点向量</li><li><p>D3DDECLTYPE_D3DCOLOR—D3DCOLOR类型，它扩展为RGBA浮点颜色向量(r g b a)，其每一分量都是归一化到区间[0, 1]了的。</p></li><li><p>Method——指定网格化方法。我们认为这个参数是高级的，因此我们使用默认值，标识为D3DDECLMETHOD_DEFAULT.。</p></li><li><p>Usage——指定已计划的对顶点分量的使用。例如，它是否准备用于一个位置向量、法线向量、纹理坐标等？有效的用途标识符（usage identifier）是D3DDECLUSAGE枚举类型的：<br>typedef enum _D3DDECLUSAGE {<br>   D3DDECLUSAGE_POSITION     = 0,  // Position.<br>   D3DDECLUSAGE_BLENDWEIGHTS = 1,  // Blending weights.<br>   D3DDECLUSAGE_BLENDINDICES = 2,  // Blending indices.<br>   D3DDECLUSAGE_NORMAL       = 3,  // Normal vector.<br>   D3DDECLUSAGE_PSIZE        = 4,  // Vertex point size.<br>   D3DDECLUSAGE_TEXCOORD     = 5,  // Texture coordinates.<br>   D3DDECLUSAGE_TANGENT      = 6,  // Tangent vector.<br>   D3DDECLUSAGE_BINORMAL     = 7,  // Binormal vector.<br>   D3DDECLUSAGE_TESSFACTOR   = 8,  // Tessellation factor.<br>   D3DDECLUSAGE_POSITIONT    = 9,  // Transformed position.<br>   D3DDECLUSAGE_COLOR        = 10, // Color.<br>   D3DDECLUSAGE_FOG          = 11, // Fog blend value.<br>   D3DDECLUSAGE_DEPTH        = 12, // Depth value.<br>   D3DDECLUSAGE_SAMPLE       = 13  // Sampler data.<br>} D3DDECLUSAGE;</p><p> D3DDECLUSAGE_PSIZE类型用于指定一个顶点的点的大小。它用于点精灵，因此我们可以基于每个顶点控制其大小。一个D3DDECLUSAGE_POSITION成员的顶点声明意味着这个顶点已经被变换，它通知图形卡不要把这个顶点送到顶点处理阶段（变形和光照）。</p></li></ul><p>注意：这些中的少数用途类型（usage type）未在本书中提及，例如BLENDWEIGHTS, BLENDINDICES, TANGENT, BINORMAL, 和TESSFACTOR</p><ul><li>UsageIndex——用于标识多个相同用途的顶点分量。这个用途索引是位于区间[0, 15]间的一个整数。例如，假设我们有三个用途为D3DDECLUSAGE_NORMAL的顶点分量。我们可以为第一个指定用途索引为0，为第二个指定用途索引为1，并且为第三个指定用途索引为2。按这种方式，我们可以通过其用途索引标识每个特定的法线。</li></ul><p>顶点描述声明的例子：假设我们想要描述的顶点格式由位置向量和三个法线向量组成。顶点声明可以指定如下：<br>D3DVERTEXELEMENT9 decl[] =<br>{<br>{0,  0, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,<br>　D3DDECLUSAGE_POSITION, 0},<br>　<br>{0, 12, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,<br>　D3DDECLUSAGE_NORMAL, 0},<br>　<br>{0, 24, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,<br>　D3DDECLUSAGE_NORMAL, 1},<br>　<br>{0, 36, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,<br>　D3DDECLUSAGE_NORMAL, 2},</p><p>D3DDECL_END()<br>};<br>D3DDECL_END宏用于初始化D3DVERTEXELEMENT9数组的最后一个顶点元素。同样的，注意法线向量的用途索引标签。</p><p>17.1.2 创建顶点声明<br>一旦你描述了一个顶点声明为D3DVERTEXELEMENT9数组，我们就可以使用下面的方法获得一个IDirect3DVertexDeclaration9接口指针：<br>HRESULT IDirect3DDevice9::CreateVertexDeclaration(<br>     CONST D3DVERTEXELEMENT9<em> pVertexElements,<br>     IDirect3DVertexDeclaration9*</em> ppDecl<br>);</p><ul><li>pVertexElements——D3DVERTEXELEMENT9结构数组，它描述我们想要创建的顶点声明。</li><li>ppDecl——用于返回创建的IDirect3DVertexDeclaration9接口指针<br>例子调用，其中decl是一个D3DVERTEXELEMENT9数组：<br>IDirect3DVertexDeclaration9* _decl = 0;<br>hr = _device-&gt;CreateVertexDeclaration(decl, &amp;_decl);</li></ul><p>17.1.3 使用一个顶点声明<br>   回忆一下：自由顶点格式是一个方便的特性并且在内部转换成了顶点声明。因此，当直接使用顶点声明，我们不再需要调用：Device-&gt;SetFVF( fvf );<br>相反，我们调用：Device-&gt;SetVertexDeclaration( _decl );<br>其中，_decl是一个IDirect3DVertexDeclaration9接口指针。<br>17.2顶点数据用途<br>考虑这个顶点声明：<br>D3DVERTEXELEMENT9 decl[] =<br>{<br>{0,  0, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,<br>　D3DDECLUSAGE_POSITION, 0},</p><p>{0, 12, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,<br>　D3DDECLUSAGE_NORMAL,   0},</p><p>{0, 24, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,<br>　D3DDECLUSAGE_NORMAL,   1},</p><p>{0, 36, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,<br>  D3DDECLUSAGE_NORMAL,   2},</p><p>D3DDECL_END()<br>};</p><p>   我们需要一种方式，来定义一个顶点声明的元素到顶点着色器的Input结构的数据成员的映射。我们在Input结构中通过指定每个数据成员的语义（: usage-type [usage-index]）定义这个映射。语义通过元素的用途类型和用途索引标识顶点声明中的一个元素。由数据成员的语义标识的顶点元素是得以映射到数据成员的元素。例如，对应于前面的顶点声明的输入结构是：<br>struct VS_INPUT<br>{<br>     vector position    : POSITION;<br>     vector normal     : NORMAL0;<br>     vector faceNormal1 : NORMAL1;<br>     vector faceNormal2 : NORMAL2;<br>};</p><p>注意：如果我们遗漏了用途索引，就意味着用途索引为零。例如，POSITION和POSITION0是同一样东西。</p><p>   这里decl中的元素0，由用途POSITION和用途索引0标识，它映射到position。decl中的元素1，由用途NORMAL和用途索引0标识，它映射到normal。decl中的元素2，由NORMAL和用途索引1标识，它映射到faceNormal1。decl中的元素3，由用途NORMAL和用途索引2标识，它映射到faceNormal2。</p><p>受支持的顶点着色器输入用途（input usage）是：</p><ul><li>POSITION [n]——位置</li><li>BLENDWEIGHTS [n]——混合权重</li><li>BLENDINDICES [n]——混合索引</li><li>NORMAL [n]——法线向量</li><li>PSIZE[n]——顶点大小</li><li>DIFFUSE [n]——散射颜色</li><li>SPECULAR [n]——镜面颜色</li><li>TEXCOORD [n]——纹理坐标<br>其中，n是一个位于区间[0, 15]的可选整数。</li></ul><p>注意：再重复一遍，这些用途类型中的少数未在本书中提及，如：BLENDWEIGHTS, TANGENT, BINORMAL, BLENDINDICES, 和TESSFACTOR。</p><p>   此外，对于输出结构，我们必须指定每个成员是用来做什么的。例如，数据成员应该被作为位置向量、颜色、纹理坐标等对待吗？图形卡没主意，除非你强制的告诉它。这也需要通过语法的语义来完成：<br>struct VS_OUTPUT<br>{<br>     vector position  : POSITION;<br>     vector diffuse   : COLOR0;<br>     vector specular  : COLOR1;<br>};</p><p>受支持的顶点着色器输出用途是：</p><ul><li>POSITION—位置</li><li>PSIZE—顶点大小</li><li>FOG—雾混合值</li><li>COLOR [n]—顶点颜色。注意：可以有多个顶点颜色被输出，并且这些颜色可以被混合在一起以产生最终的颜色。</li><li>TEXCOORD [n]—顶点纹理坐标。注意：多个顶点纹理坐标可以被输出。<br>其中，n是一个位于区间[0, 15]的可选整数。</li></ul><p>17.3使用顶点着色器的步骤<br>下面的列表概括了创建和使用顶点着色器的必须步骤：</p><ol><li>编写并编译顶点着色器</li><li>创建一个IDirect3DVertexShader9接口以引用已编译的着色器代码上的顶点着色器。</li><li>用IDirect3DDevice9:: SetVertexShader方法使用这个顶点着色器。</li></ol><p>当然，在我们做完这些之后，我们还得销毁这个顶点着色器。下面的各小节将更详细的迈入这些步骤。</p><p>17.3.1 编写并编译顶点着色器<br>   首先，我们必须编写一个顶点着色器程序。在本书中的HLSL一章中，我们已经编写了我们的着色器（译者注：参见我翻译的译文第一章中各节）。一旦着色器代码写好之后，我们就使用D3DXCompileShaderFromFile函数编译这个着色器，如16.2.2节所述。回忆一下，这个函数返回一个ID3DXBuffer指针，它包含已编译的着色器代码。</p><p>17.3.2 创建顶点着色器<br>   一旦我们拥有了编译好的着色器代码，我们就能够获得一个IDirect3DVertexShader9接口的指针，它代表一个顶点着色器——通过使用下面的方法：<br>HRESULT IDirect3DDevice9::CreateVertexShader(<br>     const DWORD <em>pFunction,<br>     IDirect3DVertexShader9*</em> ppShader<br>);<br>pFunction——已编译着色器代码的指针<br>ppShader——返回一个IDirect3DVertexShader9接口的指针</p><p>例如，假设变量shader是一个包含已编译的，着色器代码的ID3DXBuffer指针。然后要获得一个IDirect3DVertexShader9接口，我们可以写：<br>IDirect3DVertexShader9<em> ToonShader = 0;<br>hr = Device-&gt;CreateVertexShader(<br>           (DWORD</em>)shader-&gt;GetBufferPointer(),<br>           &amp;ToonShader);<br>注意：重申一遍，D3DXCompileShaderFromFile是一个函数，它将返回已编译着色器的代码（shader）。</p><p>17.3.3 建立顶点着色器<br>   在我们获得了一个代表我们的顶点着色器的IDirect3DVertexShader9接口的指针之后，我们就能够使用下面的方法使用它：<br>HRESULT IDirect3DDevice9::SetVertexShader(<br>     IDirect3DVertexShader9* pShader<br>);<br>这个方法仅接受一个参数，我们在其中传递一个想要使用的顶点着色器的指针。要使用这个我们在17.3.2节创建的着色器，我们可以写：Device-&gt;SetVertexShader(ToonShader);</p><p>17.3.4 销毁顶点着色器<br>   和所有的Direc3D接口一样，要清除他们，我们就必须在用完它们之后调用其的Release方法。仍然以我们在17.3.2节创建的顶点着色器为例，我们写：<br>d3d::Release<idirect3dvertexshader9*>(ToonShader);</idirect3dvertexshader9*></p><p>17.4样例应用程序：散射光照<br>   作为创建并使用顶点着色器的热身，我们写一个顶点着色器，它用一个方向（平行）光对每个顶点进行标准的散射光照。简而言之，散射光照根据顶点法线和光线向量（它的点朝向光源方向）的角度计算顶点接收到的光线的数量。角度越小，则顶点接收到的光线就越多；而角度越大，则顶点接收到的光线就越少。如果角度大于等于90度，顶点就接收不到光线了。</p><p>我们以检阅着色器代码作为开始：<br>// File: diffuse.txt<br>// Desc: Vertex shader that does diffuse lighting.<br>// Global variables we use to hold the view matrix, projection matrix,<br>// ambient material, diffuse material, and the light vector that<br>// describes the direction to the light source. These variables are<br>// initialized from the application.</p><p>matrix ViewMatrix;<br>matrix ViewProjMatrix;<br>vector AmbientMtrl;<br>vector DiffuseMtrl;<br>vector LightDirection;</p><p>// 环境光强度，漫射光强度<br>// 这些变量定义在着色器代码中<br>vector DiffuseLightIntensity = {0.0f, 0.0f, 1.0f, 1.0f};<br>vector AmbientLightIntensity = {0.0f, 0.0f, 0.2f, 1.0f};</p><p>// Input and Output structures.<br>struct VS_INPUT<br>{<br>     vector position : POSITION;<br>     vector normal   : NORMAL;<br>};</p><p>struct VS_OUTPUT<br>{<br>     vector position : POSITION;<br>     vector diffuse  : COLOR;<br>};</p><p>//Main<br>VS_OUTPUT Main(VS_INPUT input)<br>{<br>     // zero out all members of the output instance.<br>     VS_OUTPUT output = (VS_OUTPUT)0;</p><pre><code> // 变换位置到齐次坐标空间，保存到output.position成员中 output.position = mul(input.position, ViewProjMatrix); // 变换光和法线到视图空间，设置w分量为0，是因为变换的向量不是点  LightDirection.w = 0.0f; input.normal.w  = 0.0f; LightDirection   = mul(LightDirection, ViewMatrix); input.normal    = mul(input.normal, ViewMatrix); // 计算光与法线夹角的余弦 float s = dot(LightDirection, input.normal);  // 回忆一下，如果法线和光的夹角大于90度，则表面接收不到光。 if( s &lt; 0.0f )     s = 0.0f; // 环境光反射是执行一个叉积（环境材质向量与环境光强度向量）， // 漫射光反射是执行一个叉积（漫射材质向量与漫射光强度向量， // 更进一步讲，我们测量着色器的颜色，基于顶点从光源处接收到多少光 //环境光和漫射光综合起来，决定一个顶点的最终颜色 output.diffuse = (AmbientMtrl * AmbientLightIntensity) +                  ((DiffuseMtrl * DiffuseLightIntensity) * s); return output;</code></pre><p>}</p><p>   既然我们已经看到了实际的顶点着色器的代码，那么就让我们改变方式来看看应用程序的代码。这个应用程序有下列相关的全局变量：<br>IDirect3DVertexShader9<em> DiffuseShader = 0;<br>ID3DXConstantTable</em> DiffuseConstTable = 0;<br>ID3DXMesh* Teapot               = 0;<br>D3DXHANDLE ViewMatrixHandle     = 0;<br>D3DXHANDLE ViewProjMatrixHandle = 0;<br>D3DXHANDLE AmbientMtrlHandle    = 0;<br>D3DXHANDLE DiffuseMtrlHandle    = 0;<br>D3DXHANDLE LightDirHandle       = 0;<br>D3DXMATRIX Proj;<br>   有代表顶点着色器及其常量表的变量，有茶壶网格的变量，接着是一组D3DXHANDLE，其名字描述了他们引用的变量：</p><p>Setup函数执行下列任务：</p><ul><li>创建茶壶网格</li><li>编译顶点着色器</li><li>根据已编译代码创建顶点着色器</li><li>通过常量表获取着色器程序中的几个变量的句柄</li><li>通过常量表初始化着色器的这几个变量</li></ul><p>注意：对于本应用程序，我们的顶点结构不需要任何自由顶点格式没有的额外的分量。因此，在本例中，我们使用一个自由顶点格式来代替顶点声明。回想一下，自由顶点格式描述最终在内部被转换为一个顶点声明。<br>bool Setup()<br>{<br>     HRESULT hr = 0;</p><pre><code> // Create geometry: D3DXCreateTeapot(Device, &amp;Teapot, 0);  // Compile shader ID3DXBuffer* shader      = 0; ID3DXBuffer* errorBuffer = 0; hr = D3DXCompileShaderFromFile(      &quot;diffuse.txt&quot;,      0,      0,      &quot;Main&quot;, // entry point function name      &quot;vs_1_1&quot;,      D3DXSHADER_DEBUG,      &amp;shader,      &amp;errorBuffer,      &amp;DiffuseConstTable); // output any error messages if( errorBuffer ) {    ::MessageBox(0, (char*)errorBuffer-&gt;GetBufferPointer(), 0, 0);    d3d::Release&lt;ID3DXBuffer*&gt;(errorBuffer); } if(FAILED(hr)) {    ::MessageBox(0, &quot;D3DXCompileShaderFromFile() - FAILED&quot;, 0, 0);    return false; } // Create shader hr = Device-&gt;CreateVertexShader(      (DWORD*)shader-&gt;GetBufferPointer(),      &amp;DiffuseShader);  if(FAILED(hr)) {    ::MessageBox(0, &quot;CreateVertexShader - FAILED&quot;, 0, 0);    return false; } d3d::Release&lt;ID3DXBuffer*&gt;(shader); // Get Handles LightDirHandle    = DiffuseConstTable-&gt;GetConstantByName(0, &quot;LightDirection&quot;); ViewMatrixHandle = DiffuseConstTable-&gt;GetConstantByName(0, &quot;ViewMatrix&quot;); ViewProjMatrixHandle = DiffuseConstTable-&gt;GetConstantByName(0, &quot;ViewProjMatrix&quot;); AmbientMtrlHandle = DiffuseConstTable-&gt;GetConstantByName(0, &quot;AmbientMtrl&quot;); DiffuseMtrlHandle = DiffuseConstTable-&gt;GetConstantByName(0, &quot;DiffuseMtrl&quot;); // Set shader constants: // Light direction: D3DXVECTOR4 directionToLight(-0.57f, 0.57f, -0.57f, 0.0f); DiffuseConstTable-&gt;SetVector(Device, LightDirHandle,  &amp;directionToLight);  // Materials: D3DXVECTOR4 ambientMtrl(0.0f, 0.0f, 1.0f, 1.0f); D3DXVECTOR4 diffuseMtrl(0.0f, 0.0f, 1.0f, 1.0f); DiffuseConstTable-&gt;SetVector(Device,AmbientMtrlHandle,&amp;ambientMtrl); DiffuseConstTable-&gt;SetVector(Device,DiffuseMtrlHandle,&amp;diffuseMtrl); DiffuseConstTable-&gt;SetDefaults(Device); // Compute projection matrix. D3DXMatrixPerspectiveFovLH(   &amp;Proj, D3DX PI * 0.25f,   (float)Width / (float)Height, 1.0f, 1000.0f); return true;</code></pre><p>}</p><p>   Display函数非常简单。它检测用户输入（译者注：这里指的是用户输入的传入着色器程序的变量），并相应的更新视图矩阵。但是，因为我们在着色器中执行这个视图矩阵变换，所以我们还必须更新着色器中的视图矩阵变量。我们用常量表完成这件事情。<br>bool Display(float timeDelta)<br>{<br>     if( Device )<br>     {<br>          // Update view matrix code snipped…<br>          D3DXMATRIX V;<br>          D3DXMatrixLookAtLH(&amp;V, &amp;position, &amp;target, &amp;up);<br>          DiffuseConstTable-&gt;SetMatrix(Device, ViewMatrixHandle, &amp;V);<br>          D3DXMATRIX ViewProj =V *Proj;</p><pre><code>      DiffuseConstTable-&gt;SetMatrix(Device, ViewProjMatrixHandle,                                  &amp;ViewProj);      // Render      Device-&gt;Clear(0, 0, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,                    0xffffffff, 1.0f, 0);      Device-&gt;BeginScene();      Device-&gt;SetVertexShader(DiffuseShader);      Teapot-&gt;DrawSubset(0);      Device-&gt;EndScene();      Device-&gt;Present(0, 0, 0, 0); } return true;</code></pre><p>}</p><p>同样注意，就在DrawSubset调用之前，我们允许了这个我们希望使用的顶点着色器。<br>清理也需要被完成；我们简单的释放了这个已分配的接口：<br>void Cleanup()<br>{<br>     d3d::Release<id3dxmesh*>(Teapot);<br>     d3d::Release<idirect3dvertexshader9*>(DiffuseShader);<br>     d3d::Release<id3dxconstanttable*>(DiffuseConstTable);<br>}</id3dxconstanttable*></idirect3dvertexshader9*></id3dxmesh*></p><p>17.5 卡通渲染<br>   作为第二个顶点着色器的例子，让我们编写两个顶点着色器，它们以卡通风格的绘画方式对网格着色（shade）并画轮廓（outline）。图17.2展示了这一点：</p><p>图17.2：（a）使用卡通着色法着色的对象（注意着色间的尖锐过渡）。（b）增强卡通效果，轮廓边（silhouette edge）被勾出。（c）使用标准散射光照着色的对象</p><p>注意：卡通渲染是一种特定类型的非写实渲染（non-photorealistic rendering），有时被称作风格化渲染（stylistic rendering）。</p><p>   虽然卡通渲染不适用于所有游戏，例如激烈的第一人称射击游戏，但是它仍然可以增强一些希望表现卡通感觉类型游戏的气氛。此外，卡通渲染是漂亮的，并易于实现。让我们好好的演示一个顶点着色器。</p><p>我们将卡通渲染分为两步：</p><ol><li>卡通绘画的特点是：在一个顶点到下一个顶点的强烈转换时，有少量的阴影强度级别；我们看一下这个卡通阴影（cartoon shading）。在图17.2（a）中，我们看到网络着色使用了三种阴影强度（亮、中、暗），而且其间的过渡是不平滑的——不像图17.2（c），其明暗过渡是平滑的。</li><li>卡通绘图的主要特点是：在其外框上勾画轮廓，如图17.2（b）所示。<br>这两个步骤都需要其各自的顶点着色器。</li></ol><p>17.5.1 卡通着色<br>   要实现卡通着色，我们采用Lander在2000年3月发表在Game Developer Magazine的文章“Shades of Disney: Opaquing a 3D World”中所描述的方法。它像这样工作：我们创建一个带强度级别的灰度纹理，它包含我们需要的不同的着色强度。图17.3显示了我们在样例程序中使用的这个纹理。</p><p>图 17.3：用来保存着色强度的着色纹理。注意观察不连续的着色间过渡和纹理着色强度必须从左到右增加。<br>   然后在顶点着色器中，我们执行标准散射点积运算（standard diffuse calculation dot product）来确定顶点法线N和光线向量L之间角度的余弦，用以确定顶点接收到多少光线：s=L·N</p><p>   如果s＜0，就表示光线向量和顶点法线之间的角度大于90度，也就表示该表面接收不到光线。因此，如果s＜0，我们就让s＝0。所以s ∈ [0, 1]。</p><p>   现在，在通常的散射光照模型中，我们使用s来标记颜色向量。这样，顶点颜色的明暗取决于接收到的光照的数量：diffuseColor = s(r, g, b, a)<br>   但是，这将会导致从亮到暗之间平滑的着色。这是与我们期望的卡通着色相反的。我们想要一种在几个不同着色器间突然转换颜色的效果（对卡通渲染来说，在2至4种着色器工作起来还是挺不错的）。</p><p>   不使用s来标记颜色向量，我们将使用s作为早先提到的强度纹理的u纹理坐标——如图17.3。<br>注意：标量（scalar）s必定是一个有效的纹理坐标，因为s ∈ [0, 1]，这是通常的纹理坐标区间。</p><p>   按这种方式，顶点不会被平滑着色，而是间断的。例如，强度纹理可能被分成3种着色，如图17.4所示：</p><p>图17.4：那么，s ∈ [0, 0.33]的值使用shader0着色，s ∈ [ 0.33，0.66]的值使用shader1着色，s ∈ [0.66,1]的值使用shader2着色。当然，从这些着色的一种到另一种的过渡是不平滑的，这就赋予了我们期望的效果。</p><p>注意：我们还为卡通着色关闭了纹理过滤，因为这种过滤会试图使着色过渡变平滑。这对于我们要求的不连续过渡是多余的。</p><p>17.5.2 卡通着色的顶点着色器代码<br>   我们现在介绍卡通着色的顶点着色器。这个着色器的主要任务只是根据s=L·N计算并设置纹理坐标。注意观察输出结构，我们已经增加了一个数据成员来存储已被计算过的纹理坐标。同时还需注意，我们仍然输出顶点颜色，虽然我们不修改它，不过当颜色被与强度纹理组合起来的时候，它呈现为被着色的。<br>// File: toon.txt<br>// Desc: Vertex shader that lights geometry so it appears to be<br>// drawn in a cartoon style.</p><p>// Globals<br>extern matrix WorldViewMatrix;<br>extern matrix WorldViewProjMatrix;<br>extern vector Color;<br>extern vector LightDirection;<br>static vector Black = {0.0f, 0.0f, 0.0f, 0.0f};</p><p>// Structures<br>struct VS_INPUT<br>{<br>     vector position : POSITION;<br>     vector normal   : NORMAL;<br>};</p><p>struct VS_OUTPUT<br>{<br>     vector position : POSITION;<br>     float2 uvCoords : TEXCOORD;<br>     vector diffuse  : COLOR;<br>};</p><p>// Main<br>VS_OUTPUT Main(VS_INPUT input)<br>{<br>      // zero out each member in output<br>　　　VS_OUTPUT output = (VS_OUTPUT)0;<br>　　　<br>      // transform vertex position to homogenous clip space<br>　　　output.position = mul(input.position, WorldViewProjMatrix);<br>　　　<br>      // Transform lights and normals to view space.  Set w<br>      // components to zero since we’re transforming vectors.<br>      // Assume there are no scalings in the world<br>      // matrix as well.<br>      LightDirection.w = 0.0f;<br>      input.normal.w   = 0.0f;<br>      LightDirection   = mul(LightDirection, WorldViewMatrix);<br>      input.normal     = mul(input.normal, WorldViewMatrix);</p><pre><code>  // Compute the 1D texture coordinate for toon rendering.</code></pre><p>　　　float u = dot(LightDirection, input.normal);<br>　　　<br>      // Clamp to zero if u is negative because u<br>      // negative implies the angle between the light<br>      // and normal is greater than 90 degrees.  And<br>      // if that is true then the surface receives no light.<br>      if(u &lt; 0.0f)<br>         u = 0.0f;</p><pre><code>  // Set other tex coord to middle.  float v = 0.5f;  output.uvCoords.x = u;  output.uvCoords.y = v;  // save color</code></pre><p>　　　output.diffuse = Color;<br>　　　<br>      return output;<br>}</p><p>两点注解：</p><ul><li>我们假设世界矩阵没有执行任何缩放。因为如果它执行，它就会弄乱乘以它的顶点的长度和方向。</li><li>我们总是设置v纹理坐标为纹理的中点。这意味着我们仅使用纹理中一条单一的线，那就是说我们可以使用1D强度纹理来代替2D的那个纹理。不管怎样，1D和2D纹理都能工作。本例中，我们使用了2D纹理而不是1D纹理，这是没有什么特别的原因的。</li></ul><p>17.5.3轮廓勾勒<br>要完成卡通效果，我们还需要勾勒（outline）轮廓边（silhouette edge）。这比卡通着色稍微复杂一点。</p><p>17.5.3.1 边的表示法<br>我们将一个网格的一条边表示为一个四元组（构建自2个三角形）——参见图17.5。</p><p>图 17.5：表示边的四元组</p><p>   我们选择四元组有两个原因：我们可以通过调整四元组的维容易的改变边的厚度，并且我们可以渲染退化的四元组来隐藏某些边，也即非轮廓边。在Direct3D中，我们从两个三角形来构建一个四元组。退化四元组（degenerate quad）是从两个退化三角形构建而来的四元组。退化三角形（degenerate triangle）是一个面积为零的三角形，或者换句话说，是一个三点位于一线上的三角形。如果我们传入一个退化三角形到渲染管线，则该三角形显示为空。这是很有用的，因为如果我们希望隐藏特定三角形，我们可以简单的退化它而不需要实际的从三角形列表（顶点缓冲）移除它。回想一下，我们只需要显示轮廓边——而不是网格的每一条边。</p><p>   当我们首先创建一条边的时候，我们指定其四个顶点，并使其退化，这意味着边将会被隐藏（渲染时不显示）。</p><p>图17.6：由两个三角形共用边描述的退化四元组</p><p>   注意图17.6中的两个顶点v0和v1，我们设置其顶点法线向量为零向量。然后当我们将边的顶点送入顶点着色器的时候，顶点着色器将会检测顶点是否位于轮廓边上；如果是，则顶点着色器将按顶点法线的方向偏移顶点位置的标量。观察法线向量为零的顶点，它不会被偏移。</p><p>因此，我们最终以一个非退化四元组（non-degenerate quad）来表示轮廓边，如图17.7所示。</p><p>图17.7：位于轮廓边上的顶点v2和v3被按照其各自的顶点法线n2和n3进行偏移。观察顶点v0和v1仍然保持在其固定位置，因为其顶点法线等于零向量，因此对于它们来说没有偏移发生。按这种方式，四元组成功的重新生成来表示轮廓边。</p><p>备注：如果我们没有设置顶点v0和v1的顶点法线为零向量，那么那些顶点就同样会被偏移。但是如果偏移描述轮廓边的所有四个顶点，那么我们仅是平移了该退化四元组。通过保持顶点v0和v1固定并仅仅偏移顶点v2和v3，我们重新生成了四元组。</p><p>17.5.3.2 轮廓边测试<br>   若两个三角面face0和face1在视图方向上与两个不同方向的面共享同一条边，则该边为轮廓边。也就是说，如果一个面是前面（front facing）而另一个面是后面（back facing），那么这条边就是一条轮廓边。图17.8给出了一个轮廓边和一个非轮廓边的例子。</p><p>图17.8：在（a）中，由v0 和v1定义的共享边的一个面是前面，而共享边另一个面是背面，因此该边是轮廓边。在（b）中，由v0 和v1定义的这两个共享边面都是前面，因此该边不是轮廓边。</p><p>   接下来，为了检测一个顶点是否在轮廓边上，我们必须以每个顶点为基础了解face0 和 face1的法线向量。我们的边的顶点数据结构反映如下：<br>struct VS_INPUT<br>{<br>     vector position    : POSITION;<br>     vector normal      : NORMAL0;<br>     vector faceNormal1 : NORMAL1;<br>     vector faceNormal2 : NORMAL2;<br>};</p><p>   前两个分量很直接，但让我们看看两个额外的法线向量，它们是faceNormal1和faceNormal2。这些向量描述了两个三角面的面法线，共享边的顶点位于这两个面的共享边上，这两个面是face0和face1。</p><p>   实际检测顶点是否在共享边上的数学如下。假设我们在视图空间中，令v为一原点指向检测顶点的向量——图17.8，令n0为face0的面法线且n1为face0的面法线，若下面的不等式为真，则顶点位于轮廓边上：<br>（1）（v·n0）（v·n1）＜0</p><p>   若两点积符号相异，则不等式为真，使得不等式左边为负。回想一下点积的性质：两个点积的符号相异，这意味着一个三角面是前面而另一个是后面。</p><p>   现在，考虑一条边只有一个三角形共享它的情况，如图17.9，其法线将会被存储在faceNormal1中。</p><p>图 17.9：顶点v0和v1定义的边只有一个三角面共享它</p><p>   我们定义这种边总为轮廓边。要确保顶点着色器将这种边作为轮廓边处理，我们要让faceNormal2 = -faceNormal1。因此，反向的面法线和不等式（1）为真，表示该边为一轮廓边。</p><p>17.5.3.3 边的生成<br>   生成网格的边是微不足道的；我们简单的遍历网格的每个三角面并为三角面上每条边计算一个四元组（退化的，如图17.6所示）。<br>注意：每个三角面有三条边，因为每个三角形有三条边。</p><p>   对于每条边上的顶点，我们同样需要知道共享边的两个三角面。一个面是边所在的三角形。例如，如果要计算第1个面的一条边，那么第1个面共享该边。共享该边的另一个面可以使用网格的邻接信息找到。<br>17.5.4 轮廓边顶点着色器代码<br>   我们现在呈现渲染轮廓边的顶点着色器代码。这个着色器的主要任务就是确定传入的顶点是否在轮廓边上。如果是，顶点着色器就以一定的值，按顶点法线的方向偏移顶点。<br>// File: outline.txt<br>// Desc: Vertex shader renders silhouette edges.</p><p>// Globals</p><p>extern matrix WorldViewMatrix;<br>extern matrix ProjMatrix;<br>static vector Black = {0.0f, 0.0f, 0.0f, 0.0f};</p><p>// Structures<br>struct VS_INPUT<br>{<br>     vector position : POSITION;<br>     vector normal : NORMAL0;<br>     vector faceNormal1 : NORMAL1;<br>     vector faceNormal2 : NORMAL2;<br>};<br>struct VS_OUTPUT<br>{<br>     vector position : POSITION;<br>     vector diffuse : COLOR;<br>};</p><p>// Main<br>VS_OUTPUT Main(VS_INPUT input)<br>{<br>      // zero out each member in output<br>      VS_OUTPUT output = (VS_OUTPUT)0; </p><pre><code>  // transform position to view space  input.position = mul(input.position, WorldViewMatrix);   // Compute a vector in the direction of the vertex  // from the eye. Recall the eye is at the origin</code></pre><p>　　　// in view space - eye is just camera position.<br>      vector eyeToVertex = input.position; </p><pre><code>  // transform normals to view space.  Set w  // components to zero since we&#39;re transforming vectors.  // Assume there are no scalings in the world  // matrix as well.  input.normal.w      = 0.0f;  input.faceNormal1.w = 0.0f;  input.faceNormal2.w = 0.0f;  input.normal      = mul(input.normal,      WorldViewMatrix);  input.faceNormal1 = mul(input.faceNormal1, WorldViewMatrix);  input.faceNormal2 = mul(input.faceNormal2, WorldViewMatrix);   // compute the cosine of the angles between  // the eyeToVertex vector and the face normals.  float dot0 = dot(eyeToVertex, input.faceNormal1);  float dot1 = dot(eyeToVertex, input.faceNormal2);  // if cosines are different signs (positive/negative)  // then we are on a silhouette edge. Do the signs  // differ?  if( (dot0 * dot1) &lt; 0.0f )  {       // yes, then this vertex is on a silhouette edge,       // offset the vertex position by some scalar in the       // direction of the vertex normal.       input.position += 0.1f * input.normal;  }  // transform to homogeneous clip space  output.position = mul(input.position, ProjMatrix);  // set outline color  output.diffuse = Black;   return output;</code></pre><p>}</p><p>17.6 摘要</p><ul><li>使用顶点着色器，我们可以替换固定功能管线的变换和光照阶段。通过用我们自己的程序（顶点着色器）替换此固定处理，我们可以在图形效果方面获得我们能够达到的极大的自由性。</li><li>顶点声明用于描述顶点格式。它们和自由顶点格式相似，但是更加自由并允许我们描述FVF不能描述的顶点格式。注意，如果顶点可以用FVF描述，我们仍然可以使用它们；不管怎样，在内部它们被转换为顶点声明。</li><li>对于输入，用途语义指定了顶点分量如何被从顶点声明映射到HLSL程序中的变量。对于输出，用途语义指定了顶点分量是用来做什么的（例如：位置、颜色、纹理坐标，等等）。</li></ul><p>第十八章 像素着色器入门<br>(Introduction to Pixel Shaders)<br>   像素着色器是一个执行在图形卡的GPU上的程序，它运行在对每个像素进行光栅化处理时。（不像顶点着色器，Direct3D不会以软件模拟像素着色器的功能。）它实际上替换了固定功能管线的多纹理化阶段（the multitexturing stage），并赋予我们直接操纵单独的像素和访问每个像素的纹理坐标的能力。这种对像素和纹理坐标的直接访问使我们可以达成各种特效，例如：多纹理化（multitexturing）、每像素光照（per pixel lighting）、景深（depth of field）、云状物模拟（cloud simulation）、焰火模拟（fire simulation）、高级阴影技术（sophisticated shadowing technique）。</p><p>   图形卡支持的像素着色器的版本可以通过D3DCAPS9结构的PixelShaderVersion成员和D3DPS_VERSION宏进行检查。下列代码片断展示了这点：<br>// If the device’s supported version is less than version 2.0<br>if( caps.PixelShaderVersion &lt; D3DPS_VERSION(2, 0) )<br>     // Then pixel shader version 2.0 is not supported on this device.</p><p>目标</p><ul><li>获得对多纹理化概念的基本理解</li><li>学习如何编写、创建并使用像素着色器</li><li>学习如何使用像素着色器实现多纹理化效果</li></ul><p>18.1多纹理化概览<br>   多纹理化（Multitexturing）可能是用像素着色器实现的最简单的技巧了。此外，因为像素着色器替换多纹理化阶段，那么接下来我们应该对多纹理化“是什么”和“做什么”有一个最基本的理解。本节介绍多纹理化的简明概览。</p><p>   当我们一开始讨论纹理化（texturing）的时候（第6章），我们忽略了固定功能管线中对多纹理化的讨论，这有两个原因：第一，多纹理化是有一点棘手的过程，我们考虑到这在当时是一个高级话题；此外，固定功能多纹理化阶段被新的和更强有力的像素着色器替换掉了。因此花时间在已经过时的固定功能纹理化阶段上是无意义的。</p><p>   多纹理化后面的概念有一点和混合（blending）相关。在第七章中我们了解到：可以将正要被光栅化的像素与之前写入后台缓冲的像素进行混合来达成一种特效。我们延伸这种相同的思想到多纹理化中（multiple texture）。也就是说，我们一次使用几个纹理，然后定义这些纹理如何被混合在一起，以达到一种特殊效果。多纹理化的一个通常的用法是执行光照。作为在顶点处理阶段使用Direct3D的光照模型的替代，我们使用一种叫做“光照图”（light map）的特殊纹理贴图（texture map），它编码（encode）表面是如何被光照的。例如，假设我们希望一盏聚光灯（spotlight）照在一个大木箱上，我们要么可以定义一个D3DLIGHT9结构的聚光灯，要么可以将代表木箱的纹理贴图与代表聚光灯的光照映射混合在一起，如图18.1所示。</p><p>图18.1：使用多纹理化渲染一个通过聚光灯照亮的木箱。这里我们通过将相应的纹理像素（texels）相乘来将这两个纹理组合起来。</p><p>注意：用第七章里的混合，结果图像依赖于纹理被混合的方式。在固定功能管线的多纹理化阶段，混合方程式被纹理渲染状态（texture render state）控制。用像素着色器，我们 能够以可编程的方式在代码中写出混合函数的简单表达式。这使我们可以用任何我们想要的方式混合纹理。我们将在讨论本章的例子程序时详细讨论纹理混合。</p><p>混合多个纹理（本例中是两个）来照亮木箱比起Direct3D的光照来有两个好处：</p><ul><li>光照是是预先在聚光灯的光照贴图里计算好的。因此，光照不需要在运行时被计算，这节省了处理时间。当然，只有静态对象和静态灯光的光照可以被预先计算。</li><li>因为光照图是预先计算好的，我们能够使用比Direct3D的（光照）模型多的多的更加精确的和成熟的光照模型。（更好的光照可以产生更真实的场景。）</li></ul><p>备注：多纹理化阶段的典型应用是实现静态对象的完全光照引擎（full lighting engine）。例如，我们可以用一个纹理贴图保存对象的颜色，比如木箱的纹理贴图。然后我们可以用一个散射光照贴图（diffuse light map）保存散射表面着色（diffuse surface shade），一个单独的镜面光照贴图保存镜面表面着色，一个雾状物贴图（fog map）保存覆盖在表面的雾状物的总量，还有可以用一个详细贴图（detail map）保存小的、高访问率的表面的细节。当所有这些纹理被组合起来，只需到这些预先计算的纹理中检索，就可以有效的照亮、着色并且增加细节到场景中去。</p><p>注意：聚光灯光照贴图在很基础的光照贴图中是一个价值不高（trivial）的例子。一般的的程序通过给定的场景和光源来生成光照贴图。生成光照贴图超越了本书的范围。有兴趣的读者可以参考Alan Watt和Fabio Policarpo在《3D Games: Real-time Rendering and Software Technology》中描述的光照贴图。</p><p>18.1.1 允许多个纹理<br>   回忆一下，纹理是用IDirect3DDevice9::SetTexture方法设置，而采样器状态（sampler state）是用IDirect3DDevice9::SetSamplerState方法设置，原型如下：<br>HRESULT IDirect3DDevice9::SetTexture(<br>     DWORD Stage, // specifies the texture stage index<br>     IDirect3DBaseTexture9 *pTexture<br>);</p><p>HRESULT IDirect3DDevice9::SetSamplerState(<br>     DWORD Sampler, // specifies the sampler stage index<br>     D3DSAMPLERSTATETYPE Type,<br>     DWORD Value<br>);</p><p>注意：一个特定的采样器阶段索引I联合第i个纹理阶段（texture stage）。即第i个采样器阶段指定采样器状态是第i集（set）纹理。</p><p>   纹理/采样器阶段索引标识了我们希望设置的纹理/采样器的纹理/采样器阶段。因此，我们可以允许多个纹理并通过使用不同的阶段索引设置其相应的采样器状态。在本书前面的部分中，我们总是指定0，来指示第一个阶段，因为我们一次仅使用一个纹理。所以例如，假设我们要允许三个纹理，我们像这样使用阶段0,1和2：<br>// Set first texture and corresponding sampler states.<br>Device-&gt;SetTexture(0, Tex1);<br>Device-&gt;SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);<br>Device-&gt;SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);<br>Device-&gt;SetSamplerState(0, D3DSAMP_MIPFILTER, D3DTEXF_LINEAR); </p><p>// Set second texture and corresponding sampler states.<br>Device-&gt;SetTexture(1, Tex2);<br>Device-&gt;SetSamplerState(1, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);<br>Device-&gt;SetSamplerState(1, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);<br>Device-&gt;SetSamplerState(1, D3DSAMP_MIPFILTER, D3DTEXF_LINEAR); </p><p>// Set third texture and corresponding sampler states.<br>Device-&gt;SetTexture(2, Tex3);<br>Device-&gt;SetSamplerState(2, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);<br>Device-&gt;SetSamplerState(2, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);<br>Device-&gt;SetSamplerState(2, D3DSAMP_MIPFILTER, D3DTEXF_LINEAR);<br>这段代码使用Tex1, Tex2和Tex3，并设置每个纹理的过滤模式。</p><p>18.1.2 多纹理坐标<br>   回忆一下第六章，对于每个3D三角形，我们应该在纹理上定义一个三角形以映射该3D三角形。我们通过对每个顶点增加纹理坐标完成映射。因此，每三个顶点定义一个三角形，它对应于纹理上的三角形。</p><p>   因为我们现在使用多纹理，每三个顶点定义一个三角形，我们需要在每个被使用的纹理上定义一个相应的三角形。我们通过给每个顶点增加额外的一套纹理坐标——每个顶点一套，对应于每个使用的纹理。举个例子，如果我们混合三个纹理到一起，那么每个顶点必须有三套纹理坐标以索引到三个使用的纹理。因此，一个包含三个纹理的多纹理化顶点结构看起来可能像这样：<br>struct MultiTexVertex<br>{<br>     MultiTexVertex(float x, float y, float z,<br>                    float u0, float v0,<br>                    float u1, float v1,<br>                    float u2, float v2)<br>     {<br>          _x =  x;   _y = y; _z = z;<br>          _u0 = u0;  _v0 = v0;<br>          _u1 = u1;  _v1 = v1;<br>          _u2 = u2;  _v2 = v2;<br>     } </p><pre><code> float _x, _y, _z; float _u0, _v0; // Texture coordinates for texture at stage 0. float _u1, _v1; // Texture coordinates for texture at stage 1. float _u2, _v2; // Texture coordinates for texture at stage 2.  static const DWORD FVF;</code></pre><p>};<br>const DWORD MultiTexVertex::FVF = D3DFVF_XYZ | D3DFVF_TEX3;</p><p>注意，指定自由顶点格式标记D3DFVF_TEX3表明顶点结构包含3套纹理坐标。固定功能管线支持最多8套纹理坐标。如果多于8套，你必须使用顶点声明和可编程顶点管线。</p><p>注意：在新版本像素着色器中，我们可以使用一套纹理坐标集来索引多个纹理，并因此消除了对多个纹理坐标的需要。当然这得假设每个纹理阶段使用相同的纹理坐标。如果每个阶段的纹理坐标不同，则我们仍然需要多纹理坐标。<br>18.2像素着色器输入和输出<br>有两样东西要输入到像素着色器：颜色和纹理坐标。两样都是以每像素为单位的。<br>注意：回想一下，顶点颜色是在图元的面（face of primitive）间进行插值的。</p><p>   每个像素的纹理坐标就是简单的 (u , v) ，它指定了纹理的哪个图素被映射到像素上。在输入到像素着色器前，Direct3D根据顶点颜色和顶点纹理坐标，为每个像素计算颜色和纹理坐标。输入到像素着色器的颜色和纹理坐标的数值依赖于顶点着色器输出的颜色和纹理坐标的数值。例如，如果一个顶点着色器输出了两个颜色和三个纹理坐标，那么Direct3D将会为每个像素计算两个颜色和三个纹理坐标并且把它们把它们输入到像素着色器。我们使用带语意的语法（semantic syntax）映射输入颜色和纹理坐标进我们的着色器程序的变量里。用前面的例子，我们可以这样写：<br>struct PS_INPUT<br>{<br>     vector c0 : COLOR0;<br>     vector c1 : COLOR1;<br>     float2 t0 : TEXCOORD0;<br>     float2 t1 : TEXCOORD1;<br>     float2 t2 : TEXCOORD2;<br>};</p><p>对于输出，像素着色器只输出一个计算过的该像素的颜色值：<br>struct PS_OUTPUT<br>{<br>     vector finalPixelColor : COLOR0;<br>};</p><p>18.3使用像素着色器的步骤<br>下面的列表概述了创建和使用像素着色器的必要步骤：</p><ol><li>编写并编译像素着色器</li><li>创建一个IDirect3DPixelShader9接口来代表基于已编译代码的像素着色器</li><li>用IDirect3DDevice9::SetPixelShader方法允许该像素着色器</li></ol><p>当然，用完顶点着色器之后我们必须销毁它。下面几个小节将深入这些步骤。</p><p>18.3.1 编写并编译像素着色器<br>   我们用与编译顶点着色器一样的方式编译像素着色器。首先，我们必须编写一个像素着色器程序。本书中，我们用HLSL编写我们的着色器。一旦写好着色器代码，我们就可以用D3DXCompileShaderFromFile函数编译该着色器了，如16.2节所述。回忆一下，这个函数返回一个ID3DXBuffer指针，它包含已编译的着色器代码。</p><p>注意：因为我们使用的是像素着色器，所以要记得把编译目标改成像素着色器目标（比如：ps_2_0），而不是顶点着色器目标（比如：vs_2_0）。编译目标通过D3DXCompileShaderFromFile函数的一个参数指定。详见16.2节。<br>18.3.2 创建像素着色器<br>   一旦我们编译了着色器代码，我们就可以获得一个IDirect3DPixelShader的接口指针，它代表一个像素着色器，使用下面的方法：<br>HRESULT IDirect3DDevice9::CreatePixelShader(<br>      CONST DWORD <em>pFunction,<br>      IDirect3DPixelShader9*</em> ppShader<br>);<br>pFunction——已编译着色器代码的指针<br>ppShader——返回一个IDirect3DPixelShader9接口的指针</p><p>例如，假设变量shader是一个包含已编译着色器代码的ID3DXBuffer接口指针。那么要获得IDirect3DPixelShader9接口，我们应该写：<br>IDirect3DPixelShader9<em> MultiTexPS = 0;<br>hr = Device-&gt;CreatePixelShader(<br>           (DWORD</em>)shader-&gt;GetBufferPointer(),<br>           &amp;MultiTexPS);<br>注意：重申一遍，D3DXCompileShaderFromFile是一个可以返回已编译着色器代码（shader）的函数。</p><p>18.3.3 建立像素着色器<br>   在我们获得一个代表我们的像素着色器的IDirect3DPixelShader9接口的指针之后，我们可以使用下面的方法使用它：<br>HRESULT IDirect3DDevice9::SetPixelShader(<br>      IDirect3DPixelShader9* pShader<br>);<br>   这个方法只接受一个参数，我们通过它传递一个我们希望使用的指向像素着色器的指针。要使用我们在18.3.2节创建的像素着色器，我们应该写：<br>Device-&gt;SetPixelShader(MultiTexPS);</p><p>18.3.4 销毁像素着色器<br>   和其它所有Direct3D接口一样，要清除这些接口，我们必须在使用完毕后调用它们的Release方法。继续使用我们在18.3.2节创建的像素着色器，我们写：<br>d3d::Release<idirect3dpixelshader9*>(MultiTexPS);</idirect3dpixelshader9*></p><p>18.4 HLSL采样器对象<br>   在像素着色器中使用HLSL的内建函数tex*XXXX给纹理采样。<br>注意：采样时引用纹理上图素的坐标索引和采样器状态来生成像素。<br>   看16.7节详细地解释了这些函数，通常这些函数需要我们做2件事：</p><ul><li>使用纹理中的索引建立(u, v)纹理坐标。</li><li><p>给特定的纹理中编入索引。</p><p> 将纹理坐标（u, v）输入到像素着色器，在一个指定的HLSL对象中的像素着色器中，我们想编入索引的纹理是在像素着色器中被定义过的，在HLSL中叫作采样器。（The particular texture that we want to index into is identified in the pixel shader by a special HLSL object called a sampler.），我们可以把采样器对象想象成定义纹理和采样器阶段的对象。例如：假如我们使用3张纹理，这意味着我们需要在像素着色器里能够引用3个阶段中的每个一个。在像素着色器中我们这样写：<br>sampler FirstTex;<br>sampler SecondTex;<br>sampler ThirdTex;<br> Direct3D将给每个采样器对象连接一个唯一的纹理级别(stage)，在应用程序中我们找出与采样器对象相关联的阶段，并设置相应的纹理和采样器状态给该阶段。下列代码将举例说明如何在应用程序中设置纹理并把采样器状态设置为FirstTex：<br>// 创建<br>IDirect3DTexture9* Tex;<br>D3DXCreateTextureFromFile(Device, “tex.bmp”, &amp;Tex);<br>… …<br>// 取得常量FirstTex的句柄<br>FirstTexHandle = MultiTexCT-&gt;GetConstantByName(0, “FirstTex”);</p></li></ul><p>// 取得常量的描述<br>D3DXCONSTANT_DESC FirstTexDesc;<br>UINT count;<br>MultiTexCT-&gt;GetConstantDesc(FirstTexHandle, &amp;FirstTexDesc, &amp;count);<br>… …<br>// 为FirstTex设置纹理和采样器状态. We identify<br>// the stage FirstTex is associated with from the<br>// D3DXCONSTANT_DESC::RegisterIndex member:<br>Device-&gt;SetTexture(FirstTexDesc.RegisterIndex, Tex);</p><p>Device-&gt;SetSamplerState(FirstTexDesc.RegisterIndex,<br>                        D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);<br>Device-&gt;SetSamplerState(FirstTexDesc.RegisterIndex,<br>                        D3DSAMP_MINFILTER, D3DTEXF_LINEAR);<br>Device-&gt;SetSamplerState(FirstTexDesc.RegisterIndex,<br>                        D3DSAMP_MIPFILTER, D3DTEXF_LINEAR);<br>   注意：作为选择，替换使用采样器类型，你可以使用更多特殊的、强大的类型，如：sampler1D，sampler2D，sampler3D，和samplerCube类型，这些类型更安全并且它们只使用tex<em>函数。例如：一个sampler2D对象只使用tex2D</em>函数，同样一个sampler3D对象只使用tex3D*函数。<br>18.5 例子程序：Multitexturing in a Pixel Shader<br>   这章中的例子演示了在像素着色器中使用多纹理，这个例子将纹理一个基于图18.2方格，渲染的目标是一个木箱纹理，一个聚光灯纹理，和一个包含字符串的纹理。这就是例子程序：Pixel Shader。</p><p>   图18.2: 混合纹理. 让我们分别取得木箱纹理上、聚光灯纹理和字符串纹理上相关联的像素颜色：b，s和t，然后定义如何将这些颜色混合： c = b × s + t 。<br>   这个例子可以不使用像素着色器来实现，但实现这个程序是简单直接，它允许我们示范如何写，创建，而且使用像素着色器实现一些特效不必使用那些复杂的算法。<br>   虽然在这个例子中一次只使用3张纹理，检查采样器对象的成员以确定每个像素着色器能够使用的版本，这是值得的。换句话说，我们一次能使用多少纹理这依赖     于使用的像素着色器的版本。</p><ul><li>像素着色器的版本ps_1_1 到 ps_1_3支持4个纹理采样器。</li><li>像素着色器的版本ps_1_4支持6个纹理采样器。</li><li>像素着色器的版本ps_2_0到 ps_3_0支持16个纹理采样器。</li></ul><p>// File: ps_multitex.txt</p><p>// Desc: Pixel shader that does multitexturing.<br>// Globals<br>sampler BaseTex;<br>sampler SpotLightTex;<br>sampler StringTex;</p><p>// Structures<br>struct PS_INPUT<br>{<br>     float2 base      : TEXCOORD0;<br>     float2 spotlight : TEXCOORD1;<br>     float2 text      : TEXCOORD2;<br>};</p><p>struct PS_OUTPUT<br>{<br>     vector diffuse : COLOR0;<br>};</p><p>// Main<br>PS_OUTPUT Main(PS_INPUT input)<br>{<br>     // zero out members of output<br>     PS_OUTPUT output = (PS_OUTPUT)0;</p><pre><code> // sample appropriate textures vector b = tex2D(BaseTex,      input.base); vector s = tex2D(SpotLightTex, input.spotlight); vector t = tex2D(StringTex,    input.text); // combine texel colors vector c =b *s +t; // increase the intensity of the pixel slightly c += 0.1f; // save the resulting pixel color output.diffuse = c; return output;</code></pre><p>}</p><p>   首先像素着色器定义了3个sampler对象，要渲染的每个纹理，接下来定义是input和output结构。注意：我们没有将任何的颜色值输入到像素着色器中，这是因为我们使用纹理自己的颜色和光照；即BaseTex保存表面的颜色，SpotLightTex是光照图。像素着色器输出只一个简颜色值，指定了我们计算过的这个特定像素的颜色。<br>   Main函数使用tex2D函数采样3    个纹理，即它取得每个纹理的图素，计算映射到的像素，这通常依赖于指定的纹理坐标和采样器对象。然后我们混合图素的颜色用公式：c = b <em> s + t。接下来我们让全部的像素变亮一个bit，给每个部分增加0.1f。最后我们保存结果像素颜色并返回它。<br>   现在我们看到了的像素着色器的代码，现在我们改变并考虑应用程序的代码。应用程序有下列相应的全局变量：<br>IDirect3DPixelShader9</em> MultiTexPS = 0;<br>ID3DXConstantTable* MultiTexCT    = 0;</p><p>IDirect3DVertexBuffer9* QuadVB = 0;</p><p>IDirect3DTexture9<em> BaseTex      = 0;<br>IDirect3DTexture9</em> SpotLightTex = 0;<br>IDirect3DTexture9* StringTex    = 0;<br>D3DXHANDLE BaseTexHandle      = 0;<br>D3DXHANDLE SpotLightTexHandle = 0;<br>D3DXHANDLE StringTexHandle    = 0;</p><p>D3DXCONSTANT_DESC BaseTexDesc;<br>D3DXCONSTANT_DESC SpotLightTexDesc;<br>D3DXCONSTANT_DESC StringTexDesc;</p><p>   多纹理顶点结构的例子如下：<br>struct MultiTexVertex<br>{<br>     MultiTexVertex(float x, float y, float z,<br>                    float u0, float v0,<br>                    float u1, float v1,<br>                    float u2, float v2)<br>     {<br>          _x =  x;   _y =  y; _z = z;<br>          _u0 = u0;  _v0 = v0;<br>          _u1 = u1;  _v1 = v1;<br>          _u2 = u2,  _v2 = v2;<br>     }</p><pre><code> float _x,  _y,  _z; float _u0,  _v0; float _u1,  _v1; float _u2,  _v2; static const DWORD FVF;</code></pre><p>};<br>const DWORD MultiTexVertex::FVF = D3DFVF_XYZ | D3DFVF_TEX3;<br>   看好，它包含3个纹理坐标系统。</p><p>   Setup函数执行下列功能：</p><ul><li>填充方形的顶点缓存</li><li>编译着像素色器</li><li>创建像素色器</li><li>读取纹理</li><li>设置投影矩阵，不使用光照</li><li>取得采样器(sampler)对象的句柄</li><li>取得采样器对象的描述<br>bool Setup()<br>{<br>HRESULT hr = 0;</li></ul><p>// Create quad geometry.<br>Device-&gt;CreateVertexBuffer(<br>     6 * sizeof(MultiTexVertex),<br>     D3DUSAGE_WRITEONLY,<br>     MultiTexVertex::FVF,<br>     D3DPOOL_MANAGED,<br>     &amp;QuadVB,<br>     0);</p><p>MultiTexVertex<em>v =0;<br>QuadVB-&gt;Lock(0, 0, (void*</em>)&amp;v, 0);</p><p>v[0] = MultiTexVertex(-10.0f, -10.0f, 5.0f,<br>                       0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f);<br>v[1] = MultiTexVertex(-10.0f, 10.0f, 5.0f,<br>                       0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f);<br>v[2] = MultiTexVertex( 10.0f, 10.0f, 5.0f,<br>                       1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f);</p><p>v[3] = MultiTexVertex(-10.0f, -10.0f, 5.0f,<br>                       0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f);<br>v[4] = MultiTexVertex( 10.0f, 10.0f, 5.0f,<br>                       1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f);<br>v[5] = MultiTexVertex( 10.0f, -10.0f, 5.0f,<br>                       1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f);</p><p>QuadVB-&gt;Unlock();</p><p>// Compile shader<br>ID3DXBuffer<em> shader      = 0;<br>ID3DXBuffer</em> errorBuffer = 0;</p><p>hr = D3DXCompileShaderFromFile(<br>     “ps_multitex.txt”,<br>     0,<br>     0,<br>     “Main”, // entry point function name<br>     “ps_1_1”,<br>     D3DXSHADER_DEBUG,<br>     &amp;shader,<br>     &amp;errorBuffer,<br>     &amp;MultiTexCT);</p><p>// output any error messages<br>if( errorBuffer )<br>{<br>   ::MessageBox(0, (char<em>)errorBuffer-&gt;GetBufferPointer(), 0, 0);<br>   d3d::Release&lt;ID3DXBuffer</em>&gt;(errorBuffer);<br>}</p><p>if(FAILED(hr))<br>{<br>   ::MessageBox(0, “D3DXCompileShaderFromFile() - FAILED”, 0, 0);<br>   return false;<br>}</p><p>// Create Pixel Shader<br>hr = Device-&gt;CreatePixelShader(<br>     (DWORD*)shader-&gt;GetBufferPointer(),<br>     &amp;MultiTexPS);</p><p>if(FAILED(hr))<br>{<br>     ::MessageBox(0, “CreateVertexShader - FAILED”, 0, 0);<br>     return false;<br>}</p><p>d3d::Release<id3dxbuffer*>(shader);</id3dxbuffer*></p><p>// Load textures.<br>D3DXCreateTextureFromFile(Device, “crate.bmp”, &amp;BaseTex);<br>D3DXCreateTextureFromFile(Device, “spotlight.bmp”, &amp;SpotLightTex);<br>D3DXCreateTextureFromFile(Device, “text.bmp”, &amp;StringTex);</p><p>// Set projection matrix<br>D3DXMATRIX P;<br>D3DXMatrixPerspectiveFovLH(<br>           &amp;P, D3DX_PI * 0.25f,<br>           (float)Width / (float)Height, 1.0f, 1000.0f);</p><p>Device-&gt;SetTransform(D3DTS_PROJECTION, &amp;P);</p><p>// Disable lighting.<br>Device-&gt;SetRenderState(D3DRS_LIGHTING, false);</p><p>// Get handles<br>BaseTexHandle      = MultiTexCT-&gt;GetConstantByName(0, “BaseTex”);<br>SpotLightTexHandle = MultiTexCT-&gt;GetConstantByName(0, “SpotLightTex”);<br>StringTexHandle    = MultiTexCT-&gt;GetConstantByName(0, “StringTex”);</p><p>// Set constant descriptions:<br>UINT count;</p><p>MultiTexCT-&gt;GetConstantDesc(<br>                BaseTexHandle,<br>                &amp;BaseTexDesc,<br>                &amp;count);<br>MultiTexCT-&gt;GetConstantDesc(<br>                SpotLightTexHandle,<br>                &amp;SpotLightTexDesc,<br>                &amp;count);<br>MultiTexCT-&gt;GetConstantDesc(<br>                StringTexHandle,<br>                &amp;StringTexDesc,<br>                &amp;count);</p><p>MultiTexCT-&gt;SetDefaults(Device);</p><p>return true;<br>}</p><p>   Display函数设置像素着色器，使用2个纹理，并且在渲染方格前设置他们对应的采样器状态。<br>bool Display(float timeDelta)<br>{<br>if( Device )<br>{<br>     // …camera update code snipped<br>     // Render<br>     Device-&gt;Clear(0, 0, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,<br>                   0xffffffff, 1.0f, 0);<br>     Device-&gt;BeginScene();</p><pre><code> // set the pixel shader Device-&gt;SetPixelShader(MultiTexPS); Device-&gt;SetFVF(MultiTexVertex::FVF); Device-&gt;SetStreamSource(0, QuadVB, 0, sizeof(MultiTexVertex)); // base tex Device-&gt;SetTexture(BaseTexDesc.RegisterIndex, BaseTex); Device-&gt;SetSamplerState(BaseTexDesc.RegisterIndex,                         D3DSAMP_MAGFILTER, D3DTEXF_LINEAR); Device-&gt;SetSamplerState(BaseTexDesc.RegisterIndex,                         D3DSAMP_MINFILTER, D3DTEXF_LINEAR); Device-&gt;SetSamplerState(BaseTexDesc.RegisterIndex,                         D3DSAMP_MIPFILTER, D3DTEXF_LINEAR); // spotlight tex Device-&gt;SetTexture(SpotLightTexDesc.RegisterIndex, SpotLightTex); Device-&gt;SetSamplerState(SpotLightTexDesc.RegisterIndex,                         D3DSAMP_MAGFILTER, D3DTEXF_LINEAR); Device-&gt;SetSamplerState(SpotLightTexDesc.RegisterIndex,                         D3DSAMP_MINFILTER, D3DTEXF_LINEAR); Device-&gt;SetSamplerState(SpotLightTexDesc.RegisterIndex,                         D3DSAMP_MIPFILTER, D3DTEXF_LINEAR); // string tex Device-&gt;SetTexture(     StringTexDesc.RegisterIndex, StringTex); Device-&gt;SetSamplerState(StringTexDesc.RegisterIndex,                         D3DSAMP_MAGFILTER, D3DTEXF_LINEAR); Device-&gt;SetSamplerState(StringTexDesc.RegisterIndex,                         D3DSAMP_MINFILTER, D3DTEXF_LINEAR); Device-&gt;SetSamplerState(StringTexDesc.RegisterIndex,                         D3DSAMP_MIPFILTER, D3DTEXF_LINEAR); // draw the quad Device-&gt;DrawPrimitive(D3DPT_TRIANGLELIST, 0, 2); Device-&gt;EndScene(); Device-&gt;Present(0, 0, 0, 0);</code></pre><p>}<br>return true;<br>}</p><p>   当然我们必须想着在Cleanup函数中释放我们自己分配的接口。<br>void Cleanup()<br>{<br>     d3d::Release<idirect3dvertexbuffer9*>(QuadVB);</idirect3dvertexbuffer9*></p><pre><code> d3d::Release&lt;IDirect3DTexture9*&gt;(BaseTex); d3d::Release&lt;IDirect3DTexture9*&gt;(SpotLightTex); d3d::Release&lt;IDirect3DTexture9*&gt;(StringTex); d3d::Release&lt;IDirect3DPixelShader9*&gt;(MultiTexPS); d3d::Release&lt;ID3DXConstantTable*&gt;(MultiTexCT);</code></pre><p>}</p><p>18.6 摘要</p><ul><li>像素着色器取代了固定功能管线的多纹理级别（stage），而且，像素着色器给我们更改单独像素的能力，以任何方式选择和访问纹理数据。因而，使我们能实现很多使用固定功能管线所不能完成的特殊效果。</li><li>多纹理是一次使用几个纹理，并渲染它们一起创造出一个想要的结果的一个过程。多纹理代表性的用法是用它为静态几何图形实现光引擎。</li><li>HLSL内建的采样器（sampler）对象，标识特定的纹理/采样器级别（stage）。A采样器常用于从像素着色器中引用一个纹理/采样器级别。</li></ul><p>注意：一旦你懂得了如何去实现顶点和像素着色器，你需要的一些特效的创意，可以用它们去实现。得到特效创意最好的方法是，学习现有的用顶点和像素着色器实现的特效。《Direct3D ShaderX: Vertex and Pixel Shader Tips》和《Tricks edited by Wolfgang Engel》这2本书是众多出版物中最好的，像Nvidia和ATI的开发站点：<a href="http://developer.nvidia.com/" target="_blank" rel="noopener">http://developer.nvidia.com/</a> 和 <a href="http://ati.com/developer/index.html。另外我们推荐CG方面：由Randima" target="_blank" rel="noopener">http://ati.com/developer/index.html。另外我们推荐CG方面：由Randima</a> Fernando 和 Mark J. Kilgard写的《The Cg Tutorial by Randima Fernando》，这本书对于使用Cg的3D图形编程是一本相当好的指南，它基本上和Direct3D’s HLSL相同。</p><p>第十九章 效果架构<br>(The Effects Framework)<br>概览<br>   一个渲染效果一般由以下部分组成：一个顶点和/或像素着色器，一个需要设置的设备状态列表，一个或更多的渲染通道（rendering passes）。此外，有一个能在不同级别的图形硬件上渲染效果的可靠机制通常是值得的（也就是说，有不同的可用的效果版本执行同样的效果或尽可能尝试执行同样的效果）。显然，所有这些必要的任务组合在一起成为一个效果。因此，一个合理的做法（步聚）是，设法将这些任务封装到一个单元中。<br>   Direct3D效果构架提供了这样一个机制：将渲染效果的任务封装到一个效果文件。在效果文件中实现效果有两方面优势。其一，它允许我们不必重编译应用程序就能改变一个效果的执行。这是一种更新效果的过程，不管是修正一个bug，一些简单的加强，或者利用最新的3D硬件特性。第二，它将所有的效果组成部分封装到一个文件。<br>   这一章指导你用必要信息和步骤，编写和创建一个效果文件的。我们注意到效果文件象我们的HLSL程序一样可以写在任何ASCII文件中。<br>目标<br><em>???????? 理解一个效果文件的结构和组织</em>???????? 找到HLSL中的一些额外的对象<br><em>???????? 学习如何在效果文件中指定设备状态</em>???????? 学习如何创建并使用一个效果<br>*???????? 通过学习一些例子程序，取得使用效果框架上的一些经验<br>19.1 技术与传递（Techniques and Passes）<br>    一个效果文件由一个或多个技术组成。一个技术是用一个特殊的方法渲染一些特效。所以换句话说，一个效果文件提供了渲染相同特效的一个或多个不同的传递。为什么同样的效果需要几个不同实现呢？是的，一些硬件可能不支持一个效果的一种特定实现。因此，必需在不同硬件上实现相同效果的不同版本。</p><p>   注意：例如，我们可能实现一种效果的两个版本，一种用着色器实现而一种用固定管线实现。这样，那些有着色器（shader）支持的显卡用户能够利用着色器实现，而那些不支持着色器的用户仍然可以使用固定管线实现。</p><p>   可以在一个效果文件中实现所有版本的效果，这让我们更完整的封装了所有的效果，也是效果框架的目标之一 ―― 封装（encapsulation）。<br>   每种技术包括一次或多次渲染传递（passes）。一次渲染传递（rendering pass）在特定传递（pass）中封装了设备状态、采样器、和/或用于渲染几何体的着色器。<br>   注意：一个效果不仅限于可编程管线使用。例如，它可以使用固定功能管线控制设备状态，比如灯光、材质以及纹理。<br>    使用多次传递（multiple passes）的理由是，因为对每种特效，是通过使用不同的设备状态、着色器等等，对同样的几何体进行多次渲染来完成的。举例来说，回忆第8章 ，我们不得不在每帧里用不同的设备状态、多次渲染相同的几何体，以达到反射效果。</p><pre><code>这个例子，是一个用两种技术实现的效果文件的框架，第一种技术包括一次传递而每二种技术包括两次传递:</code></pre><p>// effect.txt<br>…<br>technique T0<br>{<br>     // first and only pass for this technique<br>     pass P0<br>     {<br>          …[specify pass device states, shaders, samplers, etc.]<br>     }<br>}</p><p>technique T1<br>{<br>     // first pass<br>     pass P0<br>     {<br>          …[specify pass device states, shaders, samplers, etc.]<br>     }</p><pre><code> // second pass pass P1 {      ...[specify pass device states, shaders, samplers, etc.] }</code></pre><p>}</p><p>19.2 更多HLSL内置对象（ More HLSL Intrinsic Objects）<br>   这是一些在HLSL中额外的内建对象类型。我们以前没有过早的提及，是因为它们主要用于效果框架。<br>19.2.1 纹理对象<br>   HLSL内建纹理类型描述了一个IDirect3DTexture9对象。通过使用纹理对象我们可以直接地在效果文件中对特定的采样器阶段结合纹理。纹理对象有下面的可以访问的数据成员：<br><em>???????? type—纹理类型 (例如：2D, 3D)</em>???????? format—纹理的像素格式<br><em>???????? width—纹理的宽度（单位像素）</em>???????? height—纹理的高度（单位像素）<br>*???????? depth—纹理的深度（如果是3D纹理，单位像素）</p><p>注意：迄今为止我们仅仅使用纹理来存贮图形数据，但是当你学到更高级的技术，你会发现纹理可用来保存任意表格信息。换句话说，纹理仅是数据表，不是必须包含图形数据。例如，在碰撞映射（bump mapping）时我们用到一种叫做法线图的东东（normal map），就是一种在每个点上包括了法向量的纹理。<br>19.2.2 采样器对象与采样器状态<br>   我们在18章讨论了采样器对象，然而，效果框架定义了新的关键字：sampler_state。使用sampler_state关键字，我们能初始化一个采样器对象（即，直接在效果方件中设置采样器对象的纹理和状态）。下面的例子说明了这点：<br>Texture Tex;?<br>sampler SO = sampler_state<br>{<br>     Texture = (Tex);  // 纹理</p><pre><code> // 采样器状态 MinFilter = LINEAR; MagFilter = LINEAR; MipFilter = LINEAR;</code></pre><p>};<br>    这里我们给采样器S0的texture成员关联了纹理 Tex，并给状态成员设置了采样状态。我们直接明了的在效果文件中设置所有信息。<br>19.2.3 顶点与像素着色器对象（Vertex and Pixel Shader Objects）<br>    vertexshader 和 pixelshader是HLSL的内建类型，分别表示顶点着色器和像素着色器。它们在效果文件中表示特定顶点和/或像素着色器，用于一个特定的渲染传递(pass)。vertexshader和/或pixelshader类型在应用程序中用ID3DXEffect::SetVertexShader和ID3DXEffect::SetPixelShader函数分别设置。例如，在效果文件中，让Effect是一个有效的ID3DXEffect对象，让VS是一个有效的IDirect3DVertexShader9对象，以及让VSHandle是一个D3DXHANDLE（是vertexshader 对象的引用）。然后，我们可以通过如下写法初始化VSHandle所引用的顶点着色器：<br>Effect-&gt;SetVertexShader(VSHandle, VS);<br>    当在应用程序中设置效果文件中的变量时，多数时候我们使用SetVertexShader 和 SetPixelShader。<br>    做为选择，我们可以直接在效果文件中写顶点和/或像素着色器。当使用一种特定的编译语法时，我们可以设置一个着色器变量。下面的例子展示了如何初始化一个pixelshader类型的变量ps。<br>// 定义入口函数<br>OUTPUT Main(INPUT input){…}<br>?<br>// 编译入口函数<br>pixelshader ps = compile ps_2_0 Main();<br>   观察在pixelshader关键字之后的特定的版本名，接下来是着色器入口函数。注意，当用这种方式（style）初始化一个顶点或像素着色器对象时，入口函数必须定义在效果文件中。</p><p>   最后，我们给一个特定传递关联一个着色器，如下：<br>// 定义入口函数<br>OUTPUT Main(INPUT input){…}?</p><p>// 编译入口函数<br>vertexshader vs = compile vs_2_0 Main();<br>?<br>pass P0<br>{<br>     // 给这个传递（pass）关联一个着色器（vs）<br>     vertexshader = (vs);?<br>     …<br>}</p><p>或者更简洁的：?<br>pass P0<br>{<br>     // 设置这个传递的顶点着色器，为入口函数” Main()”的顶点着色器<br>     vertexshader = compile vs_2_0 Main();?<br>     …<br>}<br>注意：这是一个相当有价值的论述，因此你至少要明白，你能用这样的语法来初始化一个vertexshader 和 pixelshader 类型：<br>vertexshader vs = asm { /<em>assembly instructions go here </em>/ };<br>pixelshader ps = asm { /<em>assembly instructions go here </em>/ };<br>如果你用汇编语言来写着色器，你就用这种语法。<br>19.2.4 字符串<br>最后，这是一个字符串对象，它的用法是这样地：<br>string filename = “texName.bmp”;<br>    尽管没有任何HLSL的内建函数支持字符串类型，但它可以在应用程序中读取。这样，我们能进一步封装效果使用的数据文件，比如纹理文件名和X文件字。</p><p>19.2.5 注解 (Annotations)<br>   除我们已经描述过的语义符之外，注解可以用在变量上。注解在HLSL中是不使用的，但是它们可以被应用程序通过效果框架访问。它们仅仅服务于一个绑定 “note”的变量，这样应用程序就能够访问这个变量了。为注解加入了<annotation>语法。下面一行举例说明：<br>texture tex0 &lt; string name = “tiger.bmp”; &gt;;<br>   在这个例子中的注解是<string name="tiger. bmp" ;>。它关联了一个字符串到变量tex0，即保存纹理数据的文件名。很明显，用相应的文件名注解一个纹理是有益的。<br>    注解可以使用下面函数被重新得到：<br>D3DXHANDLE ID3DXEffect::GetAnnotationByName(<br>     D3DXHANDLE hObject,<br>     LPCSTR pName<br>);<br>    pName是我们要操作的注解的名字，而hObject是注解所在的父块句柄，如一个technique、pass或者结构块。一旦我们有了一个注解的句柄，我们就能通过应用ID3DXEffect::GetParameterDesc得到有关它的信息。查看DirectX SDK文档以得到更多详细的内容。<br>19.3 效果文件的设备状态（ Device States in an Effect File）<br>   通常，为了正确执行一个效果，我们必须设置设备的状态，比如渲染状态、纹理状态、材质、灯光和纹理。将全部效果封装进一个文件使它有支持全部效果的能力，效果框架允许我们在效果文件中设置设备状态。设备状态被在渲染的传递部分（pass block）里设置，语法看起来象这样：<br>State= Value;<br>    对于完整的状态的列表，在DirectX SDK文档的索引（index）中查找”states”，或者从SDK的目录（Contents）标签下，查找DirectX Graphics\Reference\Effect Reference\Effect Format\States<br>    考虑FillMode状态。如果你看了一下刚刚提到的SDK中的内容，值与D3DFILLMODE一样，但没有D3DFILL_前缀。如果我们在SDK文档中查找D3DFILLMODE，我们找到值：D3DFILL_POINT, D3DFILL_WIREFRAME, and D3DFILL_SOLID。因而，对于效果文件我们省略了前缀，并获得下列状态FillMode的有效值：POINT, WIREFRAME, 和 SOLID。例如，你可以在效果文件中这么写-：<br>FillMode = WIREFRAME;<br>FillMode = POINT;<br>FillMode = SOLID;</string></annotation></p><p>注意：?在后面的小节中我们将在例子程序中设置几个设备状态。多数时候能够通过状态的名字猜到它的用途，但如果你想得到更详细的描述，请查看SDK文档。<br>19.4 创建效果<br>    效果用ID3DXEffect接口表示，我们用下面的D3DX函数创建它：<br>HRESULT D3DXCreateEffectFromFile(<br>     LPDIRECT3DDEVICE9 pDevice,<br>     LPCSTR pSrcFile,<br>     CONST D3DXMACRO<em> pDefines,<br>     LPD3DXINCLUDE pInclude,<br>     DWORD Flags,<br>     LPD3DXEFFECTPOOL pPool,<br>     LPD3DXEFFECT</em> ppEffect,<br>     LPD3DXBUFFER <em>ppCompilationErrors<br>);</em>???????? pDevice—被创建的ID3DXEffect对象所关联的设备<br><em>???????? pSrcFile—我们要编译的包括效果源代码的文本文件的名字（效果文件名）</em>???????? pDefines—这个参数是可选的，在本书中指定为null<br><em>???????? pInclude—ID3DXInclude接口指针。这个接口被设计成由应用程序执行，因而我们可以替换默认行为。通常，默认行为就挺好，我们可以指定null忽略这个参数。</em>???????? Flags—编译效果文件中的shader的选项标志，指定0为没有标志。有效选项为：<br>o??????? D3DXSHADER_DEBUG—指示编译器写入调试信息<br>o??????? D3DXSHADER_SKIPVALIDATION—指示编译器不做任何代码检测。这只在你正在用到一个已知正常工作的shader时使用。<br>o??????? D3DXSHADER_SKIPOPTIMIZATION—指示编译器不执行任何优化。实际上这只用于调试时，当你不想让编译器对代码做任何更改时。<br><em>???????? pPool—可选的ID3DXEffectPool接口指针，用于指定效果参数如何共享其它的效果实例。本例中指定null，表示我们不在参数与效果文件之间共享。</em>???????? ppEffect—返回一个ID3DXEffect接口指针，表示被创建的效果。<br>*???????? ppCompilationErrors—返回一个包含错误代码字符串和消息的ID3DXBuffer指针。</p><p>这是一个调用D3DXCreateEffectFromFile的例子：<br>// 修建效果<br>ID3DXEffect<em> Effect = 0;<br>ID3DXBuffer</em> errorBuffer = 0;<br>hr = D3DXCreateEffectFromFile(<br>     Device,           // 关联的设备<br>     “effect.txt”,     // 效果源文件<br>     0,                // no preprocessor definitions<br>     0,                // no ID3DXInclude interface<br>     D3DXSHADER DEBUG, // 编译标记<br>     0,                // 不共享参数<br>     &amp;Effect,          // 返回创建效果的指针<br>     &amp;errorBuffer);    // 返回的错误信息<br>?<br>// 输出错误信息<br>if( errorBuffer )<br>{<br>     ::MessageBox(0, (char<em>)errorBuffer-&gt;GetBufferPointer(), 0, 0);<br>     d3d::Release&lt;ID3DXBuffer</em>&gt;(errorBuffer);<br>}<br>?<br>if (FAILED(hr))<br>{<br>      ::MessageBox(0, “D3DXCreateEffectFromFile() - FAILED”, 0, 0);<br>      return false;<br>}</p><p>19.5 设置系数（Setting Constants）<br>   因为对于顶点和像素着色器，我们需要从程序代码中初始化效果文件中的变量。代替使用常量表，就象我们在顶点和像素着色器中做的那样，ID3DXEffect接口中有内建的设置变量的方法。我们这里不会列出所有的设置不同类型变量的方法，因为要完全列出实在是大多了—请查看DirectX SDK文档以获得完整列表。这里是一个删节的列表：<br>HRESULT ID3DXEffect::SetFloat(<br>    D3DXHANDLE hParameter,<br>    FLOAT f<br>);<br>Sets a floating-point variable in the effect file identified by hParameter to the value f<br>HRESULT ID3DXEffect::SetMatrix(<br>    D3DXHANDLE hParameter,<br>    CONST D3DXMATRIX<em> pMatrix<br>);<br>Sets a matrix variable in the effect file identified by hParameter to the value pointed to by pMatrix<br>HRESULT ID3DXEffect::SetString(<br>    D3DXHANDLE hParameter,<br>    CONST LPCSTR pString<br>);<br>Sets a matrix variable in the effect file identified by hParameter to the value pointed to by pString<br>HRESULT ID3DXEffect::SetTexture(<br>    D3DXHANDLE hParameter,<br>    LPDIRECT3DBASETEXTURE9 pTexture<br>);<br>Sets a texture variable in the effect file identified by hParameter to the value pointed to by pTexture<br>HRESULT ID3DXEffect::SetVector(<br>    D3DXHANDLE hParameter,<br>    CONST D3DXVECTOR4</em> pVector<br>);<br>Sets a vector variable in the effect file identified by hParameter to the value pointed to by pVector<br>HRESULT ID3DXEffect::SetVertexShader(<br>    D3DXHANDLE hParameter,<br>    LPDIRECT3DVERTEXSHADER9<br>      pVertexShader<br>);<br>Sets a vertex shader variable in the effect file identified by hParameter to the value pointed to by pVertexShader<br>HRESULT ID3DXEffect::SetPixelShader(<br>    D3DXHANDLE hParameter,<br>    LPDIRECT3DPIXELSHADER9 pPShader<br>);<br>Sets a pixel shader variable in the effect file identified by hParameter to the value pointed to by pPShader </p><p>   我们通过下面的方法得到变量（又叫效果参数effect parameters）句柄：<br>D3DXHANDLE ID3DXEffect::GetParameterByName(<br>     D3DXHANDLE hParent, // scope of variable - parent structure<br>     LPCSTR pName        // name of variable<br>);</p><pre><code>它的用法与D3DXConstantTable::GetConstantByName方法一样。即每一个参数是一个D3DXHANDLE，它标识我们想得到的在哪个父结构中的变量句柄。对于没有父结构的全局变量，我们指定null。第二个参数是在效果文件中所显示的变量名。做为例子，以下显示如何设置效果文件中的一些变量：</code></pre><p>// some data to set<br>D3DXMATRIX M;<br>D3DXMatrixIdentity(&amp;M);<br>?<br>D3DXVECTOR4 color(1.0f, 0.0f, 1.0f, 1.0f);<br>?<br>IDirect3DTexture9<em> tex = 0;<br>D3DXCreateTextureFromFile(Device, “shade.bmp”, &amp;tex);<br>?<br>// get handles to parameters<br>D3DXHANDLE MatrixHandle = Effect-&gt;GetParameterByName(0, “Matrix”);<br>D3DXHANDLE MtrlHandle   = Effect-&gt;GetParameterByName(0, “Mtrl”);<br>D3DXHANDLE TexHandle    = Effect-&gt;GetParameterByName(0, “Tex”);<br>?<br>// set parameters<br>Effect-&gt;SetMatrix(MatrixHandle, &amp;M);<br>Effect-&gt;SetVector(MtrlHandle, &amp;color);<br>Effect-&gt;SetTexture(TexHandle, tex);<br>?<br>注意：对每一个ID3DXEffect::Set</em>方法都有相应的ID3DXEffect::Get<em>方法用来取得效果文件中的变量值。例如，为得到一个距阵类型的变量，我们可以用这个函数：<br>HRESULT ID3DXEffect::GetMatrix(<br>     D3DXHANDLE hParameter,<br>     D3DXMATRIX</em> pMatrix<br>);<br>要取得所有的方法列表，查看DirectX SDK文档。<br>19.6 使用效果<br>    在这一节和它的小节，我们展示一旦一个效果被创建出来后如何使用它。下面步骤概述了全部过程：<br>1.??? 得到一个在你想使用的效果文件中的技术句柄。<br>2.??? 激活想得到的技术。<br>3.??? 启动当前活动的技术。<br>4.??? 对每个激活技术中的渲染传递，渲染想要的几何体。回想一下，技术可能由几个渲染传递组成，我们必须在每个传递中渲染一次几何体。<br>5.??? 结束当前激活的技术。<br>19.6.1 获得效果句柄（ Obtaining a Handle to an Effect）<br>    使用技术的第一步是获得一个技术D3DXHANDLE。可以用这个方法得到一个技术句柄：<br>D3DXHANDLE ID3DXEffect::GetTechniqueByName(<br>     LPCSTR pName // Name of the technique.<br>);<br>?<br>注意：实际上，一个效果文件包括几个技术，每一个都被针对一个特定的硬件能力设计。因此，应用程序通常在系统上运行一些能力测试，然后通过这些测试选择最好的技术。看下面小节中的ID3DXEffect::ValidateTechnique。<br>19.6.2 激活一个效果（ Activating an Effect）<br>    一旦得到了想要的技术的句柄，我们必须激活这个技术。这可以通过下面方法实现：<br>HRESULT ID3DXEffect::SetTechnique(<br>     D3DXHANDLE hTechnique // Handle to the technique to set.<br>);<br>?<br>注意：在激活一项技术前你可能想用现有设备验证它。也就是说，你也许想确保硬件支持的特色、配置技术的使用。你可以用下面的方法：<br>HRESULT ID3DXEffect::ValidateTechnique(<br>     D3DXHANDLE hTechnique // Handle to the technique to validate.<br>);</p><p>   回想一个效果文件可能有几个技术，每个偿试用不同的硬件特色执行一个特定效果，希望最少一个技术将在用户系统上执行。对于一个效果，你将遍例每一个技术并用ID3DXEffect::ValidateTechnique运行它，因而你能检测哪个技术是被支持的而哪个不被支持，然后进行适当的动作。<br>19.6.3 启动效果<br>   为了使用一个效果渲染几何体，我们必须围绕绘图函数在ID3DXEffect::Begin 和 ID3DXEffect::End技术间调用。这些函数就是分别开启和关闭效果。<br>HRESULT ID3DXEffect::Begin(<br>     UINT* pPasses,<br>     DWORD Flags<br>);</p><p><em>???????? pPasses—返回在当前活动的技术中的传递的数量。</em>???????? Flags—下面标志的任何一个：<br>o??????? Zero (0)—指定效果保存当前设备状态和着色状态，并在效果结束（这时ID3DXEffect::End被调用）后恢复它们。因为效果文件能够改变状态，对于可以保存启动效果前的状态来说，是很有用的。<br>o??????? D3DXFX_DONOTSAVESTATE—指示效果不保存和恢复设备状态（除shader状态外）。<br>o??????? D3DXFX_DONOTSAVESHADERSTATE—指示效果不保存和恢复shader状态。<br>19.6.4 设置当前的渲染传递（Setting the Current Rendering Pass）<br>   在我们用效果渲染任何几何体前，我们必须指定使用的渲染传递。回想一个技术包括一个或多个渲染传递，每一个传递封装了不同的设备状态、采样器、和/或用于这一传递的着色器。渲染传递通过下面方法指定：<br>HRESULT ID3DXEffect::Pass(<br>     UINT iPass // Index identifying the pass.<br>);<br>    一个技术的渲染传递被用标识为0…n-1的索引，共n个传递。因而，我们能用一个简单的循环遍例每一个传递，并用这一传递渲染几何体。19.6.6节有一个例子。<br>19.6.5 结束效果（Ending an Effect）<br>    最后，对于每个传递，我们渲染完几何体后，停止并结束效果时使用ID3DXEffect::End方法：<br>HRESULT ID3DXEffect::End(VOID);</p><p>19.6.6 例子<br>下面的代码片断示例了以上的使用一个效果的必要的五个步骤：<br>// 有效果文件中<br>technique T0<br>{<br>     pass P0<br>     {<br>     …<br>     }</p><h1 id="-1"><a href="#-1" class="headerlink" title="}"></a>}</h1><p>?<br>// 在应用程序中，取得技术句柄<br>D3DXHANDLE hTech = 0;<br>hTech = Effect-&gt;GetTechniqueByName(“TO”);<br>?<br>// 激活技术<br>Effect-&gt;SetTechnique(hTech );<br>?<br>// 启动激活的技术<br>UINT numPasses = 0;<br>Effect-&gt;Begin(&amp;numPasses, 0);<br>?<br>// 遍例每个传递<br>for(int i = 0; i &lt; numPasses; i++)<br>{<br>     // 设置当前传递<br>     Effect-&gt;Pass(i);<br>?<br>     // 在传递中渲染几何体<br>     Sphere-&gt;Draw();<br>}</p><p>// 结束效果<br>Effect-&gt;End();</p><p>19.7 例子程序: Lighting and Texturing in an Effect File<br>    做为热身，让我们创建一个在3D模型中操作灯光和纹理的效果文件。这个例子完全运行于固定功能管线，意味着效果框架不仅限于使用着色器。图19.1展示了使用灯光和纹理例子的屏幕截图。</p><p>图19.1: 灯光和纹理例子的屏幕截图. 纹理、材质和灯光状态在效果文件中指定。</p><p>以下是效果文件的实现：<br>// File: light tex.txt<br>// Desc: 效果文件控制光的设备状态，和纹理一个3D模型<br>?<br>// 全局变量<br>matrix WorldMatrix;<br>matrix ViewMatrix;<br>matrix ProjMatrix;<br>?<br>texture Tex;<br>?<br>// 过滤器<br>?<br>// Associated the texture ‘Tex’ with the texture stage ‘S0’<br>// corresponds with and also set the sampler states for the sampler<br>// stage ‘S0’ corresponds with.<br>sampler S0 = sampler state<br>{<br>     Texture   = (Tex);<br>     MinFilter = LINEAR;<br>     MagFilter = LINEAR;<br>     MipFilter = LINEAR;<br>};<br>?<br>// Effect<br>technique LightAndTexture<br>{<br>     pass P0<br>     {<br>          // Set misc. render states.?<br>          pixelshader      = null;   // No pixel shader.<br>          vertexshader     = null;   // No vertex shader.<br>          fvf = XYZ | Normal | Tex1; // Flexible vertex format<br>          Lighting         = true;   // Enable lighting.<br>          NormalizeNormals = true;   // Renormalize normals.<br>          SpecularEnable   = false;  // Disable specular highlights.<br>?<br>          // Set transformation states?<br>          WorldTransform[0]   = (WorldMatrix);<br>          ViewTransform       = (ViewMatrix);<br>          ProjectionTransform = (ProjMatrix);<br>?<br>          // Set a light source at light index 0. We fill out all the<br>          // components for light[0] because the Direct3D<br>          // documentation recommends filling out all components<br>          // for best performance.?<br>          LightType[0]         = Directional;<br>          LightAmbient[0]      = {0.2f, 0.2f, 0.2f, 1.0f};<br>          LightDiffuse[0]       = {1.0f, 1.0f, 1.0f, 1.0f};<br>          LightSpecular[0]     = {0.0f, 0.0f, 0.0f, 1.0f};<br>          LightDirection[0]     = {1.0f, -1.0f, 1.0f, 0.0f};<br>          LightPosition[0]      = {0.0f, 0.0f, 0.0f, 0.0f};<br>          LightFalloff[0]        = 0.0f;<br>          LightRange[0]        = 0.0f;<br>          LightTheta[0]        = 0.0f;<br>          LightPhi[0]          = 0.0f;<br>          LightAttenuation0[0]  = 1.0f;<br>          LightAttenuation1[0]  = 0.0f;<br>          LightAttenuation2[0]  = 0.0f;<br>?<br>          // Finally, enable the light:?<br>          LightEnable[0] = true;<br>?<br>          // Set material components. This is like calling<br>          // IDirect3DDevice9::SetMaterial.?<br>          MaterialAmbient  = {1.0f, 1.0f, 1.0f, 1.0f};<br>          MaterialDiffuse  = {1.0f, 1.0f, 1.0f, 1.0f};<br>          MaterialEmissive = {0.0f, 0.0f, 0.0f, 0.0f};<br>          MaterialPower    = 1.0f;<br>          MaterialSpecular = {1.0f, 1.0f, 1.0f, 1.0f};<br>?<br>          // Hook up the sampler object ‘S0’ to sampler stage 0,<br>          // which is given by Sampler[0].?<br>          Sampler[0] = (S0);<br>     }<br>}</p><pre><code>在这个效果文件中我们主要设置设备状态，就象在19.3节所述。例如，我们直接在效果文件中设置一个光源和一个材质。此外，我们指定转换距阵和纹理及采样器状态。这些状态被指定，然后用LightAndTexture方法和渲染传递P0渲染全部几何体，。</code></pre><p>   注意：考虑到在一个效果文件中涉及到的的变量，你必须把它们装入圆括号中。举例来说，涉及到距阵变量，你必须这样写：(WorldMatrix), (ViewMatrix), and (ProjMatrix)。不使用圆括号是违法的。</p><p>   因为大部分必需的和繁琐的工作都在效果文件里做了，比如设置灯光、材质和纹理。应用程序代码就是做一些创建效果和开启效果等简单的事情。例子中有下面一些相关的全局变量：<br>ID3DXEffect* LightTexEffect   = 0;</p><p>D3DXHANDLE WorldMatrixHandle  = 0;<br>D3DXHANDLE ViewMatrixHandle   = 0;<br>D3DXHANDLE ProjMatrixHandle   = 0;<br>D3DXHANDLE TexHandle          = 0;</p><p>D3DXHANDLE LightTexTechHandle = 0;</p><p>　　?这些东西很没劲 ——- 只是一个ID3DXEffect指针和一些句柄。LightTexTechHandle是一个技术的句柄，因此在它的名字中有子字符串“Tech”。</p><p>   RestoreDeviceObjects函数执行三个主要步骤：创建效果，获得作为效果参数的我们要用的技术的句柄，并初始化一些效果参数。下面是删节的实现：<br>bool Setup()<br>{<br>    HRESULT hr = 0;<br>　　// …省略了采样器的读取<br>?<br>    // 创建效果<br>    ID3DXBuffer<em> errorBuffer = 0;<br>    hr = D3DXCreateEffectFromFile(<br>        m_pd3dDevice ,<br>        “light_tex.txt”,<br>        0,                // 没有定义预处理器<br>        0,                // 没有ID3DXInclude接口<br>        D3DXSHADER_DEBUG, // 编译标记<br>        0,                // 不共享参数<br>        &amp;m_LightTexEffect,<br>        &amp;errorBuffer);<br>?<br>    // 输出错误信息<br>    if( errorBuffer )<br>    {<br>        ::MessageBox(0, (char</em>)errorBuffer-&gt;GetBufferPointer(), 0, 0);<br>        SAFE_RELEASE(errorBuffer);<br>    }<br>?<br>    if(FAILED(hr))<br>    {<br>        ::MessageBox(0, “D3DXCreateEffectFromFile() - FAILED”, 0, 0);<br>        return false;<br>    }<br>?<br>    // 保存经常访问的参数句柄<br>    m_WorldMatrixHandle  = m_LightTexEffect-&gt;GetParameterByName(0, “WorldMatrix”);<br>    m_ViewMatrixHandle   = m_LightTexEffect-&gt;GetParameterByName(0, “ViewMatrix”);<br>    m_ProjMatrixHandle   = m_LightTexEffect-&gt;GetParameterByName(0, “ProjMatrix”);<br>    m_TexHandle         = m_LightTexEffect-&gt;GetParameterByName(0, “Tex”);?<br>    m_LightTexTechHandle =<br>　　　　m_LightTexEffect-&gt;GetTechniqueByName(“LightAndTexture”);<br>?<br>    // 设置效果参数<br>    // 设置矩阵<br>    D3DXMATRIX W, P;?<br>    D3DXMatrixIdentity(&amp;W);<br>    m_LightTexEffect-&gt;SetMatrix( m_WorldMatrixHandle, &amp;W);?</p><pre><code>D3DXMatrixPerspectiveFovLH(    &amp;P,    D3DX_PI * 0.25f, // 45 - degree    (float)800.0f / (float)600.0f,    1.0f,    1000.0f);?m_LightTexEffect-&gt;SetMatrix( m_ProjMatrixHandle, &amp;P);</code></pre><p>?<br>    // Set texture<br>    IDirect3DTexture9<em> tex = 0;<br>    D3DXCreateTextureFromFile(m_pd3dDevice, “Terrain_3x_diffcol.jpg”, &amp;tex);?<br>    LightTexEffect-&gt;SetTexture(TexHandle, tex);<br>    d3d::Release&lt;IDirect3DTexture9</em>&gt;(tex);<br>?<br>    return true;<br>}</p><p>Disply函数很简单，运行步聚在19.6 节中简要说明:<br>bool Display(float timeDelta)<br>{<br>　　if( Device )<br>　　{<br>       // …[Camera update snipped]<br>       // set the new updated view matrix<br>       LightTexEffect-&gt;SetMatrix(ViewMatrixHandle, &amp;V);</p><pre><code>   // Activate the technique and render   Device-&gt;Clear(0, 0, D3DCLEAR TARGET | D3DCLEAR ZBUFFER,               0xffffffff, 1.0f, 0);   Device-&gt;BeginScene();   // set the technique to use   LightTexEffect-&gt;SetTechnique( LightTexTechHandle );   UINT numPasses = 0;   LightTexEffect-&gt;Begin(&amp;numPasses, 0);   for(int i = 0; i &lt; numPasses; i++)   {        LightTexEffect-&gt;Pass(i);        for(int j = 0; j &lt; Mtrls.size(); j++)        {           Mesh-&gt;DrawSubset(j);        }   }   LightTexEffect-&gt;End();   Device-&gt;EndScene();   Device-&gt;Present(0, 0, 0, 0);</code></pre><p>　　}<br>　　<br>　　return true;<br>}</p><p>19.8例子程序: Fog Effect<br>    非常遗憾，我们没有用一整章篇幅来介绍Direct3D雾化效果。雾化效果（以下简称雾）提高了场景的真实性，可以用它来模拟逼真的天气状况。另外，雾可以大大减少长剪裁（far-clip）平面视觉效果。<br>    虽然我们不能给它应有的重视，这里我们还是挤出了一个简要的雾化例程。虽然我们不涉及详细的细节，我们还是展示并解释了Direct3D代码，这是很直接的。<br>    Direct3D雾化是固定功能管线的一部份，受渲染状态限制。下面的效果文件设置顶点雾，以达到必要的雾化状态。</p><p>   注意：Direct3D也支持像素雾（也叫表格雾table fog），比顶点雾要更精确。<br>// File: fog.txt<br>// Desc: Effect file that handles device states for linear vertex fog.<br>technique Fog<br>{<br>     pass P0<br>     {<br>          // Set misc render states.?<br>          pixelshader      = null;<br>          vertexshader     = null;<br>          fvf              = XYZ | Normal;<br>          Lighting         = true;<br>          NormalizeNormals = true;<br>          SpecularEnable   = false;<br>?<br>          // Fog states?<br>          FogVertexMode = LINEAR;     // Linear fog function.<br>          FogStart      = 50.0f;       // Fog starts 50 units away from viewpoint.<br>          FogEnd        = 300.0f;     // Fog ends 300 units away from viewpoint.<br>?<br>          FogColor      = 0x00CCCCCC; // Gray colored fog.<br>          FogEnable     = true;        // Enable vertex fog.<br>     }<br>}</p><p>就象你看到的，线性顶点雾能够通过五个简单的渲染状态控制：<br>*???????? FogVertexMode—使用指定的雾函数用于顶点雾。雾函数指定雾如何根据距离增长，自然界的雾在近视口的地方比较薄并且根据距离增长变得厚起来了。有效的任务类型为LINEAR、EXP、EXP2。这些函数被定义为：</p><p>d 是到视口的距离(viewpoint.)</p><p>   注意：如果你用EXP或EXP2雾化函数，你不用设置FogStart 和 FogEnd，因为它们在这些雾函数类型中没被用到。代替的你必须设置雾密度（fog density）渲染状态（如，FogDensity = someFloatType）<br><em>???????? FogStart—标记了物体将开始雾化的起始深度。</em>???????? FogEnd—标记了物体将结束雾化的结束深度。<br>   注意：FogStart 与 FogEnd本质上定义了物体在其中被雾化的深度间隔（从视口）。<br><em>???????? FogColor—一个DWORD 或 D3DCOLOR值，以描述雾的颜色</em>???????? FogEnable—指定true以开启顶点雾或false以关闭顶点雾</p><p>   任何我们用fog.txt效果渲染的几何体将被雾化。通过这种方式，我们可以控制哪一物体得到雾化，而哪些不用雾化。这对只雾化特定区域是很有用的。例如，通常屋外是有雾的，屋里不被雾化。同样的，一定地理部分可能有雾，而另外部分可能没有。图19.2展示了这一小节的调用雾效果的例程的屏幕截图。<br>图19.2: 雾化效果例子程序的屏幕截图，在这个例子中我们使用线性雾函数，而且雾化渲染状态在效果文件中指定。<br>19.9例子程序: Cartoon Effect<br>   到目前为止的2个效果文件的例子，我们没有使用着色器（shader）。因为着色器在特效中的重要部分，我们想展示一个最精简的例子。例程CartoonEffect执行了在17章中讨论的卡通着色器，但是这次应用效果框架。下面是一个删节版的效果文件：<br>// File: tooneffect.txt<br>// 在效果文件中的卡通着色器<br>extern matrix WorldMatrix;<br>extern matrix ViewMatrix;<br>extern matrix ProjMatrix;<br>extern vector Color;<br>extern vector LightDirection;<br>static vector Black = {0.0f, 0.0f, 0.0f, 0.0f};<br>extern texture ShadeTex;<br>?<br>struct VS_INPUT<br>{<br>     vector position : POSITION;<br>     vector normal   : NORMAL;<br>};</p><p>struct VS_OUTPUT<br>{<br>     vector position : POSITION;<br>     float2 uvCoords : TEXCOORD;<br>     vector diffuse  : COLOR;<br>};<br>?<br>// Cartoon Shader Function:<br>VS_OUTPUT Main(VS_INPUT input)<br>{<br>     …[Implementation omitted for brevity.]<br>}<br>?<br>sampler ShadeSampler = sampler state<br>{<br>     Texture = (ShadeTex);<br>     MinFilter = POINT; // no filtering for cartoon shading<br>     MagFilter = POINT;<br>     MipFilter = NONE;<br>};<br>?<br>technique Toon<br>{<br>     pass P0<br>     {<br>          // Set P0’s vertex shader.<br>          vertexShader = compile vs_1_1 Main();<br>          // Hook up the sampler object to sampler stage 0.<br>          Sampler[0] = (ShadeSampler);<br>     }<br>}</p><p>   我们注意到卡通着色器函数被定义在效果文件中，并且我们指定着色器使用一个特定的传递，在传递部分使用语法：vertexShader = compile vs_1_1_Main();。在效果文件中的设备状态象通常一样设置。</p><p>19.10 效果编辑（EffectEdit）<br>   在结束这章前，我们想提一下在DirectX SDK中的EffectEdit程序。可以在\DXSDK\Samples\C++\Direct3D\Bin文件夹中找到它。图19.3显示了一个屏幕截图。</p><p>图19.3: 一个在DirectX SDK 中的EffectEdit 程序的屏幕截图<br>    这个EffectEdit程序在测试和书写效果文件时是很有用的。我们推荐您在这个工具上花点时间。</p><p>19.11摘要<br>略</p><p>相关文章：<br>AGP内存<br>AGP（Accelerate Graphical Port），加速图形接口。随着显示芯片的发展，PCI总线日益无法满足其需求。英特尔于1996年7月正式推出了AGP接口，它是一种显示卡专用的局部总线。严格的说，AGP不能称为总线，它与PCI总线不同，因为它是点对点连接，即连接控制芯片和AGP显示卡，但在习惯上我们依然称其为AGP总线。AGP接口是基于PCI 2.1 版规范并进行扩充修改而成，工作频率为66MHz。<br>　　AGP总线直接与主板的北桥芯片相连，且通过该接口让显示芯片与系统主内存直接相连，避免了窄带宽的PCI总线形成的系统瓶颈，增加3D图形数据传输速度，同时在显存不足的情况下还可以调用系统主内存。所以它拥有很高的传输速率，这是PCI等总线无法与其相比拟的。<br>　　由于采用了数据读写的流水线操作减少了内存等待时间，数据传输速度有了很大提高；具有133MHz及更高的数据传输频率；地址信号与数据信号分离可提高随机内存访问的速度；采用并行操作允许在CPU访问系统RAM的同时AGP显示卡访问AGP内存；显示带宽也不与其它设备共享，从而进一步提高了系统性能。<br>　　AGP标准在使用32位总线时，有66MHz和133MHz两种工作频率，最高数据传输率为266Mbps和533Mbps，而PCI总线理论上的最大传输率仅为133Mbps。目前最高规格的AGP 8X模式下，数据传输速度达到了2.1GB/s。<br>　　AGP接口的发展经历了AGP1.0(AGP1X、AGP2X)、AGP2.0(AGP Pro、AGP4X)、AGP3.0(AGP8X)等阶段，其传输速度也从最早的AGP1X的266MB/S的带宽发展到了AGP8X的2.1GB/S。<br>AGP 1.0（AGP1X、AGP2X）<br>　 1996年7月AGP 1.0 图形标准问世，分为1X和2X两种模式，数据传输带宽分别达到了266MB/s和533MB/s。这种图形接口规范是在66MHz PCI2.1规范基础上经过扩充和加强而形成的，其工作频率为66MHz，工作电压为3.3v，在一段时间内基本满足了显示设备与系统交换数据的需要。这种规范中的AGP带宽很小，现在已经被淘汰了，只有在前几年的老主板上还见得到。<br>AGP2.0(AGP4X)<br>　　显示芯片的飞速发展，图形卡单位时间内所能处理的数据呈几何级数成倍增长，AGP 1.0 图形标准越来越难以满足技术的进步了，由此AGP 2.0便应运而生了。1998年5月份，AGP 2.0 规范正式发布，工作频率依然是66MHz，但工作电压降低到了1.5v，并且增加了4x模式，这样它的数据传输带宽达到了1066MB/sec，数据传输能力大大地增强了。<br>AGP Pro<br>　　AGP Pro接口与AGP 2.0同时推出，这是一种为了满足显示设备功耗日益加大的现实而研发的图形接口标准，应用该技术的图形接口主要的特点是比AGP 4x略长一些，其加长部分可容纳更多的电源引脚，使得这种接口可以驱动功耗更大（25-110w）或者处理能力更强大的AGP显卡。这种标准其实是专为高端图形工作站而设计的，完全兼容AGP 4x规范，使得AGP 4x的显卡也可以插在这种插槽中正常使用。AGP Pro在原有AGP插槽的两侧进行延伸，提供额外的电能。它是用来增强，而不是取代现有AGP插槽的功能。根据所能提供能量的不同，可以把AGP Pro细分为AGP Pro110和AGP Pro50。在某些高档台式机主板上也能见到AGP Pro插槽，例如华硕的许多主板。<br>AGP 3.0(AGP8X)<br>　　2000年8月，Intel推出AGP3.0规范，工作电压降到0.8V,并增加了8x模式，这样它的数据传输带宽达到了2133MB/sec，数据传输能力相对于AGP 4X成倍增长，能较好的满足当前显示设备的带宽需求。<br>AGP接口的模式传输方式<br>　　不同AGP接口的模式传输方式不同。1X模式的AGP，工作频率达到了PCI总线的两倍—66MHz，传输带宽理论上可达到266MB/s。AGP 2X工作频率同样为66MHz，但是它使用了正负沿（一个时钟周期的上升沿和下降沿）触发的工作方式，在这种触发方式中在一个时钟周期的上升沿和下降沿各传送一次数据，从而使得一个工作周期先后被触发两次，使传输带宽达到了加倍的目的，而这种触发信号的工作频率为133MHz，这样AGP 2X的传输带宽就达到了266MB/s×2（触发次数）＝533MB/s的高度。AGP 4X仍使用了这种信号触发方式，只是利用两个触发信号在每个时钟周期的下降沿分别引起两次触发，从而达到了在一个时钟周期中触发4次的目的，这样在理论上它就可以达到266MB/s×2（单信号触发次数）×2（信号个数）＝1066MB/s的带宽了。在AGP 8X规范中，这种触发模式仍然使用，只是触发信号的工作频率变成266MHz，两个信号触发点也变成了每个时钟周期的上升沿，单信号触发次数为4次，这样它在一个时钟周期所能传输的数据就从AGP4X的4倍变成了8倍，理论传输带宽将可达到266MB/s×4（单信号触发次数）×2（信号个数）＝2133MB/s的高度了。</p><p>　　目前常用的AGP接口为AGP4X、AGP PRO、AGP通用及AGP8X接口。需要说明的是由于AGP3.0显卡的额定电压为0.8—1.5V，因此不能把AGP8X的显卡插接到AGP1.0规格的插槽中。这就是说AGP8X规格与旧有的AGP1X/2X模式不兼容。而对于AGP4X系统，AGP8X显卡仍旧在其上工作，但仅会以AGP4X模式工作，无法发挥AGP8X的优势。</p><p>Direct3D中实现图元的鼠标拾取<br>索引：<br>　　1、什么是拾取，拾取能做什么？<br>　　2、拾取操作的步骤和实现<br>　　2.1． 变换并获得通过视点和屏幕上点击点的射线矢量（Dir）<br>　　 2.1.1 确定鼠标选取点的屏幕坐标<br>　　 2.1.2 得到Dir在观察坐标空间内的表示<br>　　 2.1.3 转换Dir到世界坐标空间，并得到观察点在世界坐标系中的坐标<br>　　2.2 使用射线矢量对场景中的所有三角形图元求交，获得三角形索引值和重心坐标。<br>　　 2.2.1 D3D扩展函数实现求交<br>　　 2.2.2射线三角面相交的数学算法<br>　　 2.2.3 拾取完成根据获得的中心坐标计算我们关心的常见量<br>　　3、结束及声明<br>　　4、参考文献<br>　　补充：重心坐标的概念<br>　　3D交互图形应用程序中，常常要用鼠标去选择图形，其实现的机制基于鼠标拾取算法。本文主要讲述如何在D3D中实现图元的鼠标拾取。为了讨论简单，本文假定读者理解D3D 坐标变换流程和基本的图形学知识，如果阅读有困难请参考相关资料。<br>1、什么是拾取，拾取能做什么？<br>   首先，拾取操作指当我们在屏幕上用鼠标点击某个图元，应用程序能返回该图元的一个标志和某些相关信息。有图形程序设计经验的人都知道，有这些信息就表示我们有了对该图元的控制权，我们可以删除，可以编辑，可以任意对待该图元，至于你到底想干什么，就是阁下自己的事了^_^。</p><p>2、拾取操作的步骤和实现<br>　　拾取算法的思想很简单：得到鼠标点击处的屏幕坐标，通过投影矩阵和观察矩阵把该坐标转换为通过视点和鼠标点击点的一条射入场景的光线，该光线如果与场景模型的三角形相交（本文只处理三角形图元），则获取该相交三角形的信息。本文讲述的方法除可以得到三角形的一个索引号以外还可以得到相交点的重心坐标。<br>从数学角度来看，我们只要得到射线的方向矢量和射线的发射点，我们就具备了判断射线与空间三角面是否相交的条件，本文主要讨论如何获得这些条件，并描述了射线与三角面相交判断算法和D3D的通常实现方法。 </p><p>　　根据拾取操作的处理顺序，大概可以依次分为以下几个步骤<br>2.1． 变换并获得通过视点和屏幕上点击点的射线矢量（Dir）<br>详细介绍之前，为了大家方便理解，我们要先简单说一下d3d坐标转换的大概流程，如下图:</p><p>　　 所以我们要通过一系列的反变换，得到我们关心的值在世界坐标中的表示。<br>　　2.1.1 确定鼠标选取点的屏幕坐标<br>　　这一步是非常简单的Windows给我们提供了API来完成屏幕坐标的获取，使用GetCursorPos获得鼠标指针位置，然后再利用ScreenToClient转换坐标到客户区坐标系(以窗口视区左上角为坐标原点，单位为像素)，设该坐标为（POINT screenPt）。<br>　　2.1.2 得到Dir在观察坐标空间内的表示<br>　　在观察坐标系中，Dir是一条从观察坐标原点出发的射线，所以我们只需要再确定一个该射线经过的点，就可以得到它在观察坐标系中的表示。假设我们要求的射线上的另外一点为该射线与透视投影平截头体近剪切面的交点，针对最普遍的透视投影而言，透视投影平截头体经投影变换后，变成一个1/2立方体（请允许我这么叫^_^，因为它的大小为一个正方体的一半，x,y方向边长为2，z方向为1）如图：</p><p>投影坐标系以近剪切面中心为坐标原点，该立方体从z轴负向看过去与图形程序视区相对应，最终近剪切面（前剪切面）上一点与屏幕坐标之间的对应关系如下图所示：</p><p>　　根据比例关系，screenPt与投影空间上的点projPt之间的关系为<br>　　假设图形程序窗口的宽为screenWidth,高为screenHeight,<br>　　projPt.x = (screenPt.x-screenWidth/2)/screenWidth<em>2; （公式1）<br>　　projPt.y = (screenPt.y-screenHeight/2)/screenHeight</em>2; （公式2）<br>　　projPt.z =0;（实际该值可任意取，不影响最终结果。为了处理简单，我们取改值为0，表示该点取在近剪切面上）<br>　　得到projPt后，我们需要做的是把该点坐标从投影空间转换到观察空间(view space),<br>　　根据透视投影的定义，可假设点(projPt.x，projPt.y，projPt.z)<br>　　对应的其次坐标为<br>　　(projPt.x<em>projPt.w，projPt.y</em>projPt.w，projPt.z<em>projPt.w，projPt.w)<br>　　我们可以通过 GetTransform( D3DTS_PROJECTION, &amp;ProjMatrix)函数获得投影矩阵ProjMatrix,则根据观察空间到投影空间的变换关系则：投影坐标 = 观察坐标×投影矩阵<br>　　(projPt.x</em>projPt.w，projPt.y<em>projPt.w，projPt.z</em>projPt.w，projPt.w)<br>　　= (viewPt.x，viewPt.y，viewPt.z, 1)<em>pProjMatrx;<br>　　根据定义和图形学原理<br>　　ProjMatrix = =<br>　　所以,<br>　　(projPt.x</em>projPt.w，projPt.y<em>projPt.w，projPt.z</em>projPt.w，projPt.w)<br>　　= ( viewPt.x<em>ProjMatrix._m11,<br>　　   viewPt.y</em>ProjMatrix._m22,<br>　　   viewPt.z*Q-QZn,<br>       viewPt.z)</p><p>　　所以<br>　　projPt.x<em>projPt.w = viewPt.x</em>ProjMatrix._m11<br>　　projPt.y<em>projPt.w = viewPt.y</em>ProjMatrix._m22<br>　　projPt.z<em>projPt.w = viewPt.z</em>Q-QZn （注意projPt.z = 0）<br>　　projPt.w = viewPt.z;<br>　　解得<br>　　viewPt.x = projPt.x<em>Zn/ ProjMatrix._m11;<br>　　viewPt.y = projPt.y</em>Zn/ ProjMatrix._m22;<br>　　viewPt.z = Zn;<br>　　好了，到这里为止我们终于求出了射线与近剪切面交点在观察坐标系中的坐标，现在我们拥有了射线的出发点(0,0,0)和射线方向上另外一点(viewPt.x,viewPt.y,viewPt.z),则该射线的方向矢量在观察空间中的表示可确定为（viewPt.x-0,viewPt.y-0,viewPt.z-0）,化简一下三个分量同除近剪切面z坐标Zn，该方向矢量可写作<br>　　DIRview = (projPt.x/projMatrix._m11,projPt.y/projMatrix._m22,1)<br>　　代入公式1，公式2<br>　　DIRview.x = (2<em>screenPt.x/screenWidth-1)/projMatrix._m11;<br>　　DIRview.y = (2</em>screenPt.y/screenHeight-1)/projMatrix._m22;<br>　　DIRview.z = 1;<br>     其中screenWidth和screenHeight可以通过图像显示的backBuffer的目标表面（D3DSURFACE_DESC）来获得，该表面在程序初始化时由用户创建。</p><p>　　2.1.3 转换Dir到世界坐标空间，并得到观察点在世界坐标系中的坐标<br>　　由于最终的运算要在世界坐标空间中进行，所以我们还需要把矢量DIRview从观察空间转换为世界坐标空间中的矢量DIRworld。<br>　　因为<br>　　DIRview = DIRworld<em>ViewMatrix;<br>　　其中ViewMatrix为观察矩阵，在D3D中可以用函数GetTransform( D3DTS_VIEW, &amp;ViewMatrix )得到。<br>　　所以DIRworld = DIRview </em> inverse_ViewMatrix,其中inverse_ViewMatrix为ViewMatrix的逆矩阵。<br>　　观察点在观察坐标系中坐标为OriginView（0，0，0，1），所以其在世界坐标系中的坐标同样可以利用ViewMatrix矩阵，反变换至世界坐标系中，事实上我们可以很简单的判断出,其在世界坐标系中的表示为:<br>　　OriginWorld = (inverse_ViewMatrix._41,<br>　　inverse_ViewMatrix._42,<br>　　inverse_ViewMatrix._43,<br>　　1);<br>　　到这里为止，判断射线与三角面是否相交的条件就完全具备了。<br>2.2 使用射线矢量对场景中的所有三角形图元求交，获得三角形索引值和重心坐标。<br>　　这一步骤地实现由两种途径:<br>　　第一种方法非常简单，利用D3D提供的扩展函数D3DXIntersect可以轻松搞定一切。见2.1<br>　　第二种方法就是我们根据空间解析几何的知识，自己来完成射线三角形的求交算法。一般来讲，应用上用第一种方法就足够了，但是我们如果要深入的话，必须理解相交检测的数学算法，这样才能自由的扩展，面对不同的需求，内容见2.2<br>　　下面分别讲解两种实现途径：<br>　　2.2.1 D3D扩展函数实现求交<br>　　这种方法很简单也很好用，对于应用来说应尽力是用这种方式来实现，毕竟效率比自己写得要高得多。<br>　　实际上其实没什么好讲的，大概讲一下函数D3DXIntersect吧<br>　　D3D SDK该函数声明如下<br>　　HRESULT D3DXIntersect(<br>　　LPD3DXBASEMESH pMesh,<br>　　CONST D3DXVECTOR3 <em>pRayPos,<br>　　CONST D3DXVECTOR3 </em>pRayDir,<br>　　BOOL <em>pHit,<br>　　DWORD </em>pFaceIndex,<br>　　FLOAT <em>pU,<br>　　FLOAT </em>pV,<br>　　FLOAT <em>pDist,<br>　　LPD3DXBUFFER </em>ppAllHits,<br>　　DWORD <em>pCountOfHits<br>　　);<br>　　l pMesh指向一个ID3DXBaseMesh的对象，最简单的方式是从.x文件获得，描述了要进行相交检测的三角面元集合的信息，具体规范参阅direct9 SDK<br>　　l pRayPos 指向射线发出点<br>　　l pRayDir 指向前面我们辛辛苦苦求出的射线方向的向量<br>　　l pHit 当检测到相交图元时，指向一个true,不与任何图元相交则为假<br>　　l pU 用于返回重心坐标U分量<br>　　l pV返回重心坐标V分量<br>　　l pDist 返回射线发出点到相交点的长度<br>　　注意：以上红色字体部分均指最近的一个返回结果（即</em>pDist最小）<br>　　l ppAllHits用于如果存在多个相交三角面返回相交的所有结果<br>　　l pCountOfHits 返回共有多少个三角形与该射线相交<br>　　补充：重心坐标的概念<br>三角形的重心坐标：　　<br>P1，P2，P3为空间三角形的三个顶点矢量， (U,?V)就称为三角形的重心坐标<br>在空间三角形平面上的点可以表示为：　P?=?P1?+?U?<em>?(P2?-?P1)?+?V?</em>?(P3?-?P1)<br>当0?&lt;?U?&lt;?1，0?&lt;?V?&lt;?1，0?&lt;?U?+?V?&lt;?1时，这个点P就在这个三角形的内部<br>                                                                             收集<br>　　<br>　　其中pU和pV用到了重心坐标的概念，下面稍作描述<br>　　一个三角形有三个顶点，在迪卡尔坐标系中假设表示：<br>　　V1(x1,y1,z1),<br>　　V2(x2,y2,z2),<br>　　V3(x3,y3,z3),<br>　　则三角形内任意一点的坐标可以表示为（pV为任意点）：<br>　　pV = V1 + U(V2-V1) + V(V3-V1)<br>　　所以已知三个顶点坐标的情况下，任意一点可用坐标(U,V)来表示，其中 参数U控制V2在结果中占多大的权值，参数V控制V3占多大权值，最终V1占多大权值 = 1 - U - V，这种坐标定义方式就叫重心坐标。<br>　　<br>　　2..2.2射线三角面相交的数学算法<br>　　使用d3d扩展函数，毕竟有时不能满足具体需求，掌握了该方法，我们才能够获得最大的控制自由度，任意修改算法。<br>　　已知条件: 射线源点orginPoint,三角形三个顶点 v1,v2,v3,射线方向 Dir（均以三维坐标向量形式表示）。<br>　　算法目的: 判断射线与三角形是否相交，如果相交求出交点的重心坐标(U,V)和射线原点到交点的距离T。<br>　　我们可先假设射线与三角形相交则交点<br>　　(注以下均为向量运算：<br>dot(X,Y)       点乘；<br>　　cross(X，Y)    叉乘；<br>　　U，V，T      标量(这三个值为X、Y、Z轴坐标))<br>　　<br>　　则：（IntersectPoint为三角形上的交点）<br>　　IntersectPoint = V1 + U×(V2-V1) + V×(V3-V1) ;<br>　　IntersectPoint = originPoint + T×Dir；<br>　　所以：<br>　　orginPoint + T×Dir = V1 + U×(V2-V1) + V×(V3-V1);<br>　　整理得：<br>　　orginPoint - V1 = U×(V2-V1) + V×(V3-V1) - T×Dir;<br>?<br>这是一个简单的线性方程组，若有解则行列式［-Dir, V2-V1, V3-V1］不为0。<br>   根据T,U,V的含义当T&gt;0, 0&lt;U&lt;1,0&lt;V&lt;1,0&lt;U+V&lt;1时该交点在三角形内部，解此方程组即可获得我们关心的值,具体解法不再赘述，克莱姆法则就够了（详细见线性代数）:射线原点到相交点的距离T,和交点的中心坐标(U,V)。<br>下面给出Direct 9 SDK示例程序中的实现代码：<br>IntersectTriangle( const D3DXVECTOR3&amp; orig,<br>??????????????????      const D3DXVECTOR3&amp; dir, D3DXVECTOR3&amp; v0,<br>?????? ????????????     D3DXVECTOR3&amp; v1, D3DXVECTOR3&amp; v2,<br>?????? ????????????     FLOAT<em> t, FLOAT</em> u, FLOAT* v )<br>{<br>??? // 算出两个边的向量<br>??? D3DXVECTOR3 edge1 = v1 - v0;<br>??? D3DXVECTOR3 edge2 = v2 - v0;<br>?<br>   D3DXVECTOR3 pvec;<br>   D3DXVec3Cross( &amp;pvec, &amp;dir, &amp;edge2 );</p><p>   // 如果det为0，或接近于零则射线与三角面共面或平行，不相交<br>   //此处det就相当于上面的[-Dir, V2-V1, V3-V1]，<br>??? FLOAT det = D3DXVec3Dot( &amp;edge1, &amp;pvec );<br>?<br>??? D3DXVECTOR3 tvec;<br>??? if( det &gt; 0 )<br>??? {<br>??????? tvec = orig - v0;<br>??? }<br>??? else<br>??? {<br>??????? tvec = v0 - orig;<br>??????? det = -det;<br>??? }<br>?<br>??? if( det &lt; 0.0001f )<br>??????? return FALSE;<br>?<br>??? // 计算u并测试是否合法（在三角形内）<br>??? <em>u = D3DXVec3Dot( &amp;tvec, &amp;pvec );<br>??? if( </em>u &lt; 0.0f || <em>u &gt; det )<br>??????? return FALSE;<br>?<br>??? // Prepare to test V parameter<br>??? D3DXVECTOR3 qvec;<br>??? D3DXVec3Cross( &amp;qvec, &amp;tvec, &amp;edge1 );<br>?<br>??? //计算u并测试是否合法（在三角形内）<br>??? </em>v = D3DXVec3Dot( &amp;dir, &amp;qvec );<br>??? if( <em>v &lt; 0.0f || </em>u + <em>v &gt; det )<br>??????? return FALSE;<br>?<br>??? /</em>计算t,并把t,u,v放缩为合法值（注意前面的t,v,u不同于算法描述中的相应量，乘了一个系数det）,注意：由于该步运算需要使用除法，所以放到最后来进行，避免不必要的运算，提高算法效率<em>/<br>??? </em>t = D3DXVec3Dot( &amp;edge2, &amp;qvec );<br>??? FLOAT fInvDet = 1.0f / det;<br>??? <em>t </em>= fInvDet;<br>??? <em>u </em>= fInvDet;<br>??? <em>v </em>= fInvDet;<br>?<br>??? return TRUE;<br>}</p><p>?<br>2.2.3? 拾取完成根据获得的中心坐标计算我们关心的常见量<br>根据重心坐标（U,V）,我们可以很容易的算出各种相关量比如纹理坐标和交点的差值颜色，假设以纹理坐标为例设V1,V2,V3的纹理坐标分别为T1(tu1,tv1),T2(tu2,tv2),T3(tu3,tv3)则交点的坐标为<br>?<br>IntersectPointTexture = T1 + U(T2-T1) + V(T3-T1)</p><p>3、结束及声明<br>　　Ok, 到这里为止关于拾取的相关知识就介绍完了，小弟第一次写这种文章，不知道有没有把问题说清楚，希望对大家有所帮助，有任何问题可以给我发email: jzhang1@mail.xidian.edu.cn<br>　　或者到我的网站留言： www.heavysword.com<br>　　声明：<br>　　本文写作的目的是为了广大D3D学习者方便学习服务，文中算法为作者参考相关文献总结，作者无意把这些据为自己的成果，所有权原算法提出者所有（参阅参考文献），文中代码为D3d SDK的示例内容，由笔者进行了必要的解释，代码版权归microsoft所有。<br>4、参考文献<br>　　【1】Microsoft DirectX 9.0 SDK,microsoft<br>　　【2】fast,Minimun Storage Ray/Triangle Intersection,Tomas Moler,Ben Trumbore</p><p>?BY</p><p>克莱姆（Cramer）法则<br>一、线性方程组<br>　　元线性方程组是指形式为：<br>　　　　　　　　（1）<br>的方程组，其中代表个未知量，是方程的个数，， ; 称为方程组的系数，称为常数项。<br>　　线性方程组的一个解是指由个数组成的有序数组， 当个未知量分别用代入后，式（1）中每个等式都成为恒等式。方程组（1）的解的全体称为它的解集合，如果两个线性方程组有相同的解集合，就称它们是同解方程组。<br>　　为了求解一个线性方程组，必须讨论以下一些问题：<br>　　(1).这个方程组有没有解？<br>　　(2).如果这个方程组有解，有多少个解？<br>　　(3).在方程组有解时,解之间的关系,并求出全部解。<br>　　本节讨论方程的个数与未知量的个数相等(即)的情形。</p><p>二、克莱姆法则</p><p>　　定理1（克莱姆法则）如果线性方程组<br>　　　　　 ???????????（2）<br>的系数行列式：<br>　　　　<br>那么这个方程组有解，并且解是唯一的，这个解可表示成：<br>　　　　　　　　（3）<br>其中是把中第列换成常数项所得的行列式，即<br>　　　　。<br>　　分析：定理一共有3个结论：方程组有解；解是唯一的；解由公式（3）给出。因此证明的步骤是：<br>　　第一，把 代入方程组，验证它确实是解。这样就证明了方程组有解，并且（3）是一个解，即证明了结论与。<br>　　第二，证明如果是方程组（２）的一个解，那么一定有。这就证明了解的唯一性，即证明了结论。<br>　　证明：先回忆行列式的一个性质，设阶行列式，则有：<br>　<br>接下来证明定理。首先，证明（3）确实是（2）的解。将行列式按第列展开得：<br>　　　　，<br>其中是行列式中元素的代数余子式。现把<br>代入第个方程的左端，得：</p><p>这说明将（3）代入第个方程后，得到了一个恒等式，所以（3）是（2）的一个解。<br>　　其次，设是方程组（2）的一个解，那么，将代入（2）后，得到个恒等式：<br>　　　　　　　　　　（4）<br>用系数行列式的第列的代数余子式依次去乘（4）中个恒等式，得到：<br>　　　　<br>将此个等式相加，得：</p><p>从而有：。这就是说，如果是方程组（2）的一个解，那么一定有，所以方程组只有一个解。</p><p>三、齐次线性方程组<br>　　在线性方程组中，有一种特殊的线性方程组，即常数项全为零的方程组，称为齐次线性方程组。显然，齐次线性方程组总是有解的，因为就是它的解，这个解称为零解；其他的，即不全为零的解（如果还有的话），称为非零解。所以，对于齐次线性方程组，需要讨论的问题，不是有没有解，而是有没有非零解。这个问题与齐次线性方程组解的个数是有密切关系的。如果一个齐次线性方程组只有零解，那么这个方程组就只有唯一解；反之， 如果某个齐次线性方程组有唯一解， 那么由于零解是一个解，所以这个方程组不可能有非零解。<br>　　对于方程个数与未知量个数相同的齐次线性方程组，应用克莱姆法则，有<br>　　推论1? 如果齐次线性方程组<br>　　　　　　　　（5）<br>的系数行列式不等于零，那么（5）只有零解。<br>　　推论2　齐次线性方程组<br>　　　　<br>有非零解的必要条件是它的系数行列式等于零。</p><p>四、例子<br>　　例1　解线性方程组<br>　　　　<br>　　解：方程组的系数行列式：<br>　　　　<br>所以根据克莱姆法则，这个线性方程组有唯一解。又因<br>　<br>　<br>所以这个线性方程组的唯一解为：<br>　　　　<br>　　例2　解线性方程组<br>　　　　<br>　　解：方程组的系数行列式：<br>　　　　<br>所以根据克莱姆法则，这个线性方程组有唯一解。又因<br>　　　<br>　　　<br>所以这个线性方和组的唯一解为：<br>　　　　<br>　　例3???????? 已知三次曲线在四个点处的值分别为：，试求其系数。<br>　　解：将三次曲线在4点处的值代入其方程，得到关于的线性方程组：<br>　　　　<br>它的系数行列式是范德蒙行列式：<br>　　　　<br>所以根据克莱姆法则，这个线性方程组有唯一解。又因<br>　　　<br>　　　<br>所以，即所求的三次曲线方程为。<br>　　例4　如果齐次线性方程组<br>　　　　<br>有非零解，那么必须满足什么条件？<br>　　解：由克莱姆法则知，齐次线性方程组有非零解的必要条件是其系数行列式等于零，因此有<br>　　　　<br>又由：，从而必须满足的条件为。<br>　　注　用克莱姆法则求解系数行列式不等于零的元非齐次线性方程组，需要计算个阶行列式，它的计算工作量很大。实际上关于数字系数的线性方程组（包括系数行列式等于零及方程个数和未知量个数不相同的线性方程组）的解法，一般都采用后续章节介绍的方法来求解。克莱姆法则主要是在理论上具有重要的意义，特别是它明确地揭示了方程组的解和系数之间的关系。 </p>]]></content>
      
      
      
        <tags>
            
            <tag> DirectX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图</title>
      <link href="/2019/03/23/map/"/>
      <url>/2019/03/23/map/</url>
      
        <content type="html"><![CDATA[<p>图看起来就像下图这样：</p><img src="/2019/03/23/map/1.png"><p>一个图就是一些顶点的集合，这些顶点通过边连接。<br>顶点用圆圈表示，边就是这些圆圈之间的连线。顶点之间通过边连接。</p><p>注意：顶点有时也被称为节点或者交点，边有时也称为链接。<br>图有两种表示方法：邻接列表和邻接矩阵。<br><strong>邻接列表</strong>：在邻接列表实现中，每一个顶点会存储一个从它这里开始的边的列表。比如，如果顶点A有一条边到B、C和D，那么A的列表中会有3条边</p><img src="/2019/03/23/map/2.webp"><img src="/2019/03/23/map/3.webp"><p>邻接列表只描述了指向外部的边。A有一条边到B，但是B没有边到A，所以A没有出现在B的邻接列表中。查找两个顶点之间的边或者权重会比较费时，因为遍历邻接列表知道找到为止。</p><p><strong>邻接矩阵</strong>：在邻接矩阵实现中，由行和列都表示顶点，由两个顶点所决定的矩阵对应元素表示这里两个顶点是否相连、如果相连这个值表示的是相连边的权重。例如，如果从顶点A到顶点B有一条权重为5.6的边，那么矩阵中第A行第B列的位置的元素值应该是5.6：<br><img src="/2019/03/23/map/4.webp"><img src="/2019/03/23/map/5.webp"><br>往这个图中添加顶点的成本非常昂贵，因为新的矩阵结果必须重新按照新的行/列创建，然后将已有的数据复制到新的矩阵中。<br>所以使用哪一个呢？大多数的时候，选择邻接列表是正确的。下面是两种方法更详细的的比较。<br>假设V表示图中的顶点的个数，E表示边的个数。</p><div class="table-container"><table><thead><tr><th>操作</th><th>邻接列表</th><th>邻接矩阵</th></tr></thead><tbody><tr><td>存储空间</td><td>O(V+E)</td><td>O(V^2)</td></tr><tr><td>添加顶点</td><td>O(1)</td><td>O(V^2)</td></tr><tr><td>添加边</td><td>O(1)</td><td>O(1)</td></tr><tr><td>检查相邻行</td><td>O(V)</td><td>O(1)</td></tr></tbody></table></div><p>“检查相邻性”是指对于给定的顶点，尝试确定它是否是另一个顶点的邻居。在邻接列表中检查相邻性的时间复杂度是O(V)，因为最坏的轻快是一个顶点与每一个顶点都相连。</p><p>在稀疏图的情况下，每一个顶点都只会和少数几个顶点相连，这种情况下相邻列表是最佳选择。如果这个图比较密集，每一个顶点都和大多数其他顶点相连，那么相邻矩阵更合适。</p><p>图可分为有向图和无向图。有向图的所有边都有方向，即确定了顶点到顶点的一个指向；而无向图的所有边都是双向的，即无向边所连接的两个顶点可以互相到达。顶点的度是指和该顶点相连的边的条数。特别是对于有向图来说，顶点的出边条数成为该顶点的出度，顶点的入边条数成为该顶点的入度。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android开发入门</title>
      <link href="/2019/03/23/android-GettingStarted/"/>
      <url>/2019/03/23/android-GettingStarted/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AssetBundles 工作流程</title>
      <link href="/2019/03/22/AssetBundles-Workflow/"/>
      <url>/2019/03/22/AssetBundles-Workflow/</url>
      
        <content type="html"><![CDATA[<h1 id="AssetBundle工作流程"><a href="#AssetBundle工作流程" class="headerlink" title="AssetBundle工作流程"></a>AssetBundle工作流程</h1><p>要开始使用AssetBundles，请按照以下步骤操作。有关每个工作流程的更多详细信息，请参阅本文的其他页面。</p><h2 id="将资产分配给AssetBundles"><a href="#将资产分配给AssetBundles" class="headerlink" title="将资产分配给AssetBundles"></a>将资产分配给AssetBundles</h2><p>分配给定资产Assetbundle的，请按照下列步骤操作：</p><ol><li>从项目视图中选择要分配给捆绑包的资产</li><li>检查检查器中的对象</li><li>在检查器的底部，您应该看到一个分配AssetBundles和Variants的部分</li><li>左侧下拉分配AssetBundle，而右侧下拉分配变量</li><li>单击左侧下拉列表，显示”无”，以显示当前已注册的AssetBundle名称</li><li>单击”新建…”以创建新的AssetBundle</li><li>输入所需的AssetBundle名称。请注意，AssetBundle名称确实支持一种文件夹结构，具体取决于您键入的内容。要添加子文件夹，请用”/“分割文件夹名称。例如：AssetBundle名称”environment/forest”将在环境子文件夹下创建名forest的包</li><li>一旦选择或创建了AssetBundle名称，您可以重复此过程以右手下拉以分配或创建变体名称（如果需要）。构建AssetBundle不需要变体名称</li></ol><h1 id="构建AssetBundles"><a href="#构建AssetBundles" class="headerlink" title="构建AssetBundles"></a>构建AssetBundles</h1><p>在Asset文件夹中创建一个名为Editor的文件夹，并将包含以下内容的脚本放在该文件夹中：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CreateAssetBundles</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">MenuItem(<span class="meta-string">"Assets/Build AssetBundles"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BuildAllAssetBundles</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Directory.Exists(Application.streamingAssetsPath))</span><br><span class="line">        &#123;</span><br><span class="line">            Directory.CreateDirectory(Application.streamingAssetsPath);</span><br><span class="line">        &#125;</span><br><span class="line">        BuildPipeline.BuildAssetBundles(Application.streamingAssetsPath, BuildAssetBundleOptions.None, BuildTarget.Android);</span><br><span class="line">        AssetDatabase.Refresh();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此脚本将在Assets菜单底部创建一个名为”Build AssetBundles”的菜单项，该菜单项将执行与该标记关联的函数中的代码。单击”Build AssetBundles”时，将显示一个带有构建对话框的进度条。这将获取您使用AssetBundle名称标记的所有资产，并将它们放在assetBundleDirectory定义的路径中的文件夹中。</p><h1 id="将AssetBundles上传到场外存储"><a href="#将AssetBundles上传到场外存储" class="headerlink" title="将AssetBundles上传到场外存储"></a>将AssetBundles上传到场外存储</h1><p>此步骤对每个用户都是唯一的，而不是Unity可以告诉您如何操作的步骤。如果您打算将AssetBundles上传到第三方托管网站，请在此执行此操作。如果您正在进行严格的本地开发并打算将所有AssetBundle都放在磁盘上，请跳到下一步。</p><h1 id="加载AssetBundle和Assets"><a href="#加载AssetBundle和Assets" class="headerlink" title="加载AssetBundle和Assets"></a>加载AssetBundle和Assets</h1><p>对于打算从本地存储加载的用户，您将对AssetBundles.LoadFromFile API感兴趣。如下：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LoadFromFileExample</span> : <span class="title">MonoBehaviour</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> myLoaderAssetBundle = AssetBundle.LoadFromFile(Path.Combine(Application.streamingAssetsPath, <span class="string">"myassetBundle"</span>));</span><br><span class="line">        <span class="keyword">if</span> (myLoaderAssetBundle == <span class="literal">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">"Failed to load AssetBundle!"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> prefab = myLoaderAssetBundle.LoadAsset&lt;GameObject&gt;(<span class="string">"MyObject"</span>);</span><br><span class="line">        Instantiate(prefab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>LoadFromFile 获取bundle文件的路径。<br>如果您自己托管AssetBundles并需要将它们下载到游戏中，您将对UnityWebRequest API感兴趣。这是一个例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">InstantiateObject</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> uri = <span class="string">"file:///"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Unity-2018-3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity AssetBundles </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity 文件路径</title>
      <link href="/2019/03/22/Unity-Path/"/>
      <url>/2019/03/22/Unity-Path/</url>
      
        <content type="html"><![CDATA[<ol><li>Resources<br>Resources文件夹是Unity里自动识别的一种文件夹，可在Unity编辑器的Project窗口创建，并将资源放置在里面。Resources文件夹下的资源不管是否有用，全部会打包进.apk或者.ipa，并且打包时会将里面的资源压缩处理。加载方法是Resources.Load<t>(文件名)，需要注意：文件名不包括扩展名，打包后不能更改Resources下的资源内容，但是从Resources文件夹中加载出来的资源可以更改。</t></li><li>Application.dataPath<br>这个属性返回的是程序的数据文件所在的文件夹，例如在Editor中就是项目的Assets文件夹的路径，通过这个路径可以访问项目中任何文件夹中的资源，但是在移动端它是完全没用。</li><li>Application.streamingAssetsPath<br>这个属性用于返回流数据的缓存目录，返回路径为相对路径，适合设置一些外部数据文件的路径。在Unity工程的Assets目录下起一个名为”StreamingAssets”的文件夹即可，然后用Application.streamingAssetsPath访问，这个文件夹中的资源在打包时会原封不动的打包进去，不会压缩，一般放置一些资源数据。在PC/MAC中可实现对文件的“增删改查”等操作，但在移动端是一个只读路径。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最短路径算法简介（Dijkstra算法，A*算法，D*算法）</title>
      <link href="/2019/03/21/Nav/"/>
      <url>/2019/03/21/Nav/</url>
      
        <content type="html"><![CDATA[<p>最短路径计算分静态最短计算和动态最短路径计算。<br>静态最短路径算法是外界环境不变，计算最短路径。主要有Dijkstra算法，A<em>（A Star）算法。<br>动态最短路径算法是外界环境不断发生变化，即不能计算预测的情况下计算最短路径。如在游戏中敌人或障碍物不断移动的情况下。典型的有D</em>算法。</p><img src="/2019/03/21/Nav/1.jpg"><p>这是Drew程序实现的10000个节点的随机路网三条互不相交最短路径</p><img src="/2019/03/21/Nav/dijkstra_astar_dstar_introduce_2.jpg"><p><strong>真实路网计算K条路径示例</strong>：节点5696到节点3006，三条最快路径，可以看出路径基本上走环线或主干路。黑线为第一条，蓝线为第二条，红线为第三条。约束条件系数为1.2。共享部分路段。</p><h1 id="Dijkstra算法求最短路径"><a href="#Dijkstra算法求最短路径" class="headerlink" title="Dijkstra算法求最短路径"></a>Dijkstra算法求最短路径</h1><p>Dijkstra算法是典型的最短路径算法，用于计算一个节点到其他所有节点的最短路径。主要特点是起始点为中心向外层层层扩展，直到扩展到终点位置。Dijkstra算法能得出最短路径的最优解，但由于它遍历计算的节点很多，所以效率低。</p><p>Dijkstra算法是很有代表性的最短路径算法。</p><p>Dijkstra一般的表述通常有两种方式，一种用永久和临时标号方式，一种是用OPEN，CLOSE表方式，Drew为了和下面要介绍的A<em>算法和D</em>算法表述一致，这里均采用OPEN，CLOSE表的方式。</p><p>大概过程：<br>创建两个表，OPEN，CLOSE。</p><ol><li>访问路网中里起始点最近且没有被检查过的点，把这个点放入OPEN组中等待检查。</li><li>从OPEN表中找出距离起始点最近的点，找出这个点的所有子节点，把这个点放到CLOSE表中。</li><li>遍历考察这个点的子节点。求出这些子节点距离起起始点的距离值，放子节点到OPEN表中。</li><li>重复2、3步。直到OPEN表为空，或找到目标点。</li></ol><h1 id="动态路由，最短路径算法D"><a href="#动态路由，最短路径算法D" class="headerlink" title="动态路由，最短路径算法D*"></a>动态路由，最短路径算法D*</h1><ol><li>先用Dijstra算法从目标节点G向起始节点搜索。存储路网中目标点到各个节点的最短路和该位置到目标点的实际值h,k（k为所有变化h之中最小的值，当前为k=h。每个节点包含上一节到目标点的最短路信息1（2），2（5），5（4））</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>nginx</title>
      <link href="/2019/03/15/nginx/"/>
      <url>/2019/03/15/nginx/</url>
      
        <content type="html"><![CDATA[<p>启动</p><pre><code>/usr/sbin/nginx -c /etc/nginx/nginx.conf</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>IL2CPP</title>
      <link href="/2019/03/13/L2CPP/"/>
      <url>/2019/03/13/L2CPP/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是IL2CPP"><a href="#什么是IL2CPP" class="headerlink" title="什么是IL2CPP"></a>什么是IL2CPP</h1><p>从技术层面上来说，IL2CPP包含两个部分：一个进行预先编译（ahead-of-time，又叫AOT）的编译器；一个支持虚拟机的运行时库。</p><h2 id="AOT编译器"><a href="#AOT编译器" class="headerlink" title="AOT编译器"></a>AOT编译器</h2><p>IL2CPP AOT编译器实际的执行文件是il2cpp.ext。在Windows平台你可以在Unity安装路径的Editor\Data\il2cpp目录下找到。il2cpp.exe这个工具是一个托管代码可执行文件，其完全由C#编码。在开发IL2CPP的过程中，我们同时使用.NET和Mono编译器对其进行编译。</p><p>il2cpp接受来自Unity自带的或者由Mono编译器产生的托管程序集，将这些程序集转换成C++代码。这些转化出的C++代码最终由部署目标平台的C++编译器进行编译。</p><p>你可以参照下图理解IL2CPP工具链的作用：<br><img src="/2019/03/13/L2CPP/1.webp"></p><h2 id="运行时库"><a href="#运行时库" class="headerlink" title="运行时库"></a>运行时库</h2><p>IL2CPP的另外一个部分就是对虚拟机提供支持的运行时库。我们基本上是用C++代码来实现整个运行时库的（其实里面还是有一些和平台相关的代码使用了程序集）。我们把运行时库称之为libli2cpp，它是作为一个静态库被连接到最终的游戏可行性文件中。这么做的一个主要的好处是可以使得整个IL2CPP技术是简单并且是可移植的。</p><p>AOT编译器将由.Net输出的中间语言IL代码生成C++代码。运行时库则提供诸如垃圾回收，与平台无关的线程，IO以及内部调用（C++原生代码直接访问托管代码结构）这样的服务层和抽象层。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学</title>
      <link href="/2019/03/13/graphics/"/>
      <url>/2019/03/13/graphics/</url>
      
        <content type="html"><![CDATA[<h1 id="向量积"><a href="#向量积" class="headerlink" title="向量积"></a>向量积</h1><p>模长：（在这里$\theta$表示两向量之间的夹角（共起点的前提下）（$0^。\le \theta \le 180^。$），它位于这两个矢量所定义的平面上。）</p><p>$|\vec a \times \vec b| = |\vec a| \cdot |\vec b| \cdot sin\theta$ </p><p>方向：a向量与b向量的向量积的方向与这两个向量所在平面垂直，且遵守右手定则。（一个简单的确定满足“右手定则”的结果向量的方向的方法是这样的：若坐标系是满足右手定则的，当右手的四指从a以不超过180度的转角转向b时，竖起的大拇指指向的方向就是c的方向。）</p><h1 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h1><p>把刑辱z=a+bi（a，b均为实数）的数成为复数，其中a称为实部，b称为虚部，i称为<strong>虚数</strong>单位。当虚部等于零时，这个复数可以视为实数；当z的虚部不等于零时，实部等于零时，常称z为纯虚数。</p><p>数集扩展到实数范围内，仍有些运算无法进行（比如对复数开偶数次方），为了使方程有解，我们将数集再次扩充。<br>在实数域上定义二元有序对z=(a,b)，并规定有序对之间有运算”+”、”x”(记$z_{1}=(a,b),z){2}=(c,d)$):<br>$z_{1}+z_{2}=(a+c,b+d)$<br>$z_{1} \times z_{2}=(ac-db,bc+ad)$</p><h1 id="四元数"><a href="#四元数" class="headerlink" title="四元数"></a>四元数</h1><p>四元数是简单的超复数。复数是由实数加上虚数单位i组成，其中i^2=-1。相似地，四元数都是由实数加上三个虚数单位i、j、k组成，而且它们有如下的关系：i^2=j^2=k^2=-1，i^0=j^0=k^0=1，每个四元数都是1、i、j和k的线性组合，既是四元数一般可表示为a+bi+cj+dk，其中a、b、c、d是实数。</p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Light Reflect</title>
      <link href="/2019/03/12/Light-Reflect/"/>
      <url>/2019/03/12/Light-Reflect/</url>
      
        <content type="html"><![CDATA[<p>假设我们有一个发着光的太阳，太阳底下有一个“理想镜面”，如下图：<br><img src="/2019/03/12/Light-Reflect/1.png"><br>这时候我们抽象成数学图来进行计算，如下图：<br><img src="/2019/03/12/Light-Reflect/2.png"><br>这幅图可以看出，我们计算反射光线OB，则转换成了计算OP，这里OP是AO在法向量N上的投影，接下来我们推导投影向量的计算，如下图：<br><img src="/2019/03/12/Light-Reflect/3.png"><br>我们根据点积计算出$cos\theta$，然后通过$OA’ = |OA| \cdot cos\theta \cdot n$(n是单位法向量)就能得到，向量的投影公式。<br>这个时候我们在回过头来推导$OB = AO + 2OP$的结果，如下图：<br><img src="/2019/03/12/Light-Reflect/4.png"></p>]]></content>
      
      
      <categories>
          
          <category> Unity Shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shader用到的三角函数</title>
      <link href="/2019/03/09/trigonometric-function/"/>
      <url>/2019/03/09/trigonometric-function/</url>
      
        <content type="html"><![CDATA[<ol><li>正弦、余弦、正切<img src="/2019/03/09/trigonometric-function/2.jpg" title="This is an example image"></li><li>正弦、余弦曲线<img src="/2019/03/09/trigonometric-function/3.jpg" title="This is an example image">正弦曲线公式可表示为$y = Asin({\omega}x+\phi)+k$<br>A：振幅，最高和最低的距离（shader中理解为离圆心最近和最远的距离）<br>W：角速度，用于控制周期（shader中理解为圈数）<br>K：偏距，曲线整体上下偏移量（shader中理解为多边形整体大小）</li><li>余弦（正弦）曲线和圆的基本关系<img src="/2019/03/09/trigonometric-function/1.jpg" title="This is an example image">根据余弦（或正弦）曲线与园的基本关系。<br>${\omega}t={\omega}x=角度$</li></ol>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> Unity Shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MathJax</title>
      <link href="/2019/03/09/MathJax/"/>
      <url>/2019/03/09/MathJax/</url>
      
        <content type="html"><![CDATA[<h1 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h1><div class="table-container"><table><thead><tr><th>显示</th><th>命令</th><th>显示</th><th>命令</th></tr></thead><tbody><tr><td>$\alpha$</td><td>\alpha</td><td>$\beta$</td><td>\beta</td></tr><tr><td>$\gamma$</td><td>\gamma</td><td>$\delta$</td><td>\delta</td></tr><tr><td>$\epsilon$</td><td>\epsilon</td><td>$\zeta$</td><td>\zeta</td></tr><tr><td>$\eta$</td><td>\eta</td><td>$\theta$</td><td>\theta</td></tr><tr><td>$\upsilon$</td><td>\upsilon</td><td>$\phi$</td><td>\phi</td></tr><tr><td>$\omega$</td><td>\omega</td><td>$\Omega$</td><td>\Omega</td></tr></tbody></table></div><ul><li>若需要大写希腊字母，将命令首字母大写即可。 \Omega 呈现为 $\Omega$</li><li>需需要斜体希腊字母，将命令前面加上var。\varpi 呈现为 $\varPi$</li></ul><h1 id="字母修饰"><a href="#字母修饰" class="headerlink" title="字母修饰"></a>字母修饰</h1><h1 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h1><ul><li>上标：^</li><li>下标：_</li><li>举例：c_n^2呈现为$c_n^2$</li></ul><h1 id="分数"><a href="#分数" class="headerlink" title="分数"></a>分数</h1><p>有两种方法来显示分数，一种是 \frac a b 显示$\frac a b$，另一种是用\over，如{a+1 \over b+1}显示${a+1 \over b+1}$</p><h1 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h1><p>\int<br>    \int_0^\infty{fxdx} 呈现为$\int_0^\infty{fxdx}$</p><h1 id="特殊符号和记号"><a href="#特殊符号和记号" class="headerlink" title="特殊符号和记号"></a>特殊符号和记号</h1><ul><li>\lt \gt \le \ge \neq 表示 $\lt \gt \le \ge \neq$，还可以在不等号上加\not，如\not\lt 表示 $\not\lt$</li><li>\times \div \pm \mp 表示 $\times \div \pm \mp$，点乘用\cdot表示，如 x \cdot y 表示 $x \cdot y$</li></ul><h1 id="矢量"><a href="#矢量" class="headerlink" title="矢量"></a>矢量</h1><p>\vec{a} \cdot \vec{b} = 0 显示 $\vec{a} \cdot \vec{b} = 0$</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity Shader:优化GPU代码，用step()代替if sele等条件语句</title>
      <link href="/2019/03/09/US-Step/"/>
      <url>/2019/03/09/US-Step/</url>
      
        <content type="html"><![CDATA[<h1 id="普通的卡通着色Shader"><a href="#普通的卡通着色Shader" class="headerlink" title="普通的卡通着色Shader"></a>普通的卡通着色Shader</h1><p>先看一个Shader，卡通着色。由于卡通着色需要对不同渲染区域进行判定，比较适合做案例。</p>]]></content>
      
      
      <categories>
          
          <category> Unity Shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity Avatar</title>
      <link href="/2019/03/08/Unity-Avatar/"/>
      <url>/2019/03/08/Unity-Avatar/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity Reflection</title>
      <link href="/2019/03/06/Unity-Reflection/"/>
      <url>/2019/03/06/Unity-Reflection/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>反射是.NET中的重要机制，通过反射，可以在运行时获得程序或者程序集中每一个类型（包括类、结构、委托、接口和枚举等）的成员和成员的信息。另外还可以直接创建对象，即使这个对象的类型在编译时还不知道。</p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><ul><li>使用Assembly定义和加载程序集，加载在程序集清单中列出模块，从此程序集中查找类型并创建并创建该类型的实例。</li><li>使用Module了解包含模块的程序集以及模块中的类等，还可以获取在模块上定义的所有全局方法或其他特定的非全局方法。</li><li>使用ConstructorInfo了解构造函数的名称，参数，访问修饰符（如public或private）和实现详细信息（如abstract或virtual）等。</li><li>使用MethodInfo了解方法的名称，返回类型，参数，访问修饰符（如public或private）和实现详细信息（如abstract或virtual）等。</li><li>使用FieldInfo了解字段的名称、访问修饰符（如public或private）和实现相信信息（如static）等，并获取或设置字段值。</li><li>使用EventInfo了解事件的名称、事件处理程序数据类型、自定义属性、声明类型和反射类型等，添加或移除事件处理程序。</li><li>使用PropertyInfo了解属性的名称、数据类型、声明类型、反射类型和只读或可写状态等，获取或设置属性值。</li><li>使用ParameterInfo了解参数的名称、数据类型、是输入参数还是输出参数，以及参数在方法签名中的位置等。</li></ul><h2 id="需要的namespace"><a href="#需要的namespace" class="headerlink" title="需要的namespace"></a>需要的namespace</h2><pre><code>System.Reflection;System.Type;System.Reflection.Assembly;</code></pre><h2 id="主要类"><a href="#主要类" class="headerlink" title="主要类"></a>主要类</h2><pre><code>System.Type // 通过这个类可以访问任何给定数据类型的信息System.Reflection.Assembly; // 访问或者加载程序集的信息</code></pre><h3 id="System-Type"><a href="#System-Type" class="headerlink" title="System.Type"></a>System.Type</h3><p>System.Type类对于反射起着核心的作用。它是一个抽象的基类，Type有与每种数据类型对应的派生类。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 属性</span></span><br><span class="line"><span class="keyword">string</span>  Name &#123;<span class="keyword">get</span>;&#125;           <span class="comment">// 数据类型名</span></span><br><span class="line"><span class="keyword">string</span>  FullName &#123;<span class="keyword">get</span>;&#125;       <span class="comment">// 数据类型的完全限定名（包括命名空间）</span></span><br><span class="line"><span class="keyword">string</span>  Namespace;      <span class="comment">// 命名空间名</span></span><br><span class="line"><span class="keyword">bool</span>    IsAbstract;     <span class="comment">// 是否抽象</span></span><br><span class="line"><span class="keyword">bool</span>    IsArray;        <span class="comment">// 是否数组</span></span><br><span class="line"><span class="keyword">bool</span>    IsClass;        <span class="comment">// 是否类</span></span><br><span class="line"><span class="keyword">bool</span>    IsEnum;         <span class="comment">// 是否枚举</span></span><br><span class="line"><span class="keyword">bool</span>    IsInterface;    <span class="comment">// 是否接口</span></span><br><span class="line"><span class="keyword">bool</span>    IsPublic;       <span class="comment">// 是否是公有的类型</span></span><br><span class="line"><span class="keyword">bool</span>    IsSealed;       <span class="comment">// 是否是密封类</span></span><br><span class="line"><span class="keyword">bool</span>    IsValueType;    <span class="comment">// 是否是指类型</span></span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line"><span class="comment">// 用于取得该类的构造函数的信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConstructorInfo <span class="title">GetConstructor</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="comment">// 同上</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConstructorInfo[] <span class="title">GetConstructors</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="comment">// 取得该类的事件信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EventInfo <span class="title">GetEvent</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> EventInfo[] <span class="title">GetEvents</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> FieldInfo <span class="title">GetField</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> FieldInfo[] <span class="title">GetFields</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> InterfaceInfo <span class="title">GetInterFace</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> InterfaceInfo[] <span class="title">GetInterFaces</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> MemberInfo <span class="title">GetMember</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> MemberInfos <span class="title">GetMembers</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> PropertyInfo <span class="title">GetProperty</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> PropertyInfo[] <span class="title">GetProperties</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="comment">// 调用上述成员，方式是调用Type的InvokeMember()方法，或者调用MethodInfo，PropertyInfo的Invoke方法</span></span><br></pre></td></tr></table></figure></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看类的构造方法</span></span><br><span class="line">NewClass nc = <span class="keyword">new</span> NewClass();</span><br><span class="line">Type t = nc.GetType();</span><br><span class="line">ConstructorInfo[] ci = t.GetConstructors(); <span class="comment">// 获取类的所有构造函数</span></span><br><span class="line"><span class="keyword">foreach</span> (ConstructorInfo c <span class="keyword">in</span> ci)</span><br><span class="line">&#123;</span><br><span class="line">    ParamterInfo[] ps = c.GetParameters();</span><br><span class="line">    <span class="keyword">foreach</span> (ParamterInfo pi <span class="keyword">in</span> ps)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">"&#123;0&#125;\t&#123;1&#125;"</span>, pi.ParamterType.ToString(), pi.Name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用构造函数动态生成对象</span></span><br><span class="line">Type t = <span class="keyword">typeof</span>(NewClass);</span><br><span class="line">Type[] pt = <span class="keyword">new</span> Type[<span class="number">2</span>];</span><br><span class="line">pt[<span class="number">0</span>] = <span class="keyword">typeof</span>(<span class="keyword">string</span>);</span><br><span class="line">pt[<span class="number">1</span>] = <span class="keyword">typeof</span>(<span class="keyword">string</span>);</span><br><span class="line"><span class="comment">// 根据参数类型获取构造函数</span></span><br><span class="line">ConstructorInfo ci = t.GetConstructor(pt);</span><br><span class="line"><span class="comment">// 构造Object数组，作为构造函数的输入参数</span></span><br><span class="line"><span class="keyword">object</span>[] obj = <span class="keyword">new</span> <span class="keyword">object</span>[<span class="number">2</span>]&#123;<span class="string">"Liyanfeng"</span>, <span class="string">"Hello World"</span>&#125;;</span><br><span class="line"><span class="comment">// 调用构造函数生成对象</span></span><br><span class="line"><span class="keyword">object</span> o = ci.Invoke(obj);</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用Activator生成对象</span></span><br><span class="line">Type t = <span class="keyword">typeof</span>(NewClass);</span><br><span class="line"><span class="comment">// 用Activator的CreateInstance静态方法，生成新对象</span></span><br><span class="line"><span class="keyword">object</span> o = Activator.CreateInstance(t, <span class="string">"Liyanfeng"</span>, <span class="string">"Hello World"</span>);</span><br></pre></td></tr></table></figure><h3 id="获取给定类型的Type引用有3中常用方式"><a href="#获取给定类型的Type引用有3中常用方式" class="headerlink" title="获取给定类型的Type引用有3中常用方式"></a>获取给定类型的Type引用有3中常用方式</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用typeof运算啊</span></span><br><span class="line">Type t = <span class="keyword">typeof</span>(<span class="keyword">string</span>);</span><br><span class="line"><span class="comment">// 使用对象GetType()方法</span></span><br><span class="line"><span class="keyword">string</span> s = <span class="string">"Liyanfeng"</span>;</span><br><span class="line">Type t = s.GetType();</span><br><span class="line"><span class="comment">// 调用Type类的静态方法GetType()</span></span><br><span class="line">Type t = Type.GetType(<span class="string">"System.String"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(MemberInfo mi <span class="keyword">in</span> t.GetMembers())</span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(<span class="string">"&#123;0&#125;/t&#123;1&#125;"</span>, mi.MemberType, mi.Name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形渲染及优化-Batch</title>
      <link href="/2019/03/05/Batch/"/>
      <url>/2019/03/05/Batch/</url>
      
        <content type="html"><![CDATA[<p>批处理（Batch）就是对某对象进行批量的处理，本文介绍一下Batch的基本概念、</p>]]></content>
      
      
      
        <tags>
            
            <tag> 图形 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C# Job System</title>
      <link href="/2019/03/05/CsharpJobSystem/"/>
      <url>/2019/03/05/CsharpJobSystem/</url>
      
        <content type="html"><![CDATA[<p>Unity C＃ Job System允许用户编写与Unity其余部分良好交互的多线程代码，并使编写正确的代码变得更加容易。<br>编写多线程代码可以提供高性能的好处。其中包括显着提高帧速率和延长移动设备的电池寿命。<br>C＃ Job System的一个重要方面是它与Unity内部使用的集成（Unity的native jobsystem）。用户编写的代码和Unity共享工作线程。这种合作避免了导致争用CPU资源的问题，并且可以创建比CPU核心更多的线程。</p><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>在单线程计算机系统中，一次只能进入一条指令，并且只能得出一个结果。加载和完成程序的时间取决于CPU需要完成的工作量。<br>多线程是一种编程，它利用CPU在多个内核上同时处理多个线程的能力，它不是一个接一个地执行任务或指令，而是同时运行的。<br>默认情况下，一个线程在程序的开头运行。这是“主线程”。主线程创建新线程来处理任务。这些新线程彼此并行运行，并且通常在完成后将其结果与主线程同步。<br>如果您有一些运行很长时间的任务，这种多线程方法很有效。但是，游戏开发代码通常包含许多一次执行的小指令。如果为每个小指令创建一个线程，最终可能会有许多线程，每个线程的生命周期都很短。这可以推动CPU和操作系统处理能力的极限。<br>通过拥有一个线程池可以缓解线程生存期的问题。但是，即使您使用线程池，也可能同时激活大量线程。线程数多于CPU核心导致线程相互争用CPU资源，导致频繁的上下文切换。上下文切换是通过执行保存线程状态的过程，然后处理另一个线程，然后重新构建第一个线程，以便继续处理它。上下文切换是资源密集型的，因此您应尽可能避免使用它。</p><h1 id="Job-System"><a href="#Job-System" class="headerlink" title="Job System"></a>Job System</h1><p>Job System通过创建Job而不是线程来管理多线程代码。<br>Job System跨多个核心管理一组工作线程。它通常每个逻辑CPU核心有一个工作线程，以避免上下文切换（尽管它可能为操作系统或其他专用应用程序保留一些核心）。<br>Job System将Job放入作业队列中用来执行。Job System中的工作线程从作业队列中获取Job并执行它们。作业系统管理依赖关系并确保作业以适当的顺序执行。</p><h2 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h2><p>Job是完成一项特定任务的一小部分工作。Job接收参数并对数据进行操作，类似于方法调用的行为方式。Job可以是独立的，也可以是依赖的（需要等其他作业完成后，然后才能运行。）</p><h2 id="Job-依赖"><a href="#Job-依赖" class="headerlink" title="Job 依赖"></a>Job 依赖</h2><p>在复杂的系统中，如游戏开发所需的系统，每个工作都不可能是独立的。一项工作通常是为下一份工作准备数据。作业了解并支持依赖关系以使其发挥作用。如果jobA对jobB依赖，则Job System确保在完成jobA之前不会开始执行jobB。</p><h1 id="安全系统"><a href="#安全系统" class="headerlink" title="安全系统"></a>安全系统</h1><p>编写多线程代码时，总是存在竞争条件的风险。当一个操作的输出取决于其控制之外的另一个过程的时间的时候，就会发生竞争条件。<br>竞争条件并不总是一个bug，但是它不确定行为的来源，当竞争条件导致bug的时候，总是比较难以找到问题的根源。因为它取决于时间，因此你可能极少数情况下会复现问题。调试的时候可能会导致问题消失。因此调试和日志可能会改变bug的发生条件。竞争条件是编写多线程的时候面临的比较大的挑战。</p><p>为了更容易编写多线程代码，Job System可以检测所有潜在的竞争条件，并保护你免受可能导致的bug的影响。<br>例如：如果Job System将主线程中代码中的数据引用发送到Job中，则无法验证作业在写入数据的时候同时读取数据，这种情况就会创建竞争条件。</p><p>Job System通过向每个作业发送它需要的操作的数据的副本来解决这个问题，而不是对主线程中的数据的引用，这种拷贝隔离了数据，从而消除了竞争条件。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UnityHub破解</title>
      <link href="/2019/03/03/Unity-Hub/"/>
      <url>/2019/03/03/Unity-Hub/</url>
      
        <content type="html"><![CDATA[<p>退出UnityHub</p><pre><code>npm install -g asarcd C:\Program Files\Unity Hub\resourcesasar extract .\app.aser apprm -rf app.asarcd app/src/services/licenseServicevim licenseClient.js</code></pre><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getLicenseInfo<span class="params">(callback)</span>&#123;</span><br><span class="line">    <span class="string">//</span> load license</span><br><span class="line">    <span class="string">//</span> get latest data from licenseCore</span><br><span class="line">    <span class="string">//licenseInfo.activated</span> = licenseCore.getLicenseToken<span class="params">()</span><span class="string">.length</span> &gt; 0; <span class="string">//</span> 注释这行</span><br><span class="line">    licenseInfo.activated = <span class="literal">true</span>; <span class="string">//</span> 新增这行</span><br><span class="line">    licenseInfo.flow = licenseCore.getLicenseKind<span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>vim licenseCore.js</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">verifyLicenseData(xml)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span></span><br><span class="line">        resolve(<span class="literal">true</span>); <span class="comment">//新增这行</span></span><br><span class="line">        <span class="keyword">if</span> (xml === <span class="string">''</span>)&#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO多路复用之select、poll、epoll详解</title>
      <link href="/2019/03/02/NetSocket/"/>
      <url>/2019/03/02/NetSocket/</url>
      
        <content type="html"><![CDATA[<p>目前支持I/O多路复用的系统调用有select,pselect,poll,epoll,I/O多路复用就是通过一种机制，一个进程可以监听多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），就能够通知程序进行相应的读写操作。但select,pselect,poll,epoll本质上都是同步I/O，因为他们都需要在读写时间就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。（这一步有性能开销）<br>与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减少了系统的开销。</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>IO多路复用是指内核一旦发生进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合：<br>1）当客户处理多个描述符时（一般是交互式输入和网络套接口），必须适用I/O复用。<br>2）当一个客户同时处理多个套接口，这种情况是可能的，但很少出现。（貌似没见过）<br>3）如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用I/O复用。（这是最常见的方式，貌似没有其他取代方式？）<br>4）如果一个服务器既要处理TCP，又要处理UDP，一般要使用I/O复用。<br>5）如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。</p><h1 id="select、poll、epoll简介"><a href="#select、poll、epoll简介" class="headerlink" title="select、poll、epoll简介"></a>select、poll、epoll简介</h1><p>epoll跟select都能提供多路I/O复用的解决方案。在现在的Linux内核都支持，其中epoll是Linux所特有，而select则应该是POSIX规定。<br>基本流程，如图所示：<br><img src="/2019/03/02/NetSocket/netsocket1.png" title="这是一个新的博客的图片的说明"><br>select目前几乎在所有的平台上支持，其良好的跨平台支持也是它的一个优点。select的一个缺点在与单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低。<br>select本质上是通过设置或者检查存放fb标志位的数据结构来进行下一步处理。这样所带来的的缺点是：<br>1.select最大的缺陷就是单个进程打开的DF是有一定限制的，它由FD_SETSIZE设置，默认值是1024。<br>一般来说这个数目和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max查看。32位默认1024个，64位默认2048个。我查了一下自己的虚拟机Centos6.0 是95979，从数量上分析来看，对于游戏来说，select模型个人感觉这点可以忽视了。<br>2.对socket进行扫描是线性扫描，即采用轮询的方法，效率较低。<br>当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度，不管哪个Socket是活跃的，都遍历一遍。（这可太扯了）这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。<br>3.需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销很大。</p><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>poll是select的一种改良，最突出的改良有两点：<br>1.文件描述符数量没有上限<br>2.将输入输出参数进行分离，不用每次设定<br>缺点：<br>1.和select一样，poll返回后，需要轮询pollfd来获取就绪的描述符<br>2.每次调用poll都需要大把大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</p><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>1.文件描述符没有上限，通过epoll_ctl()来注册一个文件描述符，内核中使用红黑树的数据结构来管理所有需要监控的文件描述符。<br>2.基于时间就绪通知方式，一旦被监听的某个文件描述符就绪，内核会采用类似于callback的回调机制，迅速激活这个文件描述符，这样随着文件描述符数量的增加，也不会影响判定就绪的性能。<br>3.维护就绪队列，当文件描述符就绪，就会被放到内核中的一个就绪队列中，这样调用epoll_wait获取就绪文件描述符的时候，只要取队列中的元素即可，操作的时间复杂度恒为O(1)。<br>4.epoll内存映射机制，即内核将就绪队列通过mmap的方式映射到用户态，避免了拷贝内存这样的额外性能开销。</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="/2019/02/25/QuickSort/"/>
      <url>/2019/02/25/QuickSort/</url>
      
        <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序(Quick Sort)使用分治法策略。它的基本思想是：选择一个基准数，通过一趟排序将要排序的数据分割成独立的两部分；其中一部分的所有数据都比另外一部分的所有数据都要小。然后，在按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><h2 id="快速排序流程"><a href="#快速排序流程" class="headerlink" title="快速排序流程"></a>快速排序流程</h2><ul><li>从数列挑出一个基准值。</li><li>将所有比基准值小的摆放在基准前面，所有比基准值大的摆在基准的后面（相同的数可以到任一边）；在这个分区退出之后，该基准就处于数列的中间位置。</li><li>递归地把“基准值前面的子数列”和“基准值后面的子数列”进行排序。</li></ul><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分支（divide-and-conquer）策略（分治法将问题分(divide)成一些小问题然后在递归求解，而治(conquer)的阶段则将分的阶段得到的各答案“修补”在一起，即分而治之）。</p><img src="/2019/02/25/QuickSort/1.png"><p>可以看到这种结构很像一颗完全二叉树，本文的归并排序我们采用递归去实现，递归深度为$log_{2^n}$</p><h2 id="合并相邻有序子序列"><a href="#合并相邻有序子序列" class="headerlink" title="合并相邻有序子序列"></a>合并相邻有序子序列</h2><p>再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤。</p><img src="/2019/02/25/QuickSort/2.png"><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>归并排序比较占用内存，但却是一种高效且稳定的算法。<br>时间复杂度：$O(n \cdot log^n)$<br>空间复杂度：T(n)</p><h1 id="二叉堆（binary-heap）"><a href="#二叉堆（binary-heap）" class="headerlink" title="二叉堆（binary heap）"></a>二叉堆（binary heap）</h1><p>二叉堆是一种特殊的堆，二叉堆是完全二叉树（二叉树）或者近似完全二元树（二叉树）。二叉堆有两种：最小堆和最大堆。最大堆：父节点的键值总是大于或等于任何一个子节点的键值；最小堆：父结点的键值总是小于或等于任何一个子节点的键值。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++</title>
      <link href="/2019/02/25/C++/"/>
      <url>/2019/02/25/C++/</url>
      
        <content type="html"><![CDATA[<h1 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h1><ul><li>对于一个class，产生一堆指向virtual functions的指针，虚函数表指针通常放在对象实例的最前面的位置。编译报错的时候没有vtable，表示该纯虚函数没有实现。</li><li>每一个对象添加一个指针，指向相关的virtual table。这个指针被称作虚函数表指针。</li></ul><h1 id="C-C-中static关键字作用总结"><a href="#C-C-中static关键字作用总结" class="headerlink" title="C/C++中static关键字作用总结"></a>C/C++中static关键字作用总结</h1><h2 id="先来介绍它的第一条也是最重要的一条：隐藏。（static函数，static变量均可）"><a href="#先来介绍它的第一条也是最重要的一条：隐藏。（static函数，static变量均可）" class="headerlink" title="先来介绍它的第一条也是最重要的一条：隐藏。（static函数，static变量均可）"></a>先来介绍它的第一条也是最重要的一条：隐藏。（static函数，static变量均可）</h2><p>当同事编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。<br>举例来说明。同时编译两个源文件，一个是a.c，另一个是main.c。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.c</span></span><br><span class="line"><span class="keyword">char</span> a = <span class="string">'A'</span>; <span class="comment">// global variable</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">msg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">char</span> a; <span class="comment">// extern variable must be declared before use</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>, a);</span><br><span class="line">    (<span class="keyword">void</span>)msg();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>程序运行结果是：<br>A Hello<br>为什么在a.c中定义的全局变量a和函数msg能在main.c中使用？前面说过，所有未加static前缀的全局变量和函数都具有全局可见性，其它的源文件也能访问。此例中，a是全局变量，msg是函数，并且都没有加static前缀，因此对于另外的源文件main.c是可见的。<br>如果加了static，就会对其它源文件隐藏。例如在a和msg的定义前加上了static，main.c就看不到它们了。利用这一特性可以再不同的文件中定义同名函数和同名变量，而不必担心命名冲突。static可以用作函数和变量的前缀，对于函数来讲，static的作用仅限于隐藏。</p><h2 id="static的第二个作用是保持内容的持久。（static变量中的记忆功能和全局生存期）"><a href="#static的第二个作用是保持内容的持久。（static变量中的记忆功能和全局生存期）" class="headerlink" title="static的第二个作用是保持内容的持久。（static变量中的记忆功能和全局生存期）"></a>static的第二个作用是保持内容的持久。（static变量中的记忆功能和全局生存期）</h2><p>存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的，虽然这种用法不常见<br>PS：如果作为static局部变量在函数内定义，它的生存期为整个源程序，但是其作用域仍与自动变量相同，只能定义该变量的函数内使用该变量。退出该函数后，尽管该变量还继续存在，但不能使用它。</p><p>程序举例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">10</span>; <span class="comment">//在第一次进入这个函数的时候，变量a被初始化为10！并接着自减1，以后每次进入该函数，a就不会再次被初始化了，仅进行自减1的操作；在static发明前，要达到同样的功能，则只能使用全局变量；</span></span><br><span class="line">    <span class="keyword">return</span> count--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"global\t\tlocal static\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(;count&lt;=<span class="number">10</span>;++count)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t\t%d\n"</span>,count,fun());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>基于以上两点可以得出一个结论：把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。因此static这个说明符在不同的地方所起的作用是不同的。</p><h2 id="static的第三个作用是默认初始化为0（static变量）"><a href="#static的第三个作用是默认初始化为0（static变量）" class="headerlink" title="static的第三个作用是默认初始化为0（static变量）"></a>static的第三个作用是默认初始化为0（static变量）</h2><p>其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。比如初始化一个稀疏举证，我们可以一个一个地把所有元素都置0，然后把不是0的几个元素赋值。如果定义成静态的，就省去了一开始置0的操作。再比如把一个字符数组当字符串来用，但又觉得每次在字符数组末尾加’\0’；太麻烦。如果把字符串定义成静态的，就省去了这个麻烦，因为那里本来就是’\0’;</p><p>最后对static的三条作用做一句话总结。首先static的最主要功能是隐藏，其次因为static变量存放在静态存储区，所以它具备持久性和默认值0。</p><h2 id="static的第四个作用：C-中的类成员声明static（有些地方与以上作用重叠）"><a href="#static的第四个作用：C-中的类成员声明static（有些地方与以上作用重叠）" class="headerlink" title="static的第四个作用：C++中的类成员声明static（有些地方与以上作用重叠）"></a>static的第四个作用：C++中的类成员声明static（有些地方与以上作用重叠）</h2><p>在类中声明static变量或者函数时，初始化时使用作用域运算符来标明它所属类，因此，静态数据成员是类的成员，而不是对象的成员，这样就出现以下作用：<br>（1）类的静态成员函数是属于整个类而非类的对象，所以它没有this指针，这就导致了它仅能访问类的静态数据和静态成员函数。<br>（2）不能将静态成员函数定义为虚函数。<br>（3）由于静态成员声明于类中，操作于其外，所以对其取地址操作，就多少有些特殊，变量地址是指向其数据类型的指针，函数地址类型是一个”nonmember函数指针”。<br>（4）由于静态成员函数没有this指针，所以就差不多等同于nonmember函数，结果就产生了一个意想不到的好处：成为一个callback函数，使得我们得以将C++和C-based XWindow系统结合，同时也成功的应用于线程函数身上。（这条没遇见过）<br>（5）static并没有增加程序的时空开销，相反它还缩短了子类对父类静态成员的访问时间，节省了子类的内存空间。<br>（6）静态数据成员在&lt;定义或说明&gt;时前面加关键字static。<br>（7）静态数据成员是静态存储的，所以必须对它进行初始化。（程序员手动初始化，否则编译时一般不会报错，但是Link时会报错误）<br>（8）静态成员初始化与一般数据成员初始化不同：<br>初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆；<br>初始化时不加该成员的访问权限控制符private,public等；<br>初始化时使用作用域来标明它所属类；<br>所以我们得出静态数据成员初始化的格式：<br>&lt;数据类型&gt; &lt;类名&gt;::&lt;静态数据成员名&gt;=&lt;值&gt;<br>（9）为了防止父类的影响，可以在子类定一个与父类相同的静态变量，以屏蔽父类的影响。这里有一点需要注意：我们说静态成员为父类和子类共享，但我们有重复定义了静态成员，这会不会引起错误呢？不会，我们的编译器采用了一种绝妙的手法：name-mangling用以生成唯一的标志。</p><h1 id="C-智能指针"><a href="#C-智能指针" class="headerlink" title="C++智能指针"></a>C++智能指针</h1><h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p>shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。</p><h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p>weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加</p><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p>“唯一”拥有其所指对象，同一时刻只能有一个unique_ptr指向给定对象</p><h1 id="虚函数-1"><a href="#虚函数-1" class="headerlink" title="虚函数"></a>虚函数</h1><p>通过一张虚函数表（Virtual Table）来实现<br>sizeof不统计虚函数表</p><h1 id="C-C-内存对齐"><a href="#C-C-内存对齐" class="headerlink" title="C/C++内存对齐"></a>C/C++内存对齐</h1><h2 id="什么是内存对齐"><a href="#什么是内存对齐" class="headerlink" title="什么是内存对齐"></a>什么是内存对齐</h2><p>32位系统下，int占4byte，char占1byte，那么将它们放到一个结构体中实际上占8byte，这就是内存对齐导致的。</p><h1 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h1><h2 id="什么是内联函数？"><a href="#什么是内联函数？" class="headerlink" title="什么是内联函数？"></a>什么是内联函数？</h2><p>内联函数是指那些定义在类体内部的成员函数，即该函数的函数体放在类体内。<br>一般来说，inline适用的函数有两种，一种是类内定义的成员函数，另一种是类内声明，类外定义的成员函数，对于这两种情况inline的使用有一些不同；</p><h2 id="内联函数的优缺点："><a href="#内联函数的优缺点：" class="headerlink" title="内联函数的优缺点："></a>内联函数的优缺点：</h2><p>优点：<br>1.inline定义的类的内联函数，函数的代码被放入符号表中，在使用时直接进行替换，（像宏一样展开），没有了调用的开销，效率也很高。<br>2.inline也是真正的函数，编辑器在调用一个内联函数时，会首先检查它的参数的类型，保证调用正确。然后进行一系列的相关检查，就像对待任何一个正在的函数一样。这样就消除了它的隐患和局限性。（宏替换不会检查参数类型，安全隐患较大）<br>缺点：<br>1.内联函数具有一定的局限性，inline函数的函数体一般来说不能太大，如果太大，一般的编译器会放弃内联方式，而采用普通的方式调用函数。（换句话说，你使用内联函数，只不过是向编译器提出一个申请，编译器可以拒绝你的申请），这样，内联和普通函数执行效率一样了。<br>2.inline对编译器来说只是一种简易，编译器可以选择忽略这个建议。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1.内联函数不能宝库欧复杂的控制语句，如循环语句和switch语句；</p><h1 id="接口（抽象类）"><a href="#接口（抽象类）" class="headerlink" title="接口（抽象类）"></a>接口（抽象类）</h1><p>接口描述了类的行为和功能，而不需要完成类的特定实现。</p><h1 id="视C-为一个语言联邦"><a href="#视C-为一个语言联邦" class="headerlink" title="视C++为一个语言联邦"></a>视C++为一个语言联邦</h1><ol><li>C语言</li><li>面向对象</li><li>C++模版</li><li>STL容器</li></ol><h1 id="尽量用const，enum，inline替换-define"><a href="#尽量用const，enum，inline替换-define" class="headerlink" title="尽量用const，enum，inline替换#define"></a>尽量用const，enum，inline替换#define</h1><ol><li>const的好处：define直接常量替换，出现编译错误不易定位（不知道常量是哪个变量，这个其实还好，工程规范点的都不存在这个问题）；define没有作用域，const有作用域提供了封装性（这个同上，不过这两点都是人为的避开了）</li><li>enum的好处：提供了封装性，编译器肯定不会分配额外的内存空间（其实const也不会，难道define会？至于封装性，undef，所以这么多年了，虽然说避免，但是工程上用的还是比较多的）</li><li>inline的好处：define宏函数容易造成误用</li></ol><p>宏实现工厂设计模式</p><ol><li>需要一个全局map用于存储类的信息以及创建实例的函数</li><li>需要调用全局对象的构造函数用于注册</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConsoleApplication1.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pch.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> *(*register_fun)();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCFactory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">NewInstance</span><span class="params">(<span class="built_in">string</span> class_name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = map_.find(class_name);</span><br><span class="line">        <span class="keyword">if</span> (it == map_.end())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> it-&gt;second();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Register</span><span class="params">(<span class="built_in">string</span> class_name, register_fun func)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        map_[class_name] = func;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">map</span>&lt;<span class="built_in">string</span>, register_fun&gt; map_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, register_fun&gt; CCFactory::map_; <span class="comment">// 体外初始化</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REGISTER_CLASS(class_name); \</span></span><br><span class="line">    CCFactory::Register(#class_name, []()-&gt;<span class="keyword">void</span> *&#123;<span class="keyword">return</span> (<span class="keyword">new</span> class_name);&#125;);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Say</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Register</span> :</span> <span class="keyword">public</span> Product <span class="comment">// 注册者，就是产品，虽然不喜欢设计模式这坨东西，但是研究起来还是挺好玩的</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Say</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Say What?\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    REGISTER_CLASS(Register);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Release</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Init();</span><br><span class="line">    Register* a = (Register*)CCFactory::NewInstance(<span class="string">"Register"</span>);</span><br><span class="line">    a-&gt;Say();</span><br><span class="line">    Release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没写完，但是感觉做个池还是挺好玩的。</p><h1 id="尽可能使用const"><a href="#尽可能使用const" class="headerlink" title="尽可能使用const"></a>尽可能使用const</h1><ol><li>const定义接口，防止误用</li><li>const成员函数，代表这个成员函数承诺不会改变对象值（const成员只能调用const成员函数(加-fpermissive编译选项就可以了)，非const成员可以调用所有成员函数）</li></ol><h1 id="确定对象使用前被初始化"><a href="#确定对象使用前被初始化" class="headerlink" title="确定对象使用前被初始化"></a>确定对象使用前被初始化</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConsoleApplication1.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pch.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> *(*register_fun)();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCFactory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">NewInstance</span><span class="params">(<span class="built_in">string</span> class_name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = map_.find(class_name);</span><br><span class="line">        <span class="keyword">if</span> (it == map_.end())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> it-&gt;second();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Register</span><span class="params">(<span class="built_in">string</span> class_name, register_fun func)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        map_[class_name] = func;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">map</span>&lt;<span class="built_in">string</span>, register_fun&gt; map_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, register_fun&gt; CCFactory::map_; <span class="comment">// 体外初始化</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REGISTER_CLASS(class_name); \</span></span><br><span class="line">    CCFactory::Register(#class_name, []()-&gt;<span class="keyword">void</span> *&#123;<span class="keyword">return</span> (<span class="keyword">new</span> class_name(#class_name));&#125;);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Say</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Register</span> :</span> <span class="keyword">public</span> Product <span class="comment">// 注册者，就是产品，虽然不喜欢设计模式这坨东西，但是研究起来还是挺好玩的</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Say</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; name.c_str() &lt;&lt; <span class="string">": Say What?\n"</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span> <span class="keyword">const</span> <span class="comment">// 表明这个函数不会对类对象的数据成员（准确地说是非静态数据成员）作任何改变</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">string</span> name; <span class="comment">// 必须在初始化的时候赋值</span></span><br><span class="line">    Register(<span class="built_in">string</span> _y) : name(_y)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    REGISTER_CLASS(Register);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Release</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Init();</span><br><span class="line">    Register* a = (Register*)CCFactory::NewInstance(<span class="string">"Register"</span>);</span><br><span class="line">    a-&gt;Say();</span><br><span class="line">    Release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="构造、析构、赋值运算"><a href="#构造、析构、赋值运算" class="headerlink" title="构造、析构、赋值运算"></a>构造、析构、赋值运算</h1><p>如果类中没有定义，程序却调用了，编译器会产生一些函数</p><ol><li>一个default的构造函数</li><li>一个copy构造函数</li><li>一个copy assignment 操作符</li><li>一个析构函数(non virtual)</li></ol><ul><li>如果自己构造了带参数的构造函数，编译器不会产生default构造函数</li><li>base class如果把拷贝构造函数或者复制操作符设置为private，不会产生这两个函数</li><li>含有引用成员变量或者const成员变量不产生复制操作符</li></ul><h1 id="若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="若不想使用编译器自动生成的函数，就该明确拒绝"></a>若不想使用编译器自动生成的函数，就该明确拒绝</h1><p>将默认生成的函数声明为private，或者C++ 11新特性”=delete”<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UncopyTable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    UncopyTable(<span class="keyword">const</span> UncopyTable&amp;);</span><br><span class="line">    UncopyTable&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> UncopyTable&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="静态类型"><a href="#静态类型" class="headerlink" title="静态类型"></a>静态类型</h1><p>上下文无关，在编译时就可以确定其类型。</p><h1 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型"></a>动态类型</h1><p>基类指针指向的对象在编译的时候无法确定</p><h1 id="动态绑定与静态绑定"><a href="#动态绑定与静态绑定" class="headerlink" title="动态绑定与静态绑定"></a>动态绑定与静态绑定</h1><p>静态绑定：编译时绑定，通过对象调用<br>动态绑定：运行时绑定，通过地址实现</p><p>要触发动态绑定，需满足两个条件</p><ol><li>只有虚函数才能惊醒动态绑定，非虚函数不能进行动态绑定</li><li>必须通过基类类型的引用或指针进行函数调用</li></ol><h1 id="为多态基类声明virtual析构函数"><a href="#为多态基类声明virtual析构函数" class="headerlink" title="为多态基类声明virtual析构函数"></a>为多态基类声明virtual析构函数</h1><ol><li>给多态基类应该主动声明virtual析构函数</li><li>非多态基类，没有virtual函数，不要声明virtual析构函数</li></ol><h1 id="复制对象时勿忘其每个成分"><a href="#复制对象时勿忘其每个成分" class="headerlink" title="复制对象时勿忘其每个成分"></a>复制对象时勿忘其每个成分</h1><ol><li>实现拷贝构造函数和赋值操作符的时候，调用base的相关函数</li><li>可以让拷贝构造函数和赋值操作符调用一个共同的函数，比如Init</li></ol><h1 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h1><h2 id="以对象管理资源"><a href="#以对象管理资源" class="headerlink" title="以对象管理资源"></a>以对象管理资源</h2><ol><li>为了防止资源泄漏，请使用RAII对象，在构造函数里面获得资源，在析构函数里面释放资源</li><li>shared_ptr，unique_lock都是RAII对象</li></ol><h2 id="在资源管理类小心copy行为"><a href="#在资源管理类小心copy行为" class="headerlink" title="在资源管理类小心copy行为"></a>在资源管理类小心copy行为</h2><ul><li>常见的RAII对象copy行为<ul><li>禁止copy</li><li>引用计数</li><li>深度赋值</li><li>转移资源拥有权</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>序章</title>
      <link href="/2018/12/09/fiction/"/>
      <url>/2018/12/09/fiction/</url>
      
        <content type="html"><![CDATA[<p>芩也不是一开始就知道这个世界是黑白的，是他的父亲告诉他的。父亲说，芩，你长大了，父亲要走了。芩问，父亲你去哪里？父亲说，我也不知道，我总觉得有人在召唤我，我该上路了。我们每个人都会上路的，包括你，芩。芩说，父亲，我可以陪你一起上路吗？父亲回答，我们每个人的路都是不一样的，你以后会有你自己的路走的，或许是明天，或许是明年，或许是更久。芩没说话，六岁的他不知道该说什么，也不太明白父亲对他说的话。她只知道，父亲要走了。要去很远的地方，一个她找不到的地方。而她，再也见不到父亲了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 混沌 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity Shader第三部分</title>
      <link href="/2018/10/22/Unity-Shader-IntrodutionToTopic-2/"/>
      <url>/2018/10/22/Unity-Shader-IntrodutionToTopic-2/</url>
      
        <content type="html"><![CDATA[<h2 id="透明效果"><a href="#透明效果" class="headerlink" title="透明效果"></a>透明效果</h2><h3 id="为什么渲染顺序很重要"><a href="#为什么渲染顺序很重要" class="headerlink" title="为什么渲染顺序很重要"></a>为什么渲染顺序很重要</h3><h3 id="Unity-Shader的渲染顺序"><a href="#Unity-Shader的渲染顺序" class="headerlink" title="Unity Shader的渲染顺序"></a>Unity Shader的渲染顺序</h3><h3 id="透明度测试"><a href="#透明度测试" class="headerlink" title="透明度测试"></a>透明度测试</h3><h3 id="透明度混合"><a href="#透明度混合" class="headerlink" title="透明度混合"></a>透明度混合</h3><p>透明度混合的实现要比透明度测试复杂一些，这是因为我们在处理透明度测试时，实际上跟对待普通的不透明物体几乎是一样的，只是在片元着色器中增加了对透明度判断并裁剪片元的代码。而想要实现透明度混合就没这么简单了。我们回顾之前提到的透明度混合的原理。<br><strong>透明度混合：</strong>这种方法可以得到真正的半透明效果。它会使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲区种的颜色进行混合，得到新的颜色。但是，<font color="red"><strong>透明度混合需要关闭深度写入</strong></font>，这使得我们要非常小心物体的渲染顺序。<br>为了进行混合，我们需要使用Unity提供的混合命令Blend。Blend是Unity提供的设置混合模式的命令。想要实现半透明的效果就需要把当前自身的颜色和已经存在于颜色缓冲区种的颜色值进行混合，混合时使用的函数就是由该指令决定的。</p><div class="table-container"><table><thead><tr><th>语义</th><th>描述</th></tr></thead><tbody><tr><td>Blend Off</td><td>关闭混合</td></tr><tr><td>Blend SrcFactor DstFactor</td><td>开启混合，并设置混合因子。源颜色（该片元产生的颜色）会乘以SrcFactor，而目标颜色（已经存在于颜色缓存的颜色）会乘以DstFactor，然后把两者相加后在存入颜色缓冲中</td></tr><tr><td>Blend SrcFactor DstFactor, SrcFactorA DstFractorA</td><td>和上面一样，只是使用不同的因子来混合透明通道</td></tr><tr><td>BlendOp BlendOperation</td><td>并非是把源颜色和目标颜色简单相加后混合，而是使用BlendOperation对它们进行其他操作</td></tr></tbody></table></div><p>我们介绍第二种语义，即Blend SrcFactor DstFactor来进行混合。需要注意的是，这个命令在设置混合因子的同时也开启了混合模式。这是因为，只有开启了混合之后，设置片元的透明通道才有意义，而Unity在我们使用Blend命令的时候就自动帮我们打开了。很多初学者抱怨为什么自己的模型没有任何透明效果，这往往是因为他们没有在Pass中使用Blend命令，一方面是没有设置混合因子，更重要的是没有打开混合模式。我们会把源颜色的混合因子SrcFactor设为SrcAlpha，而目标颜色的混合因子DstFactor设为OneMinusSrcAlpha。这意味着，经过混合后新的颜色是：</p><script type="math/tex; mode=display">DstColor_{new} = SrcAlpha*SrcColor+(1-SrcAlpha)*DstColor_{old}</script><h3 id="开启深度写入的半透明效果"><a href="#开启深度写入的半透明效果" class="headerlink" title="开启深度写入的半透明效果"></a>开启深度写入的半透明效果</h3><h3 id="ShaderLab的混合命令"><a href="#ShaderLab的混合命令" class="headerlink" title="ShaderLab的混合命令"></a>ShaderLab的混合命令</h3><h4 id="混合等式和参数"><a href="#混合等式和参数" class="headerlink" title="混合等式和参数"></a>混合等式和参数</h4><h4 id="混合操作"><a href="#混合操作" class="headerlink" title="混合操作"></a>混合操作</h4><h4 id="常见和混合类型"><a href="#常见和混合类型" class="headerlink" title="常见和混合类型"></a>常见和混合类型</h4><h3 id="双面渲染的透明效果"><a href="#双面渲染的透明效果" class="headerlink" title="双面渲染的透明效果"></a>双面渲染的透明效果</h3><h4 id="透明度测试的双面渲染"><a href="#透明度测试的双面渲染" class="headerlink" title="透明度测试的双面渲染"></a>透明度测试的双面渲染</h4><h4 id="透明度混合的双面渲染"><a href="#透明度混合的双面渲染" class="headerlink" title="透明度混合的双面渲染"></a>透明度混合的双面渲染</h4><h2 id="渲染路径Rendering-Path"><a href="#渲染路径Rendering-Path" class="headerlink" title="渲染路径Rendering Path"></a>渲染路径Rendering Path</h2><div class="table-container"><table><thead><tr><th>LightMode</th><th>描述</th></tr></thead><tbody><tr><td>Always</td><td>不管使用哪种渲染路径，该Pass总是会被渲染，但不会计算任何光照</td></tr><tr><td>ForwardBase</td><td>用于前向渲染。该Pass会计算环境光、最重要的平行光、逐顶点/SH光源和Lightmaps</td></tr><tr><td>ForwardAdd</td><td>用于前向渲染。该Pass会计算额外的逐像素光源，每个Pass对应一个光源</td></tr><tr><td>Deferred</td><td>用于延迟渲染。该Pass会渲染G缓冲（G-buffer）</td></tr><tr><td>ShadowCaster</td><td>把物体的深度信息渲染到阴影映射纹理（shadowmap）或一张深度纹理中</td></tr><tr><td>PrepassBase</td><td>用于遗留的延迟渲染。该Pass会渲染法线和高光反射的指数部分</td></tr><tr><td>PrepassFinal</td><td>用于遗留的延迟渲染。该Pass通过合并纹理、光照和自发光来渲染得到最后的颜色</td></tr><tr><td>Vertex、VertexLMRGBM和VertexLX</td><td>用于遗留的顶点照明渲染</td></tr></tbody></table></div><p>Unity在处理多光源的情况时为我们提供了三种模式；修改的地方在Edit-&gt;Project Settings—Player—Other Settings—Redering Path</p><ul><li>顶点光Vertex Lit</li><li>方向性Forward(默认)</li><li>延迟照明 Deferred Lighting</li></ul><p>shader默认使用Forward</p><h4 id="前向渲染路径"><a href="#前向渲染路径" class="headerlink" title="前向渲染路径"></a>前向渲染路径</h4><p>每进行一次完整的前向渲染，需要渲染该对象的渲染图元，并计算两个缓冲区的信息：一个是颜色缓冲区，一个是深度缓冲区。利用深度缓冲区来决定一个片元是否可见，如果可见就更新颜色缓冲区的的颜色值。我们可以用下面的伪代码来描述前向渲染路径的大致过程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Pass </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (each primitive in <span class="keyword">this</span> model) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed in depth test)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果没有通过深度测试，说明该片元是不可见的</span></span><br><span class="line">            discard;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果该片元可见</span></span><br><span class="line">            <span class="comment">// 就进行光照计算</span></span><br><span class="line">            float4 color = Shading(materialInfo, pos, normal, lightDir, viewDir);</span><br><span class="line">            <span class="comment">// 更新帧缓冲</span></span><br><span class="line">            writeFrameBuffer(fragment, color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于每个逐像素光源，我们都需要进行上面一次完整的渲染流程。如果一个物体在多个逐像素光源的影响区域内，那么该物体就需要执行多个Pass，每个Pass计算一个逐像素光源的光照结果，然后在帧缓冲中把这些光照结果混合起来得到最终的颜色值。假设，场景中有N个物体，每个物体物体受M个光源的影响，那么要渲染整个场景一共需要N*M个Pass。可以看出，如果有大量逐像素光照，那么需要执行的Pass数目也会很大。因此，渲染引擎通常会限制每个物体的逐像素光照的数目。</p><h5 id="Unity中的前向渲染"><a href="#Unity中的前向渲染" class="headerlink" title="Unity中的前向渲染"></a>Unity中的前向渲染</h5><p>事实上，一个Pass不仅仅可以用来计算逐像素光照，它也可以用来计算逐顶点等其他光照。这取决于光照计算所处流水线阶段以及计算时使用的数学模型。当渲染一个物体时，Unity会计算哪些光源照亮了它，以及这些光源照亮该物体的方式。<br>在Unity中，前向渲染路径有3种处理光照（即照亮物体）的方式：逐顶点处理、逐像素处理，球谐函数（Spherical Harmonics, SH）处理。</p><h4 id="顶点照明渲染路径"><a href="#顶点照明渲染路径" class="headerlink" title="顶点照明渲染路径"></a>顶点照明渲染路径</h4><h4 id="延迟渲染路径"><a href="#延迟渲染路径" class="headerlink" title="延迟渲染路径"></a>延迟渲染路径</h4><p>这是一种可以按照你的需求在场景中使用任意数目的光源的方法，而且这个方法还能同时保证性能仍然保持在一个合理的范围。它也不限制阴影的数量，如果场景中的对象实在光照范围之内的话，也不会增加额外的渲染批次（如果对象投影阴影的话则是例外）。</p><p>在游戏中的实时光照，一般有三种常用的方法</p><ol><li>一遍渲染多个光源：所有光源都在一个着色器中进行。但一个着色器指令数量有限，所以这个技术只适用于光源数量较少的情况。</li><li>多遍渲染多光源</li><li>延迟渲染</li></ol><h3 id="菲涅尔反射"><a href="#菲涅尔反射" class="headerlink" title="菲涅尔反射"></a>菲涅尔反射</h3><p>在实时渲染中，经常会使用<strong>菲涅耳反射（Fresnelreflection）</strong>来根据视角方向控制反射程度。菲涅耳反射描述了一种光学现象，即当光线照射到物体表面上时，一部分发生反射，一部分进入物体内部，发生折射或散射。被反射的光和入射光之间存在一定的比率关系，这个比率关系可以通过菲涅耳等式进行计算。一个经常使用的例子是，当你站在湖边，直接低头看脚边的水面时，你会发现水几乎是透明的，你可以直接看到水底的小鱼和石子；但是，当你抬头看远处的水面时，会发现几乎看不到水下的情景，而只能看到水面反射的环境。这就是所谓的菲涅耳效果。事实上，不仅仅是水、玻璃这样的反光物体具有菲涅耳效果，几乎任何物体都或多或少包含了菲涅耳效果，这是基于物理的渲染中非常重要的一项高光反射计算因子。<br>那么，如何计算菲涅耳反射呢？这就需要使用菲涅耳等式。真实世界的菲涅耳等式是非常复杂的，但在实时渲染中，通常会使用一些近似公式来计算。其中一个著名的近似公式就是Schlick 菲涅耳近似等式：</p><font size="4" color="red">$F_{Schlick}(v,n) = F_{0}+(1-F_{0})(1-v \cdot n)^5$</font><p>其中，$F_{0}$是一个反射系数，用于控制菲涅耳反射的强度， v 是视角方向， n 是表面法线。另一个应用比较广泛的等式是Empricial菲涅耳近似等式：</p><font size="4" color="red">$F_{Empricial}(v,n) = max(0,min(1,bias+scale x (1-v \cdot n)^power))$</font>其中，bias、scale和power是控制项。使用上面的菲涅尔近似等式，可以在边界处模拟反射光强和折射光强/漫反射光强之间的变化。在许多车漆、水面等材质的渲染中，会经常用到菲涅尔反射来模拟更加真实的反射。### 广告牌广告牌技术的本质就是构建旋转矩阵，而我们知道一个变换矩阵需要3个基向量。广告牌技术使用的基向量通常就是**表面法线（normal）、指向上的方向（up）以及指向右的方向（right）**。除此之外，我们还需要指定一个**锚点（anchor location）**，这个锚点在旋转过程中是固定不变的，以此来确定多边形在空间中的位置。广告牌技术的难点在于，如何根据需求构建3个相互正交的基向量。计算过程通常是，CPU写法：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Vector3 Normal;</span><br><span class="line">Quaternion direction;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    direction = Quaternion.FromToRotation(<span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), Normal);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    transform.rotation = Camera.main.transform.rotation * direction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>## 屏幕后处理效果### 建立一个基本的屏幕后处理脚本系统    MonoBehaviour.OnRenderImage(RenderTexture src, RenderTexture dest);当在脚本中声明该函数后，Unity会把当前渲染得到的图像存储在第一个参数对应的源渲染纹理中，把第二参数对应的渲染纹理显示到屏幕上。    public static void Blit(Texture src, RenderTexture dest);    public static void Blit(Texture src, RenderTextrue dest, Material mat, int pass = -1);    public static void Blit(Texture src, Material mat, int pass = -1);参数pass的默认值胃-1，表示将会依次调用Shader内的所有Pass。否则，只会调用给定索引的Pass。### 边缘检测#### 卷积在图像处理中，卷积操作指的是使用一个卷积核（kernel）一张图像中的每个像素进行一些列操作。卷积核通常是一个四方形网格结构，该区域内每个方格都有一个权重值。当对图像中的某个像素进行卷积时，我们会把卷积核的中心放置于该像素上，翻转核之后再依次计算核中每个元素和其覆盖的图像像素值的乘积并求和，得到的结果就是该位置的新像素值。这样的过程虽然简单，但可以实现很多常见的图像处理效果，例如图像模糊、边缘检测等。#### 常见的边缘检测算子卷积操作的神奇之处在于选择的卷积核。那么，用于边缘检测的卷积核（也被称为边缘检测算子）应该张什么样呢？再回答这个问题前，我们可以首先回想一下边到底是如何形成的。如果相邻像素之间存在差别明显的颜色、亮度、纹理等属性，我们就会认为它们之间应该有一条编辑。这种相邻像素之间的差值可以用**梯度（gradient）**来表示，可以想想得到，边缘处的梯度绝对值会比较大。基于这样的理解，有几种不同的边缘检测算子被先后提出来。RobertsGx{    -1,0,        0,1, }Gy{    0,-1,    1, 0,   }PrewittGx{    -1,-1,-1,        0, 0, 0,     1, 1, 1,}Gy{    -1, 0, 1,    -1, 0, 1,    -1, -, 1,}SobelGx{    -1,-2,-1,     0, 0, 0,     1, 2, 1,}Gy{    -1, 0, 1,    -2, 0, 2,    -1, 0, 1,}3中常见的边缘检测算子，它们都包含了两个方向的卷积核，分别用于检测水平方向和竖直方向上的边缘信息。再进行边缘检测时，我们需要对每个像素分别进行一次卷积计算，得到两个方向上的梯度值Gx和Gy，而整体的梯度可按下面的公式计算而得：$$ G = \sqrt{G^2_x + G^2_y} $$ 由于上述符号包含了开根号操作，出于性能考虑，我们有时会使用绝对值操作来代替开根号操作：$$ G=|G_x|+|G_y| $$当得到梯度后，我们就可以据此来判断哪些像素对应了边缘（梯度值越大，越有可能是边缘点）。## 使用深度和法线纹理### 消融噪声纹理+透明度测试，我们使用对噪声纹理采样的结果和某个控制消融程度的阀值比较，如果小于阀值，就使用clip函数把它对应的像素裁减掉。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Test&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _BurnAmount(&quot;Burn Amount&quot;, Range(0.0, 1.0)) = 0.0 // 控制消融程度，0为正常，1完全消融</span><br><span class="line">        _LineWith(&quot;Burn Line Width&quot;, Range(0.0, 0.2)) = 0.1 // 模拟烧焦效果的线宽，值越大，火焰边缘的蔓延范围越宽</span><br><span class="line">        _MainText (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125; // 漫反射纹理</span><br><span class="line">        _BumpMap (&quot;Normal Map&quot;, 2D) = &quot;bump&quot; &#123;&#125; // 法线纹理</span><br><span class="line">        _BurnFirstColor(&quot;Burn First Color&quot;, Color) = (1,0,0,1) // 火焰边缘颜色</span><br><span class="line">        _BurnSecondColor(&quot;Burn Second Color&quot;, Color) = (1,0,0,1) // 火焰边缘颜色</span><br><span class="line">        _BurnMap(&quot;Burn Map&quot;, 2D) = &quot;white&quot; &#123;&#125; // 消融纹理</span><br><span class="line">    &#125;   </span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma vertex frag</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>### 水波效果在模拟实时水面的过程中，往往也会使用噪声纹理。此时，噪声纹理通常会用作一个高度图，以不断修改水面的法线方向。为了模拟水不断流动的效果，我们会使用和时间相关的变量来对噪声纹理进行采样，当得到法线信息后，在进行正常的反射+折射计算，得到最后的水面波动效果。<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">SubShader </span>&#123;</span><br><span class="line">    <span class="class">Tags </span>&#123;<span class="string">"Queue"</span>=<span class="string">"Transparent"</span> <span class="string">"RenderType"</span>=<span class="string">"Opaque"</span>&#125;</span><br><span class="line">    <span class="class">GrabPass </span>&#123;<span class="string">"_RefractionTex"</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>首先把SubShader的标签中渲染队列设置成Transparent，并把后面的RenderType设置为Opaque。把Queue设置成Transparent可以确保该物体渲染时，其他所有不透明的物体都已经被渲染到屏幕上了，否则就可能无法正确得到“透过水面看到的图像”。而设置RenderType则是为了在使用着色器替换（Shader Replacement）时，该物体可以在需要时被正确渲染。### 减少draw call数目#### 动态批处理基本原理：每一帧把可以进行批处理的模型网格进行合并，再把合并后的模型数据传递给GPU，然后使用同一个材质对其渲染。动态批处理的一个好处是实现方便，另一个好处是，经过批处理的物体仍然可以移动，这是由于在处理每帧时Unity都会重新合并一次网格。条件限制：- 能够进行动态批处理的网格的顶点属性规模要小于900。例如，如果shader中需要使用顶点位置、发现和纹理坐标这3个顶点属性，那么要想让模型能够被动态批处理，它的顶点数目不能超过300。- 多Pass的shader会中断批处理。在前向渲染中，我们有时需要使用额外的Pass来为模型添加更多的光照效果，但这样一来模型就不会被动态批处理了。#### 静态批处理#### 共享材质#### 批处理的注意事项### 16.5 减少需要处理的顶点数目#### 16.5.1 优化几何体移除不必要的硬边以及纹理衔接，避免边界平滑和纹理分离。#### 16.5.2 模型的LOD技术#### 16.5.3 遮挡剔除技术### 16.6 减少需要处理的片元数目#### 控制绘制顺序#### 时刻警惕透明物体#### 减少实时光照和阴影### 影响性能的因素首先，在学习如何优化之前，我们得先了解影响游戏性能的因素有哪些。对于一个游戏来说，它主要需要使用两种计算资源：CPU和GPU。它们会互相合作，来让我们的游戏可以在预期的帧率和分辨率下工作。其中，CPU主要负责保证帧率，GPU主要负责分辨率相关的一些处理。据此，可以把造成游戏性能瓶颈的主要原因分成以下几个方面。（1）CPU- 过多的draw call- 复杂的脚本或者物理模拟（2）GPU- 顶点处理   过多的顶点   过多的逐顶点计算- 片元处理   过多的片元（既可能是由于分辨率造成的，也可能是由于overdraw造成的）。   过多的逐片元计算。- 带宽   使用了尺寸很大且未压缩的纹理   分辨率过高的帧缓存对于CPU来说，限制它的主要是每一帧draw call的数目。简单来说，就是CPU在每次通知GPU进行渲染之前，都需要提前准备好顶点数据（如位置、法线、颜色、纹理坐标等），然后调用一系列API把它们放到GPU可以访问到的指定位置，最后，调用一个绘制命令，来告诉GPU。而调用一次绘制命令的时候，就会产生一个draw call。过多的draw call会造成CPU的性能瓶颈，这是因为每次调用draw call时，CPU往往都需要改变很多渲染状态的设置，而这些操作是非常耗时的。如果一帧中需要的draw call数目过多的话，就会导致CPU把大部分时间都花费在提交draw call的工作上面了。当然，其他原因也可能造成CPU瓶颈，例如物理、布料模拟、蒙皮、粒子模拟等，这些都是计算量很大的操作。而对于GPU来说，它负责整个渲染流水线。它从处理CPU传递过来的模拟数据开始，进行顶点着色器、片元着色器等一系列工作，最后输出屏幕上的每个像素。因此，GPU的性能瓶颈和需要处理的顶点数目、屏幕分辨率、显存等因素有关。而相关的优化策略可以减少处理的数据（包括顶点数目和片元数目）|信息名称|描述||--|--||每帧的时间和FPS|在Graphic的右侧显示，给出了处理和渲染一帧所需的时间，以及FPS数目||Batches|一帧中需要进行的批处理数目||Saved by batching|合并的批处理数目，这个数字表明了批处理为我们节省了多少的draw call|### 节省带宽#### 减少纹理大小- 纹理的长宽比最好是正方形，长宽值最好是2的整数幂- 多级渐远纹理技术（mipmapping）和纹理压缩。#### 利用分辨率缩放### 减少计算复杂度#### Shader的LOD技术#### 代码方面的优化#### 根据硬件进行缩放## 基于物理的渲染### 双向反射分布函数（BRDF）**辐射率（radiance）**是单位面积、单位方向上光源的辐射通量，通常用L表示，被认为是对单一光线的亮度和颜色评估。<font color="red">在渲染中，我们通常会基于表面的入射光线的入射辐射率 $ L_i  $ 来计算出射辐射率 $L_{0}$ ，这个过程往往也称为**着色（shading）**过程。</font>而要得到出射辐射率$L_{o}$，我们需要知道物体表面一点是如何和光进行交互的。而这个过程就可以使用**BRDF（Bidirectional Reflectance Distribution Function，双向反射分布函数）**来定量分析。在大多数情况下，BRDF可以用$f(I,v)$来表示，其中I为入射方向和v为观察方向（双向的含义）。这种情况下，绕着表面法线旋转入射方向或观察方向并不会影响BRDF的结果，这种BRDF被称为是**各项同性（isotropic）**的BRDF。与之对应的则是**各项异性（anisotropic）**的BRDF。### 反射率方程<font size="4">$L_{o}(p,w_{o}) = \int_\Omega(k_{d}{c \over \pi} + k_{s}{DGF \over 4(w_{o} \cdot n)(w_{i} \cdot n)})L_{i}(p,w_{i})(w_{i} \cdot n)dw_{i}$</font><p>这是PBR的核心，也是主要的劝退点。<br>翻译成自然语言，大概是这样的：</p><font size="4">$输出颜色 = \int_\Omega(漫反射比例{纹理颜色 \over \pi} + 镜面反射比例{镜面高光 x 几何遮蔽 x 菲涅尔效应 \over 4(view_{Dir} \cdot normal)(lightDir \cdot normal)})光源颜色(lightDir,normal)dw_{i}$</font><p>先解释下这个公式遗留的部分。半球积分($\int_\Omega………dw_{i}$)</p>]]></content>
      
      
      <categories>
          
          <category> Unity Shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity Shader第二部分</title>
      <link href="/2018/10/21/Unity-Shader-IntroductionToTopic1/"/>
      <url>/2018/10/21/Unity-Shader-IntroductionToTopic1/</url>
      
        <content type="html"><![CDATA[<h3 id="光源"><a href="#光源" class="headerlink" title="光源"></a>光源</h3><p>在光学里，我们使用辐照度（irradiance）来量化光。对于平行光来说，它的辐照度可通过计算在垂直于l的单位平面上的单位时间内穿过的能量来得到。</p><h4 id="吸收和散射"><a href="#吸收和散射" class="headerlink" title="吸收和散射"></a>吸收和散射</h4><p>光线由光源发射出来后，就会与一些物体相交。通常，相交的结构有两个：散射（scattering）和吸收（absorption）。<br>散射只改变光线的方向，但不改变光线的密度和颜色。而吸收只改变光线的密度和颜色，但不改变光线的方向。</p><h4 id="BRDF光照模型"><a href="#BRDF光照模型" class="headerlink" title="BRDF光照模型"></a>BRDF光照模型</h4><p>我们已经了解了光线在和物体表面相交时会发生哪些现象。当已知光源位置和方向、视角方向时，我们就需要知道一个表面是和光照进行交互的。例如，当光线从某个方向照射到一个表面时，有多少光线被反射？反射的方向有哪些？而BRDF（Bidirectional Reflectance Distribution Function）就是用来回答这些问题的。当给定模型表面上的一个点时，BRDF包含了对该点外观的完整的描述。在图形学种，BRDF大多使用一个数学公式来表示，并且提供了一些参数来调整材质属性。通俗来讲，当给定入射光线的方向和辐照度后，BRDK可以给出某个出射方向上的光照能量分布。本章涉及的BRDF都是对真实场景进行理想化和简化后的模型，也就是说，它们并不能真实地反映物体和光线之间地交互，这些光照模型被成为是经验模型。尽管如此，这些经验模型仍然在实时渲染领域被应用了多年。</p><h3 id="标准光照模型"><a href="#标准光照模型" class="headerlink" title="标准光照模型"></a>标准光照模型</h3><p>基本方法是，把进入到摄像机的光线分为4部分，每个部分使用一种方法来计算它的贡献度</p><ul><li>自发光(emissive)</li><li>高光反射(specular)</li><li>漫反射(diffuse)</li><li>环境光(ambient)</li></ul><h4 id="环境光"><a href="#环境光" class="headerlink" title="环境光"></a>环境光</h4><p>在标准光照模型中，使用一种被称为环境光的部分来近似模拟间接光照。环境光的计算非常简单，它通常是一个全局变量，即场景中的所有物体都使用这个环境光。下面的等式给出了计算环境光的部分：</p><p>$c_{ambient}=g_{ambient}$</p><h4 id="自发光"><a href="#自发光" class="headerlink" title="自发光"></a>自发光</h4><p>光线也可以直接由光源发射进入摄像机，而不需要经过任何物体的反射。标准光照模型使用自发光来计算这个部分的贡献度。它的计算也很简单，就是直接使用了该材质的自发光颜色：</p><p>$c_{emissive}=m_{emissive}$</p><p>通常在实时渲染中，自发光的表面往往并不会照亮周围的表面，也就是说，这个物体并不会被当成一个光源。</p><h4 id="漫反射"><a href="#漫反射" class="headerlink" title="漫反射"></a>漫反射</h4><p>漫反射光照是用于对那些被物体表面随机散射到各个方向的辐射度进行建模的。在漫反射中，视角的位置是不重要的，因为反射是完全随机的，因此可以认为在任何反射方向上的分布都是一样的。但是，入射光线的角度很重要。<br>漫反射光照符合<strong>兰伯特定律（Lambert’s law）</strong>：反射光线的强度与表面发现和光源方向之间夹角的余弦值成正比。因此，漫反射部分的计算如下：</p><p>$c_{diffuse} = (c_{light} \cdot m_{diffuse})max(0, n \cdot I)$</p><h4 id="高光反射"><a href="#高光反射" class="headerlink" title="高光反射"></a>高光反射</h4><p>这里的高光反射是一种经验模型，也就是说，它并不完全符合真实世界中的高光反射现象。它可用于计算那些沿着完全镜面反射方向被反射的光线，这可以让物体看起来是有光泽的，例如金属材质。<br>计算高光反射需要知道的信息比较多，如表面法线、视角方向、光源方向、反射方向等。<br>反射计算公式：<br>$r = 2(\vec{n} \cdot I)\vec{n} - I$<br>推导公式见Light Reflect<br>这样，我们就可以利用Phong模型来计算高光反射的部分：</p><p><font size="4">$c_{spscular} = (c_{light} \cdot m_{specular})max(0, \vec{v} \cdot r)^{m_{glass}}$</font><br>其中，$m_{gloss}$是材质的<strong>光泽度（gloss）</strong>，也被称为<strong>反光度（shinness）</strong>。它用于控制高光区域的“亮点”有多宽，$m_{gloss}$越大，亮点就越小。$m_{spscular}$是材质的高光反射颜色，它用于控制该材质对于高光反射的强度和颜色。$c_{light}则是光源的颜色和强度。$</p><h4 id="逐像素还是逐顶点"><a href="#逐像素还是逐顶点" class="headerlink" title="逐像素还是逐顶点"></a>逐像素还是逐顶点</h4><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h3 id="单张纹理"><a href="#单张纹理" class="headerlink" title="单张纹理"></a>单张纹理</h3><h4 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h4><h4 id="纹理的属性"><a href="#纹理的属性" class="headerlink" title="纹理的属性"></a>纹理的属性</h4><h3 id="凹凸映射"><a href="#凹凸映射" class="headerlink" title="凹凸映射"></a>凹凸映射</h3><h4 id="高度纹理"><a href="#高度纹理" class="headerlink" title="高度纹理"></a>高度纹理</h4><h4 id="法线纹理"><a href="#法线纹理" class="headerlink" title="法线纹理"></a>法线纹理</h4><h4 id="实践-1"><a href="#实践-1" class="headerlink" title="实践"></a>实践</h4><h4 id="法线纹理类型"><a href="#法线纹理类型" class="headerlink" title="法线纹理类型"></a>法线纹理类型</h4><h3 id="渐变纹理"><a href="#渐变纹理" class="headerlink" title="渐变纹理"></a>渐变纹理</h3><h3 id="遮罩纹理"><a href="#遮罩纹理" class="headerlink" title="遮罩纹理"></a>遮罩纹理</h3><h4 id="实践-2"><a href="#实践-2" class="headerlink" title="实践"></a>实践</h4><h4 id="其他遮罩纹理"><a href="#其他遮罩纹理" class="headerlink" title="其他遮罩纹理"></a>其他遮罩纹理</h4>]]></content>
      
      
      <categories>
          
          <category> Unity Shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity Shader第一部分</title>
      <link href="/2018/10/20/Unity-Shader-IntroductionToTopic/"/>
      <url>/2018/10/20/Unity-Shader-IntroductionToTopic/</url>
      
        <content type="html"><![CDATA[<h3 id="像素光-Pixel-Light"><a href="#像素光-Pixel-Light" class="headerlink" title="像素光 Pixel Light"></a>像素光 Pixel Light</h3><p>Unity中将平行光称作为像素光，第一个像素光是基础平行光，以LightMode=ForwardBase标签修饰，每多一个像素光都以LightMode=ForwardAdd标签修饰。<br>并不是所有的光源在运行时都会反射到物体上，而是根据Project的Quality中设置的像素光数量来渲染的。<br>默认的像素光的数量应该是2，我们有更多的平行光照在物体上，就需要在Edit-&gt;Project Setting-&gt;Quality中去调节像素光的数量Pixel Light Count<br>当场景中的实际像素光数量超过这个设定值的时候，Unity只会渲染最重要的光。</p><h3 id="关于像素光的叠加原理"><a href="#关于像素光的叠加原理" class="headerlink" title="关于像素光的叠加原理"></a>关于像素光的叠加原理</h3><p>片段着色器是要将mesh组件传递的信息最终计算为颜色(或者深度)存储在帧缓存(Frame Buffer)中。<br>每个Pass之间输出的颜色通过一定的公式进行混合。<br>在这里我们简单使用一比一的模式进行颜色混合，即混合指令为：</p><pre><code>Blend One One</code></pre><p>第二个Pass的代码同样的也直接复制第一个Pass即可，相应的将Tags标签中LightMode=ForwardBase修改为LightMode=ForwordAdd。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Custom/Multi-Light Diffuse&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        // 材料颜色默认为黑色，</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="渲染流水线"><a href="#渲染流水线" class="headerlink" title="渲染流水线"></a>渲染流水线</h3><p>渲染流水线的工作任务在于由一个三维场景触发、生成（或者说渲染）一张二维图像。换句话说，计算机需要从一系列的顶点数据、纹理等信息出发，把这些信息最终转换成一张人眼可以看到的图像。而这个工作通常是由CPU和GPU共同完成的。<br>《Render-Time Rendering, Third Edition》将一个渲染流程分成3个阶段：<strong>应用阶段(Application Stage)、几何阶段(Geometry Stage)、光栅化阶段(Rasterizer Stage)</strong>。<br><img src="/2018/10/20/Unity-Shader-IntroductionToTopic/shader.webp" title="渲染流水线"></p><h4 id="应用阶段（CPU处理）"><a href="#应用阶段（CPU处理）" class="headerlink" title="应用阶段（CPU处理）"></a>应用阶段（CPU处理）</h4><p>这一阶段是由开发者主导的，在这一阶段中开发都有3个主要的任务：<br>首先，需要准备好场景数据（摄像机位置，视锥体，模型和光源等）<br>接着，还需要做粗粒度的剔除工作<br>最后，需要设置好每个模型的渲染状态（使用的材质，使用的纹理，使用的Shader等）<br>这一阶段最重要的输出是渲染所需的几何信息，即渲染图元，渲染图元可以是点，线，三角面等。</p><h4 id="几何阶段（GPU处理）"><a href="#几何阶段（GPU处理）" class="headerlink" title="几何阶段（GPU处理）"></a>几何阶段（GPU处理）</h4><p>几何阶段主要用于处理所有和我们绘制的几何相关的事情。几何阶段负责和每个渲染图元打交道，进行逐顶点，逐多边形的操作。这个阶段可以进一步分成更小的流水线阶段。<br>几何阶段的一个重要任务就是把顶点坐标变换到屏幕空间中，再交给光栅器进行处理。<br>总结：输入的渲染图元-&gt;屏幕空间的二维顶点坐标、每个顶点对应深度、着色等信息</p><h3 id="光栅化阶段（GPU处理）"><a href="#光栅化阶段（GPU处理）" class="headerlink" title="光栅化阶段（GPU处理）"></a>光栅化阶段（GPU处理）</h3><p>将会使用上一个阶段传递的数据来产生屏幕上的像素，并渲染出最终的图像。主要任务是决定每个渲染图元中的那些像素应该被绘制在屏幕上。<br><strong>顶点着色器（Vertex Shader）</strong>是完全可编程的，它通常用于实现顶点的空间变换、顶点着色等功能。<strong>曲面细分着色器（Tessellation Shader）</strong>是一个可选的着色器，<strong>几何着色器（Geometry Shader）</strong>同样是一个可选的着色器，它可以被用于执行逐图元（Per-Pimitive）的着色操作，或者被用于产生更多的图元。下一个流水线是<strong>裁剪（Clipping）</strong>，这一阶段的目的是将那些不在摄像机视野内的顶点裁剪掉，并剔除某些三角图元的面片。这个阶段是可配置的。例如，我们可以使用自定义的裁剪平面来配置裁剪区域，也可以通过指令控制裁剪三角图元的正面还是背面。几何概念阶段的最后一个流水线阶段是<strong>屏幕映射（Screen Mapping）</strong>。这一阶段是不可配置和编程的，它负责把每个图元的坐标转换到屏幕坐标系中。<br>光栅化概念阶段中的<strong>三角形设置（Triangle Setup）</strong>和<strong>三角形遍历（Triangle Traversal）</strong>阶段也都是固定函数（Fixed-Function）的阶段。接下来的<strong>片元着色器（Fragment Shader）</strong>，则是完全可编程的，它用于实现逐片元（Per-Fragment）的着色操作。最后，<strong>逐片元操作（Per-Fragment Operations）</strong>阶段负责执行很多重要的操作，例如修改颜色、深度缓冲、进行混合等，它不是可编程，但具有很高的可配置型。<br>Unity内置的DiffuseShader,也就是说我们创建一个Material出来时默认的Shader也是多光源的，所以这篇文章完成的Shader与默认的diffuse shader基本效果一致。</p><h3 id="CPU与GPU之间的通信"><a href="#CPU与GPU之间的通信" class="headerlink" title="CPU与GPU之间的通信"></a>CPU与GPU之间的通信</h3><p>渲染流水线的起点是CPU，即应用阶段。应用阶段可以分为下面3个阶段：</p><ul><li>把数据加载到显存中</li><li>设置渲染状态</li><li>调用Draw Call</li></ul><ol><li><p>数据加载到显存中<br>基本步骤就是纹理、网格等数据从硬盘加载到系统内存在加载到显存中。数据记载到显存后系统内存中的数据就可以被移除了，但是对于一些数据来说CPU需要访问他们，例如用于碰撞检测用的网格数据，这些数据则会被保留。</p></li><li><p>设置渲染状态<br>渲染状态指的是场景中的网格是如何被渲染的，例如使用哪个Vertex Shader或者哪个Fragment Shader、光源属性、材质等。</p></li><li><p>调用Draw Call<br>Draw Call指的是一个命令，发起方为CPU，接收方为GPU。当给定了一个Draw Call时，GPU会根据渲染状态（例如材质、纹理、着色器等）和所有输入的顶点数据</p></li></ol><h3 id="从应用程序阶段模型数据给顶点着色器时支持的语义"><a href="#从应用程序阶段模型数据给顶点着色器时支持的语义" class="headerlink" title="从应用程序阶段模型数据给顶点着色器时支持的语义"></a>从应用程序阶段模型数据给顶点着色器时支持的语义</h3><div class="table-container"><table><thead><tr><th style="text-align:left">语义</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">POSITION</td><td style="text-align:left">模型空间的顶点位置，通常是float4类型</td></tr><tr><td style="text-align:left">NORMAL</td><td style="text-align:left">顶点法线，通常是float3类型</td></tr><tr><td style="text-align:left">TANGENT</td><td style="text-align:left">顶点切线，通常是float4类型</td></tr><tr><td style="text-align:left">TEXCOORDn,如TEXCOORD0、TEXCOORD1</td><td style="text-align:left">该顶点的纹理坐标，TEXCOORD0表示第一组纹理坐标，依次类推，通常是float2或float4类型</td></tr></tbody></table></div><p>其中TEXCOORDn中的数目是和Shader Model有关的，例如一般在Shader Model 2(即Unity默认编译到的Shader Model版本)和Shader Model 3中，n等于8，而在Shader Model 4 和Shader Model 5中，n等于16.通常情况下，一个模型的纹理坐标数组一般不超过2，即我们往往只只用TEXCOORD0和TEXCOORD1。在Unity内置的数据结构体appdata_full中，它最多使用了6个坐标纹理。</p><h3 id="从顶点着色器传递数据给片元着色器时的语义"><a href="#从顶点着色器传递数据给片元着色器时的语义" class="headerlink" title="从顶点着色器传递数据给片元着色器时的语义"></a>从顶点着色器传递数据给片元着色器时的语义</h3><div class="table-container"><table><thead><tr><th style="text-align:left">语义</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">SV_POSITION</td><td style="text-align:left">裁剪空间中的顶点坐标，结构体中必须包含一个用该语义修饰的变量。等同于Direct9中的POSITION，但最好使用SV_POSITION</td></tr><tr><td style="text-align:left">COLOR0</td><td style="text-align:left">通常用于输出第一组顶点颜色，但不是必须的</td></tr><tr><td style="text-align:left">COLOR1</td><td style="text-align:left">通常用于输出第二组顶点颜色，但不是必须的</td></tr><tr><td style="text-align:left">TEXCOORD0~TEXCOORD7</td><td style="text-align:left">通常用于输出纹理坐标，但不是必须的</td></tr></tbody></table></div><p>上面的语义中，除了SV_POSITION是有特别含意外，其他语义对变量的含义没有明确要求，也就是说，我们可以存储任意值到这些描述变量中。</p><h3 id="片元着色器输出时Unity支持的常用语义"><a href="#片元着色器输出时Unity支持的常用语义" class="headerlink" title="片元着色器输出时Unity支持的常用语义"></a>片元着色器输出时Unity支持的常用语义</h3><div class="table-container"><table><thead><tr><th style="text-align:left">语义</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:left"></td></tr></tbody></table></div><h4 id="点和矢量的区别"><a href="#点和矢量的区别" class="headerlink" title="点和矢量的区别"></a>点和矢量的区别</h4><p>点是一个没有大小之分的空间中的位置，而矢量是一个有模和方向但是没有位置的量。</p><h4 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h4><p>对于一个点，从三维坐标转换成齐次坐标是把w分量设为1，而对于方向矢量来说，需要把w分量设为0。</p><h4 id="平移矩阵"><a href="#平移矩阵" class="headerlink" title="平移矩阵"></a>平移矩阵</h4><p>我们可以使用矩阵乘法来表示对一个点进行平移变换：</p><p>$\begin{bmatrix}<br>{1}&amp;{0}&amp;{0}&amp;{t_{x}}\\<br>{0}&amp;{1}&amp;{0}&amp;{t_{y}}\\<br>{0}&amp;{0}&amp;{1}&amp;{t_{z}}\\<br>{0}&amp;{0}&amp;{0}&amp;{1}\\<br>\end{bmatrix}<br>\begin{bmatrix}<br>{x}\\<br>{y}\\<br>{z}\\<br>{1}\\<br>\end{bmatrix} =<br>\begin{bmatrix}<br>{x+t_{x}}\\<br>{y+t_{y}}\\<br>{z+t_{z}}\\<br>{1}\\<br>\end{bmatrix}$</p><p>从结果来看我们可以很容易看出为什么这个矩阵有平移的效果：点的x、y、z分量分别增加了一个位置偏移。在3D中的可视化效果是，把点$(x,y,z)$在空间中平移了$(t_{x},t_{y},t_{z})$。<br>如果我们对一个方向矢量进行平移变换，结果如下：</p><p>$\begin{bmatrix}<br>{1}&amp;{0}&amp;{0}&amp;{t_{x}}\\<br>{0}&amp;{1}&amp;{0}&amp;{t_{y}}\\<br>{0}&amp;{0}&amp;{1}&amp;{t_{z}}\\<br>{0}&amp;{0}&amp;{0}&amp;{1}\\<br>\end{bmatrix}<br>\begin{bmatrix}<br>{x}\\<br>{y}\\<br>{z}\\<br>{0}\\<br>\end{bmatrix} =<br>\begin{bmatrix}<br>{x}\\<br>{y}\\<br>{z}\\<br>{0}\\<br>\end{bmatrix}$<br>可以发现，平移变换不会对方向矢量产生任何影响。因为矢量没有位置属性，也就是说它可以位于空间中的任意一点，因此对位置的改变不应该对四维矢量产生影响。</p><h4 id="缩放矩阵"><a href="#缩放矩阵" class="headerlink" title="缩放矩阵"></a>缩放矩阵</h4><p>我们可以对一个模型沿空间的x轴、y轴和z轴进行缩放。</p><p>$\begin{bmatrix}<br>{k_{x}}&amp;{0}&amp;{0}&amp;{0}\\<br>{0}&amp;{k_{y}}&amp;{0}&amp;{0}\\<br>{0}&amp;{0}&amp;{k_{z}}&amp;{0}\\<br>{0}&amp;{0}&amp;{0}&amp;{1}\\<br>\end{bmatrix}<br>\begin{bmatrix}<br>{x}\\<br>{y}\\<br>{z}\\<br>{1}\\<br>\end{bmatrix} =<br>\begin{bmatrix}<br>{k_{x}x}\\<br>{k_{y}y}\\<br>{k_{z}z}\\<br>{1}\\<br>\end{bmatrix}$</p><p>如果缩放系数$k_{x}=k_{y}=k_{z}$，我们把这样的缩放称为统一缩放（uniform scale），否则称为非同一缩放（nonuniform scale）。从外观看，统一缩放是扩大整个模型，而非同一缩放会拉伸或挤压模型。更重要的是，统一缩放不会改变角度和比例信息。</p><h4 id="复合变换"><a href="#复合变换" class="headerlink" title="复合变换"></a>复合变换</h4><p>在绝大多数情况下，我们约定变换的顺序就是先缩放，再旋转，最后平移。<br>变换矩阵如下：(注意，矩阵是从右往左算的)<br>$<br>M_{translation}M_{rotation}M_{scale} =<br>\begin{bmatrix}<br>{1}&amp;{0}&amp;{0}&amp;{t_{x}}\\<br>{0}&amp;{1}&amp;{0}&amp;{t_{y}}\\<br>{0}&amp;{0}&amp;{1}&amp;{t_{z}}\\<br>{0}&amp;{0}&amp;{0}&amp;{1}\\<br>\end{bmatrix}<br>$<br>当我们直接给出$(\theta_{x}, \theta_{y}, \theta_{z})$这样的旋转角度时，需要定义一个旋转顺序。在Unity中，这个旋转顺序是zxy。</p><h3 id="顶点的坐标空间变化"><a href="#顶点的坐标空间变化" class="headerlink" title="顶点的坐标空间变化"></a>顶点的坐标空间变化</h3><p>在渲染流水线中，一个顶点要经过多个坐标空间的变换才能最终被画在屏幕上。一个顶点最开始是在模型空间中定义的，最后它将会变换到屏幕空间中，得到真正的屏幕像素坐标。</p><h4 id="模型空间"><a href="#模型空间" class="headerlink" title="模型空间"></a>模型空间</h4><p><strong>模型空间（model space）</strong>，是和某个模型或者说是对象有关的。有时模型空间也被称为<strong>对象空间（object space）</strong>或<strong>局部空间（local space）</strong>。每个模型都有自己独立的坐标空间，当它移动或旋转的时候，模型空间也会跟着它移动和旋转。<br>顶点变换的第一步，就是将顶点坐标从模型空间变换到世界空间中。这个变换通常叫做模型变换（model transform）。</p><h4 id="世界空间"><a href="#世界空间" class="headerlink" title="世界空间"></a>世界空间</h4><p>顶点变换的第一步，就是将顶点坐标从模型空间变换到世界空间中。这个变换通常叫做<strong>模型变换（model transform）</strong>。<br>变换矩阵如下：<br>$M_{model} = \begin{bmatrix}<br>{1}&amp;{0}&amp;{0}&amp;{t_{x}}\\<br>{0}&amp;{1}&amp;{0}&amp;{t_{y}}\\<br>{0}&amp;{0}&amp;{1}&amp;{t_{z}}\\<br>{0}&amp;{0}&amp;{0}&amp;{1}\\<br>\end{bmatrix}<br>\begin{bmatrix}<br>{cos\theta}&amp;{0}&amp;{sin\theta}&amp;{0}\\<br>{0}&amp;{1}&amp;{0}&amp;{0}\\<br>{-sin\theta}&amp;{0}&amp;{cos\theta}&amp;{0}\\<br>{0}&amp;{0}&amp;{0}&amp;{1}\\<br>\end{bmatrix}<br>\begin{bmatrix}<br>{k_{x}}&amp;{0}&amp;{0}&amp;{0}\\<br>{0}&amp;{k_{y}}&amp;{0}&amp;{0}\\<br>{0}&amp;{0}&amp;{k_{z}}&amp;{0}\\<br>{0}&amp;{0}&amp;{0}&amp;{1}\\<br>\end{bmatrix} =<br>\begin{bmatrix}<br>{k_{x}cos\theta}&amp;{0}&amp;{k_{z}sin\theta}&amp;{t_{x}}\\<br>{0}&amp;{k_{y}}&amp;{0}&amp;{t_{y}}\\<br>{-k_{x}sin\theta}&amp;{0}&amp;{k_{z}cos\theta}&amp;{-t_{z}}\\<br>{0}&amp;{0}&amp;{0}&amp;{1}\\<br>\end{bmatrix}$<br>注意：上述变换顺序是不能互换的，即先进行缩放，在进行旋转，最后是平移。</p><h4 id="观察空间"><a href="#观察空间" class="headerlink" title="观察空间"></a>观察空间</h4><p>观察空间（view space）也被称为摄像机空间（camera space）。顶点变换的第二步，就是将顶点坐标从世界空间变换到观察空间中。这个变换叫做观察变换（view transform）。</p><h4 id="裁剪空间"><a href="#裁剪空间" class="headerlink" title="裁剪空间"></a>裁剪空间</h4><p>裁剪空间（clip space，也称齐次裁剪空间），这个用于变换的矩阵叫做裁剪矩阵（clip matrix），也称为投影矩阵（projection matrix）。<br>裁剪空间的目标是能够方便地对渲染图元进行裁剪：完全位于这块空间内部的图元将会被保留，完全位于这块空间外部的图元将会被剔除，而与这块空间边界相交的图元就会被裁剪。这块空间是由视锥体来决定的。<br>视锥体指的是空间中的一块区域，这块区域决定了摄像机可以看到的空间。视锥体由六个平面包围而成，这些平面也被称为<strong>裁剪平面（clip planes）</strong>。视锥体有两种类型，一种是<strong>正交投影（orthographic projection）</strong>，一种是<strong>透视投影（perspective projection）</strong>。<br>在视锥体的6块裁剪平面中，有两块裁剪平面比较特殊，它们分别被称为<strong>近裁剪平面（near clip plane）</strong>和<strong>远裁剪平面（far clip plane）</strong>。它们决定了摄像机可以看到的深度范围。</p><h5 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h5><p>视锥体的意义在于定了场景中的一块三维空间。所有位于这块空间内的物体将会被渲染，否则就会被剔除或裁剪。这块区域是由6个裁剪平面组成，在Unity中，它们由Camera组件中的参数和Game视图中横纵比共同决定<br><img src="/2018/10/20/Unity-Shader-IntroductionToTopic/3.jpg"><br>Camera组件的Field of View（简称FOV）属性来改变视锥体竖直方向的张开角度，而Clipping Planes中的Near和Far参数可以控制视锥体的近裁剪面和远裁剪面距离相机的远近。<br>这样，我们可以求出视锥体近裁剪面和远裁剪面的高度</p><p>$nearClipPlaneHeight = 2 \cdot Near \cdot tan {FOV \over 2}$</p><p>$farClipPlaneHeight = 2 \cdot Far \cdot tan {FOV \over 2}$</p><p>透视投影的横向信息，可以通过相机的横纵比得到。在Unity中，一个摄像机的横纵比由Game视图的横纵比和Viewport Rect中的W和H属性共同决定（实际上，Unity允许我们在脚本里通过Camera.aspect进行更改）。假设，当前相机的横纵比为Aspect，则：</p><p>$Aspect = {nearClipPlaneWidth \over nerClipPlaneHeight}$</p><p>$Aspect = {farClipPlaneWidth \over farClipPlaneHeight}$    </p><p>现在，我们可以根据已知的Near、Far、FOV和Aspect的值来确定透视投影的投影矩阵。如下：</p><p>$<br>M_{frustum} = \begin{bmatrix}<br>{cot{FOV \over 2} \over Aspect}&amp;{0}&amp;{0}&amp;{0}\\<br>{0}&amp;{cot{FOV \over 2}}&amp;{0}&amp;{0}\\<br>{0}&amp;{0}&amp;{-{Far+Near \over Far-Near}}&amp;{-{2 \cdot Far \cdot Near \over Far-Near}}\\<br>{0}&amp;{0}&amp;{-1}&amp;{0}\\<br>\end{bmatrix}<br>$<br>这里针对的是观察空间是右手坐标系，使用列矩阵在矩阵右侧相乘的，且变换后z分量范围在[-w,w]之间的情况。<br>而一个顶点和上述投影矩阵相乘后，可以由观察空间变换到裁剪空间中，结果如下<br>$<br>P_{clip} = M_{frustum}P_{view} =<br>\begin{bmatrix}<br>{cot{FOV \over 2} \over Aspect}&amp;{0}&amp;{0}&amp;{0}\\<br>{0}&amp;{cot{FOV \over 2}}&amp;{0}&amp;{0}\\<br>{0}&amp;{0}&amp;{-{Far+Near \over Far-Near}}&amp;{-{2 \cdot Far \cdot Near \over Far-Near}}\\<br>{0}&amp;{0}&amp;{-1}&amp;{0}\\<br>\end{bmatrix}<br>\begin{bmatrix}<br>{x}\\{y}\\{z}\\{1}\\<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>{x{cot{FOV \over 2} \over Aspect}}\\{y{cot{FOV \over 2}}}\\{-z{Far+Near \over Far-Near}-{2 \cdot Near \cdot Far \over Far-Near}}\\{-z}\\<br>\end{bmatrix}<br>$<br>从这个结果来看，这个投影矩阵本质就是对x、y和z分量进行了不同程度的缩放（z分量还有一个平移），缩放的目的是为了方便裁剪。此时顶点的w分量不再是1，而是原先z分量的取反结果。<br>现在，我们就可以按如下不等式来判断一个变换后的顶点是否位于视锥体内。如果一个顶点在视锥体内，那么它变换后的坐标必须满足：<br>$-w \le x \le w$<br>$-w \le y \le w$<br>$-w \le z \le w$<br>任何不满足上述条件的图元都需要被剔除或者裁剪。下图显示了经过上述投影矩阵后，视锥体的变化。<br><img src="/2018/10/20/Unity-Shader-IntroductionToTopic/4.jpg" title="在透视投影中，投影矩阵对顶点进行了缩放。"><br>从上图还可以注意到，裁剪矩阵会改变空间的旋向行；空间从右手坐标系变换到了左手坐标系。这意味着，离摄像机越远，z值将越大。</p><h5 id="正交投影"><a href="#正交投影" class="headerlink" title="正交投影"></a>正交投影</h5><img src="/2018/10/20/Unity-Shader-IntroductionToTopic/5.jpg" title="正交相机的参数对正交投影视锥体的影响"><p>正交投影的6个裁剪面和透视投影类似，在Unity中，它们也是由Camera组件中的参数和Game视图的横纵比共同决定。<br>正交投影的视锥体是一个长方体，因此计算上相比透视投影来说更加简单。由图可以看出，我们可以通过Camera组件的Size属性来改变视锥体竖直方向上高度的一般，而Clipping Planes中的Near和Far参数可以控制视锥体的近裁剪面和远裁剪面距离相机的远近。这样，可以求出视锥体近裁剪面和远裁剪面的高度，也就是：<br>$newClipPlaneHeight=2 \cdot Size$<br>$farClipPlaneHeight=nearClipPlaneHeight$</p><p>现在我们还缺乏横向的信息。同样，我们可以通过摄像机的横纵比得到。假设，当前摄像机的横纵比为Aspect，那么：<br>$nearClipPlaneWidth=Aspect \cdot nearClipPlaneHeight$<br>$farClipPlaneWidth=nearClipPlaneWidth$<br>现在，我们可以根据已知的Near、Far、Size和Aspect的值来确定正交投影的裁剪矩阵。如下：<br>$M_{prtho} =<br>\begin{bmatrix}<br>{1 \over Aspect \cdot Size}&amp;{0}&amp;{0}&amp;{0}\\<br>{0}&amp;{1 \over Size}&amp;{0}&amp;{0}\\<br>{0}&amp;{0}&amp;{-{2 \over Far-Near}}&amp;{-{Far+Near} \over {Far-Near}}\\<br>{0}&amp;{0}&amp;{0}&amp;{1}\\<br>\end{bmatrix}$</p><h4 id="屏幕空间"><a href="#屏幕空间" class="headerlink" title="屏幕空间"></a>屏幕空间</h4><p>经过投影矩阵的变换后，我们可以进行裁剪操作。当完成了所有的裁剪工作后，就需要进行真正的投影了，也就是说，我们需要把视锥体投影到<strong>屏幕空间（screen space）</strong>中。经过这一步变换，我们会得到真正的像素位置，而不是虚拟的三维坐标。<br>屏幕空间是一个二维空间，因此，我们必须把顶点从裁剪空间投影到屏幕空间中，来生成对应的2D坐标。这个过程可理解成有两个步骤。<br>首先，我们需要进行标准<strong>齐次除法（homogeneous division）</strong>，也被称为<strong>透视除法（perspective division）</strong>。虽然这个步骤听起来很陌生，但是它实际上非常简单，就是用齐次坐标系的w分量去除以x、y、z分量。在OpenGL中，我们把这一步得到的坐标叫做<strong>归一化的设备坐标（Normalized Device Coordinates，NDC）</strong>。经过这一步，我们可以把坐标从齐次裁剪坐标空间转换到NDC中。经过透视投影变换后的裁剪空间，经过齐次除法会变换到一个立方体内。按照OpenGL的传统，这个立方体的x、y、z分量的范围都是[-1,1]。但在DirectX这样的API中，z分量的范围会是[0,1]。而Unity选择了OpenGL这样的齐次裁剪空间。</p><img src="/2018/10/20/Unity-Shader-IntroductionToTopic/1.jpg" class="7.jpg% 经过齐次除法后，透视投影的裁剪空间会变换到一个立方体} #### 总结 顶点着色器的最基本的任务就是把顶点坐标从模型空间转换到裁剪空间中。 {% asset_img" title="渲染流水线中顶点的空间变化过程"> <img src="/2018/10/20/Unity-Shader-IntroductionToTopic/2.jpg" title="Unity中各个坐标空间的旋向性"><h3 id="一个最简单的顶点-片元着色器"><a href="#一个最简单的顶点-片元着色器" class="headerlink" title="一个最简单的顶点/片元着色器"></a>一个最简单的顶点/片元着色器</h3><h4 id="顶点-片元着色器的基本结构"><a href="#顶点-片元着色器的基本结构" class="headerlink" title="顶点/片元着色器的基本结构"></a>顶点/片元着色器的基本结构</h4><p>Unity Shader的基本结构包含了Shader、Properties、SubShader、Fallback等语义块。顶点/片元着色器的结构与之大体类似，它的结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;MyShaderName&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        // 属性</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        // 针对显卡A的SubShader</span><br><span class="line">        Pass &#123;</span><br><span class="line">            // 设置渲染状态和标签</span><br><span class="line"></span><br><span class="line">            // 开始CG代码片段</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            // 该片段的编译指令，例如:</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line"></span><br><span class="line">            // CG代码写在这里</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line"></span><br><span class="line">            // 其他设置</span><br><span class="line">        &#125;</span><br><span class="line">        // 其他需要的Pass</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        // 针对显卡B的SubShader</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 上述SubShader都失败后用于回调的Unity Shader</span><br><span class="line">    Fallback &quot;VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，最重要的部分是Pass语义块，我们绝大部分的代码都是写在这个语义块里面的。下面我们就来创建一个最简单的顶点/片元着色器。<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Shader</span> <span class="string">"Shader/Simple"</span> &#123;</span><br><span class="line">    <span class="section">SubShader</span> &#123;</span><br><span class="line">        <span class="section">Pass</span> &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="comment">#pragma vertex vert</span></span><br><span class="line">            <span class="comment">#pragma fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="attribute">float4</span> vert(float4 v : POSITION) : SV_POSITION &#123;</span><br><span class="line">                <span class="attribute">return</span> UnityObjectToClipPos(v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="attribute">fixed4</span> frag() : SV_Target&#123;</span><br><span class="line">                <span class="attribute">return</span> fixed4(<span class="number">1</span>.<span class="number">0</span>, <span class="number">1</span>.<span class="number">0</span>, <span class="number">1</span>.<span class="number">0</span>, <span class="number">1</span>.<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">"Shader/Simple1"</span>&#123;</span><br><span class="line">    SubShader&#123;</span><br><span class="line">        Pass&#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#pargma fragment frag</span></span><br><span class="line">            <span class="comment">// 使用一个结构体来定义顶点着色器的输入</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span> &#123;</span></span><br><span class="line">                <span class="comment">// POSITION语义告诉Unity，用模型空间的顶点坐标填充vertex变量</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模型数据从哪里来"><a href="#模型数据从哪里来" class="headerlink" title="模型数据从哪里来"></a>模型数据从哪里来</h4><h4 id="顶点着色器和片元着色器之间如何通信"><a href="#顶点着色器和片元着色器之间如何通信" class="headerlink" title="顶点着色器和片元着色器之间如何通信"></a>顶点着色器和片元着色器之间如何通信</h4><h4 id="如何使用属性"><a href="#如何使用属性" class="headerlink" title="如何使用属性"></a>如何使用属性</h4><h3 id="Unity提供的内置文件和变量"><a href="#Unity提供的内置文件和变量" class="headerlink" title="Unity提供的内置文件和变量"></a>Unity提供的内置文件和变量</h3><h4 id="内置的包含文件"><a href="#内置的包含文件" class="headerlink" title="内置的包含文件"></a>内置的包含文件</h4><h4 id="内置的变量"><a href="#内置的变量" class="headerlink" title="内置的变量"></a>内置的变量</h4><h3 id="Unity提供的CG-HLSL语义"><a href="#Unity提供的CG-HLSL语义" class="headerlink" title="Unity提供的CG/HLSL语义"></a>Unity提供的CG/HLSL语义</h3><h3 id="Unity支持的语义"><a href="#Unity支持的语义" class="headerlink" title="Unity支持的语义"></a>Unity支持的语义</h3><div class="table-container"><table><thead><tr><th>语义</th><th>描述</th></tr></thead><tbody><tr><td>POSITION</td><td>模型空间的顶点位置，通常是float4类型</td></tr><tr><td>NORMAL</td><td>顶点法线，通常是float3类型</td></tr><tr><td>TANGENT</td><td>顶点切线，通常是float4类型</td></tr><tr><td>$TEXCOORD_{n}$，如TEXCOORD0、TEXCOORD1</td><td>该顶点的纹理坐标，TEXCOORD0表示第一组纹理坐标，依此类推。通常是float2或float4类型</td></tr><tr><td>COLOR</td><td>顶点颜色，通常是fixed4或float4类型</td></tr></tbody></table></div><h4 id="如何定义复杂的变量类型"><a href="#如何定义复杂的变量类型" class="headerlink" title="如何定义复杂的变量类型"></a>如何定义复杂的变量类型</h4><h4 id="使用假彩色图形"><a href="#使用假彩色图形" class="headerlink" title="使用假彩色图形"></a>使用假彩色图形</h4><h4 id="float、half还是fixed"><a href="#float、half还是fixed" class="headerlink" title="float、half还是fixed"></a>float、half还是fixed</h4><p>在本书中，我们使用CG/HLSL来编写Unity Shader中的代码。而在CG/HLSL中，有3中精度的数值类型：float、half和fixed。这些精度将决定计算结果的数值范围。表5.8给出了这3中精度在通常情况下的数值范围。</p><p>CG/HLSL中3种精度的数值类型</p><div class="table-container"><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">精度</th></tr></thead><tbody><tr><td style="text-align:left">float</td><td style="text-align:left">最高精度的浮点值。通常使用32位来存储</td></tr><tr><td style="text-align:left">half</td><td style="text-align:left">中等精度的浮点值。通常用16位来存储，精度范围是-60000~+60000</td></tr><tr><td style="text-align:left">fixed</td><td style="text-align:left">最低精度的浮点值。通常使用11位来存储，精度方位是-2.0~+2.0</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> Unity Shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity Shader Manual</title>
      <link href="/2018/10/15/Unity-Shader-Manual/"/>
      <url>/2018/10/15/Unity-Shader-Manual/</url>
      
        <content type="html"><![CDATA[<h1 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;ShaderLab Tutorials/TestShader&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Range (&quot;My Range&quot;, Range(0.02, 0.15)) = 0.07 // sliders</span><br><span class="line">        _Color (&quot;My Color&quot;, Color) = (.34, .85, .92, 1) // color</span><br><span class="line">        _2D (&quot;My Texture 2D&quot;, 2D) = &quot;&quot; &#123;&#125; // texture</span><br><span class="line">        _Rect (&quot;My Rectangle&quot;, Rect) = &quot;name&quot; &#123;&#125;</span><br><span class="line">        _Cube (&quot;My Cubemap&quot;, Cube) = &quot;name&quot; &#123;&#125;</span><br><span class="line">        _Float (&quot;My Float&quot;, Float) = 1</span><br><span class="line">        _Vector (&quot;My Vector&quot;, Vector) = (1,2,3,4)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Shader在Unity编辑器暴露给美术的参数，通过Properties来实现。</li><li>所有可能的参数如上所示。主要也就是Float、Vector和Texture这3类。</li><li>除了通过编辑器编辑Properties，脚本也可以通过Material的接口（比如SetFloat、SetTexture编辑）</li><li>之后的Shader程序通过[name]（固定管线）或者直接name（可编程Shader）访问这些属性。</li><li>在每一个Property前面也能类似C#那样添加Attribute，以达到额外UI功能。详见<h1 id="Semantics"><a href="#Semantics" class="headerlink" title="Semantics"></a>Semantics</h1><h1 id="SubShader"><a href="#SubShader" class="headerlink" title="SubShader"></a>SubShader</h1><h2 id="Tags-“TagName1”-”Value1”-“TagName2”-”Value2”"><a href="#Tags-“TagName1”-”Value1”-“TagName2”-”Value2”" class="headerlink" title="Tags{“TagName1”=”Value1” “TagName2”=”Value2”}"></a>Tags{“TagName1”=”Value1” “TagName2”=”Value2”}</h2>Tag的语法结构，通过Tags{}来表示需要添加的标识，大括号可以添加多组Tag（所以才叫Tags嘛），名称(TagName)和值（Value）是成对出现的，并且全部用字符串表示。</li></ul><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>渲染队列直接影响性能中的重复绘制，合理的队列可极大的提升渲染效率。<br>渲染队列数目小于2500的对象都被认为是不透明的物体（从前往后渲染），高于2500的被任务是半透明物体（后后往前渲染）。<br>“Queue”=”Geometry+1”可通过值后加数字的方式来改变队列。</p><div class="table-container"><table><thead><tr><th>Queue标签</th><th>解释</th></tr></thead><tbody><tr><td>“Queue”=”Background”</td><td>值为1000，此队列的对象最先进行渲染</td></tr><tr><td>“Queue”=”Geometry”</td><td>默认值，值为2000，通常用于不透明对象，比如场景中的物体与角色等</td></tr><tr><td>“Queue”=”AlphaTest”</td><td>值为2450，要么完全透明要么完全不透明，多用于利用贴图来实现边缘透明的效果，也就是美术常说的透贴</td></tr><tr><td>“Queue”=”Transparent”</td><td>值为3000，常用于半透明对象，渲染时从后往前进行渲染，建议需要混合的对象放入此队列</td></tr><tr><td>“Queue”=”Overlay”</td><td>值为4000，此渲染队列用于叠加选过。最后渲染的东西应该放在这里（例如镜头光晕等）</td></tr></tbody></table></div><h2 id="RenderType"><a href="#RenderType" class="headerlink" title="RenderType"></a>RenderType</h2><p>用来区分这个Shader要渲染的对象是属于什么类型的，你可以想象成事我们把不同的物体按我们需要的类型来进行分类一样。<br>当然你也可以根据需要改成自定义的名称，这样并不会影响到Shader的选过。<br>此Tag多用于摄像机的替换材质功能（Camera.SetReplacementShader）。</p><div class="table-container"><table><thead><tr><th>标签</th><th>释义</th></tr></thead><tbody><tr><td>“RenderType”=”Opaque”</td><td>大多数不透明着色器</td></tr><tr><td>“RenderType”=”Transparent”</td><td>大多数半透明着色器，比如粒子、特效、字体等。</td></tr><tr><td>“RenderType”=”TransparentCutout”</td><td>透贴着色器，多用于植被等。</td></tr><tr><td>“RenderType”=”Background”</td><td>多用于天空盒着色器。</td></tr><tr><td>“RenderType”=”Overlay”</td><td>GUI、光晕着色器等。</td></tr><tr><td>“RenderType”=”TreeOpaque”</td><td>Terrain地形中的树干。</td></tr><tr><td>“RenderType”=”TreeTransparentCutout”</td><td>Treeain地形中的树叶。</td></tr><tr><td>“RenderType”=”TreeBillboard”</td><td>Terrain地形中的永对面树。</td></tr><tr><td>“RenderType”=”Grass”</td><td>Terrain地形中的草。</td></tr><tr><td>“RenderType”=”GrassBillboard”</td><td>Terrain地形中的用对面草。</td></tr></tbody></table></div><p>指定RenderType的名称，主要是为了配合使用替代渲染的方法。</p><pre><code>Camera.SetReplacementShader(&quot;shader&quot;, &quot;RenderType&quot;)</code></pre><h2 id="DisableBatching"><a href="#DisableBatching" class="headerlink" title="DisableBatching"></a>DisableBatching</h2><p>在利用Shader在模型的定点本地坐标下做一些位移动画，而当此模型有批处理时会出现效果不正确的情况，这是因为批处理将所有模型转换为世界坐标空间，因为”本地坐标空间”将丢失。</p><div class="table-container"><table><thead><tr><th>批处理标签</th><th>解释</th></tr></thead><tbody><tr><td>“DisableBatching”=”True”</td><td>禁止批处理</td></tr><tr><td>“DisableBatching”=”False”</td><td>不禁用批处理</td></tr></tbody></table></div><h1 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h1><h2 id="dot-a-b"><a href="#dot-a-b" class="headerlink" title="dot(a,b)"></a>dot(a,b)</h2><p>点乘，a和b必须为三维向量或者四维向量，其计算结果是两个向量夹角的余弦值，相当于a.x*b.x+a.y*b.y+a.z*b.z<br>a和b的位置无所谓前后，结果都是一样的</p><h1 id="Miscellaneous"><a href="#Miscellaneous" class="headerlink" title="Miscellaneous"></a>Miscellaneous</h1><pre><code>float3 objCenterPos = mul(unity_ObjectToWorld, float4(0,0,0,1)).xyz;</code></pre><p>在Shader中获取当前模型的中心点，其实就是将(0,0,0)点从本地坐标转换到世界空间坐标下即可。</p><h1 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h1><div class="table-container"><table><thead><tr><th>Name</th><th>Syntax</th><th>参数释义</th><th>Description</th></tr></thead><tbody><tr><td>abs</td><td>abs(x)</td><td></td><td>Absolute value (per component)(每个组件).</td></tr><tr><td>acos</td><td>acos(x)</td><td></td><td>Returns the arccosine(反余弦) of each component of x.</td></tr><tr><td>ceil</td><td>ceil(x)</td><td></td><td>Returns the smallest integer(最小整数) which is greater(大于) than or equal to x.</td></tr><tr><td>clip</td><td>clip(x)</td><td></td><td>Discards(抛弃) the current pixel,if any component of x is less than zero.</td></tr><tr><td>cross</td><td>cross(x,y)</td><td></td><td>x向量和y向量的向量积（差积）</td></tr><tr><td>lerp</td><td>lerp(x,y,s)</td><td></td><td>Returns x + s(y-x)</td></tr><tr><td>noise</td><td>noise(x)</td><td></td><td>Generates a random value using the Perlin-noise algorithm.</td></tr><tr><td>pow</td><td>pow(x,y)</td><td></td><td>Returns $x^y$</td></tr><tr><td>saturate</td><td>saturate(x)</td><td>x: 为用于操作的标量或矢量，可以是float、float2、float3等类型。</td><td>把x截取在[0,1]范围内，如果x是一个矢量，那么会对它的每一个分量进行这样的操作。</td></tr><tr><td>smoothstep</td><td>smoothstep(min,max,x)</td><td></td><td>如果x比min小，返回0；如果x比max大，返回1；如果x处于范围[min,max]中，则返回0和1之间的值（返回值在min和max间的比例）。</td></tr><tr><td>step</td><td>step(a,b)</td><td></td><td>Returns (b&gt;=a)?1:0 (一般用这个取代if else)</td></tr><tr><td>tex2D</td><td>tex2D(s, t)</td><td></td><td>2D texture lookup.</td></tr><tr><td>reflect</td><td>reflect(I,N)</td><td></td><td>根据入射光方向向量I，和顶点法向量N，计算反射光方向向量。其中I和N必须被归一化，需要非常注意的是，这个I是指向顶点的；函数只对三元向量有效</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> Unity Shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TSF4G</title>
      <link href="/2018/09/21/TSF4G/"/>
      <url>/2018/09/21/TSF4G/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/johnnyluo586/TSF4G.git" target="_blank" rel="noopener">https://github.com/johnnyluo586/TSF4G.git</a></p><h1 id="Tbus简介"><a href="#Tbus简介" class="headerlink" title="Tbus简介"></a>Tbus简介</h1><p>Tbus是tsf4g(Tencent ServiceFramework for Game,腾讯游戏服务框架)中的基础组件之一，主要的目的是为上层业务提供统一的线程或进程间通信接口，屏蔽本地进程间通信以及远程进程通信的细节，让开发人员可以集中精力关注业务逻辑，是tsf4g重要组成部分。</p><h1 id="Tbus原理"><a href="#Tbus原理" class="headerlink" title="Tbus原理"></a>Tbus原理</h1><p> Tbus基于共享内存构建无锁双通循环消息队列，发送的双方通过专用的读写队列完成数据收发，实现本地进程或者远程进程间通信。通信双方使用的两个队列称之为tbus通道(channel)，每一组通讯的双方就需要有一个tbus通道。</p><p> 进程A发送消息后，消息被存储到Host A的发送队列中，部署于Host A的tbusd发现队列中存在消息，则从队列中把消息取出，通过tcp发送到Host B上。Host B上的tbusd接收到消息后，把消息写入本地的接收队列，以供进程B读取。</p><p> 为了能完成通信，Tbus还有以下几个特点：<br> 通信双方具备全局唯一的tbus通信地址，该地址是一个点分十进制的字符串，与IP地址类型，总长度为32bit，分为4段，每段bit位数可以自定义，总长度不超过32bit。例如：128.1.100.1,5.0.200.1。</p><p> Tbus通道以及消息是存储在共享内存中，必须要使用相应的工具提前创建，进程才能绑定与使用。而当业务进程异常退出后，由于消息是存储在共享内存中，只要不主动清理共享内存、重启服务器或损坏共享内存，通道的消息就不会丢失。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Server </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity-Lua-Manual</title>
      <link href="/2018/09/18/Unity-Lua-Manual/"/>
      <url>/2018/09/18/Unity-Lua-Manual/</url>
      
        <content type="html"><![CDATA[<h2 id="GameObject"><a href="#GameObject" class="headerlink" title="GameObject"></a>GameObject</h2><h3 id="GO-name"><a href="#GO-name" class="headerlink" title="GO_name"></a>GO_name</h3><pre><code>gameObject.GO_name = &quot;name&quot;</code></pre><p>设置或者获取游戏对象的名字</p><h3 id="GO-self"><a href="#GO-self" class="headerlink" title="GO_self"></a>GO_self</h3><pre><code>gameObject.GO_self</code></pre><p>绑定到自己身上的Lua模块指针</p><h3 id="GO-active"><a href="#GO-active" class="headerlink" title="GO_active"></a>GO_active</h3><pre><code>gameObject.GO_active = true/false</code></pre><p>设置游戏对象的显式或者隐藏</p><h3 id="GO-parent"><a href="#GO-parent" class="headerlink" title="GO_parent"></a>GO_parent</h3><pre><code>gameObject.GO_parent = parent</code></pre><p>设置游戏对象的父节点</p><h3 id="GO-childCount"><a href="#GO-childCount" class="headerlink" title="GO_childCount"></a>GO_childCount</h3><pre><code>gameObject.GO_childCount</code></pre><p>获取游戏对象的子节点对象，不递归</p><h3 id="GO-AddComponent"><a href="#GO-AddComponent" class="headerlink" title="GO_AddComponent"></a>GO_AddComponent</h3><pre><code>gameObject:GO_AddComponent(“UILabel&quot;)</code></pre><p>给游戏对象添加组件</p><h3 id="GO-GetComponent"><a href="#GO-GetComponent" class="headerlink" title="GO_GetComponent"></a>GO_GetComponent</h3><pre><code>gameObject:GO_GetComponent(&quot;UILabel&quot;)gameObject:GO_GetComponent(&quot;UILabel&quot;, &quot;Sprite/Label&quot;)</code></pre><p>方法一：获取游戏对象的组件<br>方法二：获取子节点上的组件，参数二表示相对于父节点的路径</p><h3 id="GO-Find"><a href="#GO-Find" class="headerlink" title="GO_Find"></a>GO_Find</h3><pre><code>gameObject:GO_Find(&quot;Sprite/Label&quot;)</code></pre><p>获取子节点对象</p><h3 id="GO-AddChild"><a href="#GO-AddChild" class="headerlink" title="GO_AddChild"></a>GO_AddChild</h3><pre><code>gameObject:GO_AddChild(&quot;UI/ui_node&quot;)gameObject:GO_AddChild(ui_node)</code></pre><p>方法一：通过相对于Resources下的路径来给游戏对象添加子节点<br>方法二：通过实例对象来给游戏对象添加子节点<br>如果是UI节点，请使用<strong><em>UI_AddChild</em></strong></p><h3 id="UI-AddChild"><a href="#UI-AddChild" class="headerlink" title="UI_AddChild"></a>UI_AddChild</h3><pre><code>gameObject:UI_AddChild(&quot;UI/ui_node&quot;)gameObject:UI_AddChild(ui_node)    </code></pre><p>方法一：通过相对于Resources下的路径来给游戏对象添加子节点<br>方法二：通过实例对象来给游戏对象添加子节点</p><h3 id="GO-DelChild"><a href="#GO-DelChild" class="headerlink" title="GO_DelChild"></a>GO_DelChild</h3><pre><code>gameObject:GO_DelChild(idx)</code></pre><p>删除游戏对象的子节点，idx是下标从0开始的索引（顺序是检视面板显示的顺序）</p><h3 id="GO-DestroySelf"><a href="#GO-DestroySelf" class="headerlink" title="GO_DestroySelf"></a>GO_DestroySelf</h3><pre><code>gameObject:GO_DestroySelf()</code></pre><p>销毁自己</p><h3 id="GO-RemoveAllChildren"><a href="#GO-RemoveAllChildren" class="headerlink" title="GO_RemoveAllChildren"></a>GO_RemoveAllChildren</h3><pre><code>gameObject:GO_RemoveAllChildren()</code></pre><p>销毁所有的子节点</p><h3 id="GO-ShowAllChildren"><a href="#GO-ShowAllChildren" class="headerlink" title="GO_ShowAllChildren"></a>GO_ShowAllChildren</h3><pre><code>gameObject:GO_ShowAllChildren(ture/false)</code></pre><p>显示或者隐藏自己所有的子节点</p><h3 id="GO-GetLocalPosition"><a href="#GO-GetLocalPosition" class="headerlink" title="GO_GetLocalPosition"></a>GO_GetLocalPosition</h3><pre><code>local x,y,z = gameObject:GO_GetLocalPosition()</code></pre><p>获取自己的localPosition</p><h3 id="GO-SetLocalPosition"><a href="#GO-SetLocalPosition" class="headerlink" title="GO_SetLocalPosition"></a>GO_SetLocalPosition</h3><pre><code>gameObject:GO_SetLocalPosition(x,y [,z])</code></pre><p>设置自己的localPosition,[] 表示可选参数,当未指定时表示使用之前的z</p><h3 id="GO-GetLocalRotation"><a href="#GO-GetLocalRotation" class="headerlink" title="GO_GetLocalRotation"></a>GO_GetLocalRotation</h3><pre><code>local x,y,z = gameObject:GO_GetLocalRotation()</code></pre><p>获取自己的localRotation</p><h3 id="GO-SetLocalRotation"><a href="#GO-SetLocalRotation" class="headerlink" title="GO_SetLocalRotation"></a>GO_SetLocalRotation</h3><pre><code>gameObject:GO_SetLocalRotation(x,y [,z])</code></pre><p>设置自己的localRotation,[]表示可选参数,当未指定时表示使用之前的z</p><h3 id="GO-SetLocalScale"><a href="#GO-SetLocalScale" class="headerlink" title="GO_SetLocalScale"></a>GO_SetLocalScale</h3><pre><code>gameObject:GO_SetLocalScale(x,y,z)</code></pre><p>设置自己的localScale</p><h3 id="GO-UpdateAllAnchors"><a href="#GO-UpdateAllAnchors" class="headerlink" title="GO_UpdateAllAnchors"></a>GO_UpdateAllAnchors</h3><pre><code>gameObject:GO_UpdateAllAnchors()</code></pre><p>手动刷新自身的锚点</p><h3 id="UI-active"><a href="#UI-active" class="headerlink" title="UI_active"></a>UI_active</h3><pre><code>gameObject.UI_active = true/false</code></pre><p>递归刷新自己和子节点的显示和隐藏，如无特殊要求请使用<strong><em>GO_active</em></strong></p><h3 id="UI-onClick"><a href="#UI-onClick" class="headerlink" title="UI_onClick"></a>UI_onClick</h3><pre><code>gameObject.UI_onClick = function()end</code></pre><p>添加点击事件，游戏对象需要添加boxcollider2D</p><h3 id="UIToggle-onChange"><a href="#UIToggle-onChange" class="headerlink" title="UIToggle_onChange"></a>UIToggle_onChange</h3><pre><code>gameObject.UIToggle_onChange = function()end</code></pre><p>添加Toggle状态改变的回调函数，游戏对象需要添加UIToggle</p><h3 id="UILabel-text"><a href="#UILabel-text" class="headerlink" title="UILabel_text"></a>UILabel_text</h3><pre><code>gameObject.UILabel_text = &quot;Hello, World!&quot;</code></pre><p>设置或者读取游戏对象的UILabel文本，游戏对象需要添加UILabel</p><h3 id="UILabel-color"><a href="#UILabel-color" class="headerlink" title="UILabel_color"></a>UILabel_color</h3><pre><code>gameObject.UILabel_color = Color.FromHex(&quot;C4C4C4FF&quot;)</code></pre><p>设置或者读取文本颜色，返回值是Color</p><h3 id="UISprite-spriteName"><a href="#UISprite-spriteName" class="headerlink" title="UISprite_spriteName"></a>UISprite_spriteName</h3><pre><code>gameObject.UISprite_spriteName = &quot;btn_blue&quot;</code></pre><p>设置或者读取精灵的名字，游戏对象需要添加UISprite组件</p><h3 id="UISprite-color"><a href="#UISprite-color" class="headerlink" title="UISprite_color"></a>UISprite_color</h3><pre><code>gameObject.UISprite_color = Color.FormHex(&quot;6f4f3fff&quot;)</code></pre><p>设置或者读取精灵的颜色，游戏对象需要添加UISprite组件</p><h3 id="UIToggle-value"><a href="#UIToggle-value" class="headerlink" title="UIToggle_value"></a>UIToggle_value</h3><pre><code>gameObject.UIToggle_value = true/false</code></pre><p>设置UIToggle的值</p><h3 id="UIWidget-color"><a href="#UIWidget-color" class="headerlink" title="UIWidget_color"></a>UIWidget_color</h3><pre><code>gameObject.UIWidget_color = Color.FormHex(&quot;6f4f3fff&quot;)</code></pre><p>设置UIWidget或者继承他的子类（UILabel,UISprite)的颜色</p><h3 id="UIWidget-width"><a href="#UIWidget-width" class="headerlink" title="UIWidget_width"></a>UIWidget_width</h3><pre><code>gameObject.UIWidget_width = 100</code></pre><p>设置UIWidget或者继承他的子类（UILabel,UISprite)的宽度</p><h3 id="UIWidget-height"><a href="#UIWidget-height" class="headerlink" title="UIWidget_height"></a>UIWidget_height</h3><pre><code>gameObject.UIWidget_height = 100</code></pre><p>设置UIWidget或者继承他的子类的高度</p><h3 id="UIGrid-Reposition"><a href="#UIGrid-Reposition" class="headerlink" title="UIGrid_Reposition"></a>UIGrid_Reposition</h3><pre><code>gameObject:UIGrid_Reposition()</code></pre><p>使Grid重新排序，一般给Grid添加了子节点后使用</p><h3 id="Tween-Play"><a href="#Tween-Play" class="headerlink" title="Tween_Play"></a>Tween_Play</h3><pre><code>gameObject:Tween_Play()</code></pre><p>播放Tween动画</p><h2 id="MB"><a href="#MB" class="headerlink" title="MB"></a>MB</h2><h3 id="MB-Log"><a href="#MB-Log" class="headerlink" title="MB.Log"></a>MB.Log</h3><pre><code>MB.Log(&quot;Hello,World!&quot;)</code></pre><p>打印日志</p><h3 id="MB-PCall"><a href="#MB-PCall" class="headerlink" title="MB.PCall"></a>MB.PCall</h3><pre><code>MB.PCall(function()end)</code></pre><p>安全的调用函数，当函数内部发生错误的时候，不会中断当前执行环境</p><h3 id="MB-LoadModule"><a href="#MB-LoadModule" class="headerlink" title="MB.LoadModule"></a>MB.LoadModule</h3><pre><code>MB.LoadModule(&quot;ui_task&quot;)</code></pre><p>加载一个lua模块</p><h3 id="MB-ShowTheTip"><a href="#MB-ShowTheTip" class="headerlink" title="MB.ShowTheTip"></a>MB.ShowTheTip</h3><pre><code>MB.ShowTheTip(&quot;Hello,World!&quot;, 2)</code></pre><p>弹出Tips，第二个参数表示时长单位是秒</p><h3 id="String-CSFormat"><a href="#String-CSFormat" class="headerlink" title="String.CSFormat"></a>String.CSFormat</h3><pre><code>String.CSFormat(&quot;id={0},name={1}&quot;,10,&quot;test&quot;)</code></pre><p>调用C#的格式化函数</p><h3 id="MB-GetStringX"><a href="#MB-GetStringX" class="headerlink" title="MB.GetStringX"></a>MB.GetStringX</h3><pre><code>MB.GetStringX(bytes[], 10, &quot;test&quot;)</code></pre><p>调用C#的格式化函数，第一个参数是byte数组，一般来说表格中的字段用它</p><h3 id="MB-GetExcelList"><a href="#MB-GetExcelList" class="headerlink" title="MB.GetExcelList"></a>MB.GetExcelList</h3><pre><code>MB.GetExcelList(&quot;NewTaskResConf&quot;)</code></pre><p>读取表格</p><h3 id="MB-GO-GetResource"><a href="#MB-GO-GetResource" class="headerlink" title="MB.GO_GetResource"></a>MB.GO_GetResource</h3><pre><code>self.u_testSprite.atlas = MB.GO_GetResource(&quot;UI/01Common&quot;)</code></pre><p>获取资源 参数表示相对于Resources的路径，返回的是GameObject</p><h2 id="UITexture"><a href="#UITexture" class="headerlink" title="UITexture"></a>UITexture</h2><h3 id="SetTexturePath"><a href="#SetTexturePath" class="headerlink" title="SetTexturePath"></a>SetTexturePath</h3><pre><code>texture:SetTexturePath(&quot;Texture/UI/Chapter1&quot;)</code></pre><p>设置texture的资源路径，路径相对于Resources，texture是通过gameObject获取的组件</p><h3 id="SetMat"><a href="#SetMat" class="headerlink" title="SetMat"></a>SetMat</h3><pre><code>texture:SetMat(path)</code></pre><p>设置texture的材质，path表示相对Resources路径</p><h2 id="UILable"><a href="#UILable" class="headerlink" title="UILable"></a>UILable</h2><h3 id="text"><a href="#text" class="headerlink" title="text"></a>text</h3><pre><code>label.text = &quot;Hello, World！&quot;</code></pre><p>设置或者读取Label的文本</p><h3 id="color"><a href="#color" class="headerlink" title="color"></a>color</h3><pre><code>label.color = Color.FromHex(&quot;6F4F3FFF&quot;)</code></pre><p>设置或者读取Label的颜色</p><h3 id="effectColor"><a href="#effectColor" class="headerlink" title="effectColor"></a>effectColor</h3><pre><code>label.effectColor = Color.FromHex(&quot;6F4F3FFF&quot;)</code></pre><p>设置或者读取Label的效果颜色</p><h3 id="fontSize"><a href="#fontSize" class="headerlink" title="fontSize"></a>fontSize</h3><pre><code>label.fontSize = 20</code></pre><p>设置或者读取字体的大小</p><h2 id="UISprite"><a href="#UISprite" class="headerlink" title="UISprite"></a>UISprite</h2><h3 id="spriteName"><a href="#spriteName" class="headerlink" title="spriteName"></a>spriteName</h3><pre><code>sprite.spriteName = &quot;btn_red&quot;</code></pre><p>设置或者读取Sprite的名字（图集中的）</p><h3 id="width"><a href="#width" class="headerlink" title="width"></a>width</h3><pre><code>sprite.width = 100</code></pre><p>设置或者读取Sprite的宽度</p><h3 id="height"><a href="#height" class="headerlink" title="height"></a>height</h3><pre><code>sprite.height = 100</code></pre><p>设置或者读取Sprite的高度</p><h3 id="atlas"><a href="#atlas" class="headerlink" title="atlas"></a>atlas</h3><pre><code>sprite.atlas = MB.GO_GetResource(&quot;UI/01Common&quot;)</code></pre><p>设置或者读取图集</p><h2 id="LuaEvent"><a href="#LuaEvent" class="headerlink" title="LuaEvent"></a>LuaEvent</h2><p>C#中</p><pre><code>LuaEvent.CallEvent((int)eLuaEvnet.eLuaEvent_PlayerTaskUpdate, param1, param2, param3);</code></pre><p>lua中</p><pre><code>lua_event.InvokeEvent(lua_def.eLuaEvent_PlayerTaskUpdate, param1, param2, param3)lua_event.InsertEvent(lua_def.eLuaEvent_PlayerTaskUpdate, callback, name, 0)function callback(param1, param2, param3)end</code></pre><p>CallEvent表示C#事件通知Lua<br>InvokeEvent表示Lua事件通知Lua<br>LuaEvent.CallEvent中的第一个参数表示类型在obj_def.cs中定义，后面是需要传递给lua的参数</p><h2 id="lua-net"><a href="#lua-net" class="headerlink" title="lua_net"></a>lua_net</h2><h3 id="SendBin"><a href="#SendBin" class="headerlink" title="SendBin"></a>SendBin</h3><pre><code>lua_net.SendBin(lua_def.CS_CMD_GET_TASK_LIST_REQ, {Page = 1, Type = 4}, callback)function callback(msg)end</code></pre><p>发送二进制包，第一个参数是消息ID，第二个参数是相对于数据结构类型，callback是回调函数，可选类型<br>回调函数中的msg表示一个json的xml中结构。</p><h3 id="Send"><a href="#Send" class="headerlink" title="Send"></a>Send</h3><pre><code>lua_net.Send(lua_def.eCTS_UI_Task, {op = &quot;get&quot;})</code></pre><p>发送JSON包，第一个参数是cts_def.cs中定义的消息，第二个参数是lua table</p><h3 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h3><pre><code>lua_net.Register(lua_def.eSTC_UI_Task, OnUITaskHandle, signal, -1)function OnUITaskHandler(msg)endlua_net.Register(lua_def.CS_CMD_GET_TASK_LIST_RES, OnGetTaskListRes, signal, -1)function OnGetTaskListRes(msg) -- msg是xml生成的数据结构，传到lua里面是一个json tableend</code></pre><p>注册一个消息回调，signal表示一个回调的唯一句柄，-1表示调用该回调函数的顺序，默认是0</p><h2 id="lua-timer"><a href="#lua-timer" class="headerlink" title="lua_timer"></a>lua_timer</h2><pre><code>lua_timer.Timer(self.gameObject, span, onTick, count, name)</code></pre><p>— 创建Timer对象<br>— go : 指定挂到某个gameObject上<br>— span : 时间间隔，毫秒<br>— onTick : 回调函数(timer, dt)，回调的dt参数是超时的时间，一般也用不上<br>— count : 重复次数，缺省是1，如果是-1则无限循环。<br>— <em>return</em> : 返回一个lua table作为Timer</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>luajit</title>
      <link href="/2018/09/10/luajit/"/>
      <url>/2018/09/10/luajit/</url>
      
        <content type="html"><![CDATA[<p>JIT = Just In Time<br>IOS中禁止使用（不让自主申请内存）</p><h2 id="解释执行："><a href="#解释执行：" class="headerlink" title="解释执行："></a>解释执行：</h2><ul><li>效率低</li><li>代码暴露</li></ul><h2 id="静态编译"><a href="#静态编译" class="headerlink" title="静态编译"></a>静态编译</h2><ul><li>不够灵活，无法热更新</li><li>平台兼容性差</li></ul><h2 id="JIT："><a href="#JIT：" class="headerlink" title="JIT："></a>JIT：</h2><ul><li>效率：高于解释执行，低于静态编译。</li><li>安全性：一般都先转换成字节码</li><li>热更新：无论源码还是字节码本质都是自愿文件。</li><li>兼容性：虚拟机会处理平台差异，对用户透明。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Andorid NDK</title>
      <link href="/2018/07/21/Android-NDK/"/>
      <url>/2018/07/21/Android-NDK/</url>
      
        <content type="html"><![CDATA[<h3 id="JNI"><a href="#JNI" class="headerlink" title="JNI"></a>JNI</h3><p>JNI的全称是Java Native Interface，Java原生接口。提供别的代码调用的一组函数。首先使用C++写出了一些函数，然后将这些函数在Java类中再声明一次（加上关键字native），这样Java类中的函数和C++中的函数就匹配到一起了，我们使用Java类中的函数，其实就是使用C++中的函数。这个在Java类中声明的函数就是一个JNI。</p><h3 id="NDK"><a href="#NDK" class="headerlink" title="NDK"></a>NDK</h3><p>NDK的全称是Native Development Kit，原生开发工具包。</p><h3 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h3><p>交叉编译就是在一个平台上生成另一个平台上的可执行代码。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AndroidManifest.xml详解</title>
      <link href="/2018/07/21/AndroidManifest/"/>
      <url>/2018/07/21/AndroidManifest/</url>
      
        <content type="html"><![CDATA[<ul><li>为应用的JAVA软件包命名。软件包名称充当应用的唯一标识符</li><li>描述应用的各个组件，包括构成应用的Activity、服务、广播接收器和内容提供程序。它还为实现每个组件的类命名并发布其功能，例如它们可以处理Intent消息。这些声明向Android系统告知有关组件以及可以启动这些组件的条件的信息。</li><li>确定托管应用组件的进程。</li><li>声明应用必须具备哪些权限才能访问API中受保护的部分并与其他应用交互。还声明其他应用与该应用组件交互所需具备的权限。</li><li>列出Instrumentation类，这些类可在应用运行时提供分析和其他信息。这些声明只会在应用处于开发阶段时出现在清单中，在应用发布之前会将移除。</li><li>声明应用所需的最低Android API级别。</li><li>列出应用必须链接到的库</li></ul><h3 id="元素"><a href="#元素" class="headerlink" title="元素"></a><manifest>元素</manifest></h3><p>首先，所有的xml都必须包含<manifest>元素。这是文件的根节点。它必须要包含<application>元素，并且指明xmlns:android和package属性。</application></manifest></p><p>xmlns:android<br>这个属性定义了Android命名空间。必须设置成”<a href="http://schemas.android.com/apk/res/android&quot;。不要手动修改。" target="_blank" rel="noopener">http://schemas.android.com/apk/res/android&quot;。不要手动修改。</a></p><p>package<br>这是一个完整的Java语言风格包名。包名由英文字母（大小写均可）、数字和下划线组成。每个独立的名字必须以字母开头。</p><p>构建APK的时候，构建系统使用这个属性来做两件事：</p><ol><li>生成R.java类时用这个名字作为命名空间（用于访问APP的资源）比如：package被设置成net.pixelgame.unity3d</li></ol><p>android:name<br>该属性以字符串形式指定了APP要用的硬件或软件功能。</p><p>android:required</p><p>andorid:glEsVersion</p><p><application>元素</application></p><p>此元素描述了应用的配置。这是一个必备的元素，它包含了很多子元素来描述应用的组件，它的属性影响到所有的子组件。许多属性</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Protocol Buffer</title>
      <link href="/2018/07/21/Protocol/"/>
      <url>/2018/07/21/Protocol/</url>
      
        <content type="html"><![CDATA[<p>高效的二进制方式存储<br>Varint是一种紧凑的表示数字的方法。它用一个或多个字节来表示一个数字，值越少的数字使用越少的字节数。<br>采用这种Key-Pair结构无需使用分隔符来分割不同的Field。</p><div class="table-container"><table><thead><tr><th style="text-align:left">Type</th><th style="text-align:left">Meaning</th><th style="text-align:left">Used For</th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:left">Varint</td><td style="text-align:left">int32,int64,uint32,uint64,sint32,sint64,bool,enum</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">64-bit</td><td style="text-align:left">fixed64</td><td>sfixed64,double</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">Length-delimi</td><td style="text-align:left">string,bytes,embedded messages,packed repeated fields</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">Start group</td><td style="text-align:left">Groups(deprecated)</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">End group</td><td style="text-align:left">Groups(deprecated)</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">32-bit</td><td style="text-align:left">fixed32,sfixed32,float</td></tr></tbody></table></div><p>在计算机内，一个负数一般会被表示一个很大的整数，因为计算机定义负数的符号位为数字的最高位。如果采用Varint表示一个负数，那么一定需要5个byte。为此Google Protocol Buffer定义了sint32这种类型，采用zigzag编码。</p><p>Zigzag编码用无符号来表示有符号数字，正数和负数交错，这就是zigzag这个词的含义了。</p><p><img src="http://oxcvfpext.bkt.clouddn.com/Protocol-1.jpg"></p><p>使用zigzag编码，绝对值小的数字，无论正负都可以采用较少的byte来表示，充分利用了Varint这种技术。</p><p>其他的数据类型，比如字符串则采用类似数据库中的varchar的表示方法，即用一个varint表示长度，然后其余部分紧跟在这个长度部分之后即可。</p><h3 id="封解包的速度"><a href="#封解包的速度" class="headerlink" title="封解包的速度"></a>封解包的速度</h3><p>首先来了解一下XML的封解包过程。XML需要从文件中读取字符串，再转换为XML文档对象结构模型。之后，再从XML文档对象结构模型中读取指定节点的字符串，最后再将这个字符串转换成指定类型的变量。这个过程非常复杂，其中将XML文件转换为文档对象结构模型的过程通常需要完成词法文法分析等大量消耗CPU的复杂计算。</p><p>反观Protobuf，它只需要简单地将一个二进制序列，按照指的格式读取到C++对应的结构类型中就可以了。从上一节的描述可以看到消息的decoding过程也可以通过几个位移操作组成的表达式计算即可完成。速度非常快。</p><h3 id="T-L-V的数据存储方式"><a href="#T-L-V的数据存储方式" class="headerlink" title="T-L-V的数据存储方式"></a>T-L-V的数据存储方式</h3><p>Tag-Lenght-Value,标识-长度-字段值存储方式</p><p>标识-长度-字段值表示单个数据，最终将所有数据拼接成一个字节流，从而实现数据存储的功能</p><ul><li>其中Length可选存储，如存储Varint编码数据就不需要存储Length</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CameraEditor</title>
      <link href="/2018/07/11/CameraEditor/"/>
      <url>/2018/07/11/CameraEditor/</url>
      
        <content type="html"><![CDATA[<p>Floder:Editor\Mono\Inspector<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unity C# reference source</span></span><br><span class="line"><span class="comment">// Copyright (c) Unity Technologies. For terms of use, see</span></span><br><span class="line"><span class="comment">// https://unity3d.com/legal/licenses/Unity_Reference_Only_License</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Rendering;</span><br><span class="line"><span class="keyword">using</span> AnimatedBool = UnityEditor.AnimatedValues.AnimBool;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Scripting;</span><br><span class="line"><span class="keyword">using</span> UnityEditor.Modules;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">UnityEditor</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">CustomEditor(typeof(Camera))</span>]</span><br><span class="line">    [<span class="meta">CanEditMultipleObjects</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CameraEditor</span> : <span class="title">Editor</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Settings</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">private</span> SerializedObject m_SerializedObject;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Settings</span>(<span class="params">SerializedObject so</span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                m_SerializedObject = so;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Manually entered rendering path names/values, since we want to show them</span></span><br><span class="line">            <span class="comment">// in different order than they appear in the enum.</span></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> GUIContent[] kCameraRenderPaths =</span><br><span class="line">            &#123;</span><br><span class="line">                EditorGUIUtility.TrTextContent(<span class="string">"Use Graphics Settings"</span>),</span><br><span class="line">                EditorGUIUtility.TrTextContent(<span class="string">"Forward"</span>),</span><br><span class="line">                EditorGUIUtility.TrTextContent(<span class="string">"Deferred"</span>),</span><br><span class="line">                EditorGUIUtility.TrTextContent(<span class="string">"Legacy Vertex Lit"</span>),</span><br><span class="line">                EditorGUIUtility.TrTextContent(<span class="string">"Legacy Deferred (light prepass)"</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="keyword">int</span>[] kCameraRenderPathValues =</span><br><span class="line">            &#123;</span><br><span class="line">                (<span class="keyword">int</span>)RenderingPath.UsePlayerSettings,</span><br><span class="line">                (<span class="keyword">int</span>)RenderingPath.Forward,</span><br><span class="line">                (<span class="keyword">int</span>)RenderingPath.DeferredShading,</span><br><span class="line">                (<span class="keyword">int</span>)RenderingPath.VertexLit,</span><br><span class="line">                (<span class="keyword">int</span>)RenderingPath.DeferredLighting</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> SerializedProperty clearFlags &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">            <span class="keyword">public</span> SerializedProperty backgroundColor &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">            <span class="keyword">public</span> SerializedProperty normalizedViewPortRect &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">            <span class="keyword">public</span> SerializedProperty fieldOfView &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">            <span class="keyword">public</span> SerializedProperty orthographic &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">            <span class="keyword">public</span> SerializedProperty orthographicSize &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">            <span class="keyword">public</span> SerializedProperty depth &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">            <span class="keyword">public</span> SerializedProperty cullingMask &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">            <span class="keyword">public</span> SerializedProperty renderingPath &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">            <span class="keyword">public</span> SerializedProperty occlusionCulling &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">            <span class="keyword">public</span> SerializedProperty targetTexture &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">            <span class="keyword">public</span> SerializedProperty HDR &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">            <span class="keyword">public</span> SerializedProperty allowMSAA &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">            <span class="keyword">public</span> SerializedProperty allowDynamicResolution &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">            <span class="keyword">public</span> SerializedProperty stereoConvergence &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">            <span class="keyword">public</span> SerializedProperty stereoSeparation &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">            <span class="keyword">public</span> SerializedProperty nearClippingPlane &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">            <span class="keyword">public</span> SerializedProperty farClippingPlane &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> SerializedProperty targetDisplay &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> SerializedProperty targetEye &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> GUIContent[] kTargetEyes =</span><br><span class="line">            &#123;</span><br><span class="line">                EditorGUIUtility.TrTextContent(<span class="string">"Both"</span>),</span><br><span class="line">                EditorGUIUtility.TrTextContent(<span class="string">"Left"</span>),</span><br><span class="line">                EditorGUIUtility.TrTextContent(<span class="string">"Right"</span>),</span><br><span class="line">                EditorGUIUtility.TrTextContent(<span class="string">"None (Main Display)"</span>),</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="keyword">int</span>[] kTargetEyeValues = &#123; (<span class="keyword">int</span>)StereoTargetEyeMask.Both, (<span class="keyword">int</span>)StereoTargetEyeMask.Left, (<span class="keyword">int</span>)StereoTargetEyeMask.Right, (<span class="keyword">int</span>)StereoTargetEyeMask.None &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEnable</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                clearFlags = m_SerializedObject.FindProperty(<span class="string">"m_ClearFlags"</span>);</span><br><span class="line">                backgroundColor = m_SerializedObject.FindProperty(<span class="string">"m_BackGroundColor"</span>);</span><br><span class="line">                normalizedViewPortRect = m_SerializedObject.FindProperty(<span class="string">"m_NormalizedViewPortRect"</span>);</span><br><span class="line">                nearClippingPlane = m_SerializedObject.FindProperty(<span class="string">"near clip plane"</span>);</span><br><span class="line">                farClippingPlane = m_SerializedObject.FindProperty(<span class="string">"far clip plane"</span>);</span><br><span class="line">                fieldOfView = m_SerializedObject.FindProperty(<span class="string">"field of view"</span>);</span><br><span class="line">                orthographic = m_SerializedObject.FindProperty(<span class="string">"orthographic"</span>);</span><br><span class="line">                orthographicSize = m_SerializedObject.FindProperty(<span class="string">"orthographic size"</span>);</span><br><span class="line">                depth = m_SerializedObject.FindProperty(<span class="string">"m_Depth"</span>);</span><br><span class="line">                cullingMask = m_SerializedObject.FindProperty(<span class="string">"m_CullingMask"</span>);</span><br><span class="line">                renderingPath = m_SerializedObject.FindProperty(<span class="string">"m_RenderingPath"</span>);</span><br><span class="line">                occlusionCulling = m_SerializedObject.FindProperty(<span class="string">"m_OcclusionCulling"</span>);</span><br><span class="line">                targetTexture = m_SerializedObject.FindProperty(<span class="string">"m_TargetTexture"</span>);</span><br><span class="line">                HDR = m_SerializedObject.FindProperty(<span class="string">"m_HDR"</span>);</span><br><span class="line">                allowMSAA = m_SerializedObject.FindProperty(<span class="string">"m_AllowMSAA"</span>);</span><br><span class="line">                allowDynamicResolution = m_SerializedObject.FindProperty(<span class="string">"m_AllowDynamicResolution"</span>);</span><br><span class="line"></span><br><span class="line">                stereoConvergence = m_SerializedObject.FindProperty(<span class="string">"m_StereoConvergence"</span>);</span><br><span class="line">                stereoSeparation = m_SerializedObject.FindProperty(<span class="string">"m_StereoSeparation"</span>);</span><br><span class="line"></span><br><span class="line">                targetDisplay = m_SerializedObject.FindProperty(<span class="string">"m_TargetDisplay"</span>);</span><br><span class="line"></span><br><span class="line">                targetEye = m_SerializedObject.FindProperty(<span class="string">"m_TargetEye"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                m_SerializedObject.Update();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ApplyModifiedProperties</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                m_SerializedObject.ApplyModifiedProperties();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DrawClearFlags</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                EditorGUILayout.PropertyField(clearFlags, EditorGUIUtility.TextContent(<span class="string">"Clear Flags|What to display in empty areas of this Camera's view.\n\nChoose Skybox to display a skybox in empty areas, defaulting to a background color if no skybox is found.\n\nChoose Solid Color to display a background color in empty areas.\n\nChoose Depth Only to display nothing in empty areas.\n\nChoose Don't Clear to display whatever was displayed in the previous frame in empty areas."</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DrawBackgroundColor</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                EditorGUILayout.PropertyField(backgroundColor, EditorGUIUtility.TextContent(<span class="string">"Background|The Camera clears the screen to this color before rendering."</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DrawCullingMask</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                EditorGUILayout.PropertyField(cullingMask);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DrawProjection</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                ProjectionType projectionType = orthographic.boolValue ? ProjectionType.Orthographic : ProjectionType.Perspective;</span><br><span class="line">                EditorGUI.BeginChangeCheck();</span><br><span class="line">                EditorGUI.showMixedValue = orthographic.hasMultipleDifferentValues;</span><br><span class="line">                projectionType = (ProjectionType)EditorGUILayout.EnumPopup(EditorGUIUtility.TextContent(<span class="string">"Projection|How the Camera renders perspective.\n\nChoose Perspective to render objects with perspective.\n\nChoose Orthographic to render objects uniformly, with no sense of perspective."</span>), projectionType);</span><br><span class="line">                EditorGUI.showMixedValue = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (EditorGUI.EndChangeCheck())</span><br><span class="line">                    orthographic.boolValue = (projectionType == ProjectionType.Orthographic);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!orthographic.hasMultipleDifferentValues)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (projectionType == ProjectionType.Orthographic)</span><br><span class="line">                        EditorGUILayout.PropertyField(orthographicSize, <span class="keyword">new</span> GUIContent(<span class="string">"Size"</span>));</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        EditorGUILayout.Slider(fieldOfView, <span class="number">1f</span>, <span class="number">179f</span>, EditorGUIUtility.TextContent(<span class="string">"Field of View|The width of the Camera’s view angle, measured in degrees along the local Y axis."</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DrawClippingPlanes</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                EditorGUILayout.PropertiesField(EditorGUI.s_ClipingPlanesLabel, <span class="keyword">new</span>[] &#123;nearClippingPlane, farClippingPlane&#125;, EditorGUI.s_NearAndFarLabels, EditorGUI.kNearFarLabelsWidth);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DrawNormalizedViewPort</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                EditorGUILayout.PropertyField(normalizedViewPortRect, EditorGUIUtility.TextContent(<span class="string">"Viewport Rect|Four values that indicate where on the screen this camera view will be drawn. Measured in Viewport Coordinates (values 0–1)."</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DrawDepth</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                EditorGUILayout.PropertyField(depth);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DrawRenderingPath</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                EditorGUILayout.IntPopup(renderingPath, kCameraRenderPaths, kCameraRenderPathValues, EditorGUIUtility.TempContent(<span class="string">"Rendering Path"</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DrawTargetTexture</span>(<span class="params"><span class="keyword">bool</span> deferred</span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                EditorGUILayout.PropertyField(targetTexture);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// show warning if we have deferred but manual MSAA set</span></span><br><span class="line">                <span class="comment">// only do this if the m_TargetTexture has the same values across all target cameras</span></span><br><span class="line">                <span class="keyword">if</span> (!targetTexture.hasMultipleDifferentValues)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> targetTexture = <span class="keyword">this</span>.targetTexture.objectReferenceValue <span class="keyword">as</span> RenderTexture;</span><br><span class="line">                    <span class="keyword">if</span> (targetTexture</span><br><span class="line">                        &amp;&amp; targetTexture.antiAliasing &gt; <span class="number">1</span></span><br><span class="line">                        &amp;&amp; deferred)</span><br><span class="line">                    &#123;</span><br><span class="line">                        EditorGUILayout.HelpBox(<span class="string">"Manual MSAA target set with deferred rendering. This will lead to undefined behavior."</span>, MessageType.Warning, <span class="literal">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DrawOcclusionCulling</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                EditorGUILayout.PropertyField(occlusionCulling);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DrawHDR</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                EditorGUILayout.PropertyField(HDR, EditorGUIUtility.TempContent(<span class="string">"Allow HDR"</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DrawMSAA</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                EditorGUILayout.PropertyField(allowMSAA);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DrawDynamicResolution</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                EditorGUILayout.PropertyField(allowDynamicResolution);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DrawVR</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                <span class="keyword">if</span> (PlayerSettings.virtualRealitySupported)</span><br><span class="line">                &#123;</span><br><span class="line">                    EditorGUILayout.PropertyField(stereoSeparation);</span><br><span class="line">                    EditorGUILayout.PropertyField(stereoConvergence);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DrawMultiDisplay</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                <span class="keyword">if</span> (ModuleManager.ShouldShowMultiDisplayOption())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> prevDisplay = targetDisplay.intValue;</span><br><span class="line">                    EditorGUILayout.Space();</span><br><span class="line">                    EditorGUILayout.IntPopup(targetDisplay, DisplayUtility.GetDisplayNames(), DisplayUtility.GetDisplayIndices(), EditorGUIUtility.TempContent(<span class="string">"Target Display"</span>));</span><br><span class="line">                    <span class="keyword">if</span> (prevDisplay != targetDisplay.intValue)</span><br><span class="line">                        GameView.RepaintAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DrawTargetEye</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                EditorGUILayout.IntPopup(targetEye, kTargetEyes, kTargetEyeValues, EditorGUIUtility.TempContent(<span class="string">"Target Eye"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">class</span> <span class="title">Styles</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">static</span> GUIContent iconRemove = EditorGUIUtility.IconContent(<span class="string">"Toolbar Minus"</span>, <span class="string">"|Remove command buffer"</span>);</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">static</span> GUIStyle invisibleButton = <span class="string">"InvisibleButton"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">readonly</span> AnimatedBool m_ShowBGColorOptions = <span class="keyword">new</span> AnimatedBool();</span><br><span class="line">        <span class="keyword">readonly</span> AnimatedBool m_ShowOrthoOptions = <span class="keyword">new</span> AnimatedBool();</span><br><span class="line">        <span class="keyword">readonly</span> AnimatedBool m_ShowTargetEyeOption = <span class="keyword">new</span> AnimatedBool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Camera camera &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> target <span class="keyword">as</span> Camera; &#125; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">IsDeferredRenderingPath</span>(<span class="params">RenderingPath rp</span>)</span> &#123; <span class="keyword">return</span> rp == RenderingPath.DeferredLighting || rp == RenderingPath.DeferredShading; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">bool</span> wantDeferredRendering</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">bool</span> isCamDeferred  = IsDeferredRenderingPath(camera.renderingPath);</span><br><span class="line">                <span class="keyword">bool</span> isTierDeferred = IsDeferredRenderingPath(Rendering.EditorGraphicsSettings.GetCurrentTierSettings().renderingPath);</span><br><span class="line">                <span class="keyword">return</span> isCamDeferred || (camera.renderingPath == RenderingPath.UsePlayerSettings &amp;&amp; isTierDeferred);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">enum</span> ProjectionType &#123; Perspective, Orthographic &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Camera m_PreviewCamera;</span><br><span class="line">        <span class="keyword">protected</span> Camera previewCamera</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (m_PreviewCamera == <span class="literal">null</span>)</span><br><span class="line">                    m_PreviewCamera = EditorUtility.CreateGameObjectWithHideFlags(<span class="string">"Preview Camera"</span>, HideFlags.HideAndDontSave, <span class="keyword">typeof</span>(Camera), <span class="keyword">typeof</span>(Skybox)).GetComponent&lt;Camera&gt;();</span><br><span class="line">                m_PreviewCamera.enabled = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> m_PreviewCamera;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> RenderTexture m_PreviewTexture;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// should match color in GizmosDrawers.cpp</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Color kGizmoCamera = <span class="keyword">new</span> Color(<span class="number">233f</span> / <span class="number">255f</span>, <span class="number">233f</span> / <span class="number">255f</span>, <span class="number">233f</span> / <span class="number">255f</span>, <span class="number">128f</span> / <span class="number">255f</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">float</span> kPreviewNormalizedSize = <span class="number">0.2f</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">bool</span> m_CommandBuffersShown = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Settings m_Settings;</span><br><span class="line">        <span class="keyword">protected</span> Settings settings</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (m_Settings == <span class="literal">null</span>)</span><br><span class="line">                    m_Settings = <span class="keyword">new</span> Settings(serializedObject);</span><br><span class="line">                <span class="keyword">return</span> m_Settings;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> clearFlagsHasMultipleValues</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123; <span class="keyword">return</span> settings.clearFlags.hasMultipleDifferentValues; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> orthographicHasMultipleValues</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123; <span class="keyword">return</span> settings.orthographic.hasMultipleDifferentValues; &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> targetEyeValue</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123; <span class="keyword">return</span> settings.targetEye.intValue; &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEnable</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            settings.OnEnable();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> c = (Camera)target;</span><br><span class="line">            m_ShowBGColorOptions.<span class="keyword">value</span> = !clearFlagsHasMultipleValues &amp;&amp; (c.clearFlags == CameraClearFlags.SolidColor || c.clearFlags == CameraClearFlags.Skybox);</span><br><span class="line">            m_ShowOrthoOptions.<span class="keyword">value</span> = c.orthographic;</span><br><span class="line">            m_ShowTargetEyeOption.<span class="keyword">value</span> = targetEyeValue != (<span class="keyword">int</span>)StereoTargetEyeMask.Both || PlayerSettings.virtualRealitySupported;</span><br><span class="line"></span><br><span class="line">            m_ShowBGColorOptions.valueChanged.AddListener(Repaint);</span><br><span class="line">            m_ShowOrthoOptions.valueChanged.AddListener(Repaint);</span><br><span class="line">            m_ShowTargetEyeOption.valueChanged.AddListener(Repaint);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">internal</span> <span class="keyword">void</span> <span class="title">OnDisable</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            m_ShowBGColorOptions.valueChanged.RemoveListener(Repaint);</span><br><span class="line">            m_ShowOrthoOptions.valueChanged.RemoveListener(Repaint);</span><br><span class="line">            m_ShowTargetEyeOption.valueChanged.RemoveListener(Repaint);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_PreviewCamera != <span class="literal">null</span>)</span><br><span class="line">                DestroyImmediate(m_PreviewCamera.gameObject, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DepthTextureModeGUI</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="comment">// Camera's depth texture mode is not serialized data, so can't get to it through</span></span><br><span class="line">            <span class="comment">// serialized property (hence no multi-edit).</span></span><br><span class="line">            <span class="keyword">if</span> (targets.Length != <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">var</span> cam = target <span class="keyword">as</span> Camera;</span><br><span class="line">            <span class="keyword">if</span> (cam == <span class="literal">null</span> || cam.depthTextureMode == DepthTextureMode.None)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            List&lt;<span class="keyword">string</span>&gt; buffers = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line">            <span class="keyword">if</span> ((cam.depthTextureMode &amp; DepthTextureMode.Depth) != <span class="number">0</span>)</span><br><span class="line">                buffers.Add(<span class="string">"Depth"</span>);</span><br><span class="line">            <span class="keyword">if</span> ((cam.depthTextureMode &amp; DepthTextureMode.DepthNormals) != <span class="number">0</span>)</span><br><span class="line">                buffers.Add(<span class="string">"DepthNormals"</span>);</span><br><span class="line">            <span class="keyword">if</span> ((cam.depthTextureMode &amp; DepthTextureMode.MotionVectors) != <span class="number">0</span>)</span><br><span class="line">                buffers.Add(<span class="string">"MotionVectors"</span>);</span><br><span class="line">            <span class="keyword">if</span> (buffers.Count == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"Info: renders "</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffers.Count; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span>)</span><br><span class="line">                    sb.Append(<span class="string">" &amp; "</span>);</span><br><span class="line"></span><br><span class="line">                sb.Append(buffers[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.Append(buffers.Count &gt; <span class="number">1</span> ? <span class="string">" textures"</span> : <span class="string">" texture"</span>);</span><br><span class="line">            EditorGUILayout.HelpBox(sb.ToString(), MessageType.None, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> Rect <span class="title">GetRemoveButtonRect</span>(<span class="params">Rect r</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">var</span> buttonSize = Styles.invisibleButton.CalcSize(Styles.iconRemove);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Rect(r.xMax - buttonSize.x, r.y + (<span class="keyword">int</span>)(r.height / <span class="number">2</span> - buttonSize.y / <span class="number">2</span>), buttonSize.x, buttonSize.y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Draws the 2D bounds of the camera when in 2D mode.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        [<span class="meta">DrawGizmo(GizmoType.NonSelected)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DrawCameraBound</span>(<span class="params">Camera camera, GizmoType gizmoType</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">var</span> sv = SceneView.currentDrawingSceneView;</span><br><span class="line">            <span class="keyword">if</span> (sv != <span class="literal">null</span> &amp;&amp; sv.in2DMode)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (camera == Camera.main &amp;&amp; camera.orthographic)</span><br><span class="line">                    CameraEditor.RenderGizmo(camera);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CommandBufferGUI</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="comment">// Command buffers are not serialized data, so can't get to them through</span></span><br><span class="line">            <span class="comment">// serialized property (hence no multi-edit).</span></span><br><span class="line">            <span class="keyword">if</span> (targets.Length != <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">var</span> cam = target <span class="keyword">as</span> Camera;</span><br><span class="line">            <span class="keyword">if</span> (cam == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">int</span> count = cam.commandBufferCount;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            m_CommandBuffersShown = GUILayout.Toggle(m_CommandBuffersShown, GUIContent.Temp(count + <span class="string">" command buffers"</span>), EditorStyles.foldout);</span><br><span class="line">            <span class="keyword">if</span> (!m_CommandBuffersShown)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            EditorGUI.indentLevel++;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="function">CameraEvent ce <span class="title">in</span> (<span class="params">CameraEvent[]</span>)System.Enum.<span class="title">GetValues</span>(<span class="params"><span class="keyword">typeof</span>(CameraEvent</span>)))</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                CommandBuffer[] cbs = cam.GetCommandBuffers(ce);</span><br><span class="line">                <span class="keyword">foreach</span> (CommandBuffer cb <span class="keyword">in</span> cbs)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">using</span> (<span class="keyword">new</span> GUILayout.HorizontalScope())</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// row with event &amp; command buffer information label</span></span><br><span class="line">                        Rect rowRect = GUILayoutUtility.GetRect(GUIContent.none, EditorStyles.miniLabel);</span><br><span class="line">                        rowRect.xMin += EditorGUI.indent;</span><br><span class="line">                        Rect minusRect = GetRemoveButtonRect(rowRect);</span><br><span class="line">                        rowRect.xMax = minusRect.x;</span><br><span class="line">                        GUI.Label(rowRect, <span class="keyword">string</span>.Format(<span class="string">"&#123;0&#125;: &#123;1&#125; (&#123;2&#125;)"</span>, ce, cb.name, EditorUtility.FormatBytes(cb.sizeInBytes)), EditorStyles.miniLabel);</span><br><span class="line">                        <span class="comment">// and a button to remove it</span></span><br><span class="line">                        <span class="keyword">if</span> (GUI.Button(minusRect, Styles.iconRemove, Styles.invisibleButton))</span><br><span class="line">                        &#123;</span><br><span class="line">                            cam.RemoveCommandBuffer(ce, cb);</span><br><span class="line">                            SceneView.RepaintAll();</span><br><span class="line">                            GameView.RepaintAll();</span><br><span class="line">                            GUIUtility.ExitGUI();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// "remove all" button</span></span><br><span class="line">            <span class="keyword">using</span> (<span class="keyword">new</span> GUILayout.HorizontalScope())</span><br><span class="line">            &#123;</span><br><span class="line">                GUILayout.FlexibleSpace();</span><br><span class="line">                <span class="keyword">if</span> (GUILayout.Button(<span class="string">"Remove all"</span>, EditorStyles.miniButton))</span><br><span class="line">                &#123;</span><br><span class="line">                    cam.RemoveAllCommandBuffers();</span><br><span class="line">                    SceneView.RepaintAll();</span><br><span class="line">                    GameView.RepaintAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            EditorGUI.indentLevel--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnInspectorGUI</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            settings.Update();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> c = (Camera)target;</span><br><span class="line">            m_ShowBGColorOptions.target = !clearFlagsHasMultipleValues &amp;&amp; (c.clearFlags == CameraClearFlags.SolidColor || c.clearFlags == CameraClearFlags.Skybox);</span><br><span class="line">            m_ShowOrthoOptions.target = !orthographicHasMultipleValues &amp;&amp; c.orthographic;</span><br><span class="line">            m_ShowTargetEyeOption.target = targetEyeValue != (<span class="keyword">int</span>)StereoTargetEyeMask.Both || PlayerSettings.virtualRealitySupported;</span><br><span class="line"></span><br><span class="line">            settings.DrawClearFlags();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (EditorGUILayout.BeginFadeGroup(m_ShowBGColorOptions.faded))</span><br><span class="line">                settings.DrawBackgroundColor();</span><br><span class="line">            EditorGUILayout.EndFadeGroup();</span><br><span class="line"></span><br><span class="line">            settings.DrawCullingMask();</span><br><span class="line"></span><br><span class="line">            EditorGUILayout.Space();</span><br><span class="line"></span><br><span class="line">            settings.DrawProjection();</span><br><span class="line"></span><br><span class="line">            settings.DrawClippingPlanes();</span><br><span class="line"></span><br><span class="line">            settings.DrawNormalizedViewPort();</span><br><span class="line"></span><br><span class="line">            EditorGUILayout.Space();</span><br><span class="line">            settings.DrawDepth();</span><br><span class="line">            settings.DrawRenderingPath();</span><br><span class="line">            <span class="keyword">if</span> (m_ShowOrthoOptions.target &amp;&amp; wantDeferredRendering)</span><br><span class="line">                EditorGUILayout.HelpBox(<span class="string">"Deferred rendering does not work with Orthographic camera, will use Forward."</span>,</span><br><span class="line">                    MessageType.Warning, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            settings.DrawTargetTexture(wantDeferredRendering);</span><br><span class="line">            settings.DrawOcclusionCulling();</span><br><span class="line">            settings.DrawHDR();</span><br><span class="line">            settings.DrawMSAA();</span><br><span class="line">            settings.DrawDynamicResolution();</span><br><span class="line"></span><br><span class="line">            DisplayCameraWarnings();</span><br><span class="line"></span><br><span class="line">            settings.DrawVR();</span><br><span class="line">            settings.DrawMultiDisplay();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (EditorGUILayout.BeginFadeGroup(m_ShowTargetEyeOption.faded))</span><br><span class="line">                settings.DrawTargetEye();</span><br><span class="line">            EditorGUILayout.EndFadeGroup();</span><br><span class="line"></span><br><span class="line">            DepthTextureModeGUI();</span><br><span class="line">            CommandBufferGUI();</span><br><span class="line"></span><br><span class="line">            serializedObject.ApplyModifiedProperties();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DisplayCameraWarnings</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Camera camera = target <span class="keyword">as</span> Camera;</span><br><span class="line">            <span class="keyword">if</span> (camera != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">string</span>[] warnings = camera.GetCameraBufferWarnings();</span><br><span class="line">                <span class="keyword">if</span> (warnings.Length &gt; <span class="number">0</span>)</span><br><span class="line">                    EditorGUILayout.HelpBox(<span class="keyword">string</span>.Join(<span class="string">"\n\n"</span>, warnings), MessageType.Warning, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnOverlayGUI</span>(<span class="params">Object target, SceneView sceneView</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">if</span> (target == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// cache some deep values</span></span><br><span class="line">            <span class="keyword">var</span> c = (Camera)target;</span><br><span class="line"></span><br><span class="line">            Vector2 previewSize = GameView.GetMainGameViewTargetSize();</span><br><span class="line">            <span class="keyword">if</span> (previewSize.x &lt; <span class="number">0f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Fallback to Scene View of not a valid game view size</span></span><br><span class="line">                previewSize.x = sceneView.position.width;</span><br><span class="line">                previewSize.y = sceneView.position.height;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Apply normalizedviewport rect of camera</span></span><br><span class="line">            Rect normalizedViewPortRect = c.rect;</span><br><span class="line">            previewSize.x *= Mathf.Max(normalizedViewPortRect.width, <span class="number">0f</span>);</span><br><span class="line">            previewSize.y *= Mathf.Max(normalizedViewPortRect.height, <span class="number">0f</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Prevent using invalid previewSize</span></span><br><span class="line">            <span class="keyword">if</span> (previewSize.x &lt;= <span class="number">0f</span> || previewSize.y &lt;= <span class="number">0f</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> aspect = previewSize.x / previewSize.y;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Scale down (fit to scene view)</span></span><br><span class="line">            previewSize.y = kPreviewNormalizedSize * sceneView.position.height;</span><br><span class="line">            previewSize.x = previewSize.y * aspect;</span><br><span class="line">            <span class="keyword">if</span> (previewSize.y &gt; sceneView.position.height * <span class="number">0.5f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                previewSize.y = sceneView.position.height * <span class="number">0.5f</span>;</span><br><span class="line">                previewSize.x = previewSize.y * aspect;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (previewSize.x &gt; sceneView.position.width * <span class="number">0.5f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                previewSize.x = sceneView.position.width * <span class="number">0.5f</span>;</span><br><span class="line">                previewSize.y = previewSize.x / aspect;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Get and reserve rect</span></span><br><span class="line">            Rect cameraRect = GUILayoutUtility.GetRect(previewSize.x, previewSize.y);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Event.current.type == EventType.Repaint)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// setup camera and render</span></span><br><span class="line">                previewCamera.CopyFrom(c);</span><br><span class="line">                <span class="comment">// also make sure to sync any Skybox component on the preview camera</span></span><br><span class="line">                <span class="keyword">var</span> dstSkybox = previewCamera.GetComponent&lt;Skybox&gt;();</span><br><span class="line">                <span class="keyword">if</span> (dstSkybox)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> srcSkybox = c.GetComponent&lt;Skybox&gt;();</span><br><span class="line">                    <span class="keyword">if</span> (srcSkybox &amp;&amp; srcSkybox.enabled)</span><br><span class="line">                    &#123;</span><br><span class="line">                        dstSkybox.enabled = <span class="literal">true</span>;</span><br><span class="line">                        dstSkybox.material = srcSkybox.material;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        dstSkybox.enabled = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> previewTexture = GetPreviewTextureWithSize((<span class="keyword">int</span>)cameraRect.width, (<span class="keyword">int</span>)cameraRect.height);</span><br><span class="line">                previewTexture.antiAliasing = Mathf.Max(<span class="number">1</span>, QualitySettings.antiAliasing);</span><br><span class="line">                previewCamera.targetTexture = previewTexture;</span><br><span class="line">                previewCamera.pixelRect = <span class="keyword">new</span> Rect(<span class="number">0</span>, <span class="number">0</span>, cameraRect.width, cameraRect.height);</span><br><span class="line"></span><br><span class="line">                Handles.EmitGUIGeometryForCamera(c, previewCamera);</span><br><span class="line"></span><br><span class="line">                GL.sRGBWrite = QualitySettings.activeColorSpace == ColorSpace.Linear;</span><br><span class="line">                previewCamera.Render();</span><br><span class="line">                GL.sRGBWrite = <span class="literal">false</span>;</span><br><span class="line">                Graphics.DrawTexture(cameraRect, previewTexture, <span class="keyword">new</span> Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, GUI.color, EditorGUIUtility.GUITextureBlit2SRGBMaterial);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> RenderTexture <span class="title">GetPreviewTextureWithSize</span>(<span class="params"><span class="keyword">int</span> width, <span class="keyword">int</span> height</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_PreviewTexture == <span class="literal">null</span> || m_PreviewTexture.width != width || m_PreviewTexture.height != height)</span><br><span class="line">            &#123;</span><br><span class="line">                m_PreviewTexture = <span class="keyword">new</span> RenderTexture(width, height, <span class="number">24</span>, RenderTextureFormat.Default, RenderTextureReadWrite.Linear);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> m_PreviewTexture;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">RequiredByNativeCode</span>]</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">float</span> <span class="title">GetGameViewAspectRatio</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Vector2 gameViewSize = GameView.GetMainGameViewTargetSize();</span><br><span class="line">            <span class="keyword">if</span> (gameViewSize.x &lt; <span class="number">0f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Fallback to Scene View of not a valid game view size</span></span><br><span class="line">                gameViewSize.x = Screen.width;</span><br><span class="line">                gameViewSize.y = Screen.height;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> gameViewSize.x / gameViewSize.y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">float</span> <span class="title">GetFrustumAspectRatio</span>(<span class="params">Camera camera</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Rect normalizedViewPortRect = camera.rect;</span><br><span class="line">            <span class="keyword">if</span> (normalizedViewPortRect.width &lt;= <span class="number">0f</span> || normalizedViewPortRect.height &lt;= <span class="number">0f</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1f</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> viewportAspect = normalizedViewPortRect.width / normalizedViewPortRect.height;</span><br><span class="line">            <span class="keyword">return</span> GetGameViewAspectRatio() * viewportAspect;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Returns near- and far-corners in this order: leftBottom, leftTop, rightTop, rightBottom</span></span><br><span class="line">        <span class="comment">// Assumes input arrays are of length 4 (if allocated)</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">GetFrustum</span>(<span class="params">Camera camera, Vector3[] near, Vector3[] far, <span class="keyword">out</span> <span class="keyword">float</span> frustumAspect</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            frustumAspect = GetFrustumAspectRatio(camera);</span><br><span class="line">            <span class="keyword">if</span> (frustumAspect &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (far != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                far[<span class="number">0</span>] = <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">0</span>, camera.farClipPlane); <span class="comment">// leftBottomFar</span></span><br><span class="line">                far[<span class="number">1</span>] = <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">1</span>, camera.farClipPlane); <span class="comment">// leftTopFar</span></span><br><span class="line">                far[<span class="number">2</span>] = <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">1</span>, camera.farClipPlane); <span class="comment">// rightTopFar</span></span><br><span class="line">                far[<span class="number">3</span>] = <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">0</span>, camera.farClipPlane); <span class="comment">// rightBottomFar</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">                    far[i] = camera.ViewportToWorldPoint(far[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (near != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                near[<span class="number">0</span>] = <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">0</span>, camera.nearClipPlane); <span class="comment">// leftBottomNear</span></span><br><span class="line">                near[<span class="number">1</span>] = <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">1</span>, camera.nearClipPlane); <span class="comment">// leftTopNear</span></span><br><span class="line">                near[<span class="number">2</span>] = <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">1</span>, camera.nearClipPlane); <span class="comment">// rightTopNear</span></span><br><span class="line">                near[<span class="number">3</span>] = <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">0</span>, camera.nearClipPlane); <span class="comment">// rightBottomNear</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">                    near[i] = camera.ViewportToWorldPoint(near[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Called from C++ when we need to render a Camera's gizmo</span></span><br><span class="line">        <span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RenderGizmo</span>(<span class="params">Camera camera</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">var</span> near = <span class="keyword">new</span> Vector3[<span class="number">4</span>];</span><br><span class="line">            <span class="keyword">var</span> far = <span class="keyword">new</span> Vector3[<span class="number">4</span>];</span><br><span class="line">            <span class="keyword">float</span> frustumAspect;</span><br><span class="line">            <span class="keyword">if</span> (GetFrustum(camera, near, far, <span class="keyword">out</span> frustumAspect))</span><br><span class="line">            &#123;</span><br><span class="line">                Color orgColor = Handles.color;</span><br><span class="line">                Handles.color = kGizmoCamera;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">                &#123;</span><br><span class="line">                    Handles.DrawLine(near[i], near[(i + <span class="number">1</span>) % <span class="number">4</span>]);</span><br><span class="line">                    Handles.DrawLine(far[i], far[(i + <span class="number">1</span>) % <span class="number">4</span>]);</span><br><span class="line">                    Handles.DrawLine(near[i], far[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                Handles.color = orgColor;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">IsViewPortRectValidToRender</span>(<span class="params">Rect normalizedViewPortRect</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">if</span> (normalizedViewPortRect.width &lt;= <span class="number">0f</span> || normalizedViewPortRect.height &lt;= <span class="number">0f</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (normalizedViewPortRect.x &gt;= <span class="number">1f</span> || normalizedViewPortRect.xMax &lt;= <span class="number">0f</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (normalizedViewPortRect.y &gt;= <span class="number">1f</span> || normalizedViewPortRect.yMax &lt;= <span class="number">0f</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnSceneGUI</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">var</span> c = (Camera)target;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!IsViewPortRectValidToRender(c.rect))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            SceneViewOverlay.Window(EditorGUIUtility.TrTextContent(<span class="string">"Camera Preview"</span>), OnOverlayGUI, (<span class="keyword">int</span>)SceneViewOverlay.Ordering.Camera, target, SceneViewOverlay.WindowDisplayOption.OneWindowPerTarget);</span><br><span class="line"></span><br><span class="line">            Color orgHandlesColor = Handles.color;</span><br><span class="line">            Color slidersColor = kGizmoCamera;</span><br><span class="line">            slidersColor.a *= <span class="number">2f</span>;</span><br><span class="line">            Handles.color = slidersColor;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// get the corners of the far clip plane in world space</span></span><br><span class="line">            <span class="keyword">var</span> far = <span class="keyword">new</span> Vector3[<span class="number">4</span>];</span><br><span class="line">            <span class="keyword">float</span> frustumAspect;</span><br><span class="line">            <span class="keyword">if</span> (!GetFrustum(c, <span class="literal">null</span>, far, <span class="keyword">out</span> frustumAspect))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            Vector3 leftBottomFar = far[<span class="number">0</span>];</span><br><span class="line">            Vector3 leftTopFar = far[<span class="number">1</span>];</span><br><span class="line">            Vector3 rightTopFar = far[<span class="number">2</span>];</span><br><span class="line">            Vector3 rightBottomFar = far[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// manage our own gui changed state, so we can use it for individual slider changes</span></span><br><span class="line">            <span class="keyword">bool</span> guiChanged = GUI.changed;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// FOV handles</span></span><br><span class="line">            Vector3 farMid = Vector3.Lerp(leftBottomFar, rightTopFar, <span class="number">0.5f</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Top and bottom handles</span></span><br><span class="line">            <span class="keyword">float</span> halfHeight = <span class="number">-1.0f</span>;</span><br><span class="line">            Vector3 changedPosition = MidPointPositionSlider(leftTopFar, rightTopFar, c.transform.up);</span><br><span class="line">            <span class="keyword">if</span> (!GUI.changed)</span><br><span class="line">                changedPosition = MidPointPositionSlider(leftBottomFar, rightBottomFar, -c.transform.up);</span><br><span class="line">            <span class="keyword">if</span> (GUI.changed)</span><br><span class="line">                halfHeight = (changedPosition - farMid).magnitude;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Left and right handles</span></span><br><span class="line">            GUI.changed = <span class="literal">false</span>;</span><br><span class="line">            changedPosition = MidPointPositionSlider(rightBottomFar, rightTopFar, c.transform.right);</span><br><span class="line">            <span class="keyword">if</span> (!GUI.changed)</span><br><span class="line">                changedPosition = MidPointPositionSlider(leftBottomFar, leftTopFar, -c.transform.right);</span><br><span class="line">            <span class="keyword">if</span> (GUI.changed)</span><br><span class="line">                halfHeight = (changedPosition - farMid).magnitude / frustumAspect;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Update camera settings if changed</span></span><br><span class="line">            <span class="keyword">if</span> (halfHeight &gt;= <span class="number">0.0f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Undo.RecordObject(c, <span class="string">"Adjust Camera"</span>);</span><br><span class="line">                <span class="keyword">if</span> (c.orthographic)</span><br><span class="line">                &#123;</span><br><span class="line">                    c.orthographicSize = halfHeight;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Vector3 pos = farMid + c.transform.up * halfHeight;</span><br><span class="line">                    c.fieldOfView = Vector3.Angle(c.transform.forward, (pos - c.transform.position)) * <span class="number">2f</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                guiChanged = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            GUI.changed = guiChanged;</span><br><span class="line">            Handles.color = orgHandlesColor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Vector3 <span class="title">MidPointPositionSlider</span>(<span class="params">Vector3 position1, Vector3 position2, Vector3 direction</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Vector3 midPoint = Vector3.Lerp(position1, position2, <span class="number">0.5f</span>);</span><br><span class="line">            <span class="keyword">return</span> Handles.Slider(midPoint, direction, HandleUtility.GetHandleSize(midPoint) * <span class="number">0.03f</span>, Handles.DotHandleCap, <span class="number">0f</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> UnityCsReference </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11</title>
      <link href="/2018/07/09/C++11/"/>
      <url>/2018/07/09/C++11/</url>
      
        <content type="html"><![CDATA[<h1 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h1><ul><li>对于一个class，产生一堆指向virtual functions的指针，虚函数表指针通常放在对象实例的最前面的位置。</li><li>每一个对象添加一个指针，指向相关的virtual table。这个指针被称作虚函数表指针。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>arithmetic</title>
      <link href="/2018/07/09/arithmetic/"/>
      <url>/2018/07/09/arithmetic/</url>
      
        <content type="html"><![CDATA[<h1 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h1><p>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都要小，然后再按此方法对这两部分分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1>]]></content>
      
      
      
        <tags>
            
            <tag> arithmetic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LoadingPerformance_Texture</title>
      <link href="/2018/07/05/LoadingPerformance_Texture/"/>
      <url>/2018/07/05/LoadingPerformance_Texture/</url>
      
        <content type="html"><![CDATA[<h1 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h1><p>资源加载是加载模块中最为耗时的部分，其CPU开销在Unity引擎中主要体现在Loading.UpdatePreloading和Loading.ReadObject两项中。</p><p>Loading.UpdatePreloading，这一项尽在调用类似LoadLevel(Async)的接口处出现，主要负责卸载当前场景的资源</p>]]></content>
      
      
      
        <tags>
            
            <tag> uwa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>optimzation_memory_1</title>
      <link href="/2018/07/05/optimzation-memory-1/"/>
      <url>/2018/07/05/optimzation-memory-1/</url>
      
        <content type="html"><![CDATA[<p>内存开销：</p><h1 id="资源内存占用"><a href="#资源内存占用" class="headerlink" title="资源内存占用"></a>资源内存占用</h1><p>在一个较为复杂的大中型项目中，资源的内存占用往往占据了总体内存的70%以上。因此，资源使用是否恰当直接决定了项目的内存占用情况。一般来说，一款游戏项目的资源主要可分为如下几种：纹理（Texture）、网格（Mesh）、动画片段（AnimationClip）、音频片段（AudioClip）、材质（Material）、着色器（Shader）、字体资源（Font）以及文本资源（Text Asset）等等。其中，纹理、网格、动画片段和音频片段则是最容易造成较大内存开销的资源。</p><h2 id="一、纹理"><a href="#一、纹理" class="headerlink" title="一、纹理"></a>一、纹理</h2><p>纹理资源可以说是几乎所有游戏项目中占据最大内存开销的资源。一个6万面片的场景，网格资源最大才不过10MB，但一个2048x2048的纹理，可能直接就达到16MB。因此，项目中纹理资源的使用是否得当会极大地影响项目地内存占用。</p><h3 id="纹理格式"><a href="#纹理格式" class="headerlink" title="纹理格式"></a>纹理格式</h3><p>纹理格式是研发团队最需要关注的纹理属性。因为它不仅影响着纹理的内存占用，同时还决定了纹理的加载效率。<br>在使用硬件支持的纹理格式时，你可能会遇到以下几个问题：</p><ul><li><p>色阶问题<br>  由于ETX、PVRTC等格式均为有损压缩，因此，当纹理色查范围跨度较大时，均不可避免地造成不同程度地“阶梯”状的色阶问题。因此，很多研发团队使用RGBA32/ARGB32格式来实现更好的效果。但是，这种做法将造成很大的内存占用。比如，同样一张1024x1024的纹理，如果不开启Mipmap，并且PVRTC格式，则其内存占用为512KB，而如果转换为RGBA32位，则很可能占用达到4MB。</p></li><li><p>ETC1不支持透明通道问题<br>  在Andorid平台上，对于使用OpenGL ES 2.0的设备，其纹理格式仅能支持ETC1格式，该格式有个较为严重的问题，即不支持Alpha透明通道，使得透明贴图无法直接通过ETC1格式来进行储存。对此，我们建议研发团队将透明贴图尽可能拆分成两张，即一张RGB24位纹理记录原始纹理的颜色部分和一张Alpha8纹理记录原始纹理的透明通道部分。然后，将这两张贴图分别转化为ETC1格式的纹理，并通过特定的Shader来进行渲染，从而达到支持透明贴图的效果。这种方法极大程度伤毕竟RGBA透明贴图的渲染效果，同时降低纹理的内存占用。</p></li></ul><h3 id="纹理尺寸"><a href="#纹理尺寸" class="headerlink" title="纹理尺寸"></a>纹理尺寸</h3><p>一般来说，纹理尺寸越大，则内存占用越大。所以，尽可能降低纹理尺寸，如果512x512的纹理对于显示效果已经够用，那么就不要使用1024x1024的纹理，因为后者的内存占用时前者的4倍。</p><h3 id="Mipmap功能"><a href="#Mipmap功能" class="headerlink" title="Mipmap功能"></a>Mipmap功能</h3><p>Mipmap旨在有效降低渲染带宽的压力，提升游戏的渲染效率。但是，开启Mipmap会将纹理内存提升1.33倍。对于具有较大纵深感的3D游戏来说，3D场景模型和角色我们一般是建议开启Mipmap功能的，而绝大多数UI均是渲染在屏幕最上层，开启Mipmap并不会提升渲染效率，反倒会增加无谓的内存占用。</p><h3 id="Read-amp-Write"><a href="#Read-amp-Write" class="headerlink" title="Read &amp; Write"></a>Read &amp; Write</h3><p>一般情况下，纹理资源的”Read &amp; Write”功能在Unity引擎中默认是关闭的。开启该选项将会使纹理内存增大一倍。</p><h2 id="二、网格"><a href="#二、网格" class="headerlink" title="二、网格"></a>二、网格</h2><h3 id="Normal、Color和Tangent"><a href="#Normal、Color和Tangent" class="headerlink" title="Normal、Color和Tangent"></a>Normal、Color和Tangent</h3><p>Mesh资源的数据中经常会含有大量的Color数据、Normal数据和Tangent数据。这些数据的存在将大幅度增加Mesh资源的文件提及和内存占用。其中，Color数据和Normal数据主要为3DMax、Maya等建模软件导出时设置所生成，而Tangent一般为导入引擎的生成。</p><p>更为麻烦的是，如果项目对Mesh进行Draw Call Batching操作的话，那么将很有可能进一步增大总体内存的占用。比如，100个Mesh进行拼合，其中99个Mesh均没有Color、Tangent等属性，剩下一个则包含有Color、Normal和Tangent属性，那么Mesh拼合后，CombinedMesh中将为每个Mesh来添加上此三个顶点属性，进而造成很大的内存开销。</p><h1 id="引擎模块自身内存占用"><a href="#引擎模块自身内存占用" class="headerlink" title="引擎模块自身内存占用"></a>引擎模块自身内存占用</h1><p>引擎自身中存在内存开销的部分纷繁复杂，可以说是由巨量“微小”内存所积累起来的，比如GameObject及其各种Component（量最大的Component应该算是Transform）了、ParticleSystem、MonoScript以及各种各样的模块Manager（SceneManager、CanvasManager、PersistentManager）等。</p><p>一般情况下，上面所指出的引擎各组成部分的内存开销均比较小，真正占据较大内存开销的这两处：WebStream和SerializedFile。其绝大部分的内存分配则是由AssetBundle加载资源所致。当使用new WWW或CreateFromMemory来加载AssetBundle时，Unity引擎会加载原始数据到内存中并对其进行解压，而WebStream的大小则是AssetBundle原始文件大小+解压后的数据大小+DecompressionBuffer(0.5MB)。同时，由于Unity5.3版本之前的AssetBundle文件为LZMA压缩，其压缩比类似于Zip(20%-50%)，所以对于1MB的原始AssetBundle文件，其加载后WebStream的大小则可能时5~6MB，因此，当项目中通过new WWW加载多个AssetBundle文件，且AssetBundle又无法即时释放时，WebStream的内存可能会很大。</p><p>对于SerilizedFile，则是当你使用LoadFromCacheOrDownload、CreateFromFile或new WWW本地AssetBundle文件时产生的序列化文件。</p><p>对于WebStream和SerializedFile，需要关注两点：</p><ul><li>是否存在AssetBundle没有被清理干净的情况。可以通过Unity Profiler直接查看其具体的使用情况，并确定Take Sample时AssetBundle的存在是否合理；</li><li>对于占用WebStream较大的AssetBundle文件（如UI Atlas相关的AssetBundle文件等），建议使用LoadFromCacheOrDownLoad或CreateFromFile来替换，即将解压后的AssetBundle数据存储与本地Cache中进行使用。这种做法非常适合于内存特别吃紧的项目，即通过本地的磁盘控件来存储内存空间。</li></ul><h1 id="托管堆内存占用"><a href="#托管堆内存占用" class="headerlink" title="托管堆内存占用"></a>托管堆内存占用</h1><p>对于目前绝大多数基于Unity引擎开发的项目而言，其托管堆是由Mono分配和管理的。“托管”的本意是Mono可以自动地改变堆地大小来适应你所需要的内存，并且适当地调用垃圾回收（Garbage Collection操作来释放已经不需要地内存，从而降低开发人员再代码内存管理方面的门槛。</p><p>目前Unity所使用的Mono版本存在一个严重的问题，即：Mono的堆内存一旦分配就不会返还给系统。这意味着Mono的堆内存是只升不降的。举个粒子，项目运行时，再场景A中开辟了60MB的托管堆内存，而到下一个场景B时，只需要使用20MB的托管堆内存，那么Mono中将会存在40MB空闲的堆内存，且不会返还给系统。</p><ul><li>高频率地New Class/Container/Array等。不要再Update、FixUpdate或较高调用频率地函数中开辟堆内存。</li></ul><p>项目中较为合理地内存分配：</p><ul><li>纹理资源：50MB</li><li>网格资源：20MB</li><li>动画片段：15MB</li><li>音频片段：15MB</li><li>Mono堆内存：40MB</li><li>其它：10MB</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> uwa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>optimzation_memory_2</title>
      <link href="/2018/07/05/optimzation_memory_2/"/>
      <url>/2018/07/05/optimzation_memory_2/</url>
      
        <content type="html"><![CDATA[<h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1>]]></content>
      
      
      
        <tags>
            
            <tag> uwa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>presentandsync</title>
      <link href="/2018/07/05/presentandsync/"/>
      <url>/2018/07/05/presentandsync/</url>
      
        <content type="html"><![CDATA[<h1 id="WaitForTargetFPS"><a href="#WaitForTargetFPS" class="headerlink" title="WaitForTargetFPS"></a>WaitForTargetFPS</h1><p>该参数一般出现在CPU开销过低，且通过设定了目标帧率地情况下(Application.targetFrameRate)。当上一帧产生一个WaitForTargetFPS地空闲等待消耗时，以维持目标帧率。</p><p>解析：该项在Unity引擎地主循环中其实是最早执行地，即引擎实际上是根据上一帧地CPU耗时，在当前帧通过增补WaitForTargetFPS的方式来将运行FPS维持到目标值。比如，目标帧率为30帧/秒，上一帧耗时15ms，那么当前帧中WaitForTargetFPS将会是18（33-15）ms，但是这一帧中其他耗时为28ms，那么在Profiler中这一帧的总耗时就变成了46（18+28<br>）ms。<br>因此，由该值造成了Profiler开销较高的现象，其实是耗时的“假象”，在优化过程中，你对它可以“视而不见”。</p><h1 id="Gfx-WaitForPresend-amp-amp-Graphics-PresentAndSync"><a href="#Gfx-WaitForPresend-amp-amp-Graphics-PresentAndSync" class="headerlink" title="Gfx.WaitForPresend &amp;&amp; Graphics.PresentAndSync"></a>Gfx.WaitForPresend &amp;&amp; Graphics.PresentAndSync</h1><p>这两个参数在Profiler中经常出现CPU占用较高的情况，且仅在发布版本中可以看到。究其原因，其实是CPU和GPU之间垂直同步（VSync）导致的，之所以会有两种参数，主要是与项目是否开启多线程渲染有关。当项目开启多线程渲染时，你看到的是Gfx.WaitForPresent；当项目未开启多线程渲染时，看到的则是Graphics.PresentAndSync。</p><p>Graphics.PresentAndSync是指主线程进行Present时的等待时间和等待垂直同步的时间。</p><p>Gfx.WaitForPresent其字面意思同样也是进行Present时需要等待的时间，但这里其实省略了很多的内容，其真实的意思应该是为了在渲染子线程（Rendering Thread）中进行Presend，当前主线程（MainThread）需要等待的时间。</p>]]></content>
      
      
      
        <tags>
            
            <tag> uwa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity3D手游游戏</title>
      <link href="/2018/07/01/Unity3D_Game_Design/"/>
      <url>/2018/07/01/Unity3D_Game_Design/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity3D美工"><a href="#Unity3D美工" class="headerlink" title="Unity3D美工"></a>Unity3D美工</h1><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><ol><li>模型命名 Max文件中角色模型命名为skin@sk_001武器模型命名为skin@wq_001</li><li>颜色贴图skin@st_001.png 高光贴图skin@st_001_ctr.png</li></ol><h2 id="导入导出"><a href="#导入导出" class="headerlink" title="导入导出"></a>导入导出</h2><h3 id="能够从3DsMax导入Unity3D的资源"><a href="#能够从3DsMax导入Unity3D的资源" class="headerlink" title="能够从3DsMax导入Unity3D的资源"></a>能够从3DsMax导入Unity3D的资源</h3><ul><li>所有节点的位移、旋转、锁方、轴心和命名都将导入</li><li>网格模型包含顶点颜色、法线，一到两个UV通道</li><li>材质包含贴图以及漫反射颜色，以及单个网格的多维材质</li><li>动画（物体移动、旋转、缩放）</li><li>骨骼动画（角色动画）</li></ul><h2 id="角色模型制作规范"><a href="#角色模型制作规范" class="headerlink" title="角色模型制作规范"></a>角色模型制作规范</h2><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><ol><li>选人界面模型面数约4500-5000左右</li><li>游戏内主角模型面数2500-3000左右</li><li>Boss模型面数根据体型大小3000-5000左右</li><li>Npc模型面数900-1200造型简单面数没下限</li><li>武器模型面数250-500 造型简单面数没下限</li><li>模型在不是非常废面的情况下，转折的地方做出厚度，厚度适当夸张。</li><li>地面部分制作成双面或是封闭，小布条类模型做成双面模型</li><li>角色结构整体均衡 比如眼睛部分不需要细致刻画</li></ol><h3 id="贴图"><a href="#贴图" class="headerlink" title="贴图"></a>贴图</h3><p>主角 512*512 png<br>Boss 512*512 png<br>Npc 256*256 png</p><p>武器体积较大的使用256*256 体积较小 128*128 png</p><h4 id="尺寸设定"><a href="#尺寸设定" class="headerlink" title="尺寸设定"></a>尺寸设定</h4><p>制作模型前必须先确保模型尺寸，统一将显示单位与系统单位改为公尺。<br><img src="http://oxcvfpext.bkt.clouddn.com/Unity3D_Game_Design_1.png"><br><img src="http://oxcvfpext.bkt.clouddn.com/Unity3D_Game_Design_2.png"></p><h3 id="注意正反面关系"><a href="#注意正反面关系" class="headerlink" title="注意正反面关系"></a>注意正反面关系</h3><p>每个模型都包含正面和反面，一般来说引擎只会显示模型的正面，如要反面也一起显示需透过shader来实现，但增加反面显示时会降低性能，因此尽量让模型单面显示就好，而在制作模型时必须确保要显示的模型面是正面即可。</p><h3 id="不要存在破面和迭面"><a href="#不要存在破面和迭面" class="headerlink" title="不要存在破面和迭面"></a>不要存在破面和迭面</h3><p>制作模型时注意顶点是否焊接好，未焊接的顶点可能会导致模型有破面的情形，另外模型面与面之间最好保持距离，不然会发生迭面的情况。</p><h3 id="不要存在多余的顶点和T点"><a href="#不要存在多余的顶点和T点" class="headerlink" title="不要存在多余的顶点和T点"></a>不要存在多余的顶点和T点</h3><p>删除一些没用的顶点，并且避免出现T点。</p><h3 id="删除看不到的面"><a href="#删除看不到的面" class="headerlink" title="删除看不到的面"></a>删除看不到的面</h3><p>制作模型时有些面可能在低下或是在模型里面，都是在场景进行中看不到的面，这些面可以删除，以减少模型面数提高效能。</p><h3 id="物体的轴心"><a href="#物体的轴心" class="headerlink" title="物体的轴心"></a>物体的轴心</h3><p>每个物体都有一个坐标轴心，宜据物体属性设计好物体轴心位置，一般来说轴心都会放置在中心的位置，其他情况如门的轴心可能会在低下角落的位置。<br><img src="http://oxcvfpext.bkt.clouddn.com/Unity3D_Game_Design_3.png"><br><img src="http://oxcvfpext.bkt.clouddn.com/Unity3D_Game_Design_4.png"></p><h3 id="使用简单几何体来制作复杂对象"><a href="#使用简单几何体来制作复杂对象" class="headerlink" title="使用简单几何体来制作复杂对象"></a>使用简单几何体来制作复杂对象</h3><p>当遇到比较复杂的对象，且对象比较小，左乘模型反而增加了模型的面数，因此可以使用简单的平面模型结合透空贴图来实现复杂的造型，可以将图片存成PSD、PNG、TGA这种带有透明通道属性的贴图档。</p><h3 id="重置模型（ResetXForm）"><a href="#重置模型（ResetXForm）" class="headerlink" title="重置模型（ResetXForm）"></a>重置模型（ResetXForm）</h3><p>制作模型时可能使用了缩放功能或镜像功能，这些指令会使得模型比例错乱以及出现负数轴向的情形，因此在模型制作完毕时最好进行ResetXForm指令，让模型回归最基本的状态。</p><h3 id="制作虚拟碰撞体"><a href="#制作虚拟碰撞体" class="headerlink" title="制作虚拟碰撞体"></a>制作虚拟碰撞体</h3><p>可以为模型制作简单的几何体来当作物体的碰撞体，可以依据物体的重要性与精确性来设计几何体外观。</p><h2 id="材质贴图和UV"><a href="#材质贴图和UV" class="headerlink" title="材质贴图和UV"></a>材质贴图和UV</h2><h3 id="Unity3D支持的Max材质"><a href="#Unity3D支持的Max材质" class="headerlink" title="Unity3D支持的Max材质"></a>Unity3D支持的Max材质</h3><p>Unity3D支持3dsmax的Standard(标准材质)与Muti/Sub-Object(多维/子物体材质)。</p><h3 id="模型汇入Unity后没有贴图？"><a href="#模型汇入Unity后没有贴图？" class="headerlink" title="模型汇入Unity后没有贴图？"></a>模型汇入Unity后没有贴图？</h3><p>当模型汇入Unity前，可以先创建一个Texture文件夹，并事先将贴图导入，这样模型汇入后就会自动读取到贴图。</p><h3 id="模型塌陷"><a href="#模型塌陷" class="headerlink" title="模型塌陷"></a>模型塌陷</h3><p>制作模型时，建议将模型以一栋建筑进行塌陷，接着对模型进行UV拆解，这样可以将一个模型使用一张贴图来完成。</p><h3 id="避免拉伸UV"><a href="#避免拉伸UV" class="headerlink" title="避免拉伸UV"></a>避免拉伸UV</h3><p>调整UV前先将材质球使用棋格 (checkter) 贴图来观看UV比例，调整UV时尽量让棋格维持正方形的形状。</p><h3 id="贴图尺寸"><a href="#贴图尺寸" class="headerlink" title="贴图尺寸"></a>贴图尺寸</h3><p>贴图必须是2的N词放（8、16、32、64、128、256），建议贴图不要超过1024*1024大小。</p><h3 id="绘制UV出血"><a href="#绘制UV出血" class="headerlink" title="绘制UV出血"></a>绘制UV出血</h3><p>绘制材质时绘制出血边缘，可避免出现明显接缝线。</p><h3 id="透空贴图在Unity里的使用"><a href="#透空贴图在Unity里的使用" class="headerlink" title="透空贴图在Unity里的使用"></a>透空贴图在Unity里的使用</h3><h3 id="透空贴图毛边处理技巧"><a href="#透空贴图毛边处理技巧" class="headerlink" title="透空贴图毛边处理技巧"></a>透空贴图毛边处理技巧</h3><h3 id="透空贴图毛边处理技巧（进阶）"><a href="#透空贴图毛边处理技巧（进阶）" class="headerlink" title="透空贴图毛边处理技巧（进阶）"></a>透空贴图毛边处理技巧（进阶）</h3><h3 id="材质与贴图命名"><a href="#材质与贴图命名" class="headerlink" title="材质与贴图命名"></a>材质与贴图命名</h3><h2 id="烘培贴图教学"><a href="#烘培贴图教学" class="headerlink" title="烘培贴图教学"></a>烘培贴图教学</h2><h3 id="3dsMax-LightMap-烘培贴图"><a href="#3dsMax-LightMap-烘培贴图" class="headerlink" title="3dsMax LightMap 烘培贴图"></a>3dsMax LightMap 烘培贴图</h3><h3 id="3dsMax-CompleteMap-烘培贴图"><a href="#3dsMax-CompleteMap-烘培贴图" class="headerlink" title="3dsMax CompleteMap 烘培贴图"></a>3dsMax CompleteMap 烘培贴图</h3><h2 id="Unity烘培贴图"><a href="#Unity烘培贴图" class="headerlink" title="Unity烘培贴图"></a>Unity烘培贴图</h2><h2 id="Unity3D地形制作"><a href="#Unity3D地形制作" class="headerlink" title="Unity3D地形制作"></a>Unity3D地形制作</h2><h3 id="地形编辑器基本功能介绍"><a href="#地形编辑器基本功能介绍" class="headerlink" title="地形编辑器基本功能介绍"></a>地形编辑器基本功能介绍</h3><h3 id="水系统介绍"><a href="#水系统介绍" class="headerlink" title="水系统介绍"></a>水系统介绍</h3><h3 id="天空盒系统介绍"><a href="#天空盒系统介绍" class="headerlink" title="天空盒系统介绍"></a>天空盒系统介绍</h3><h3 id="第一人称导览"><a href="#第一人称导览" class="headerlink" title="第一人称导览"></a>第一人称导览</h3><h2 id="3dsMax角色动画导入与基本控制"><a href="#3dsMax角色动画导入与基本控制" class="headerlink" title="3dsMax角色动画导入与基本控制"></a>3dsMax角色动画导入与基本控制</h2><h3 id="单个角色动画导入"><a href="#单个角色动画导入" class="headerlink" title="单个角色动画导入"></a>单个角色动画导入</h3><h3 id="多个角色动画导入"><a href="#多个角色动画导入" class="headerlink" title="多个角色动画导入"></a>多个角色动画导入</h3><h3 id="角色基本控制"><a href="#角色基本控制" class="headerlink" title="角色基本控制"></a>角色基本控制</h3><h2 id="第三人称角色控制"><a href="#第三人称角色控制" class="headerlink" title="第三人称角色控制"></a>第三人称角色控制</h2><h3 id="角色阴影"><a href="#角色阴影" class="headerlink" title="角色阴影"></a>角色阴影</h3><h2 id="树木与粒子系统"><a href="#树木与粒子系统" class="headerlink" title="树木与粒子系统"></a>树木与粒子系统</h2><h3 id="树木制作"><a href="#树木制作" class="headerlink" title="树木制作"></a>树木制作</h3><h2 id="粒子系统-繁星粒子效果"><a href="#粒子系统-繁星粒子效果" class="headerlink" title="粒子系统-繁星粒子效果"></a>粒子系统-繁星粒子效果</h2><h2 id="粒子系统-雪花粒子效果"><a href="#粒子系统-雪花粒子效果" class="headerlink" title="粒子系统-雪花粒子效果"></a>粒子系统-雪花粒子效果</h2><h2 id="粒子系统-火焰粒子效果"><a href="#粒子系统-火焰粒子效果" class="headerlink" title="粒子系统-火焰粒子效果"></a>粒子系统-火焰粒子效果</h2><h2 id="编辑界面介绍"><a href="#编辑界面介绍" class="headerlink" title="编辑界面介绍"></a>编辑界面介绍</h2><h3 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h3><h3 id="打开工程"><a href="#打开工程" class="headerlink" title="打开工程"></a>打开工程</h3><h3 id="Project视图"><a href="#Project视图" class="headerlink" title="Project视图"></a>Project视图</h3><h3 id="Hierarchy视图"><a href="#Hierarchy视图" class="headerlink" title="Hierarchy视图"></a>Hierarchy视图</h3><h3 id="Inspector视图"><a href="#Inspector视图" class="headerlink" title="Inspector视图"></a>Inspector视图</h3><h3 id="Scene视图"><a href="#Scene视图" class="headerlink" title="Scene视图"></a>Scene视图</h3><h4 id="视图介绍"><a href="#视图介绍" class="headerlink" title="视图介绍"></a>视图介绍</h4><h4 id="移动视图"><a href="#移动视图" class="headerlink" title="移动视图"></a>移动视图</h4><h4 id="移动模型"><a href="#移动模型" class="headerlink" title="移动模型"></a>移动模型</h4><h4 id="旋转模型"><a href="#旋转模型" class="headerlink" title="旋转模型"></a>旋转模型</h4><h4 id="缩放模型"><a href="#缩放模型" class="headerlink" title="缩放模型"></a>缩放模型</h4><h4 id="场景工具"><a href="#场景工具" class="headerlink" title="场景工具"></a>场景工具</h4><h4 id="Sence视图控制条"><a href="#Sence视图控制条" class="headerlink" title="Sence视图控制条"></a>Sence视图控制条</h4><h4 id="Game视图"><a href="#Game视图" class="headerlink" title="Game视图"></a>Game视图</h4><h4 id="Game视图控制条"><a href="#Game视图控制条" class="headerlink" title="Game视图控制条"></a>Game视图控制条</h4><h2 id="工程的打包"><a href="#工程的打包" class="headerlink" title="工程的打包"></a>工程的打包</h2><h3 id="导出与导入"><a href="#导出与导入" class="headerlink" title="导出与导入"></a>导出与导入</h3><h3 id="游戏案例1"><a href="#游戏案例1" class="headerlink" title="游戏案例1"></a>游戏案例1</h3><h2 id="Android和iOS版本发布"><a href="#Android和iOS版本发布" class="headerlink" title="Android和iOS版本发布"></a>Android和iOS版本发布</h2><h2 id="Unity3D脚本概述"><a href="#Unity3D脚本概述" class="headerlink" title="Unity3D脚本概述"></a>Unity3D脚本概述</h2><h3 id="Unity3D脚本概述-1"><a href="#Unity3D脚本概述-1" class="headerlink" title="Unity3D脚本概述"></a>Unity3D脚本概述</h3><h3 id="Unity3D的基本语法"><a href="#Unity3D的基本语法" class="headerlink" title="Unity3D的基本语法"></a>Unity3D的基本语法</h3><h4 id="访问其他组件"><a href="#访问其他组件" class="headerlink" title="访问其他组件"></a>访问其他组件</h4><h4 id="访问其他游戏对象"><a href="#访问其他游戏对象" class="headerlink" title="访问其他游戏对象"></a>访问其他游戏对象</h4><h4 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h4><h4 id="成员变量与全局变量"><a href="#成员变量与全局变量" class="headerlink" title="成员变量与全局变量"></a>成员变量与全局变量</h4><h4 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h4><h4 id="协同程序与中断"><a href="#协同程序与中断" class="headerlink" title="协同程序与中断"></a>协同程序与中断</h4><h4 id="创建游戏对象"><a href="#创建游戏对象" class="headerlink" title="创建游戏对象"></a>创建游戏对象</h4><h4 id="获取游戏对象"><a href="#获取游戏对象" class="headerlink" title="获取游戏对象"></a>获取游戏对象</h4><h4 id="添加组件与修改组件"><a href="#添加组件与修改组件" class="headerlink" title="添加组件与修改组件"></a>添加组件与修改组件</h4><h4 id="脚本组件"><a href="#脚本组件" class="headerlink" title="脚本组件"></a>脚本组件</h4><h4 id="克隆游戏对象"><a href="#克隆游戏对象" class="headerlink" title="克隆游戏对象"></a>克隆游戏对象</h4><h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnGUI</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GUILayout.Label(<span class="string">"当前游戏时间："</span> + Time.time);</span><br><span class="line">    GUILayout.Label(<span class="string">"上一帧所消耗的时间："</span> + Time.deltaTime);</span><br><span class="line">    GUILayout.Label(<span class="string">"固定增量时间："</span> + Time.fixedTime);</span><br><span class="line">    GUILayout.Label(<span class="string">"上一帧所消耗的固定时间："</span> + Time.fixedDeltaTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h4><h4 id="四元数"><a href="#四元数" class="headerlink" title="四元数"></a>四元数</h4><h2 id="Unity3D-GUI界面设计（GUI-amp-NGUI-amp-UGUI）"><a href="#Unity3D-GUI界面设计（GUI-amp-NGUI-amp-UGUI）" class="headerlink" title="Unity3D GUI界面设计（GUI&amp;NGUI&amp;UGUI）"></a>Unity3D GUI界面设计（GUI&amp;NGUI&amp;UGUI）</h2><h3 id="GUI常用控件"><a href="#GUI常用控件" class="headerlink" title="GUI常用控件"></a>GUI常用控件</h3><h4 id="GUI-Text"><a href="#GUI-Text" class="headerlink" title="GUI Text"></a>GUI Text</h4><h4 id="GUI-Texture-LazyTexture"><a href="#GUI-Texture-LazyTexture" class="headerlink" title="GUI Texture (LazyTexture)"></a>GUI Texture (LazyTexture)</h4><h4 id="Label控件"><a href="#Label控件" class="headerlink" title="Label控件"></a>Label控件</h4><h4 id="Button控件"><a href="#Button控件" class="headerlink" title="Button控件"></a>Button控件</h4><h4 id="TextField"><a href="#TextField" class="headerlink" title="TextField"></a>TextField</h4><h4 id="ToolBar"><a href="#ToolBar" class="headerlink" title="ToolBar"></a>ToolBar</h4><h4 id="Slider"><a href="#Slider" class="headerlink" title="Slider"></a>Slider</h4><h4 id="ScrollView控件"><a href="#ScrollView控件" class="headerlink" title="ScrollView控件"></a>ScrollView控件</h4><h4 id="群组视图"><a href="#群组视图" class="headerlink" title="群组视图"></a>群组视图</h4><h4 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h4><h4 id="NGUI-Panel-amp-UGUI-Canvas"><a href="#NGUI-Panel-amp-UGUI-Canvas" class="headerlink" title="NGUI Panel &amp; UGUI Canvas"></a>NGUI Panel &amp; UGUI Canvas</h4><h4 id="图集制作-TexturePacket"><a href="#图集制作-TexturePacket" class="headerlink" title="图集制作(TexturePacket)"></a>图集制作(TexturePacket)</h4><h4 id="UITween动画"><a href="#UITween动画" class="headerlink" title="UITween动画"></a>UITween动画</h4><h4 id="顶点动画"><a href="#顶点动画" class="headerlink" title="顶点动画"></a>顶点动画</h4><h3 id="GUI-Skin"><a href="#GUI-Skin" class="headerlink" title="GUI Skin"></a>GUI Skin</h3><h4 id="自定义风格组件"><a href="#自定义风格组件" class="headerlink" title="自定义风格组件"></a>自定义风格组件</h4><h2 id="Unity3D输入与控制"><a href="#Unity3D输入与控制" class="headerlink" title="Unity3D输入与控制"></a>Unity3D输入与控制</h2><h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><h4 id="键盘按下事件"><a href="#键盘按下事件" class="headerlink" title="键盘按下事件"></a>键盘按下事件</h4><h4 id="键盘抬起事件"><a href="#键盘抬起事件" class="headerlink" title="键盘抬起事件"></a>键盘抬起事件</h4><h4 id="键盘长按事件"><a href="#键盘长按事件" class="headerlink" title="键盘长按事件"></a>键盘长按事件</h4><h3 id="触摸事件"><a href="#触摸事件" class="headerlink" title="触摸事件"></a>触摸事件</h3><h4 id="触摸按下事件"><a href="#触摸按下事件" class="headerlink" title="触摸按下事件"></a>触摸按下事件</h4><h4 id="触摸抬起事件"><a href="#触摸抬起事件" class="headerlink" title="触摸抬起事件"></a>触摸抬起事件</h4><h4 id="触摸长按事件"><a href="#触摸长按事件" class="headerlink" title="触摸长按事件"></a>触摸长按事件</h4><h3 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h3><h4 id="鼠标按下事件"><a href="#鼠标按下事件" class="headerlink" title="鼠标按下事件"></a>鼠标按下事件</h4><h4 id="鼠标抬起事件"><a href="#鼠标抬起事件" class="headerlink" title="鼠标抬起事件"></a>鼠标抬起事件</h4><h4 id="鼠标长按事件"><a href="#鼠标长按事件" class="headerlink" title="鼠标长按事件"></a>鼠标长按事件</h4><h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><h4 id="输入管理器（InputHelper）"><a href="#输入管理器（InputHelper）" class="headerlink" title="输入管理器（InputHelper）"></a>输入管理器（InputHelper）</h4><h4 id="自定义按键事件"><a href="#自定义按键事件" class="headerlink" title="自定义按键事件"></a>自定义按键事件</h4><h4 id="自定义按键轴"><a href="#自定义按键轴" class="headerlink" title="自定义按键轴"></a>自定义按键轴</h4><h4 id="实例练习"><a href="#实例练习" class="headerlink" title="实例练习"></a>实例练习</h4><h3 id="角色模型与动画（Animation-amp-Animator）"><a href="#角色模型与动画（Animation-amp-Animator）" class="headerlink" title="角色模型与动画（Animation&amp;Animator）"></a>角色模型与动画（Animation&amp;Animator）</h3><h4 id="模型的载入"><a href="#模型的载入" class="headerlink" title="模型的载入"></a>模型的载入</h4><h4 id="设置角色动画"><a href="#设置角色动画" class="headerlink" title="设置角色动画"></a>设置角色动画</h4><h4 id="播放3D动画"><a href="#播放3D动画" class="headerlink" title="播放3D动画"></a>播放3D动画</h4><h4 id="动画裁切"><a href="#动画裁切" class="headerlink" title="动画裁切"></a>动画裁切</h4><h4 id="动画的帧"><a href="#动画的帧" class="headerlink" title="动画的帧"></a>动画的帧</h4><h4 id="Tween"><a href="#Tween" class="headerlink" title="Tween"></a>Tween</h4><h3 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h3><h4 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h4><h4 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h4>]]></content>
      
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阴影映射的原理和实现</title>
      <link href="/2018/06/30/Shadow_Mapping/"/>
      <url>/2018/06/30/Shadow_Mapping/</url>
      
        <content type="html"><![CDATA[<h1 id="阴影贴图-Shadwom-mapping"><a href="#阴影贴图-Shadwom-mapping" class="headerlink" title="阴影贴图 (Shadwom mapping)"></a>阴影贴图 (Shadwom mapping)</h1><p>像素与以纹理形式保存的光照深度缓冲区或者深度图像比较，通过这种方式计算像素是否处于光源照射范围之内，从而生成阴影。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>阴影贴图是一种使用深度纹理来为渲染阴影提供解决方法的多通道计算。它的关键是，就是用投影光源代替最终视口来观察场景。通过移动视口到光源位置，可以观察到这个位置每个东西都是明亮的，因为从光的角度来看是没有阴影的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity3D优化专题</title>
      <link href="/2018/06/26/Unity3D-Optimize/"/>
      <url>/2018/06/26/Unity3D-Optimize/</url>
      
        <content type="html"><![CDATA[<h1 id="一-遮挡剔除OcclusionCulling"><a href="#一-遮挡剔除OcclusionCulling" class="headerlink" title="一 遮挡剔除OcclusionCulling"></a>一 遮挡剔除OcclusionCulling</h1><p>遮挡剔除(Occlusion Culling)功能可在对象因被其他物体遮挡，当前在相机中无法看到时，禁用对象渲染。该功能不会在三维计算机图形中自动开启，因为在大部分情况下，离相机最远的对象最先渲染，离相机的对象覆盖先前的物体（该步骤称之为“重复渲染(overdraw)”）。遮挡剔除(Occlusion Culling)与视锥体剔除(Frustum Culling)不同。视锥体剔除(Frustum Culling)只禁用相机视野外的对象渲染，不禁用视野中被遮挡的任何物体的渲染。注意，使用遮挡剔除(Occlusion Culling)功能时，仍将受益于视锥体剔除(Frustum Culling)。<br>当场景中包含大量模型时，势必会造成渲染效率的降低。如果使用遮挡剔除技术，可以使用那些被阻挡的物体不被渲染，从而达到提高渲染效率的目的。</p><p>遮挡剔除的基本原理是在场景中创建一个遮挡区域，该遮挡区域由单元格组成；每个单元格构成整个场景遮挡区域的一部分，这些单元格会把整个场景拆分为多个部分。当摄像机能够看到该单元格时，单元格中的物体会被渲染出来，而被其他单元格挡住的不被摄像机看到的物体不会被渲染。</p><p>下面，我们来做遮挡剔除的案例</p><h1 id="二-层级消隐"><a href="#二-层级消隐" class="headerlink" title="二 层级消隐"></a>二 层级消隐</h1><p>如果场景中存在大量的小物体，则可以使用层消隐优化场景。层消隐就是在比较远的距离将小物体剔除，减少绘制调用的次数。例如，在比较远的距离，大型建筑物依然可见，但是小型的石块和碎片隐藏掉。可以将小物件单独放入一个层，并且使用Camera.main.layerCullDistance函数设置层的消隐距离。调整摄像机位置进行测试即可。只有在摄像机距离这些物体小于10M的时候，地面上的这些物体才能显示出来。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SeperateControl</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">float</span>[] distance = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">32</span>];</span><br><span class="line">        distances[<span class="number">8</span>] = <span class="number">10</span>;</span><br><span class="line">        Camera.main.layerCullDistances = distances; <span class="comment">// 如果main == null,则设置camera的tag为mainCamera</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三-层级细节LOD"><a href="#三-层级细节LOD" class="headerlink" title="三 层级细节LOD"></a>三 层级细节LOD</h1><p>层级细节LOD全称为LevelOfDetail,它是根据物体在游戏画面中锁占据的百分比来调用不同复杂度的模型的。简单理解就是当一个物体距离摄像机比较远的时候，使用复杂度低的模型，比较近的时候，使用复杂度高的模型。</p><p>在建模软件中，制作好各个层级的模型，并且根据复杂程度自高向低命名为：模型名称_LOD0,模型名称_LOD1,模型名称_LOD2，数字越低，复杂程度越高。</p><p>我们新建一个场景，构造最简单的LOD模型示例。</p><ol><li>准备3个Unity基本游戏对象，添加必要的材质。</li><li>定义一个空对象，命名为_LOD,添加LODGroup组件</li><li>分别将以上三个基本对象拖拽到LODGroup的各个级别上</li><li>首先添加LOD0的对象，当然中间需要修改父节点，点击确定即可</li><li>在Scene视图中，拖动摄像机分别近距离与远距离观察模型的变化。</li></ol><h1 id="四-DrawCall讲解"><a href="#四-DrawCall讲解" class="headerlink" title="四 DrawCall讲解"></a>四 DrawCall讲解</h1><p>一个DrawCall，表示U3D使用这个材质/纹理，来进行一次渲染，那么这次渲染假设有3个对象，那么当3个对象都使用这一个材质/纹理的时候，就会产生一次DrawCall，可以理解为一次将纹理输送到屏幕上的过程，（实际上引擎大多会使用如双缓冲，缓存这类的手段来优化这个过程，但在这里我们只需要这样认识就可以了），假设3个对象使用不同的材质/纹理，那么无疑会产生3个DrawCall。</p><p>批处理动态物体需要在每个顶点上进行一定的开销，所以动态批处理仅支持小于900顶点的网格物体，如果你的着色器使用顶点位置，法线和UV值三种属性，那么你只能批处理300顶点一下的物体；请注意：属性数量的限制可能会在将来进行改变。</p><ol><li>相同的物体采取相同的材质，修改其缩放比例，观察DrawCall的变化。</li></ol><p>功能描述如下：Static Batching是将标明为Static的静态物件，如果在使用相同材质球的条件下，Unity会自动帮你把这两个物体合并成一个Batch，送往GPU来处理。</p><p>Static Batching可以让引擎降低任何尺寸网格的Draw Call，如下图所示：</p><h1 id="Profile-工具使用"><a href="#Profile-工具使用" class="headerlink" title="Profile 工具使用"></a>Profile 工具使用</h1><p>性能分析工具可以给我们提供游戏性能表现的详细信息。如果我们的游戏存在性能问题，如低帧率或者高内存占用，性能分析工具可以帮助我们法线问题的起因，并协助我们解决问题。</p><p>Profiler布局</p><p>在我们使用Profiler收集游戏数据之前，先打开它熟悉下界面布局。从菜单Window-&gt;Profiler打开。</p><p>在窗口左侧，可以看到一列profilers，每个profiler显示我们游戏的一个方面的信息，分别为cpu使用情况，gpu使用情况，渲染，内存使用情况，声音，物理和网络。</p><p>当开始录制时，窗口上部的每个profiler会随着时间显示数据。性能是随着时间变化的，所以随着时间变化的信息是比仅仅一帧的信息有用的多的。有些性能问题是持续性的，有些问题是仅仅在一帧中出现的，还有一些性能问题是随着时间逐渐显现的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于物理的着色：BRDF</title>
      <link href="/2018/06/09/BRDF/"/>
      <url>/2018/06/09/BRDF/</url>
      
        <content type="html"><![CDATA[<p>在计算机图形学领域，着色（Shading）是指根据表面或者多边形相对光源和相机的角度和距离来计算它的颜色的过程。不同的用户可以使用不同的着色算法，CAD等追求相应速度的交互式图形领域可以使用简单快速的着色算法，卡通油画等艺术效果使用非真实感（Nonphotorealistic）着色算法，而追求真实感的CG电影或游戏则可以使用基于物理建模的着色算法。<br>本文关注基于物理着色的BRDF模型，希望能将BRDF的来龙去脉将清楚，并分析Cook-TorranceBRDF公式的推倒过程。<br>要模拟真实光照，我们先要弄清楚光照的现象。</p><h2 id="光照现象"><a href="#光照现象" class="headerlink" title="光照现象"></a>光照现象</h2><p>光由光子组成，光子即具有粒子的特性，又表现出波的特性。从波的角度看，光是电磁波的一种，不同频率（波长）的光波能量不同，频率越高（波长越短），能量越高，频率越低（波长越长），能量越低，其中波长在380nm-780nm范围内的光波能被认类的视网膜感知到，这个范围的光波成为可见光，不同频率的可见光被人感知为不同的颜色，频率越高的光偏蓝，频率较低的光则偏红。<br><img src="http://oxcvfpext.bkt.clouddn.com/BRDF-1.jpg"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>3D美术人员Technical Artist（TA技术美术）的学习之旅（1）</title>
      <link href="/2018/06/03/TA-1/"/>
      <url>/2018/06/03/TA-1/</url>
      
        <content type="html"><![CDATA[<p>文章针对于有一定3D美术基础，并了解次时代游戏制作流程的开发者，需要具备以下知识基础：了解3D建模，以及拓扑流程，贴图制作。相关软件3DMAX,ZB,substancepainte,ps等。<br>TA是美术和程序之间沟通的桥梁。美术同学需要一些更加方便，可视化更强的工具，例如拓扑的工具，各位都知道MAX里有一个石墨工具是可以用于拓扑的，但是操作石墨工具拓扑是一件很痛苦的事，这时候有一个插件工具能给解决这个问题，例如wrapit的拓扑插件。正因为有了这个插件工具，我们就不用把模型导入Topogun在再次进行二次操作，而编写这个插件就可以算作TA人员所要去做的一件事。</p>]]></content>
      
      
      
        <tags>
            
            <tag> -TA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity ShaderLab</title>
      <link href="/2018/05/19/Unity3D-ShaderLab/"/>
      <url>/2018/05/19/Unity3D-ShaderLab/</url>
      
        <content type="html"><![CDATA[<h1 id="CG类型"><a href="#CG类型" class="headerlink" title="CG类型"></a>CG类型</h1><div class="table-container"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>float</td><td>32位浮点数据</td></tr><tr><td>half</td><td>16位浮点数据</td></tr><tr><td>int</td><td>32位整形数据</td></tr><tr><td>fixed</td><td>12位定点数</td></tr><tr><td>bool</td><td>布尔数据</td></tr><tr><td>sampler</td><td>纹理对象的句柄，分为sampler、sampler1D、sampler2D、sampler3D、samplerCUBE和samplerRECT。</td></tr></tbody></table></div><p>float2x4 matrix // 表示2x4阶矩阵，包含8个float类型数据</p><p>使用技巧：</p><ul><li>精度够用就好</li><li>颜色和单位向量，使用fixed</li><li>其他情况，尽量使用half（即范围在[-6万，）</li></ul><p>内置数据类型：基于基础数据类型，如float3，表示float3类型的三维向量；同理，bool2表示布尔类型的二维向量。</p><p>向量最长不能超过四元，如float5 vector; //编译错误</p><p>Swizzle操作符：它可以将一个向量的成员取出组成一个新的向量。对于坐标或者角度等其它多维向量，Swizzle操作符(.)后接x、y、z、w分别表示原始向量的第一个、第二个、第三个和第四个元素；同样，对于颜色可以后接r、g、b和a来表示同样的索引。<br>例如：</p><pre><code>float4(a,b,c,d).xwz 等价于 float4(a,d,c)float4(a,b,c,d).xxy 等价于 float4(a,a,b)</code></pre><p>Swizzle操作符只能对结构体和向量使用，不能对数组使用。</p>]]></content>
      
      
      <categories>
          
          <category> Unity Shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何系统地进行性能优化？</title>
      <link href="/2018/05/17/How-to-systematically-optimize-performance/"/>
      <url>/2018/05/17/How-to-systematically-optimize-performance/</url>
      
        <content type="html"><![CDATA[<p>项目做到一定阶段之后，要开始性能优化了。目前比较没有头绪地是，如何系统地开始？比如是否先要列一份清单，逐项去检查，用什么工具？这里想请教的是一套方法，或者说是一套工作流，能够系统地定位性能问题。<br>谢邀。<br>这是个好问题，也是个大问题。我想UWA团队在做深度优化地时候应该算是一个系统地性能优化，所以请@xin他们来回答可能更合适。<br>我就仅仅从我个人的经验角度来回答一下，抛砖引玉。</p><h2 id="1-是否需要性能优化？"><a href="#1-是否需要性能优化？" class="headerlink" title="1.是否需要性能优化？"></a>1.是否需要性能优化？</h2><p>知乎老惯例，“先问有没有，再问为什么”。所以第一步是确定产品有没有性能问题，需不需要性能优化？<br>虽然通常来说，绝大部分项目都需要关注性能的部分，但是就像我在UWA Day上分享所说的，我个人的感觉是性能优化最终要直接或者间接的反馈到游戏体验上。如果你的游戏再高中低配置对应的设备上都很流畅，对于发热和耗电也没有特别明显的问题，那我觉得可以调低一些性能优化的优先级。<br>所以是否需要性能优化这个问题，我的回答是是否有影响游戏体验的表现，比如设备达不到目标帧率、卡顿、发热等等问题。</p><h2 id="2-如何定位问题原因？"><a href="#2-如何定位问题原因？" class="headerlink" title="2.如何定位问题原因？"></a>2.如何定位问题原因？</h2><p>有问题才有优化的具体目标，那接下来就是根据问题来进行原因的排查。排查的过程根据问题不同项目不同有各自的方法和过程，我这里提供一些常规问题的排查方法。</p><p>从抓大放小的角度，我们进行优化通常采用先检查常规消耗，再检查峰值消耗的思路来进行，即首先保证运行时的平均帧率，再减少卡顿，然后关注内存，最后考虑发热。这几部分其实也有很多的相关性，比如减少卡顿可能会使用缓存/预加载的策略，这时候对于内存可能会有影响，而提升了平均帧率再限制帧率设备上可以减少发热和耗电等。</p><h3 id="2-1平时运行帧率低"><a href="#2-1平时运行帧率低" class="headerlink" title="2.1平时运行帧率低"></a>2.1平时运行帧率低</h3><p>低配机器上运行帧率比较低是常见问题。<br>a)首先是做分类，把通常的问题归类到几种瓶颈下来做讨论：GPU Bound、CPU Bound、Bandwidth Bound，还有Memory。这种分类方式基本是按照硬件资源的方式来进行的。<br>b)GPU Bound是一种目前手游中比较常见的瓶颈，降低分辨率如果对帧率有非常明显的提升的话，非常大的可能就是GPU Bound。<br>c)CPU Bound,降低分辨率的方式如果并不能提高帧率，那么可能是CPU Bound。CPU通常和Draw Call祥光，或者和复杂的游戏逻辑相关，通过Unity的Profiler工具可以比较明确看出是否是CPU Bound，以及这些计算时间都消耗在了哪里。<br>TimeLine可以比较明确的看到瓶颈（5.3.8没有，暂时不研究）<br>d)Bandwith Bound 在手游中也比较常见，一种比较简单的判断方式是使用NVIDIA Tegra Graphics Debugger这个工具（对于Tegra硬件更友好，但是比较难找。。。）中将所有贴图替换成2 * 2的大小，如果帧率有明显提升可能是Bandwidth瓶颈。当然也可以自己协代码所图来确认，比如使用Unity的Quality Setting里的Texture Quality。<br><img src="http://oxcvfpext.bkt.clouddn.com/How-to-systematically-optimize-performance-1.png"><br>e)内存就用Unity地Profiler来看吧，不过这个对于帧率没什么影响。</p><h3 id="2-2-卡顿"><a href="#2-2-卡顿" class="headerlink" title="2.2 卡顿"></a>2.2 卡顿</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>3D数学基础：图形与游戏开发</title>
      <link href="/2018/05/16/3d-math-base-graph-game-develop/"/>
      <url>/2018/05/16/3d-math-base-graph-game-develop/</url>
      
        <content type="html"><![CDATA[<h3 id="9-4-1-4D齐次空间"><a href="#9-4-1-4D齐次空间" class="headerlink" title="9.4.1 4D齐次空间"></a>9.4.1 4D齐次空间</h3><p>4.1.3节曾提到，4D向量有4个分量，前3个是标准的x,y和z分量，第四个是w，有时称作齐次坐标。<br>    为了理解标准3D坐标是怎样扩展到4D坐标的，让我们先看一下2D中的齐次坐标，它的形式为(x,y,w)。想象在3D中w=1处的标准2D平面，实际的2D点(x,y)用齐次坐标表示(x,y,1)，对于哪些不在w=1平面的点，则将它们投影到w=1平面上。所以齐次坐标(x,y,w)映射的实际2D点为(x/w,y/w)。如图9.2所示。<br>    因此，给定一个2D点(x,y)，齐次空间中有无数多个点与之对应。所有点的形式都为(kx,ky,k),k≠0。这些点构成一条穿过齐次原点的直线。<br>    当w=0时，除法未定义，因此不存在实际的2D点。然而，可以将2D齐次点(x,y,0)解释为“位于无穷远的点”，它描述了一个方向而不是一个位置。在下节中会有关于该点的更多讨论。<br>    <img src="http://oxcvfpext.bkt.clouddn.com/3d-math-base-graph-game-develop-9-2-1.png" longdesc="图9.2 齐次坐标投影到2D中w=1的平面上"><br>    4D坐标的基本思想相同。实际的3D点能被认为是在4D中w=1“平面”上。4D点的形式为(x,y,z,w)，将4D点投影到这个“平面”上得到相应的实际3D点(x/w,y/w,z/w)。w=0时4D点表示“无限远点”，它描述了一个方向而不是一个位置。</p><pre><code>齐次坐标和通过除以w来投影时很有趣的，那我们为什么要使用4D坐标呢？有两个基本原因使得我们要使用4D向量和4X4矩阵。第一个原因实际上就是因为它是一种方便的记法，这也是下一节将要讨论的。</code></pre><h3 id="9-4-2-4X4平移矩阵"><a href="#9-4-2-4X4平移矩阵" class="headerlink" title="9.4.2 4X4平移矩阵"></a>9.4.2 4X4平移矩阵</h3><pre><code>回忆8.8.1节，3X3变换矩阵表示的是线性变换，不包含平移。因为矩阵乘法的性质，零向量总是变换成零向量，因此，任何能用矩阵乘法表达的变换都不包含平移。这很不幸，因为矩阵乘法和它的逆是一种非常方便的工具，不仅可以用来复用复杂的变换组合成简单的单一变换，还可以操纵嵌入式坐标系间的关系。如果能找到一种方法将3X3变换矩阵进行扩展，使它能处理平移，这将是</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PBR_Guide_Vol1</title>
      <link href="/2018/05/14/PBR-Guide-Vol1/"/>
      <url>/2018/05/14/PBR-Guide-Vol1/</url>
      
        <content type="html"><![CDATA[<h3 id="光与物质"><a href="#光与物质" class="headerlink" title="光与物质"></a>光与物质</h3><p>光与物质：基于物理的渲染与着色理论<br>光是一种复杂的现象，它同时展现出波与粒子两种特性。于是，为了描述光的表现特性，人们建立了各种模型。<br>作为材质艺术家，我们感兴趣的是光线模型（Light Ray Model）因为它描述了光与物质的交互作用。<br>对我们来说，理解光线如何与物质表面交互非常重要，因为我们的工作是创作描述物体表面的材质。<br>我们创作出的纹理与材质再虚拟世界中与光交互，对光线表现特效理解的越多，创作出的材质就会更好。<br>再这篇指南中，我们会讨论物理理论，而基于物理的渲染(physically-based rendering)(PBR)模型正是建立在其上的。<br>我们从光线开始，逐步讲解PBR中的关键点。</p><h3 id="光线"><a href="#光线" class="headerlink" title="光线"></a>光线</h3><p>光线模型阐明，光线在均匀透明介质（如空气）中的轨迹为直线。光线模型同时也阐明，当光传播遇到表面是，例如遇到不透明物体或穿过不同介质如从空气折射入水中，光的表现是可预测的。这样，当光从一个起点传播到某点最终转换为其他形式例如热时，我们可以将它的轨迹视觉化。<br>击中一个表面的光线成为入射光，而它击中的角度称为入射角，如图01所示。<br>一条光线射入两个不同介质间的平面交界面。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>d3d11</title>
      <link href="/2018/05/14/d3d11/"/>
      <url>/2018/05/14/d3d11/</url>
      
        <content type="html"><![CDATA[<ol><li>点积(dot product)计算结果是标量值；也叫标量积(scalar product)。等于两个向量对应分量的乘积之和。</li></ol><p>$\mathbf{u \cdot v} = u_xv_x+u_yv_y+u_zv_z$</p><h2 id="4-1-准备工作"><a href="#4-1-准备工作" class="headerlink" title="4.1 准备工作"></a>4.1 准备工作</h2><h3 id="4-1-4-交换链和页面翻转"><a href="#4-1-4-交换链和页面翻转" class="headerlink" title="4.1.4 交换链和页面翻转"></a>4.1.4 交换链和页面翻转</h3><p>为了避免在动画中出现闪烁，最好的做法是在一个离屏（off-screen）纹理中执行所有的动画帧绘制工作，这个离屏纹理成为后台缓存区(back buffer)。当我们在后台缓冲区中完成给定帧的绘制工作后，便可以将后台缓冲区作为一个作为一个完整的帧显示在屏幕上；使用这种方法，用户不会感觉到帧的绘制过程，只会看到完整的帧。从理论上讲，将一帧显示到屏幕上所消耗的时间小于屏幕的垂直刷新时间。硬件会自动维护两个内置的纹理缓冲区来实现这一功能，这两个缓冲区分别成为前台缓冲区(front buffer)和后台缓冲区。前台缓冲区存储了当前显示在屏幕上的图像数据，而动画的下一帧会在后台缓冲区中执行绘制。当后台缓冲区的绘制工作完成之后，前后两个缓冲区的做哟个会发生翻转；后台缓冲区会变为前台huan’ch</p><h3 id="4-1-5-深度缓冲区"><a href="#4-1-5-深度缓冲区" class="headerlink" title="4.1.5 深度缓冲区"></a>4.1.5 深度缓冲区</h3><p><strong>深度缓冲区(depth buffer)</strong>是一个不包含图像数据的纹理对象。在一定程度上，深度信息可以被认为是一种特殊的像素。常见的深度值范围在0.0到1.0之间，其中0.0表示离观察者最近的物体，1.0表示离观察者最远的物体。深度缓冲区中的每个元素与后台缓冲区中的每个像素一一对那个（即，后台缓冲区的第ij个元素对应于深度缓冲区第ij个元素）。所以，当后台缓冲区的分辨率为1280x1024时，在深度缓冲区中有1280x1024个深度元素。</p><h3 id="4-1-6-纹理资源视图"><a href="#4-1-6-纹理资源视图" class="headerlink" title="4.1.6 纹理资源视图"></a>4.1.6 纹理资源视图</h3><p>纹理可以被绑定到<strong>渲染管线（rendering pipeline）</strong>的不同<strong>阶段(stage)</strong>;例如，比较常见的情况是将纹理作为渲染目标（即，Direct3D渲染到纹理）或着色器资源（即，在着色器中对纹理进行采样）。当创建用于这两种目的的纹理资源时，应使用绑定标记值：<br>    D3D11_BIND_RENDER_TARGET|D3D10_BIND_SHADER_RESOURCE<br>指定纹理所要绑定的两个管线阶段。其实，资源不能被直接绑定到一个管线阶段；我们只能把与资源关联的资源试图绑定到不同的管线阶段。无论以哪种方式使用纹理，Direct3D始终要求我们在初始化时为纹理创建相关的<strong>资源视图(resource view)</strong>。这样有助于提供运行效率，正如SDK文档指出的那样：“运行时环境与驱动程序可以在视图创建执行相应的验证和映射，减少绑定时的类型检查”。所以，当把纹理作为一个渲染目标和着色器资源时，我们要为它创建两种试图：<strong>渲染目标试图 (ID3D11RenderTargetView)</strong>和<strong>着色器资源视图 (ID3D11ShaderResourceView)</strong>。资源视图主要有两个功能：（1）告诉Direct3D如何使用资源（即，指定资源所要绑定的管线阶段）；</p><h3 id="4-1-7-多重采样"><a href="#4-1-7-多重采样" class="headerlink" title="4.1.7 多重采样"></a>4.1.7 多重采样</h3><p>因为计算机显示器上的像素分辨率有限，所以当我们绘制一条任意直线时，该直线很难精确地显示在屏幕上。<br>当无法提高显示器的分辨率，缩小像素尺寸，也可以有效地缓解这一问题，使阶梯效应明显降低。<br>当无法提高显示器分辨率或分辨率不够高时，我们可以使用<strong>抗锯齿 (antialiasing)技术</strong>。其中的一种技术叫做<strong>超级采样（supersampling）</strong>，它把后台缓冲和深度缓冲的大小提高到屏幕分辨率的4倍。</p><h3 id="4-1-8-Direct3D中的多重采样"><a href="#4-1-8-Direct3D中的多重采样" class="headerlink" title="4.1.8 Direct3D中的多重采样"></a>4.1.8 Direct3D中的多重采样</h3><h2 id="4-2-对Direct3D进行初始化"><a href="#4-2-对Direct3D进行初始化" class="headerlink" title="4.2 对Direct3D进行初始化"></a>4.2 对Direct3D进行初始化</h2><ol><li>ID3D11Device接口用于检测显示适配器功能和分配资源。</li><li>ID3D11DeviceContext接口用于设置管线状态、将资源绑定到图形管线和生成渲染命令。</li></ol><h3 id="4-2-2-检测4X多重采样质量支持"><a href="#4-2-2-检测4X多重采样质量支持" class="headerlink" title="4.2.2 检测4X多重采样质量支持"></a>4.2.2 检测4X多重采样质量支持</h3><p>创建了设备后，我们就可以检查4X多重采样质量等级了。所有支持Direct3D 11的设备都支持所有渲染目标格式的4X MSAA（支持的质量等级可能并不相同）。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UINT m4xMsaaQuality;</span><br><span class="line">HR(md3dDevice-&gt;CheckMultisampleQualityLevels(DXGI_FORMAT_R8G8B8AB_UNORM, <span class="number">4</span>, &amp;m4xMassQuality));</span><br><span class="line">assert(m4xMsaaQuality&gt;<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><p>因为4X MSAA总是被支持的，所以返回的质量等级总是大于0。</p><h3 id="4-2-3-描述交换链"><a href="#4-2-3-描述交换链" class="headerlink" title="4.2.3 描述交换链"></a>4.2.3 描述交换链</h3><p>下一步是创建交换链，首先需要填充一个DXGI_SWAP_CHAIN_DESC结构体来描述我们将要创建的交换链的特性。该结构体的定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DXGI_SWAP_CHAIN_DESC</span>&#123;</span></span><br><span class="line">    DXGI_MODE_DESC BufferDesc;</span><br><span class="line">    DXGI_SAMPLE_DESC SampleDesc;</span><br><span class="line">    DXGI_USAGE BufferUsage;</span><br><span class="line">    UINT BufferCount;</span><br><span class="line">    HWND OutputWindow;</span><br><span class="line">    BOOL Windowed;</span><br><span class="line">    DXGI_SWAP_EFFECT SwapEffect;</span><br><span class="line">    UINT Flags;</span><br><span class="line">&#125;DXGI_SWAP_CHAIN_DESC;</span><br></pre></td></tr></table></figure></p><p><strong>DXGI_MODE_DESC</strong>类型是另一个结构体，其定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DXGI_MODE_DESC</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    UINT Width;<span class="comment">// 后台缓冲区宽度</span></span><br><span class="line">    UINT Height;<span class="comment">// 后台缓冲区高度</span></span><br><span class="line">    DXGI_RATIONAL RefreshRate; <span class="comment">// 显示刷新率</span></span><br><span class="line">    DXGI_MODE_SCANLINE_ORDER ScanlineOrdering; <span class="comment">// display scanline mode</span></span><br><span class="line">    DXGI_MODE_SCALING Scaling; <span class="comment">// display scaling mode </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>注意：</strong>在下面的数据成员描述中，我们只覆盖了一些常用的标记值和选项，它们对于初学者来说非常重要。对于其他标志值和选项的描述，请参阅SDK文档。</p><ol><li><strong>BufferDesc:</strong>该结构体描述了我们所要创建的后台缓冲区的属性。我们主要关注的属性有：宽度、高度和像素骼时；其他属性的详情请参阅SDK文档。</li><li><strong>SampleDesc:</strong></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Liyanfeng-Notes</title>
      <link href="/2018/04/26/Liyanfeng-Notes/"/>
      <url>/2018/04/26/Liyanfeng-Notes/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Shader模板缓冲和模板测试</title>
      <link href="/2018/04/26/Unity-Stencil-Buffer-Stencil-Test/"/>
      <url>/2018/04/26/Unity-Stencil-Buffer-Stencil-Test/</url>
      
        <content type="html"><![CDATA[<p>在图形学种一个像素会有如下缓存：</p><ul><li>颜色缓存color buffer/pixel buffer : 存储该点即将显示地颜色，RGBA值</li><li>深度缓存depth buffer/z buffer:存储该点地深度，z</li><li>模板缓存stencil buffer： 通常用作限制渲染区域。更高级用法需结合深度缓冲，例如某像素地模板缓冲值会随着其是否通过深度缓冲测试而改变。</li><li>累计缓存Accumulation Buffer:与颜色缓存类似，同样储存一个RGBA值。累计缓存是为合成多幅图像而设计地，累计缓存提供了一种在保持好地颜色分辨率下实现在场景中”多重曝光(multiple exposures”地方法。使用累计缓存可以产生许多图像效果来提高图像的真实性，其中包括：反走样，运动模糊，软阴影，深度域（景深）和卷积。要产生这些效果，必须将图像渲染多次，对场景位置（或所选的物体）进行微小的、渐增的改变，然后累计结果。</li></ul><p>stencil与颜色缓冲区和深度缓存区类似，模板缓存区可以为屏幕上的每个像素点保存一个无符号整数值（通常是个八位整数）。这个值的具体意义视程序的具体应用而定。在渲染的过程中，可以用这个值与一个预先设定的参考值相比较，根据比较的结果来决定是否更新相应的像素点的颜色值。这个比较的过程成为模板测试Stencil Test。模板测试发生在透明度测试(alpha test)之后。如果模板测试通过，则相应的像素点更新，否则不更新。图形渲染管线中，基于单个像素的测试操作的顺序如下图<br><img src="http://oxcvfpext.bkt.clouddn.com/Unity-Stencil-Buffer-Stencil-Test-1.jpg"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity Lerp</title>
      <link href="/2018/04/26/Unity-Lerp/"/>
      <url>/2018/04/26/Unity-Lerp/</url>
      
        <content type="html"><![CDATA[<p>有时，我们在做游戏时会发现有些跟随动作不够圆滑或者需要一个缓冲的效果，这时，一般会考虑到插值。（比如摄像机跟随主角）</p><p>插值是数学上的一个概念，公式： from + (to - from) * t;<br>from是起始地位置，to是目标位置，按照数字t在from到to之间插值。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CG-Input-Output-And-Semantic-Bind</title>
      <link href="/2018/04/21/CG-Input-Output-And-Semantic-Bind/"/>
      <url>/2018/04/21/CG-Input-Output-And-Semantic-Bind/</url>
      
        <content type="html"><![CDATA[<p>先复习一下GPU的工作流程，第三章从CPU运行原理和数据流程的角度阐述了顶点着色器程序和片段着色程序的输入输出，即，应用程序(宿主程序)将图元信息(顶点位置、法向量、纹理坐标等)传递给顶点着色程序；顶点着色程序基于图元信息进行坐标空间变换，运算得到的数据传递到片段着色程序中；片段着色程序还可以接受从应用程序中传递的纹理信息，将这些信息综合起来计算每个片段的颜色值，最后将这些颜色值输送到帧缓冲区(或颜色缓冲区)中。<br><img src="http://oxcvfpext.bkt.clouddn.com/CG-Input-Output-And-Semantic-Bind-1.jpg"><br>这一章中，我们将讲解Cg语言通过何种机制确定数据类型和传递形式。<br>三个问题：<br>1、从应用程序传递到GPU的数据，分为图元信息数据(在GPU处理的基本数据如顶点位置信息等)和其他的离散数据(在GPU运行流程中不会发生变化，如材质对光的反射、折射信息)，这两种输入数据如何区分？<br>2、从应用程序传递到GPU中的图元信息如何区分类型，即，顶点程序怎么知道一个数据是位置数据，而不是法线量数据？<br>3、顶点着色程序与片段着色程序之间的数据传递如何进行？<br>cg关键字不但用于指定输入图元的数据含义(是位置信息，还是法向量信息),本质也则对应着这些图元数据存放的硬件资源(寄存器或者纹理)，称之为语义词(Semantics),通常也根据其用法称之为绑定语义词(binging semantics)。</p><p>除语义词外，Cg中还提供了三个关键字，int、out、inout，用于表示函数的输入参数的传递方式，称为输入/输出关键字，这组关键字可以和语义词合用表达硬件上不同的存储位置，即同一个语义词，使用in关键字修饰和out关键词修饰，表示的图形硬件上不同的寄存器。</p><p>Cg语言还提供两个修饰符：uniform,用于指定变量的数据初始化方式；const关键字的含义与C/C++中相同，表示被修饰变量为常量变量。</p><h3 id="uniform"><a href="#uniform" class="headerlink" title="uniform"></a>uniform</h3><p>Cg语言将输入输出数据流分为两类：</p><ol><li>Varying inputs,即数据流输入图元信息的各种组成要素。从应用程序输入到GPU的数据除了顶点位置数据，还有顶点的法向量数据，纹理坐标数据等。</li><li>Uniform inputs,表示一些与三维渲染有关的离散信息数据，这些数据通常由应用程序传入，并通常不会随着图元信息的变化而变化，如材质对光的反射信息、运动矩阵等。Uniform修饰一个参数，表示该参数的值由外部应用程序初始化并传入。<br>使用Uniform修饰的变量，除了数据来源不同外，与其他变量是完全一样的。需要注意的一点是：uniform修辞的变量是从外部传入的，所以在Cg程序(顶点程序和片段程序)中通常所有uniform参数修辞函数形参，不容许声明一个uniform修辞的局部变量！</li></ol><p>Cg语言中参数传递方式同样分为”值传递”和”引用传递”，但指针机制并不被GPU硬件支持，所以Cg语言采用不同的语法修辞符来区别”值传递”和”引用传递”.这些修辞符分别为：</p><ol><li>in   :修辞一个形参只是用于输入，进入函数体时被初始化，且该形参值的改变不会影响实参值，这是典型的值传递方式。</li><li>out  :修辞一个形参只是用于输出的，进入函数体时并没有被初始化，这种类型的形参一般是一个函数的运行结果；</li><li>inout:修辞一个形参即用于输入也用于输出，这是典型的引用传递。<br>例如： void myFunction(float x); //等价于in float x，这种用法和C/C++完全一致<br>语义词(Semantic)与语义绑定(Binding semantics)</li></ol><p>语义词，表示输入图元的数据含义(是位置信息，还是法向量信息)，也表明这些图元数据存放的硬件资源(寄存器或者纹理缓存区)。顶点着色程序和片段着色程序中Varying inputs类型的输入，必须和一个语义词相绑定，这称之为绑定语义(binding semantics)。</p><p>记住这一点：语义，是两个处理阶段(顶点程序、片段程序)之间的输入/输出数据和寄存器之间的桥梁，同时语义通常也表示数据的含义，如POSITION一般表示参数存放的数据是顶点位置。</p><p>语义，只对两个处理阶段的输入/输出数据有意义，也就是说，语义只有在入口函数中才有效，在内部函数(一个阶段的内部处理函数，和下一个阶段没有数据传递关系)无效，被忽略。</p><p>顶点着色程序必须声明一个输出变量，并绑定POSITION语义词，该变量中的数据将被用于且至被用于光栅化！</p><p>为了保持顶点程序输出语义和片段程序输入语义的一致性，通常使用相同的struct类型数据作为两者之间的传递，这是一种非常方便的写法，推荐使用。</p><p>注意：当使用struct结构中成员变量绑定语义时，需要主要到顶点着色程序中使用的POSITION语义词，是不会被片段程序所使用的。</p><p>都要记住vertex program中的绑定语义(POSITION除外)的输出形参中的数据会传递到fragment program中绑定相同语义的输入形参中。</p><p>片段着色器的输出语义词较少，通常是COLOR。这是因为片段着色程序运行完毕后，就基本到了GPU流水线的末端了。片段程序必须声明一个out向量(三元或四元),绑定语义词COLOR，这个值将被用作该片段的最终颜色值。</p><h3 id="语义绑定方法"><a href="#语义绑定方法" class="headerlink" title="语义绑定方法"></a>语义绑定方法</h3><p>绑定语义放在函数的参数列表的参数声明后面中：</p><pre><code>[const][int|out|inout]&lt;type&gt;&lt;identifier&gt;[:&lt;binding-semantic&gt;][=&lt;initializer&gt;]</code></pre><p>绑定语义可以放在结构体(struct)的成员变量后面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct &lt;struct-tag&gt;</span><br><span class="line">&#123;</span><br><span class="line">    &lt;type&gt;&lt;identifier&gt; [:&lt;binding-semantic&gt;];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>绑定语义词可以放在函数声明的后面，其形式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt; &lt;identifier&gt;(&lt;parameter-list&gt;)[:&lt;binding-semantic&gt;]</span><br><span class="line">&#123;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后一种语义绑定的方法是，将绑定语义词放在全局非静态变量的声明后面。其形式为：</p><pre><code>&lt;type&gt; &lt;identifer&gt;[:&lt;binding-semantic&gt;][=&lt;initializer&gt;];</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> CG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity Mesh</title>
      <link href="/2018/04/21/Unity-Mesh/"/>
      <url>/2018/04/21/Unity-Mesh/</url>
      
        <content type="html"><![CDATA[<p>Mesh是Unity内的一个组件，成为网格组件。</p><ul><li>Mesh网格</li><li>MeshFilter网格过滤器</li><li>Mesh Renderer 网格渲染器</li></ul><p>Mesh: 是指模型的网格，建模就是建网格。Mesh的主要属性内容包括顶点坐标，法线，纹理坐标，三角形绘制序列等其他有用属性和功能。因此建网格，就是画三角形；画三角形就是定位三个点。<br>Mesh Filter: 内包含一个Mesh组件，可以根据MeshFilter获得网格的组件，也可以为MeshFilter设置Mesh内容。<br>Mesh Renderer: 是用于把网格渲染出来的组件。MeshFilter的作用就是把Mesh扔给MeshRender将模型或者是几何体绘制显示出来。</p><p>它们之间的关系大概就是GameObject挂MeshFilter组件，该组件有Mesh属性，该属性存顶点坐标，法线等属性，然后用Mesh Renderer(SkinMeshRenderer)才能将此网格渲染出来。</p><h3 id="Mesh属性"><a href="#Mesh属性" class="headerlink" title="Mesh属性"></a>Mesh属性</h3><ul><li>顶点坐标(vertex) 顶点坐标数组存放Mesh的每个顶点空间坐标，假设某mesh有n个顶点，则vertex的size为n</li><li>法线(normal) 法线数组存放mesh每个顶点的法线，大小与顶点坐标对应，normal[i]对应vector[i]的法线</li><li>纹理坐标(uv) 它定义了图片上每个点的位置的信息，这些点与3D模型是互相联系的，以决定表面纹理贴图的位置，UV就是将图像上每个点精确对应到模型物体的表面uv[i]对应vectex[i]</li><li>三角形序列(triangle) 每个mesh都由若干个三角形组成，而三角形的三个点就是顶点坐标里的点，三角形的数组的size - 三角形个数 * 3</li></ul><p>例如：某mesh有四个顶点0,1,2,3<br>v0( 1, 1, 0)<br>v1(-1, 1, 0)<br>V2( 1,-1, 0)<br>V3(-1,-1, 0)<br>那么它们可以组成这样的一个网格<br>tri[0] = v0,v3,v1, tri[1] = v0, v2, v3</p><p>注意：三角形的顶点顺序必须是顺时针，顺时针表示正面，逆时针表示背面，而Unity3D在渲染默认只渲染正面，背面是看不见的。(双面渲染一般用于头发等材质的处理)<br>那么该三角形可以表示:</p><pre><code>tri = new int[2 * 3]{0,3,1, 0, 2, 3};</code></pre><p>如何要获取第N个三角形对应的三个顶点坐标，则:V1 = tri[N <em> 3+0],v2 = tri[N </em> 3 + 1], v3 = tri[N * 3 + 2]</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="comment">//注意Unity是左手坐标系！！！，Unity默认是不渲染背面的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CreateMesh</span> : <span class="title">MonoBehaviour</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> MeshFilter filter;</span><br><span class="line">    <span class="keyword">private</span> Mesh mesh;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span> (<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        filter = GetComponent&lt;MeshFilter&gt;();</span><br><span class="line">        mesh = <span class="keyword">new</span> Mesh();</span><br><span class="line">        filter.mesh = mesh;</span><br><span class="line">        InitMesh();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InitMesh</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        mesh.name = <span class="string">"MyMesh"</span>;</span><br><span class="line">        Vector3[] vertics = <span class="keyword">new</span> Vector3[<span class="number">8</span>]&#123;</span><br><span class="line">            <span class="keyword">new</span> Vector3(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>),</span><br><span class="line">            <span class="keyword">new</span> Vector3(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">            <span class="keyword">new</span> Vector3(<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>),</span><br><span class="line">            <span class="keyword">new</span> Vector3(<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>),</span><br><span class="line">            <span class="keyword">new</span> Vector3(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),</span><br><span class="line">            <span class="keyword">new</span> Vector3(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">            <span class="keyword">new</span> Vector3(<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>),</span><br><span class="line">            <span class="keyword">new</span> Vector3(<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">1</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        mesh.vertices = vertics;</span><br><span class="line">        <span class="keyword">int</span>[] triangles = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">12</span> * <span class="number">3</span>]&#123;</span><br><span class="line">            <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">            <span class="number">4</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>,</span><br><span class="line">            <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">4</span>,</span><br><span class="line">            <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">6</span>,</span><br><span class="line">            <span class="number">0</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">2</span>,</span><br><span class="line">            <span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">5</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        mesh.triangles = triangles;</span><br><span class="line">        <span class="comment">/*Vector2[] uv = new Vector2[4]&#123;</span></span><br><span class="line"><span class="comment">            new Vector2(1,1),</span></span><br><span class="line"><span class="comment">            new Vector2(0,1),</span></span><br><span class="line"><span class="comment">            new Vector2(1,0),</span></span><br><span class="line"><span class="comment">            new Vector2(0,0)</span></span><br><span class="line"><span class="comment">        &#125;;</span></span><br><span class="line"><span class="comment">        mesh.uv = uv;*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下(一定要加Mesh Renderer因为这玩意是负责渲染的,Unity这货材质缺失就是显示粉色的)<br><img src="http://oxcvfpext.bkt.clouddn.com/Unity-Mesh-2.png"></p><p>网格已经生成了，接下来就是给网格贴图了，uv属性会直接控制贴显示贴图的哪一部分，以及如何显示贴图uv中的每一项和vertices的每一项都是一一对应的，unity在贴图的时候，会把uv中的每一个点和vertices中对应的索引的顶点一一关联起来，这样可以实现贴图任意形状实现<br>最终效果<br><img src="http://oxcvfpext.bkt.clouddn.com/Unity-Mesh-3.png"></p><h3 id="shared"><a href="#shared" class="headerlink" title="shared"></a>shared</h3><p>在源对象上修改属性，非shared每次修改属性会从新生成一个对象。<br>在编辑器下非运行期如果使用shared会修改本地文件，如果使用非shared会提示内存泄漏。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cocos2d</title>
      <link href="/2018/04/20/cocos2d/"/>
      <url>/2018/04/20/cocos2d/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> Cocos2D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity3D MMORPG客户端游戏设计</title>
      <link href="/2018/04/20/xxsy-client-framework/"/>
      <url>/2018/04/20/xxsy-client-framework/</url>
      
        <content type="html"><![CDATA[<h1 id="资源模块"><a href="#资源模块" class="headerlink" title="资源模块"></a>资源模块</h1><h1 id="UI模块"><a href="#UI模块" class="headerlink" title="UI模块"></a>UI模块</h1><h1 id="更新模块"><a href="#更新模块" class="headerlink" title="更新模块"></a>更新模块</h1><h1 id="网络模块"><a href="#网络模块" class="headerlink" title="网络模块"></a>网络模块</h1><h1 id="Lua模块"><a href="#Lua模块" class="headerlink" title="Lua模块"></a>Lua模块</h1><h2 id="Lua-注册"><a href="#Lua-注册" class="headerlink" title="Lua 注册"></a>Lua 注册</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MonoInvokeCallbackAttribute(typeof(LuaCSFunction))</span>]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">call</span>(<span class="params">System.IntPtr L</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> upidx = LuaDLL.lua_upvalueindex(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> fnidx = (<span class="keyword">int</span>)LuaDLL.lua_touserdata(L, upidx);</span><br><span class="line">    <span class="keyword">if</span> (fnidx &lt;= || fnidx &gt; m_count)</span><br><span class="line">    &#123;</span><br><span class="line">        LuaDLL.luaL_error(L, <span class="string">"SafeCallApi : bad function index "</span> + fnidx);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> info = m_infos[fnidx - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (L != LuaMgr.m_L)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">using</span> (<span class="keyword">new</span> GuardL &#123; L = LuaMgr.m_L&#125;)</span><br><span class="line">            &#123;</span><br><span class="line">                LuaMgr.m_L = L;</span><br><span class="line">                <span class="keyword">int</span> v = info.function();</span><br><span class="line">                <span class="keyword">return</span> v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> r = info.function();</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (System.Exception err)</span><br><span class="line">    &#123;</span><br><span class="line">        LuaDLL.lua_pushstring(L, <span class="string">"SafeCallApi : exception \n"</span> + err.ToString());</span><br><span class="line">    &#125;</span><br><span class="line">    LuaDll.lua_error(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="技能模块"><a href="#技能模块" class="headerlink" title="技能模块"></a>技能模块</h1><h1 id="角色模块"><a href="#角色模块" class="headerlink" title="角色模块"></a>角色模块</h1><h1 id="动画模块"><a href="#动画模块" class="headerlink" title="动画模块"></a>动画模块</h1><h1 id="状态模块"><a href="#状态模块" class="headerlink" title="状态模块"></a>状态模块</h1><h1 id="CD模块"><a href="#CD模块" class="headerlink" title="CD模块"></a>CD模块</h1><h1 id="状态模块-1"><a href="#状态模块-1" class="headerlink" title="状态模块"></a>状态模块</h1><h1 id="场景模块"><a href="#场景模块" class="headerlink" title="场景模块"></a>场景模块</h1><h1 id="子物体模块"><a href="#子物体模块" class="headerlink" title="子物体模块"></a>子物体模块</h1><h1 id="同屏系统"><a href="#同屏系统" class="headerlink" title="同屏系统"></a>同屏系统</h1><p>每个场景里一般都有很多对象，对其中一个对象而言，它一般只关注自己周围一定范围内的其它对象。同屏系统的主要工作就是将对象周围一定范围内的其它对象精确且高效的统计，为客户端的表现以及其它系统提供服务。</p><p>我们采取的思想是每个对象维护了一个同屏信息，同屏信息主要包括同屏对象列表和同屏玩家列表。</p><p>导致同屏信息表改变的原因主要有三个：新对象进入场景，对象位置改变，对象离开场景。<br>针对以上三种原因我们采取了两种实现机制：定时更新机制，立刻更新机制。<br>立刻更新机制：<br>    主要针对对象离开场景的情况。<br>    实现步骤主要是根据离开对象记录的同屏信息，再相关联对象和自己的同屏信息内相互去掉。<br>定时更新机制：<br>    主要针对对象进入场景和对象位置改变两个原因。<br>    针对对象进入场景原因实现主要是对象进入场景时，设置新对象标记。然后通过定时更新实现同屏信息变化。<br>    针对对象位置改变原因实现步骤主要是对象位置改变，设置位置变更标记。然后通过定时更新实现同屏信息变化。<br>    定时更新机制是每个tick对场景内所有本tick进行过位置变化或者新进入的对象进行同屏信息更新。更新的主要逻辑是再同屏信息内的对象若离开同屏则进行清除和未在同屏信息内的玩家若满足进入同屏则加入。<br>    由于定时更新使用频繁且实现复杂，因此采取了搞笑的实现方法来实现这个功能。由于定时更新需要检测哪些对象进入同屏，如果整个检测整个场景内的对象，比较费，由此提出了单元格概念(CellSpace)，就是把场景划分N*N的格子，每个各自作为一个单元格，单元格内维护对象列表。然后再根据玩家的同屏距离，首先获得所在的单元戈，再判断对应单元格的对象是否进入对象同屏，减少判断数量。</p><p>游戏专用子系统<br>武器、道具、<br>游戏专用渲染<br>地形渲染、水体模拟及渲染<br>玩家机制<br>状态机及动画、相对摄像机的操控（HID）、碰撞流行、移动<br>游戏摄像机<br>固定设想、脚本/动画摄像机、跟踪玩家摄像机、调试用飞行摄像机<br>人工智能<br>目标及决策、动作（引擎接口）、视线追踪及感知、路径搜寻（A*）<br>前端<br>平视显示器（HUD）、全动视频（FMV）、游戏内置电影（IGC）、游戏内置GUI、游戏内置菜单、包裹/吸引模式<br>视觉效果<br>光照贴图及动态阴影、高动态光照、PRT光照此表面散射、粒子及贴花系统、后处理效果、环境贴图<br>场景图/剔除优化<br>空间部分（BSP树）、遮挡及潜在可见集、纹理及表面管理、调试绘图（直线等）、图形设备接口<br>性能剖析及调试<br>录影及回放、内存及性能统计、游戏内菜单或控制台<br>游戏性基础<br>高层次的游戏流程系统/FSM<br>脚本系统<br>静态世界元素、动态游戏对象模型、实时基于代理人模拟、时间/信息系统、世界载入/串流<br>骨骼动画<br>动画状态树及蹭、反向动力学（IK）层阶式物体依附、游戏专用的后期处理、线性插值、动画播放、子骨骼播放、动画解压、骨骼网格渲染、布娃娃物理<br>在线多人<br>安排比赛及游戏管理、对象管辖权策略、游戏状态复制<br>音频<br>DSP/效果、三维音频模型、音频播放/管理<br>低阶渲染器<br>材质及着色器、静态及动态光源、摄像机、文本及字体、几何图元提交、视区及虚拟屏幕、纹理及表面管理、调试绘图（直线等）、图形设备接口<br>碰撞及物理<br>力及约束、光线/形状投影（查询）、刚体、Phantom、形状/可碰撞体、物理/碰撞世界<br>人体学接口设备（HID）<br>游戏专用接口、物理设备I/O<br>资源（游戏资产）<br>三维模型资源、纹理资源、材质资源、字体资源、骨骼资源、碰撞资源、物理参数、游戏世界/地图、其他<br>核心系统<br>模块启动及终止、断言、单元测试、内存分配、数学库、字符串及散列字符串标识符、调试用打印及日志、本地化服务、影片播放器、语法分析器（CSV、XML等）、性能剖析/统计采集、引擎配置（INI文件等）、随机数生成器、曲线及曲圆库、RITI/反射/序列化、对象句柄/唯一标识符、异步文件I/O<br>平台独立层<br>平台检测、原子数据类型、集合及迭代器、文件系统、网络传播层（UDP/TCP）、高分辨率时钟、线程库、图形包裹类、物理/碰撞包裹类<br>第三方软件开发包<br>DirectX\OpenGL、Boost、STL/STLPort</p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
            <tag> MMORPG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.Net .Net Framework mono</title>
      <link href="/2018/04/18/Net-Net-Framework-mono/"/>
      <url>/2018/04/18/Net-Net-Framework-mono/</url>
      
        <content type="html"><![CDATA[<p>.net从一个抽象上来说其实是一个理念，使多种语言编写的程序能够通过一个通用的Runtime运行在不同的操作系统及硬件平台上。比如.net framework是在windows上实现的.net platform,mono是一个跨平台的.net platform<br>一个.net platform想到达到.net的目标，就需要一些组件，比如CLR(Common Language Runtime),比如FCL基础类库，比如各种语言编译器，编译器编译出来的东西想要在CLR中运行，那也需要遵循一定的标准，这就是CLI和CIL，CIL规定了编译输出的规则，而CLI规定了编译器输入语言的规则，只有符合这种标准的语言才能编译成CIL语言运行在CLR中。<br>好了现在有CIL和CLR，可以用符合CLI的语言比如C#编写程序了，然后将其编译成CIL，最后在CLR中运行<br>Unity能跨平台的原因就是实现了各个平台的”即时编译器”(C#代码-&gt;中间语言-&gt;各个平台的原生代码)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>减少装箱(Boxing)和拆箱(UnBoxing)操作</title>
      <link href="/2018/04/17/C-0/"/>
      <url>/2018/04/17/C-0/</url>
      
        <content type="html"><![CDATA[<p>.Net的类型分值类型和引用类型，这两个类型的本质区别，值类型数据是分配在栈中，而引用类型数据分配在堆上，那么如果要把一个值类型数据放到堆上，就需要装箱操作；反之，把一个放在堆上的值类型数据取出来，则需要拆箱操作。<br>减少装箱和拆箱操作的好处</p><ul><li>对于堆的操作效率比较低</li><li>堆上分配的内存资源，需要GC来回收，从而降低程序效率</li></ul><p>格式化操作有较多的装箱拆箱操作，比如String.Format, Console.WriteLine之类的语句，</p><pre><code>Console.WriteLine(&quot;Number list:{0}, {1}, {2}&quot;, 1.ToString(), t.2ToString(), 3.ToString())</code></pre><p>由于1.ToString()的结果是String类型，属于引用类型，因此不涉及装箱拆箱操作；</p>]]></content>
      
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity ECS Readme</title>
      <link href="/2018/04/17/Unity-ECS-README/"/>
      <url>/2018/04/17/Unity-ECS-README/</url>
      
        <content type="html"><![CDATA[<p align="center">    <a href="https://gitter.im/sschmid/Entitas-CSharp?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge" target="_blank" rel="noopener">        <img src="https://img.shields.io/badge/chat-on%20gitter-brightgreen.svg" alt="Join the chat at https://gitter.im/sschmid/Entitas-CSharp"></a>    <a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fgithub.com%2Fsschmid%2FEntitas-CSharp&screen_name=s_schmid&tw_p=followbutton" target="_blank" rel="noopener">        <img src="https://img.shields.io/badge/twitter-follow%20%40s__schmid-blue.svg" alt="Twitter Follow Me"></a>    <a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fgithub.com%2Fsschmid%2FEntitas-CSharp&screen_name=entitas_csharp&tw_p=followbutton" target="_blank" rel="noopener">        <img src="https://img.shields.io/badge/twitter-follow%20%40entitas__csharp-blue.svg" alt="Twitter Follow Me"></a>    <a href="https://travis-ci.org/sschmid/Entitas-CSharp" target="_blank" rel="noopener">        <img src="https://travis-ci.org/sschmid/Entitas-CSharp.svg?branch=master" alt="Build Status"></a>    <a href="https://github.com/sschmid/Entitas-CSharp/releases" target="_blank" rel="noopener">        <img src="https://img.shields.io/github/release/sschmid/Entitas-CSharp.svg" alt="Latest release"></a></p><h1 id="Entitas-The-Entity-Component-System-Framework-for-C-and-Unity"><a href="#Entitas-The-Entity-Component-System-Framework-for-C-and-Unity" class="headerlink" title="Entitas - The Entity Component System Framework for C# and Unity"></a>Entitas - The Entity Component System Framework for C# and Unity</h1><p>Entitas is a super fast Entity Component System Framework (ECS) specifically made for C# and Unity. Internal caching and blazing fast component access makes it second to none. Several design decisions have been made to work optimal in a garbage collected environment and to go easy on the garbage collector. Entitas comes with an optional code generator which radically reduces the amount of code you have to write and <a href="https://cleancoders.com" title="Clean Coders" target="_blank" rel="noopener">makes your code read like well written prose.</a></p><hr><h3 id="»-Download"><a href="#»-Download" class="headerlink" title="» Download"></a><strong><a href="#download-entitas">» Download</a></strong></h3><h3 id="»-Documentation"><a href="#»-Documentation" class="headerlink" title="» Documentation"></a><strong><a href="http://sschmid.github.io/Entitas-CSharp/" title="Entitas Documentation" target="_blank" rel="noopener">» Documentation</a></strong></h3><h3 id="»-Ask-a-question"><a href="#»-Ask-a-question" class="headerlink" title="» Ask a question"></a><strong><a href="https://github.com/sschmid/Entitas-CSharp/issues/new" title="New issue" target="_blank" rel="noopener">» Ask a question</a></strong></h3><h3 id="»-Wiki-and-example-projects"><a href="#»-Wiki-and-example-projects" class="headerlink" title="» Wiki and example projects"></a><strong><a href="https://github.com/sschmid/Entitas-CSharp/wiki" title="Entitas Wiki" target="_blank" rel="noopener">» Wiki and example projects</a></strong></h3><h3 id="»-madeWithEntitas"><a href="#»-madeWithEntitas" class="headerlink" title="» #madeWithEntitas"></a><strong><a href="https://github.com/sschmid/Entitas-CSharp/wiki/Made-With-Entitas" title="Wiki - #madeWithEntitas" target="_blank" rel="noopener">» #madeWithEntitas</a></strong></h3><hr><h1 id="Video-Tutorials-amp-Unity-Unite-Talks"><a href="#Video-Tutorials-amp-Unity-Unite-Talks" class="headerlink" title="Video Tutorials &amp; Unity Unite Talks"></a>Video Tutorials &amp; Unity Unite Talks</h1><div class="table-container"><table><thead><tr><th style="text-align:center">Entitas ECS Unity Tutorial</th><th style="text-align:center">Entitas ECS Unity Tutorial</th><th style="text-align:center">Entity system architecture with Unity</th><th style="text-align:center">ECS architecture with Unity by example</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://www.youtube.com/watch?v=L-18XRTarOM" title="Video: Entitas - Shmup - Part 1" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/sschmid/Entitas-CSharp/master/Readme/Images/Entitas-Shmup-Part-1.jpg" alt="Shmup1" title="Video: Entitas - Shmup - Part 1"></a></td><td style="text-align:center"><a href="https://www.youtube.com/watch?v=DZpvUnj2dGI" title="Video: Entitas - Shmup - Part 2" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/sschmid/Entitas-CSharp/master/Readme/Images/Entitas-Shmup-Part-2.jpg" alt="Shmup2" title="Video: Entitas - Shmup - Part 2"></a></td><td style="text-align:center"><a href="https://www.youtube.com/watch?v=Re5kGtxTW6E" title="Video: Watch the Entitas Talk at Unite Europe 2015" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/sschmid/Entitas-CSharp/master/Readme/Images/UniteEurope2015-Video.png" alt="Unite 15" title="Video: Watch the Entitas Talk at Unite Europe 2015"></a></td><td style="text-align:center"><a href="https://www.youtube.com/watch?v=Phx7IJ3XUzg" title="Video: Watch the Entitas Talk at Unite Europe 2016" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/sschmid/Entitas-CSharp/master/Readme/Images/UniteEurope2016-Video.png" alt="Unite 16" title="Video: Watch the Entitas Talk at Unite Europe 2016"></a></td></tr><tr><td style="text-align:center">Setup &amp; Basics</td><td style="text-align:center">Git &amp; Unit Tests</td><td style="text-align:center"><a href="http://www.slideshare.net/sschmid/uniteeurope-2015" title="SlideShare: Unite Europe 2015" target="_blank" rel="noopener">» Open the slides on SlideShare: Unite Europe 2015</a></td><td style="text-align:center"><a href="http://www.slideshare.net/sschmid/uniteeurope-2016" title="SlideShare: Unite Europe 2016" target="_blank" rel="noopener">» Open the slides on SlideShare: Unite Europe 2016</a></td></tr></tbody></table></div><h1 id="First-glimpse"><a href="#First-glimpse" class="headerlink" title="First glimpse"></a>First glimpse</h1><p>The optional <a href="https://github.com/sschmid/Entitas-CSharp/wiki/Code-Generator" title="Wiki - Code Generator" target="_blank" rel="noopener">code generator</a> lets you write code that is super fast, safe and literally screams its intent.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GameEntity <span class="title">CreateRedGem</span>(<span class="params"><span class="keyword">this</span> GameContext context, Vector3 position</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> entity = context.CreateEntity();</span><br><span class="line">    entity.isGameBoardElement = <span class="literal">true</span>;</span><br><span class="line">    entity.isMovable = <span class="literal">true</span>;</span><br><span class="line">    entity.AddPosition(position);</span><br><span class="line">    entity.AddAsset(<span class="string">"RedGem"</span>);</span><br><span class="line">    entity.isInteractive = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> entity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> entities = context.GetEntities(Matcher&lt;GameEntity&gt;.AllOf(GameMatcher.Position, GameMatcher.Velocity));</span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">var</span> e <span class="keyword">in</span> entities) &#123;</span><br><span class="line">    <span class="keyword">var</span> pos = e.position;</span><br><span class="line">    <span class="keyword">var</span> vel = e.velocity;</span><br><span class="line">    e.ReplacePosition(pos.<span class="keyword">value</span> + vel.<span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>Entitas is fast, light and gets rid of unnecessary complexity. There are less than a handful classes you have to know to rocket start your game or application:</p><ul><li>Entity</li><li>Context</li><li>Group</li><li>Entity Collector</li></ul><p><a href="https://github.com/sschmid/Entitas-CSharp/wiki/Overview" title="Wiki - Overview" target="_blank" rel="noopener">Read more…</a></p><h1 id="Code-Generator"><a href="#Code-Generator" class="headerlink" title="Code Generator"></a>Code Generator</h1><p>The Code Generator generates classes and methods for you, so you can focus on getting the job done. It radically reduces the amount of code you have to write and improves readability by a huge magnitude. It makes your code less error-prone while ensuring best performance. I strongly recommend using it!</p><p><a href="https://github.com/sschmid/Entitas-CSharp/wiki/Code-Generator" title="Wiki - Code Generator" target="_blank" rel="noopener">Read more…</a></p><h1 id="Unity-integration"><a href="#Unity-integration" class="headerlink" title="Unity integration"></a>Unity integration</h1><p>The optional Unity module integrates Entitas nicely into Unity and provides powerful editor extensions to inspect and debug contexts, groups, entities, components and systems.</p><p><a href="https://github.com/sschmid/Entitas-CSharp/wiki/Unity-integration" title="Wiki - Unity Integration" target="_blank" rel="noopener">Read more…</a></p><p align="center">    <img src="https://raw.githubusercontent.com/sschmid/Entitas-CSharp/master/Readme/Images/Entitas.Unity-MenuItems.png" alt="Entitas.Unity MenuItems" height="200"><br>    <img src="https://raw.githubusercontent.com/sschmid/Entitas-CSharp/master/Readme/Images/Entitas.Unity.VisualDebugging-Entity.png" alt="Entitas.Unity.VisualDebugging Entity" width="400">    <img src="https://raw.githubusercontent.com/sschmid/Entitas-CSharp/master/Readme/Images/Entitas.Unity.VisualDebugging-DebugSystems.png" alt="Entitas.Unity.VisualDebugging Systems" width="400"></p><h1 id="Entitas-deep-dive"><a href="#Entitas-deep-dive" class="headerlink" title="Entitas deep dive"></a>Entitas deep dive</h1><p><a href="https://github.com/sschmid/Entitas-CSharp/wiki" title="Entitas Wiki" target="_blank" rel="noopener">Read the wiki</a> or checkout the <a href="https://github.com/sschmid/Entitas-CSharp/wiki/Example-projects" title="Wiki - Example Projects" target="_blank" rel="noopener">example projects</a> to see Entitas in action. These example projects illustrate how systems, groups, collectors and entities all play together seamlessly.</p><h1 id="Download-Entitas"><a href="#Download-Entitas" class="headerlink" title="Download Entitas"></a>Download Entitas</h1><p>Each release is published with zip files containing all source files you need.</p><p><a href="https://github.com/sschmid/Entitas-CSharp/releases" title="Releases" target="_blank" rel="noopener">Show releases</a></p><h1 id="Thanks-to"><a href="#Thanks-to" class="headerlink" title="Thanks to"></a>Thanks to</h1><p>Big shout out to <a href="https://github.com/mzaks" title="@mzaks" target="_blank" rel="noopener">@mzaks</a>, <a href="https://github.com/cloudjubei" title="@cloudjubei" target="_blank" rel="noopener">@cloudjubei</a> and <a href="https://github.com/devboy" title="@devboy" target="_blank" rel="noopener">@devboy</a> for endless hours of discussion and helping making Entitas awesome!</p><h1 id="Maintainer-s"><a href="#Maintainer-s" class="headerlink" title="Maintainer(s)"></a>Maintainer(s)</h1><ul><li><a href="https://github.com/sschmid" title="@sschmid" target="_blank" rel="noopener">@sschmid</a> | <a href="https://twitter.com/s_schmid" title="s_schmid on Twitter" target="_blank" rel="noopener">@s_schmid</a> | <a href="https://twitter.com/entitas_csharp" title="entitas_csharp on Twitter" target="_blank" rel="noopener">@entitas_csharp</a></li></ul><h1 id="Different-language"><a href="#Different-language" class="headerlink" title="Different language?"></a>Different language?</h1><p>Entitas is available in</p><ul><li><a href="https://github.com/sschmid/Entitas-CSharp" target="_blank" rel="noopener">C#</a></li><li><a href="https://github.com/mzaks/Entitas-Swift" target="_blank" rel="noopener">Swift</a></li><li><a href="https://github.com/JuDelCo/Entitas-Cpp" target="_blank" rel="noopener">C++</a></li><li><a href="https://github.com/wooga/entitas" target="_blank" rel="noopener">Objective-C</a></li><li><a href="https://github.com/Rubentxu/entitas-java" target="_blank" rel="noopener">Java</a></li><li><a href="https://github.com/Aenyhm/entitas-python" target="_blank" rel="noopener">Python</a></li><li><a href="https://github.com/darkoverlordofdata/entitas-scala" target="_blank" rel="noopener">Scala</a></li><li><a href="https://github.com/wooga/go-entitas" target="_blank" rel="noopener">Go</a></li><li><a href="https://github.com/darkoverlordofdata/entitas-fsharp" target="_blank" rel="noopener">F#</a></li><li><a href="https://github.com/darkoverlordofdata/entitas-ts" target="_blank" rel="noopener">TypeScript</a></li><li><a href="https://github.com/darkoverlordofdata/entitas-kotlin" target="_blank" rel="noopener">Kotlin</a></li><li><a href="https://github.com/mhaemmerle/entitas-haskell" target="_blank" rel="noopener">Haskell</a></li><li><a href="https://github.com/mhaemmerle/entitas_erl" target="_blank" rel="noopener">Erlang</a></li><li><a href="https://github.com/mhaemmerle/entitas-clj" target="_blank" rel="noopener">Clojure</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity ECS</title>
      <link href="/2018/04/16/Unity-Coroutine/"/>
      <url>/2018/04/16/Unity-Coroutine/</url>
      
        <content type="html"><![CDATA[<h1 id="Coroutines"><a href="#Coroutines" class="headerlink" title="Coroutines"></a>Coroutines</h1><p>WaitForENdOffFrame 帧末尾执行</p><p>yield return null 表示暂缓一帧，在下一帧接着往下处理，于yield return 0 或 yield return 1一样的功能</p><p>yield return new WaitForSeconds</p><p>协程的真正用途是分布做一个比较耗时的事情，比如游戏里面的加载资源</p><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>应用程序运行过程中，开辟一个新的、独立于主线程的运行片段；这可以推动CPU和操作系统处理事务的极限。<br>通过拥有一个线程池可以缓解线程生存期的问题。但是，即使使用线程池也有可能激活大量线程，线程数如果多余CPU核心数将会互相争夺CPU资源，导致频繁切换上下文。切换上下文要先保存当前线程状态，在处理下一个线程，然后重新构建第一个线程，以便继续处理它。上下文切换是资源密集型的，因此尽可能避免切换上下文。</p><h1 id="Job-System"><a href="#Job-System" class="headerlink" title="Job System"></a>Job System</h1><p>Job System是通过创建Job而不是线程来管理多线程的。<br>Job System跨多个核心管理一组线程。它通常每个CPU有一个工作线程，以避免频繁切换上下文。</p><h1 id="Unity面对的问题"><a href="#Unity面对的问题" class="headerlink" title="Unity面对的问题"></a>Unity面对的问题</h1><ul><li>面向对象的编程方式（曾经的圣典，已经跟不上时代，OOP最大的问题是数据和逻辑混在一起，而现在我们要数据驱动模型）</li><li>由Mono编译的非最优机器码</li><li>GC机制</li><li>单线程开发</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity Manual</title>
      <link href="/2018/04/16/Unity-Manual/"/>
      <url>/2018/04/16/Unity-Manual/</url>
      
        <content type="html"><![CDATA[<h3 id="YieldInstruction-中断指令"><a href="#YieldInstruction-中断指令" class="headerlink" title="YieldInstruction 中断指令"></a>YieldInstruction 中断指令</h3><p>所有yield指令的基类<br>参考WaitForSeconds, WaitForFixedUpdate, Coroutine and MonoBehaviour,StartCoroutine</p><h3 id="WaitForSeconds-等待几秒"><a href="#WaitForSeconds-等待几秒" class="headerlink" title="WaitForSeconds 等待几秒"></a>WaitForSeconds 等待几秒</h3><p>Namespace: UnityEngine<br>Inherits from: YieldInstruction</p><p>在给定的秒数内，暂停协同程序的执行。<br>WaitForSeconds只能用在协同程序中的yield声明。</p><h3 id="RequireComponent"><a href="#RequireComponent" class="headerlink" title="RequireComponent"></a>RequireComponent</h3><p>当你添加了一个用了RequireComponent组件的脚本，需要的组件将会自动被添加到GameObject上。这个可以有效避免组装错误。在新建类的前面加</p><pre><code>[RequireComponent(typeof(LineRenderer))]</code></pre><h3 id="AssetDatabase-ImportAsset"><a href="#AssetDatabase-ImportAsset" class="headerlink" title="AssetDatabase.ImportAsset"></a>AssetDatabase.ImportAsset</h3><pre><code>static function ImportAsset(path : string, options : ImportAssetOptions = ImportAssetOptions.Default):void</code></pre><p>导入指定路径的资源<br>所有路径都是相对于工程目录文件，例如”Assets/MyTexture/hello.png”</p><h3 id="AssetImporter-GetAtPath"><a href="#AssetImporter-GetAtPath" class="headerlink" title="AssetImporter.GetAtPath"></a>AssetImporter.GetAtPath</h3><pre><code>static function GetAtPath(path: string):AssetImporter</code></pre><p>通过指定路径来导入资源</p><h3 id="TextureWrapMode"><a href="#TextureWrapMode" class="headerlink" title="TextureWrapMode"></a>TextureWrapMode</h3><p>在进行纹理贴图时，图像会出现在物体表面(u,v)位置上，而这些值在[0.0,1.0]范围内。但是，如果超出这个范围，会发生什么情况呢，这由纹理的映射函数来决定.常见有下面几种：</p><ol><li>重复(REPEAT):图像在表面上重复出现。在算法上，忽略纹理坐标的整数部分，并将纹理图的拷贝粘贴在物体表面上。对于大多数复制纹理的使用，在纹理顶部的纹理单元应于底部的纹理单元相匹配，在纹理左侧的纹理单元也应于右侧的纹理单元相匹配。</li><li>截取(CLAMP): 将大于1.0的数值设置为1.0，将小于0.0的数值设置为0.0，即将超出[0.0,1.0]范围的数值截取到[0.0,1.0]范围内，这样会导致纹理边缘的重复。</li><li>镜像重复(MIRRORED_REPEAT_ARB)</li><li>边界截取(CLAMP_TO_BORDER_ARB)</li><li>边缘截取(CLAMP_TO_EDGE)</li></ol><h3 id="CameraClearFlag"><a href="#CameraClearFlag" class="headerlink" title="CameraClearFlag"></a>CameraClearFlag</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> CameraClearFlags</span><br><span class="line">&#123;</span><br><span class="line">    Skybox = <span class="number">1</span>,<span class="comment">// 这是默认设置，在屏幕上空的部分显示当前相机的天空盒。如果当前相机没有设置天空盒，它会默认使用Edit-&gt;Render Settings里)中选择天空盒。然后它将退回使用背景颜色，另外天空盒组件可以添加到相机上。</span></span><br><span class="line">    SolidColor = <span class="number">2</span>, <span class="comment">// 屏幕上的任何空的部分显示当前相机的背景颜色</span></span><br><span class="line">    Color = <span class="number">2</span>,</span><br><span class="line">    Depth = <span class="number">3</span>,<span class="comment">// 该深度的东西永远都不会被裁剪</span></span><br><span class="line">    Nothing = <span class="number">4</span>,<span class="comment">// 什么事情都不做</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Projector"><a href="#Projector" class="headerlink" title="Projector"></a>Projector</h3><pre><code>nearClipPlane       近裁剪面的距离farClipPlane        远裁剪面的距离fieldOfView         该投影的视野，以度为单位aspectRatio         投影的宽高比orthographic        投射是正交还是透视orthographicSize    在正交模式下投射的一半尺寸ignoreLayers        哪个物体层被这个投射器忽略material            要投射到每个物体的材质</code></pre><h2 id="Mesh"><a href="#Mesh" class="headerlink" title="Mesh"></a>Mesh</h2><h3 id="Mesh-RecalculateBounds"><a href="#Mesh-RecalculateBounds" class="headerlink" title="Mesh.RecalculateBounds"></a>Mesh.RecalculateBounds</h3><p>在修改完顶点后你应该用这个函数以确保包围体是恰当的。赋值三角形将自动重新计算包围体。</p><h3 id="Mesh-RecalculateNormals"><a href="#Mesh-RecalculateNormals" class="headerlink" title="Mesh.RecalculateNormals"></a>Mesh.RecalculateNormals</h3><p>重新计算网格的法线<br>在修改完定点后，通常会更新发现来反映新的变化。发现是根据共享的顶点计算出来的。导入到网格有时不共享所有顶点。例如：一个顶点在一个纹理坐标的接缝处将会被分为两个顶点。因此这个RecalculateNormals函数将会在纹理坐标接缝处创建一个不光滑的法线。RecalculateNormals不会自动产生切线，因此bumpmap着色器在调用RecalculateNormals之后不会工作。然而你可以提取你自己的切线。</p><h2 id="惯性坐标系"><a href="#惯性坐标系" class="headerlink" title="惯性坐标系"></a>惯性坐标系</h2><p>因为在进行物体到世界坐标系的转换时候，即需要平移同时也需要进行旋转，为了简化这种变化，在其中假如惯性坐标系，其中惯性坐标系的原点与本地坐标系的原点重合其轴和世界坐标系平英。那么本地坐标系到惯性坐标系只需要旋转操作（之前也得缩放）再到世界坐标系只需要进行平移。</p><h1 id="构建AssetBundles"><a href="#构建AssetBundles" class="headerlink" title="构建AssetBundles"></a>构建AssetBundles</h1><p>在<a href="https://docs.unity3d.com/Manual/AssetBundles-Workflow.html" target="_blank" rel="noopener">AssetBundle工作流</a>的文档中，我们有一个代码示例，它将三个参数传递给BuildPipeline.BuildAssetBundles函数。让我们更深入实际的了解。<br>Assets/AssetBundles:这是AssetBundles输出的目录。您可以将其更改为您想要的任何输出目录，只需确保在尝试构建之前文件夹实际存在。</p><h2 id="BuildAssetBundleOptions"><a href="#BuildAssetBundleOptions" class="headerlink" title="BuildAssetBundleOptions"></a>BuildAssetBundleOptions</h2><p>BuildAssetBundleOptions您可以指定几种具有各种效果的不同。有关所有选项的表，请参阅</p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity优化</title>
      <link href="/2018/04/12/Unity-Optimize/"/>
      <url>/2018/04/12/Unity-Optimize/</url>
      
        <content type="html"><![CDATA[<ol><li>更新不透明贴图的压缩格式为ETC 4bit，因为android市场的手机中的GPU有多种，每家的GPU支持不同的压缩格式，但他们都兼容ETC格式。</li><li>对于透明贴图，我们只能选择RGBA 16bit 或者RGBA 32bit。</li><li>减少FPS，在ProjectSetting-&gt; Quality中的VSync Count 参数会影响你的FPS，EveryVBlank相当于FPS=60，EverySecondVBlank = 30；<br>这两种情况都不符合游戏的FPS的话，我们需要手动调整FPS，首先关闭垂直同步这个功能，然后在代码的Awake方法里手动设置FPS（Application.targetFrameRate = 45;）<br>降低FPS的好处：<br>1）省电，减少手机发热的情况；<br>2）能都稳定游戏FPS，减少出现卡顿的情况。</li><li>当我们设置了FPS后，再调整下Fixed timestep这个参数，这个参数在ProjectSetting-&gt;Time中，目的是减少物理计算的次数，来提高游戏性能。</li><li>尽量少使用Update LateUpdate FixedUpdate，这样也可以提升性能和节省电量。多使用事件（不是SendMessage，使用自己写的，或者C#中的事件委托）。</li><li>待机时，调整游戏的FPS为1，节省电量。</li><li>图集大小最好不要高于1024，否则游戏安装之后、低端机直接崩溃、原因是手机系统版本低于2.2、超过1000的图集无法读取、导致。2.2 以上没有遇见这个情况。注意手机的RAM 与 ROM、小于 512M的手机、直接放弃机型适配。</li></ol><h2 id="VSCount-垂直同步"><a href="#VSCount-垂直同步" class="headerlink" title="VSCount 垂直同步"></a>VSCount 垂直同步</h2><p>Unity3D中新建一个空场景的时候，帧速率（FPS总是很低），大概在60~70之间。在Unity3D中当运行场景打开Profiler的时候，我们会看到VSync 这一项占了很大的比重。<br>这个是什么呢，这个就是垂直同步。<br>我们可以关闭VSync来提高帧速率，选择edit-&gt;project settings-&gt;Quality。<br>在右侧面板中可以找到VSync Count,把它选成Don’t Sync。<br>这就关闭了VSync(垂直同步)，现在在运行场景看看，帧速率是不是提高很多。<br>现在来说说什么是垂直同步，要知道什么是垂直同步，必须要先明白显示器的工作原理，<br>显示器上的所有图像都是一线一线的扫描上去的，无论是隔行扫描还是逐行扫描，<br>显示器都有两种同步参数——水平同步和垂直同步。</p><p>什么叫水平同步？什么叫垂直同步？<br>垂直和水平是CRT中两个基本的同步信号，水平同步信号决定了CRT画出一条横越屏幕线的时间，<br>垂直同步信号决定了CRT从屏幕顶部画到底部，再返回原始位置的时间，<br>而恰恰是垂直同步代表着CRT显示器的刷新率水平。</p><p>为什么关闭垂直同步信号会影响游戏中的FPS数值？<br>如果我们选择等待垂直同步信号（也就是我们平时所说的垂直同步打开），<br>那么在游戏中或许强劲的显卡迅速的绘制完一屏的图像，但是没有垂直同步信号的到达，<br>显卡无法绘制下一屏，只有等85单位的信号到达，才可以绘制。<br>这样FPS自然要受到操作系统刷新率运行值的制约。</p><p>而如果我们选择不等待垂直同步信号（也就是我们平时所说的关闭垂直同步），那么游戏中作完一屏画面，<br>显卡和显示器无需等待垂直同步信号就可以开始下一屏图像的绘制，自然可以完全发挥显卡的实力。<br>但是不要忘记，正是因为垂直同步的存在，才能使得游戏进程和显示器刷新率同步，使得画面更加平滑和稳定。<br>取消了垂直同步信号，固然可以换来更快的速度，但是在图像的连续性上势必打折扣。<br>这也正是很多朋友抱怨关闭垂直后发现画面不连续的理论原因。</p><p>合并材质球Unity3D中每导入一次模型就多一个材质球，可我的这些模型都是共用一张贴图的就想共用一个材质球，所以每次都要删除再附上，很麻烦。怎么才能合并这些材质球？<br>采用TexturePacking吧</p><ol><li>遍历gameobject，取出material，并根据shader来将material分类；</li><li>调用Unity自带的PackTextures函数来合并每个shader分类中的material所对应的textures（PackTextures函数有缺陷，不过可以将就用）；</li><li>根据合并的大的texture来更新原有模型的texture、material已经uv坐标值。</li></ol><p>需要注意的是：需要合并的纹理应该是物体在场景中距离相近的，如果物体在场景中的距离较远，<br>则不建议合并纹理，因为这样做很有可能非但起不到优化的作用，反而降低了运行效率。 </p><p>mesh合并<br>分为2种方式合并</p><ol><li><p>自带的合并必须勾选静态。</p><p>所有被勾选了“Static”的GameObject，其中的Mesh Filter中的mesh都会被合并到 “Combined Mesha (root: scene)” 中</p></li><li><p>也可以用脚本来合并mesh 。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span>  <span class="title">MyClass</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line"></span><br><span class="line">        MeshFilter [] meshFilters = GetComponentsInChildren&lt;MeshFilter&gt; ();</span><br><span class="line">        CombineInstance[] combine = <span class="keyword">new</span> CombineInstance[meshFilters.Length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; meshFilters.Length; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            combine[i].mesh = meshFilters[i].sharedMesh;</span><br><span class="line">            combine[i].transform = meshFilters[i].transform.localToWorldMatrix;</span><br><span class="line">            meshFilters[i].gameObject.active = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        transform.GetComponent&lt;MeshFilter&gt;().mesh = <span class="keyword">new</span> Mesh ();</span><br><span class="line">        transform.GetComponent&lt;MeshFilter&gt;().mesh.CombineMeshes (combine);</span><br><span class="line">        transform.gameObject.active = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>先在 Unity 中建立空物件 ( Empty ) </p></li><li>再创建2个 Cube 方块，并放入空物件底下 (可以改成你自己的模型)</li><li>把 MyClass 代码丟进空物件上 。</li><li>(可选) 建立一个 Material 材质，并且丢进空物件上</li><li><p>执行</p></li><li><p>角色Material数量2-3个，骨骼数量小于30个，面片数量300-1500，一般角色应该没有IK结点<br>这是因为角色的动作大多数都是事先设定好的，并不需要经过IK操作来进行实时计算（Rogdoll除外），所以在模型导入时，不要将IK结点一起导入。</p></li><li>静态实体不要附加Animation Component<br>在静态实体上附加Animation部件虽然对结果没有影响，但却会增加一定的CPU开销来调用这一组件，所以尽量去掉该组件。<br>网格顶点数小于500；UV值范围尽量不要超过（0, 1）区间；尽量保证UV值不越界，这对于将来的纹理拼合优化很有帮助。</li><li>地形<br>地形的分辨率大小<br>长宽均尽量小于257。这是因为地形太大，会造成大量顶点数据，给你的内存带宽造成一定的影响，在目前的ios设备中，内存带宽是非常有限的，需要尽量节省。同时，如果用Unity自带的地形，一定也要使用Occlusion Culling，因为Unity的刷地形工具虽然方便，但却是framekiller，刷过之后，你会发现drawcall增加的非常多。<br>混合纹理数量<br>不要超过4。地形的混合操作是很耗时的，应该尽量避免。能合并的纹理尽量合并。</li><li>纹理</li></ol><ul><li>纹理格式<br>建议png或tga。不用转成ios硬件支持的PVRTC格式，因为Unity在发布时会帮你自动转的。</li><li>纹理尺寸<br>长宽小于1024。同时应该尽可能地小，够用就好，以保证纹理对内存带宽的影响达到最小。</li><li>支持Mipmap（UI不需要转，不然会增大内存）<br>建议生成Mipmap。虽然这种做法会增加一些应用程序的大小，但在游戏运行时，系统会根据需求应用Mipmap来渲染，从而减少内存带宽。</li><li>检查Alpha值<br>如果纹理的alpha通道均为1，则用RGB的24位纹理来代替RGBA的32位纹理。（据说Unity内部会进行自动检测）</li></ul><ol><li>光源<br>光源“Important”个数建议1个，一般为方向光。“Important”个数应该越小越少。个数越多，drawcall越多。<br>Pixel Light数目1-2个。</li><li>粒子特效<br>屏幕上的最大粒子数建议小于200个粒子。<br>每个粒子发射器发射的最大粒子数建议不超过50个。<br>粒子大小如果可以的话，粒子的size应该尽可能地小。因为Unity的粒子系统的shader无论是alpha test还是alpha blending都是一笔不小的开销。同时，对于非常小的粒子，建议粒子纹理去掉alpha通道。<br>尽量不要开启粒子的碰撞功能。<br>非常耗时。</li><li>音频<br>游戏中播放时间较长的音乐（如背景音乐）使用.ogg或.mp3的压缩格式。<br>较短音乐（如枪声）使用.wav和.aif的未压缩音频格式。</li><li>相机<br>裁剪平面<br>将远平面设置成合适的距离。远平面过大会将一些不必要的物体加入渲染，降低效率。<br>根据不同的物体设置不同的远裁剪平面<br>Unity提供了可以根据不同的layer来设置不同的view distance，所以我们可以实现将物体进行分层，大物体层设置的可视距离大些，而小物体层可以设置地小些，另外，一些开销比较大的实体（如粒子系统）可以设置得更小些等等。</li><li>碰撞<br>尽量不用MeshCollider<br>如果可以的话，尽量不用MeshCollider，以节省不必要的开销。如果不能避免的话，尽量用减少Mesh的面片数，或用较少面片的代理体来代替。</li><li>其他<br>Drawcall<br>尽可能地减少Drawcall的数量。IOS设备上建议不超过100。减少的方法主要有如下几种：Frustum Culling，Occlusion Culling，Texture Packing。Frustum Culling是Unity内建的，我们需要做的就是寻求一个合适的远裁剪平面；Occlusion Culling，遮挡剔除，Unity内嵌了Umbra，一个非常好OC库。但Occlusion Culling也并不是放之四海而皆准的，有时候进行OC反而比不进行还要慢，建议在OC之前先确定自己的场景是否适合利用OC来优化；Texture Packing，或者叫Texture Atlasing，是将同种shader的纹理进行拼合，根据Unity的static batching的特性来减少draw call。建议使用，但也有弊端，那就是一定要将场景中距离相近的实体纹理进行拼合，否则，拼合后很可能会增加每帧渲染所需的纹理大小，加大内存带宽的负担。这也就是为什么会出现“DrawCall降了，渲染速度也变慢了”的原因。</li></ol><p>非运动物体尽量打上Static标签<br>Unity在运行时会对static物体进行自动优化处理，所以应该尽可能将非运行实体勾上static标签。</p><p>场景中尽可能地使用prefab<br>尽可能地使用prefab的实例化物体，以降低内存带宽的负担。检查实体的PrefabType，尽量将其变成PrefabInstance，而不是ModelPrefabInstance。</p><p>移动平台相对于PC机，具有体积小，计算弱，带宽少的特点。</p><p>因此做手机游戏的开发，优化的方向，与力度对比PC游戏都有所区别。</p><p>必须要做到优化流程，合理利用资源。<br>目前在手机上面，还不能够像PC游戏那样追求高质量渲染效果，为了让手机不那么容易发烫，还要控制cpu，gpu，不能让他们全速运算。</p><p>材质方面：<br>纹理方面，建议使用压缩纹理，</p><p>Android上面使用ETC1，苹果上面使用PVRTC。<br>UV坐标控制在0到1之间，人物模型面数控制在1500内，骨骼控制在30个以内。<br>场景中使用一个主光（不能再多了）。<br>尽量减少alphaTest和alphaBlend材质的使用。在手机上，这是很杀效率的。<br>骨骼动画方面：<br>在动画方面可以考虑不使用插值，固定的帧率的动画。</p><p>如果要做插值，考虑使用四元数（表示旋转）和向量（表示位移）来做插值。</p><p>四元数做插值速度比矩阵来的快，Slerp提供了平滑插值。</p><p>优化的常规技巧<br>剖析你的游戏。<br>不要花费时间来优化那些晦涩的代码或者缩减图形文件的大小，除非这是你游戏的瓶颈。<br>第一次剖析你的游戏将会使你发现你游戏的瓶颈。Apple’s Shark是一个很好的用来剖析基于OpenGL的程序的工具。<br>再次剖析你的游戏。<br>优化之后不要忘记再剖析一次你的游戏，这样可以检查你所做的优化是否达到了预期的效果。<br>当然，这样做也可能会使你发现更多的瓶颈。<br>流程第一、性能第二。花费时间来使你游戏的创建尽可能地流畅。<br>尽可能快地修正游戏中的错误将会使你后期更容易优化你的游戏。<br>在Scene View中测试场景。<br>这样做将会使你清楚了解这个场景中的物体或者附加在物体上的脚本是否降低了游戏性能。<br>如果Scene View反应迟钝，那么有可能是图形方面的原因，如果Scene View反应不迟钝，那么瓶颈可能出在脚本或者物理系统上。<br>禁用指定游戏物体。<br>在play模式下，尝试禁用并启用游戏物体来排查出游戏慢的原因。</p><p>网格<br>如果可能的话，把相邻的物体（网格）合并为一个只有一个材质的物体（网格）。比如，你的游戏中包含一个桌子，上面有一堆东西，你完全可以在3D程序中将它们合并在一起（这可能也需要你将这些物体的纹理合并为一个大的纹理集）。减少需要渲染的物体的数量可以极大地提高游戏性能。</p><p>不要有不必要的网格。<br>如果你的游戏场景中有一个人物，那么他应该是一个网格。如果你有一个船，那么它也应该只是一个网格。<br>每一个网格只用一种材质。<br>使用极少的面数的网格（比如500个多边形以下）。<br>最好把你人物的三角面数量控制在1500-2000个之间。<br>这个数量可以说是游戏质量和性能之间一个均衡值。如果你的模型有四边形，那么在导入模型的时候，引擎将会把每个四边形变为两个三角形。</p><p>光照<br>像素光。<br>像素光可以让你的游戏看起来效果很牛逼，但是不要使用过多的像素光。<br>在你的游戏中可以使用质量管理器来调节像素光的数量来取得一个性能和质量的均衡点.</p><p>性能占用顺序：聚光灯&gt;点光源&gt;平行光。<br>一个好的点亮场景的方法就是先得到你想要的效果，然后看看哪些光更重要；<br>在保持光效的前提下看看哪些光可以去掉。</p><p>点光源和聚光灯只影响它们范围内的网格。<br>如果一个网格处于点光源或者聚光灯的照射范围之外，并且光源的attenuate开关是打开的，那么这个网格将不会被光源所影响，这样就可以节省性能开销。<br>这样做理论上来讲可以使用很多小的点光源而且依然能有一个好的性能，因为这些光源只影响一小部分物体。<br>一个网格在有8个以上光源影响的时候，只响应前8个最亮的光源。</p><p>贴图<br>在外观不变的前提下，贴图大小越小越好。<br>如果你的显卡的显存不够大的话，你游戏中的贴图将会被转存到系统内存中，在显卡调用它们的时候再传到显卡中。<br>对于比较新的电脑来说，内存和显卡之间有足够的带宽来达到一个很好的性能；<br>如果你很无耻地用了巨多的大图片的话，在低显存的电脑上运行你的游戏的时候，你的游戏必然会挂掉。<br>倒是没有必要在图形编辑软件中调整贴图的大小。你可以在unity导入贴图的时候进行调整。</p><p>不要使用低质量的图片。<br>在小播放界面的游戏中使用低质量的jpeg图片或者低色彩的png图片亦或是gif图片没什么问题。<br>在发布游戏的时候，引擎会自动压缩这些图片，多重压缩和解压将会降低图片的质量，所以最好保持贴图文件的分辨率为原始分辨率。<br>这样就会减少多重压缩和解压所导致的图片失真现象。</p><p>Shaders<br>多重效果的shader就比看起来样式很单一的shader要更耗费资源。<br>同样在一个拥有贴图和光反射的物体上，使用VertexLit Diffuse shader无疑是最省资源的。</p><p>在美术制作场景的过程中，会使用到大量的粒子系统。<br>比如场景中的火把。在我们的一个地下城场景中，美术们放置了大量的火把。整个场景中的各个地方，有100来个火把。</p><p>unity中，在摄像机范围外的粒子系统虽然不会被绘制。<br>但是update是一直持续的。这也就意味着，这100多个火把，不论是否可见都在更新。</p><p>这个设计应该是很不合理的，在我看过的其他引擎中，都会有一个开关，来控制不可见的粒子系统是否需要update。<br>有的粒子系统在不可见的时候需要更新,比如爆炸。有的不需要更新，比如火堆火把。</p><p>为了避免不必要的update开销，尤其是最后游戏是要发布到页游平台（web player只能使用一个cpu的核）。<br>于是写了一个脚本，控制不可见的粒子系统就不更新。</p><p>该脚本主要是用到了2个MonoBehaviour的函数。<br>OnBecameInvisible() 当变为不可见   和   OnBecameVisible() 当变成可见。 </p><p>要这2个函数起作用的前提是，该GameObject绑定了MeshRender组件。<br>所以，我们要在粒子系统的GameObject放置在一个GameObject  下，且给该GameObject绑定一个MeshRender 与 MeshFilter。<br>MeshFilter中的mesh可以随便找个cube。</p><p>在Start（） 的时候，把最GameObject的scale设置为很小，以保证该cube不被看见。<br>其实遍历所有的child，把active设置为false。</p><p>在OnBecameVisible 中 遍历所有child，把active设置为true。<br>在OnBecameInvisible中 遍历所有child，把active设置为false。</p><p>Unity 性能优化 Draw Call </p><p>Unity（或者说基本所有图形引擎）生成一帧画面的处理过程大致可以这样简化描述：引擎首先经过简单的可见性测试，确定摄像机可以看到的物体，然后把这些物体的顶点（包括本地位置、法线、UV等），索引（顶点如何组成三角形），变换（就是物体的位置、旋转、缩放、以及摄像机位置等），相关光源，纹理，渲染方式（由材质/Shader决定）等数据准备好，然后通知图形API——或者就简单地看作是通知GPU——开始绘制，GPU基于这些数据，经过一系列运算，在屏幕上画出成千上万的三角形，最终构成一幅图像。</p><p>在Unity中，每次引擎准备数据并通知GPU的过程称为一次Draw Call。这一过程是逐个物体进行的，对于每个物体，不只GPU的渲染，引擎重新设置材质Shader也是一项非常耗时的操作。因此每帧的Draw Call次数是一项非常重要的性能指标，对于iOS来说应尽量控制在20次以内，这个值可以在编辑器的Statistic窗口看到。</p><p>Unity内置了Draw Call Batching技术，从名字就可以看出，它的主要目标就是在一次Draw Call中批量处理多个物体。只要物体的变换和材质相同，GPU就可以按完全相同的方式进行处理，即可以把它们放在一个Draw Call中。Draw Call Batching技术的核心就是在可见性测试之后，检查所有要绘制的物体的材质，把相同材质的分为一组（一个Batch），然后把它们组合成一个物体（统一变换），这样就可以在一个Draw Call中处理多个物体了（实际上是组合后的一个物体）。</p><p>但Draw Call Batching存在一个缺陷，就是它需要把一个Batch中的所有物体组合到一起，相当于创建了一个与这些物体加起来一样大的物体，与此同时就需要分配相应大小的内存。这不仅会消耗更多内存，还需要消耗CPU时间。特别是对于移动的物体，每一帧都得重新进行组合，这就需要进行一些权衡，否则得不偿失。但对于静止不动的物体来说，只需要进行一次组合，之后就可以一直使用，效率要高得多。</p><p>Unity提供了Dynamic Batching和Static Batching两种方式。Dynamic Batching是完全自动进行的，不需要也无法进行任何干预，对于顶点数在300以内的可移动物体，只要使用相同的材质，就会组成Batch。Static Batching则需要把静止的物体标记为Static，然后无论大小，都会组成Batch。如前文所说，Static Batching显然比Dynamic Batching要高效得多</p><p>要有效利用Draw Call Batching，首先是尽量减少场景中使用的材质数量，即尽量共享材质，对于仅纹理不同的材质可以把纹理组合到一张更大的纹理中（称为Texture Atlasing）。然后是把不会移动的物体标记为Static。此外还可以通过CombineChildren脚本（Standard Assets/Scripts/Unity Scripts/CombineChildren）手动把物体组合在一起，但这个脚本会影响可见性测试，因为组合在一起的物体始终会被看作一个物体，从而会增加GPU要处理的几何体数量，因此要小心使用。</p><p>对于复杂的静态场景，还可以考虑自行设计遮挡剔除算法，减少可见的物体数量同时也可以减少Draw Call。</p><p>总之，理解Draw Call和Draw Call Batching原理，根据场景特点设计相应的方案来尽量减少Draw Call次数才是王道，其它方面亦然。</p><p>Draw Call Batching （绘制调用批处理）</p><p>To draw an object on the screen, the engine has to issue a draw call to the graphics API (OpenGL ES in the case of iOS). Every single draw call requires a significant amount of work on the part of the graphics API, causing significant performance overhead on the CPU side.<br>在屏幕上渲染物体，引擎需要发出一个绘制调用来访问图形API（iOS系统中为OpenGL ES）。<br>每个绘制调用需要进行大量的工作来访问图形API，从而导致了CPU方面显著的性能开销。</p><p>Unity combines a number of objects at runtime and draws them together with a single draw call. This operation is called “batching”. The more objects Unity can batch together, the better rendering performance you will get.<br>Unity在运行时可以将一些物体进行合并，从而用一个绘制调用来渲染他们。这一操作，我们称之为“批处理”。<br>一般来说，Unity批处理的物体越多，你就会得到越好的渲染性能。</p><p>Built-in batching support in Unity has significant benefit over simply combining geometry in the modeling tool (or using theCombineChildren script from the Standard Assets package). Batching in Unity happensafter visibility determination step. The engine does culling on each object individually, and the amount of rendered geometry is going to be the same as without batching. Combining geometry in the modeling tool, on the other hand, prevents effecient culling and results in much higher amount of geometry being rendered.<br>Unity中内建的批处理机制所达到的效果要明显强于使用几何建模工具（或使用Standard Assets包中的CombineChildren脚本）的批处理效果。<br>这是因为，Unity引擎的批处理操作是在物体的可视裁剪操作之后进行的。<br>Unity先对每个物体进行裁剪，然后再进行批处理，这样可以使渲染的几何总量在批处理前后保持不变。<br>但是，使用几何建模工具来拼合物体，会妨碍引擎对其进行有效的裁剪操作，从而导致引擎需要渲染更多的几何面片。</p><p>Materials<br>材质<br>Only objects sharing the same material can be batched together. Therefore, if you want to achieve good batching, you need to share as many materials among different objects as possible.<br>只有拥有相同材质的物体才可以进行批处理。<br>因此，如果你想要得到良好的批处理效果，你需要在程序中尽可能地复用材质和物体。</p><p>If you have two identical materials which differ only in textures, you can combine those textures into a single big texture - a process often calledtexture atlasing. Once textures are in the same atlas, you can use single material instead.<br>如果你的两个材质仅仅是纹理不同，那么你可以通过纹理拼合操作来将这两张纹理拼合成一张大的纹理。<br>一旦纹理拼合在一起，你就可以使用这个单一材质来替代之前的两个材质了。</p><p>If you need to access shared material properties from the scripts, then it is important to note that modifyingRenderer.material will create a copy of the material. Instead, you should useRenderer.sharedMaterial to keep material shared.<br>如果你需要通过脚本来访问复用材质属性，那么值得注意的是改变Renderer.material将会造成一份材质的拷贝。<br>因此，你应该使用Renderer.sharedMaterial来保证材质的共享状态。</p><p>Dynamic Batching<br>动态批处理<br>Unity can automatically batch moving objects into the same draw call if they share the same material.<br>如果动态物体共用着相同的材质，那么Unity会自动对这些物体进行批处理。</p><p>Dynamic batching is done automatically and does not require any additional effort on your side.<br>动态批处理操作是自动完成的，并不需要你进行额外的操作。</p><p>Tips:<br>提醒：<br>1、Batching dynamic objects has certain overheadper vertex, so batching is applied only to meshes containing less than900 vertex attributes in total.<br>批处理动态物体需要在每个顶点上进行一定的开销，所以动态批处理仅支持小于900顶点的网格物体。</p><p>2、If your shader is using Vertex Position, Normal and single UV, then you can batch up to 300 verts and if your shader is using Vertex Position, Normal, UV0, UV1 and Tangent, then only 180 verts.<br>Please note: attribute count limit might be changed in future<br>如果你的着色器使用顶点位置，法线和UV值三种属性，那么你只能批处理300顶点以下的物体；<br>如果你的着色器需要使用顶点位置，法线，UV0，UV1和切向量，那你只能批处理180顶点以下的物体。<br>请注意：属性数量的限制可能会在将来进行改变。</p><p>4、Don’t use scale. Objects with scale (1,1,1) and (2,2,2) won’t batch.<br>不要使用缩放尺度（scale）。分别拥有缩放尺度(1,1,1)和(2,2,2)的两个物体将不会进行批处理。</p><p>5、Uniformly scaled objects won’t be batched with non-uniformly scaled ones.<br>统一缩放尺度的物体不会与非统一缩放尺度的物体进行批处理。<br>Objects with scale (1,1,1) and (1,2,1) won’t be batched. On the other hand (1,2,1) and (1,3,1) will be.<br>使用缩放尺度(1,1,1)和 (1,2,1)的两个物体将不会进行批处理，但是使用缩放尺度(1,2,1)和(1,3,1)的两个物体将可以进行批处理。</p><p>6、Using different material instances will cause batching to fail.<br>使用不同材质的实例化物体（instance）将会导致批处理失败。</p><p>7、Objects with lightmaps have additional (hidden) material parameter: offset/scale in lightmap, so lightmapped objects won’t be batched (unless they point to same portions of lightmap)<br>拥有lightmap的物体含有额外（隐藏）的材质属性，比如：lightmap的偏移和缩放系数等。所以，拥有lightmap的物体将不会进行批处理（除非他们指向lightmap的同一部分）。</p><p>8、Multi-pass shaders will break batching. E.g. Almost all unity shaders supports several lights in forward rendering, effectively doing additional pass for them<br>多通道的shader会妨碍批处理操作。比如，几乎unity中所有的着色器在前向渲染中都支持多个光源，并为它们有效地开辟多个通道。</p><p>9、Using instances of a prefab automatically are using the same mesh and material.<br>预设体的实例会自动地使用相同的网格模型和材质。</p><p>Static Batching<br>静态批处理</p><p>Static batching, on the other hand, allows the engine to reduce draw calls for geometry of any size (provided it does not move and shares the same material). Static batching is significantly more efficient than dynamic batching. You should choose static batching as it will require less CPU power.<br>相对而言，静态批处理操作允许引擎对任意大小的几何物体进行批处理操作来降低绘制调用（只要这些物体不移动，并且拥有相同的材质）。因此，静态批处理比动态批处理更加有效，你应该尽量低使用它，因为它需要更少的CPU开销。</p><p>In order to take advantage of static batching, you need explicitly specify that certain objects are static and willnot move, rotate or scale in the game. To do so, you can mark objects as static using the Static checkbox in the Inspector:<br>为了更好地使用静态批处理，你需要明确指出哪些物体是静止的，并且在游戏中永远不会移动、旋转和缩放。想完成这一步，你只需要在检测器（Inspector）中将Static复选框打勾即可；<br>Using static batching will require additional memory for storing the combined geometry. If several objects shared the same geometry before static batching, then a copy of geometry will be created for each object, either in the Editor or at runtime. This might not always be a good idea - sometimes you will have to sacrifice rendering performance by avoiding static batching for some objects to keep a smaller memory footprint. For example, marking trees as static in a dense forest level can have serious memory impact.<br>使用静态批处理操作需要额外的内存开销来储存合并后的几何数据。在静态批处理之前，如果一些物体共用了同样的几何数据，那么引擎会在编辑以及运行状态对每个物体创建一个几何数据的备份。这并不总是一个好的想法，因为有时候，你将不得不牺牲一点渲染性能来防止一些物体的静态批处理，从而保持较少的内存开销。比如，将浓密森里中树设为Static，会导致严重的内存开销。</p><p>Static batching is only available in Unity iOS Advanced.<br>静态批处理目前只支持Unity iOS Advanced。</p><p>前两天，MadFinger，就是当今iOS与Android上画质最牛逼闪闪的游戏之一——ShadowGun的开发商，令人惊异地放出了一个ShadowGun的样例关卡以及若干可免费使用的Shader，国外同行们的分享精神真的是令人赞叹不已。原文在这里，以下是我的一些摘录和笔记。</p><p>首先是一些优化常识。针对图形方面的优化主要包括三角形数量，纹理所占内存，以及Shader，前两项基本没什么好讲的，针对设备机能的限制制定相应的指标即可，所以Shader就成为了图形性能优化的关键。</p><p>Alpha blending</p><p>在Unity官方文档中讲，由于硬件原因，在iOS设备上使用alpha-test会造成很大的性能开销，应尽量使用alpha-blend代替。这里提到，在同屏使用alpha-blend的面数，尤其是这些面所占屏幕面积的大小，对性能也会造成很大影响。原因是使用alpha-blend的面会造成overdraw的增加，这尤其对低性能设备的影响很大。不过没有购买Pro版，没有Occlusion Culling功能的话，就不必顾虑这一问题了，反正overdraw是必然的。</p><p>复杂的Per-pixel shader</p><p>Per-pixel shader即Fragment shader，顾名思义是要对每个渲染到屏幕上的像素做处理的shader，如果per-pixel shader比较复杂且需要处理的像素很多时，也就是使用该shader的面占屏幕面积很大时，对性能的影响甚至要超过alpha blending。因此复杂的per-pixel shader只适用于小物体。</p><p>下面是对几个Shader的逐一讲解：</p><p>Environment specular maps(Shader Virtual Gloss Per Vertex Additive)<br>Specular map通常都是利用贴图的alpha通道来定义物体表面的光滑程度（反光度），这个shader的特点是per-vertex计算反光度的，有着相当不错的效果的同时比per-pixel的shader性能要高得多。这个shader很适用于关卡环境等占很大区域的模型。</p><p>经过优化的动态角色光照和阴影(Light probes和BRDF Shader)<br>传统的Lightmaps无法支持动态物体，对此Unity提供了Light probes技术，预先把动态物体的光照信息保存在代理对象(即Light probes)中，运行时动态物体从距离最近的Probe中获取光照信息。</p><p>Unity本身还提供了一个效果非常棒的专为移动设备优化过的角色Shader，支持Diffuse、Specular和Normal maps，并通过一个特殊的脚本生成贴图用于模仿BRDF光照效果。最终产生的效果堪比次时代大作中的角色光影效果。</p><p>雾和体积光(Shader Blinking Godrays)<br>目前在移动设备上要开启真正的雾效基本不可行，ShadowGun的方案是通过简单的网格＋透明贴图(称为雾面)来模拟雾效。在玩家靠近时，雾面逐渐变淡，同时fog plane的顶点也会移开(即使完全透明的alpha面也会消耗很多渲染时间)。</p><p>使用这个Shader的网格需要经过处理：</p><p>顶点的alpha值用于决定顶点是否可以移动(在例子中0为不可动，1为可动)。<br>顶点法线决定移动的方向<br>然后Shader通过计算与观察者的距离来控制雾面的淡入/淡出。<br>这个Shader还可以用来做体积光和其它一些alpha效果。</p><p>飞机坠毁的浓烟效果(Shader Scroll 2 Layers Sine Alpha-blended)<br>通过粒子产生浓烟的代价太高，所以ShadowGun中使用了网格＋贴图动画来制作这个效果。通过混合两层贴图并让它们交错移动来产生动画效果。其中顶点alpha值用于让网格的边缘看起来比较柔和，同时使用顶点颜色来模拟从火焰到烟雾的过渡效果。</p><p>带动态效果的天空盒(Shader Scroll 2 Layers Multiplicative)<br>通过两张贴图的混合和移动产生云的动态效果。</p><p>旗帜和衣服的飘动效果(Shader Lightmap + Wind)<br>同样利用顶点alpha值决定哪些顶点可以移动，然后shader的参数用于调整摆动的方向和速度。</p><p>一、程序方面<br>　　1. 务必删除脚本中为空或不需要的默认方法；<br>　　2. 只在一个脚本中使用OnGUI方法；（最好不要加）<br>　 3. 避免在OnGUI中对变量、方法进行更新、赋值，输出变量建议在Update内；<br>　　4. 同一脚本中频繁使用的变量建议声明其为全局变量，脚本之间频繁调用的变量或方法建议声明为全局静态变量或方法；<br>　　5. 不要去频繁获取组件，将其声明为全局变量；<br>　　6. 数组、集合类元素优先使用Array，其次是List；<br>　　7. 脚本在不使用时脚本禁用之，需要时再启用；<br>　　8. 可以使用Ray来代替OnMouseXXX类方法；<br>　　9. 需要隐藏/显示或实例化来回切换的对象，尽量不要使用SetActiveRecursively或active，而使用将对象远远移出相机范围和移回原位的做法；<br>　　10. 尽量少用模运算和除法运算，比如a/5f，一定要写成a * 0.2f。<br>　　11. 对于不经常调用或更改的变量或方法建议使用Coroutines &amp; Yield；<br>　　12. 尽量直接声明脚本变量，而不使用GetComponent来获取脚本；<br>iPhone<br>　　13. 尽量使用整数数字，因为iPhone的浮点数计算能力很差；<br>　　14. 不要使用原生的GUI方法；<br>　　15. 不要实例化（Instantiate）对象，事先建好对象池，并使用Translate“生成”对象；<br>二、模型方面<br>　　1. 合并使用同贴图的材质球，合并使用相同材质球的Mesh；<br>　　2. 角色的贴图和材质球只要一个，若必须多个则将模型离分离为多个部分；<br>　　2. 骨骼系统不要使用太多；<br>　　3. 当使用多角色时，将动画单独分离出来；<br>　　4. 使用层距离来控制模型的显示距离；<br>　　5. 阴影其实包含两方面阴暗和影子，建议使用实时影子时把阴暗效果烘焙出来，不要使用灯光来调节光线阴暗。<br>　　6. 少用像素灯和使用像素灯的Shader；<br>　　7. 如果硬阴影可以解决问题就不要用软阴影，并且使用不影响效果的低分辨率阴影；<br>　　08、实时阴影很耗性能，尽量减小产生阴影的距离；<br>　　09、允许的话在大场景中使用线性雾，这样可以使远距离对象或阴影不易察觉，因此可以通过减小相机和阴影距离来提高性能；<br>　　10、使用圆滑组来尽量减少模型的面数；<br>　　11、项目中如果没有灯光或对象在移动那么就不要使用实时灯光；<br>　　12、水面、镜子等实时反射/折射的效果单独放在Water图层中，并且根据其实时反射/折射的范围来调整；<br>　　13、碰撞对效率的影响很小，但碰撞还是建议使用Box、Sphere碰撞体；<br>　　14、建材质球时尽量考虑使用Substance；<br>　　15、尽量将所有的实时反射/折射（如水面、镜子、地板等等）都集合成一个面；<br>　　16、假反射/折射没有必要使用过大分辨率，一般64<em>64就可以，不建议超过256</em>256；<br>　　17、需要更改的材质球，建议实例化一个，而不是使用公共的材质球；<br>　　18、将不须射线或碰撞事件的对象置于IgnoreRaycast图层；<br>　　19、将水面或类似效果置于Water图层<br>　　20、将透明通道的对象置于TransparentFX图层；<br>　　21、养成良好的标签（Tags）、层次（Hieratchy）和图层（Layer）的条理化习惯，将不同的对象置于不同的标签或图层，三者有效的结合将很方便的按名称、类别和属性来查找；<br>　　22、通过Stats和Profile查看对效率影响最大的方面或对象，或者使用禁用部分模型的方式查看问题到底在哪儿；<br>　　23、使用遮挡剔除（Occlusion Culling）处理大场景，一种较原生的类LOD技术，并且能够“分割”作为整体的一个模型。</p><p>三、其它<br>　　场景中如果没有使用灯光和像素灯，就不要使用法线贴图，因为法线效果只有在有光源（Direct Light/Point Light/Angle Light/Pixel Light）的情况下才有效果。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C# 线程同步</title>
      <link href="/2018/04/12/C-Thread-Sync/"/>
      <url>/2018/04/12/C-Thread-Sync/</url>
      
        <content type="html"><![CDATA[<h1 id="线程同步的方式"><a href="#线程同步的方式" class="headerlink" title="线程同步的方式"></a>线程同步的方式</h1><p>线程同步有：临界区、互斥区、事件、信号量四种方式</p><ol><li>临界区(Critical Section)：临界区：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。在任意时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占。</li><li>互斥量(Mutex)：采用互斥对象机制。 只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问。互斥不仅能实现同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享 </li><li>信号量(Semaphore)：它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目 </li><li>事件(Event)：通过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作</li></ol><h2 id="lock-关键字"><a href="#lock-关键字" class="headerlink" title="lock 关键字"></a>lock 关键字</h2><p>lock 关键字将语句块标记为临界区，方法是获取给定对象的互斥锁，执行语句，然后释放该锁。<br>lock 确保当一个线程位于代码的临界区时，另一个线程不进入临界区。如果其他线程试图进入锁定的代码，则它将一直等待（即被阻止），直到该对象被释放。</p><h2 id="同步事件和等待句柄"><a href="#同步事件和等待句柄" class="headerlink" title="同步事件和等待句柄"></a>同步事件和等待句柄</h2><p>使用锁或监视器对于防止同时执行区分线程的代码块很有用，但是这些构造不允许一个线程向另一个线程传达事件。这需要“同步事件”，它是有两个状态（终止和非终止）的对象，可以用来激活和挂起线程。让线程等待非终止的同步事件可以将线程挂起，将事件状态更改为终止可以将线程激活。如果线程试图等待已经终止的事件，则线程将继续执行，而不会延迟。     </p><p>同步事件有两种：AutoResetEvent 和 ManualResetEvent。它们之间唯一的不同在于，无论何时，只要 AutoResetEvent 激活线程，它的状态将自动从终止变为非终止。相反，ManualResetEvent 允许它的终止状态激活任意多个线程，只有当它的 Reset 方法被调用时才还原到非终止状态。</p><p>等待句柄，可以通过调用一种等待方法，如WaitOne、WaitAny 或 WaitAll，让线程等待事件。System.Threading.WaitHandle.WaitOne使线程一直等待，直到单个事件变为终止状态；System.Threading.WaitHandle.WaitAny 阻止线程，直到一个或多个指示的事件变为终止状态；System.Threading.WaitHandle.WaitAll 阻止线程，直到所有指示的事件都变为终止状态。当调用事件的 Set 方法时，事件将变为终止状态。</p><p>AutoResetEvent 允许线程通过发信号互相通信。 通常，当线程需要独占访问资源时使用该类。线程通过调用 AutoResetEvent 上的 WaitOne 来等待信号。 如果 AutoResetEvent 为非终止状态，则线程会被阻止，并等待当前控制资源的线程通过调用 Set 来通知资源可用。调用 Set 向 AutoResetEvent 发信号以释放等待线程。 AutoResetEvent 将保持终止状态，直到一个正在等待的线程被释放，然后自动返回非终止状态。 如果没有任何线程在等待，则状态将无限期地保持为终止状态。如果当 AutoResetEvent 为终止状态时线程调用 WaitOne，则线程不会被阻止。 AutoResetEvent 将立即释放线程并返回到非终止状态。<br>可以通过将一个布尔值传递给构造函数来控制 AutoResetEvent 的初始状态：如果初始状态为终止状态，则为 true；否则为 false。<br>AutoResetEvent 也可以同 staticWaitAll 和 WaitAny 方法一起使用。</p><h2 id="WaitHandle-WaitOne"><a href="#WaitHandle-WaitOne" class="headerlink" title="WaitHandle.WaitOne()"></a>WaitHandle.WaitOne()</h2><p>阻止当前线程，直到当前的 WaitHandle 收到信号为止</p><h2 id="EventWaitHandle-Set"><a href="#EventWaitHandle-Set" class="headerlink" title="EventWaitHandle.Set()"></a>EventWaitHandle.Set()</h2><p>将事件状态设置为有信号，从而允许一个或多个等待线程继续执行。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>托管代码和非托管代码</title>
      <link href="/2018/04/11/managed-code-unmanaged-code/"/>
      <url>/2018/04/11/managed-code-unmanaged-code/</url>
      
        <content type="html"><![CDATA[<p>托管代码是-Microsoft的中间语言(IL)，他主要作用是在.Net FRAMEWORK的公共语言运行库(CLR)执行代码前去编译源代码，也就是说托管代码充当着翻译的作用，源代码在运行时分为两个阶段：</p><ol><li>源代码编译为托管代码，(所以源代码可以有很多种，如VB,C#,J#)</li><li>托管代码编译为Microsoft的平台专用语言</li></ol><p>编译器把代码编译成中间语言(IL),而不是能在你的电脑上运行的机器码。中间语言被封装在一个叫程序集(Assembly)的文件中，程序集中包含了描述你所创建的类，方法和属性(例如安全需求)的所有元数据。你可以拷贝这个程序集到另一台服务器上部署它。</p><p>托管代码在公共语言运行库(CLR)中运行。这个运行库给你的运行代码提供各种各样的服务，通常来说，他会加载和验证程序集，以此来保证中间语言的正确性</p><ol><li>托管代码是一种中间语言，运行在CLR上；<br>非托管代码被编译为机器码，运行在机器上</li><li>托管代码独立于平台和语言，能更好的实现不同语言平台之间的兼容；<br>非托管代码依赖于平台和语言。</li><li>托管代码可享受CLR提供的服务（如安全检测，垃圾回收），不需要自己完成这些操作<br>非托管代码需要自己提供安全检测、垃圾回收等操作。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity加载和内存管理</title>
      <link href="/2018/04/11/AssetBundle/"/>
      <url>/2018/04/11/AssetBundle/</url>
      
        <content type="html"><![CDATA[<p>Unity有两种动态加载机制：Resources.Load和AssetBundle，二者本质并无区别。Resources.Load就是从一个缺省打进程程序包的AssetBundle(Resourece)里加载资源，而一般AssetBundle文件需要你自己创建，运行时加载。</p><h1 id="AssetBundle加载基础"><a href="#AssetBundle加载基础" class="headerlink" title="AssetBundle加载基础"></a>AssetBundle加载基础</h1><p>通过AssetBunlde加载资源，分为两步，第一步是获取AssetBundle对象，第二步是通过该对象加载需要的资源。而第一步又分为两种方式，下文中将结合常用的API进行详细地描述。</p><h2 id="第一步，获取AssetBundle对象常用地API"><a href="#第一步，获取AssetBundle对象常用地API" class="headerlink" title="第一步，获取AssetBundle对象常用地API"></a>第一步，获取AssetBundle对象常用地API</h2><h3 id="方式一，先获取WWW对象，再通过WWW-assetBundle获取AssetBundle对象："><a href="#方式一，先获取WWW对象，再通过WWW-assetBundle获取AssetBundle对象：" class="headerlink" title="方式一，先获取WWW对象，再通过WWW.assetBundle获取AssetBundle对象："></a>方式一，先获取WWW对象，再通过WWW.assetBundle获取AssetBundle对象：</h3><pre><code>public WWW(string uri);</code></pre><p>加载Bundle文件并获取WWW对象，完成后会在内存中创建较大地WebStream(解压后的内容，通常为原Bundle文件的4~5倍大小，纹理资源比例可能更大),因此后续的AssetBundle.Load可以直接在内存中进行。</p><pre><code>public static WWW LoadFromCacheOrDownload(string uri, int version, unit crc = 0);</code></pre><p>加载Bundle文件并获取WWW对象，同时将解压形式的Bundle内容存入磁盘中作为缓存（如果该Bundle已在缓存中，则省去这一步），完成后只会在内存中创建较小的SerializedFile，而后续的AssetBundle.Load需要通过IO从磁盘中的缓存获取。</p><pre><code>public AssetBundle assetBundle;</code></pre><p>通过之前两个接口获取WWW对象后，即可通过WWW.assetBundle获取AssetBundle对象。</p><h3 id="方式二，直接获取AssetBundle"><a href="#方式二，直接获取AssetBundle" class="headerlink" title="方式二，直接获取AssetBundle:"></a>方式二，直接获取AssetBundle:</h3><pre><code>public static AssetBundle LoadFromFile(string path); public static AssetBundle LoadFromFileAsync(string path);</code></pre><p>通过未压缩的Bundle文件，同步创建AssetBundle对象，这是最快的方式。创建完成后只会在内存中创建较小的SerializedFile，而后续的AssetBundle.Load需要通过IO从磁盘中获取。<br>如果AssetBundle是未压缩，或者是数据块形式（LZ4算法压缩）的，LoadFromFile将从磁盘中直接加载它。如果AssetBundle是高度压缩(LZMA算法压缩)的，再将它加载进入内存前，会首先将它解压。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LoadAssetBundles</span>(<span class="params"><span class="keyword">string</span> baseDir</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (assetBundleInfos != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; assetBundleInfos.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> bInfo = assetBundleInfos[i];</span><br><span class="line">            <span class="keyword">if</span> (bInfo.assetBundle != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                bInfo.assetBundle.Unload(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        assetBundleInfos = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> abInfos = <span class="keyword">new</span> List&lt;AssetBundleInfo&gt;(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> files = Directory.GetFiles(m_dir_update, <span class="string">"*.bytes"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; files.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">string</span> f = files[i];</span><br><span class="line">        <span class="keyword">string</span> n = Path.GetFileName(f);</span><br><span class="line">        <span class="keyword">if</span> (!CheckABName(abInfos, n)) contine;</span><br><span class="line"></span><br><span class="line">        abInfos.Add(<span class="keyword">new</span> AssetBundleInfo&#123;name = n, uri = f&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (baseDir != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        files = Directory.GetFiles(baseDir, <span class="string">"*.bytes"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; files.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">string</span> f = files[i];</span><br><span class="line">            <span class="keyword">string</span> n = Path.GetFileName(f);</span><br><span class="line">            <span class="keyword">if</span> (!CheckABName(abInfos, n)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            abInfos.Add(<span class="keyword">new</span> AssetBundleInfo&#123;name = n, uri = f&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    files = LoadConfigLines(<span class="string">"res_idx"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; files.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">string</span> n = files[i].Trim();</span><br><span class="line">        <span class="keyword">if</span> (!CheckABName(abInfos, n)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">string</span> f = streamAssetsPath + n;</span><br><span class="line">        abInfos.Add(<span class="keyword">new</span> AssetBundleInfo&#123;name = n, uri = f&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (abInfos.Count == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">string</span> prefix = <span class="string">"assets/res/"</span>;</span><br><span class="line">    <span class="keyword">int</span> cprefix = prefix.Length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; abInfos.Count;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> abInfo = abInfos[i];</span><br><span class="line">        <span class="keyword">var</span> ab = AssetBundle.LoadFromFile(abInfo.uri);</span><br><span class="line">        <span class="keyword">if</span> (ab == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            abInfos.RemoveAt(i);</span><br><span class="line">            sbError.Append(<span class="string">"\nfail ab : "</span>);</span><br><span class="line">            sbError.Append(abInfo)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>public static AssetBundle LoadFromMemory(byte[] binary)</code></pre><p>通过Bundle的二进制数据，异步创建AssetBundle对象，完成后会在内存中创建较大的WebStream。调用时，Bundle的解压是异步进行的，因此对于未压缩的Bundle文件，该接口于LoadFromMemoryAsync是等价的。</p><pre><code>public static AssetBundle LoadFromMemoryAsync</code></pre><p>该接口是 CreateFromMemory 的同步版本，这个方法的参数是包含了AssetBundle数据的字节数组。如果需要的话，你还可以传入一个CRC(循环冗余校验码)参数。如果AssetBundle使用了LZMA算法压缩，那么AssetBundle在加载的时候会被解压。如果AssetBundle使用了LZ4算法压缩，它将直接以压缩形式被加载。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">LoadFromMemoryAsync</span>(<span class="params"><span class="keyword">string</span> path</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AssetBundleCreateRequest createRequest = AssetBundle.LoadFromMemoryAsync(File.ReadAllBytes(path));</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> createRequest;</span><br><span class="line">    AssetBundle bundle = createRequest.assetBundle;</span><br><span class="line">    <span class="keyword">var</span> prefab = bundle.LoadAsset&lt;GameObject&gt;(<span class="string">"MyObject"</span>);</span><br><span class="line">    Instantiate(prefab);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第二步，从AssetBundle加载资源的常用API"><a href="#第二步，从AssetBundle加载资源的常用API" class="headerlink" title="第二步，从AssetBundle加载资源的常用API"></a>第二步，从AssetBundle加载资源的常用API</h2><pre><code>public Object Load(string name, Type type);</code></pre><p>通过给定的名字和资源类型，加载资源。加载时会自动加载其依赖的资源，即Load一个Prefab时，会自动Load其引用的Texture资源。</p><pre><code>public Object[] LoadAll(Type type);public AssetBundleRequest LoadAllAssetsAsync();</code></pre><p>一次性加载Bundle中给定资源类型的所有资源</p><pre><code>public AssetBundleRequest LoadAsync(string name, Type type)</code></pre><h3 id="2-3-AssetBundle的压缩类型"><a href="#2-3-AssetBundle的压缩类型" class="headerlink" title="2.3 AssetBundle的压缩类型"></a>2.3 AssetBundle的压缩类型</h3><p>Unity3D引擎为我们提供了三种压缩策略来处理AssetBundle的压缩，即：</p><ul><li>LZMA格式</li><li>LZ4格式</li><li>不压缩</li></ul><h4 id="LAMZ格式"><a href="#LAMZ格式" class="headerlink" title="LAMZ格式"></a>LAMZ格式</h4><p>在默认情况下，打包生成的AssetBundle都会被压缩。在U3D中，AssetBundle的标准压缩格式便是LZMA（LZMA是一种序列化流文件），因此在默认情况下，打出的AssetBundle包处于LZMA格式的压缩状态，</p><h4 id="LZ4格式"><a href="#LZ4格式" class="headerlink" title="LZ4格式"></a>LZ4格式</h4><p>Unity 5.3之后的版本增加了LZ4格式压缩，由于LZ4的压缩比一般，因此经过压缩之后的AssetBundle包体的体积较大（该算法基于chunk）。但是，使用LZ4格式的好处在于解压缩的时间相对要短。</p><p>使用LZ4格式压缩，需要打包设置</p><pre><code>BuildPipeline.BuildAssetBundles(Application.streamingAssetPath, BuildAssetBundleOptions.ChunkBasedCompression);</code></pre><h4 id="不压缩"><a href="#不压缩" class="headerlink" title="不压缩"></a>不压缩</h4><p>当然，我们也可以不对AssetBundle进行压缩。没有经过压缩的胞体系最大，但是访问速度最快。</p><p>若要使用不压缩的策略，只需要在打包的时候开启</p><pre><code>BuildPipeline.BuildAsetBundles(Application.streamingAssetPath, BuildAssetBundleOptions.UncompressedAssetBundle);</code></pre><h1 id="五-AssetBundle原理分析"><a href="#五-AssetBundle原理分析" class="headerlink" title="五 AssetBundle原理分析"></a>五 AssetBundle原理分析</h1><h2 id="5-2-AssetBundle及Assets的卸载"><a href="#5-2-AssetBundle及Assets的卸载" class="headerlink" title="5.2 AssetBundle及Assets的卸载"></a>5.2 AssetBundle及Assets的卸载</h2><p>在AssetBundle的下载和加载过程中，以及Assets加载和实例化过程中，AssetBundle以及加载的Assets都会占用内存。</p><ol><li>AssetBundle的卸载采用Assetbundle.Unload(bool)接口。</li><li>Assets的卸载有两种方式:<ul><li>AssetBundle.Unload(true); // 这会强制卸载掉所有从AssetBundle加载的Assets。</li><li>Resource.UnloadUnusedAssets()和Resources.UnloadAsset。这会卸载掉所有没有用到的Assets。需要注意的是，该接口作用于整个系统，而不仅仅是当前的AssetBundle，而且不会卸载从当前AssetBundle文件中加载并仍在使用的Assets。</li></ul></li><li>对于实例化出来的对象，可以使用GameObject.Destroy活GameObject.DestroyImmediate。注意的是：官方说法是这样的，如果使用GameObject.Destroy接口，Unity会将真正的删除操作延后到一个合适的时机统一进行处理，但会在渲染之前。</li></ol><p>对于WWW对象，可以使用www=null或www.dispose。<br>这两者是由区别的，www=null不会立即释放内存，而是系统自动回收机制启动时回收。www.dispose则会立即调用系统的回收机制来释放内存。当WWW对象被释放后，其对于Web Stream数据的引用计数也会相应减1。</p><p>对于Web Stream数据，它所占用的内存会在其引用计数为0时，被系统自动回收。例如：当上图中的AssetBundle对象和WWW对象被释放后，Web Stream数据所占内存也会被系统自动回收。</p><h1 id="六-AssetBundle依赖加载"><a href="#六-AssetBundle依赖加载" class="headerlink" title="六 AssetBundle依赖加载"></a>六 AssetBundle依赖加载</h1><p>如果一个或者多个UnityEngine.Objects引用了其他AssetBundle中的UnityEngine.Object，那么AssetBundle之间就产生了依赖关系了。如果UnityEngine.ObjectA所引用的UnityEngine.ObjectB不是其他的AssetBundle中的，那么依赖就不会产生。<br>如果产生依赖，被依赖对象(UnityEngine.ObjectB)将被拷贝进你创建的AssetBundle(指包含UnityEngine.ObjectA的AssetBundle)</p><p>更进一步，如果有多个对象(UnityEngine.ObjectA1、UnityEngine.ObjectA2、UnityEngine.ObjectA3…)引用了同一个被依赖对象(UnityEngine.ObjectB)，那么被依赖对象将被拷贝多份，打包进各个对象各自的AssetBundle。</p><p>如果一个AssetBundle存在依赖性，那么要注意的是，那些包含了被依赖对象的AssetBundles，需要在你想要实例化的对象的加载之前加载。Unity不会自动帮你加载这些依赖。</p><p>想想看下面的例子，Bundle1中的一个材质(Material)引用了Bundle2中的一个纹理(Texture)<br>在这个例子中，在从Bundle1中加载材质前，你需要先将Bundle2加载到内存中。你按照声明顺序加载Bundle1和Bundle2并不重要，重要的是，想从Bundle1中加载材质前，你需要先加载Bundle2。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity3D笔记</title>
      <link href="/2018/04/11/Unity-Note/"/>
      <url>/2018/04/11/Unity-Note/</url>
      
        <content type="html"><![CDATA[<p>在Update中使用Time.deltaTime，获取到的是这一帧的时间，如果游戏卡，帧率低，那这个值就大。如果游戏流畅，帧率高，这个值就小，Time.deltaTime=1.0f/帧率</p><p>1、MonoBehaviour.Update 更新渲染帧<br>当MonoBehaviour启用时，其Update在每一帧被调用。</p><p>2、MonoBehaviour.FixedUpdate 固定更新逻辑帧<br>当MonoBehaviour启用时，其 FixedUpdate在每一帧被调用。<br>处理Rigidbody时，需要用FixedUpdate代替Update。例如：给刚体加一个作用力时，你必须应用作用力在FixedUpdate里的固定帧，而不是Update中的帧(两者帧长不同)。</p><p>3、MonoBehaviour.LateUpdate 晚于更新渲染帧末尾<br>当Behaviour启用时，其LateUpdate在每一帧被调用。<br>LateUpdate是在所有Update函数调用后被调用。这可用于调整脚本执行顺序。例如:当物体在Update里移动时，跟随物体的相机可以在LateUpdate里实现。</p><h3 id="Update和FixedUpdate的区别："><a href="#Update和FixedUpdate的区别：" class="headerlink" title="Update和FixedUpdate的区别："></a>Update和FixedUpdate的区别：</h3><p>Update跟当前平台的帧数有关，而FixedUpdate是CPU tick 的时间，所以处理物理逻辑的时候要把代码放在FixedUpdate而不是Update。<br>Update是在每次渲染新的一帧的时候才会调用，也就是说，这个函数的更新频率和设备的性能有关以及被渲染的物体（可以认为是三角形的数量）。在性能好的机器上可能fps 30，差的可能小些。这会导致同一个游戏在不同的机器上效果不一致，有的快有的慢。因为Update的执行间隔不一样了。<br>而FixedUpdate，是在固定的时间间隔执行，不受游戏帧率的影响。有点像Tick。所以处理Rigidbody的时候最好用FixedUpdate。</p><p>FixedUpdate的时间间隔可以在项目设置中更改，Edit-&gt;ProjectSetting-&gt;time  找到Fixedtimestep。就可以修改了。</p><h3 id="Update和LateUpdate的区别："><a href="#Update和LateUpdate的区别：" class="headerlink" title="Update和LateUpdate的区别："></a>Update和LateUpdate的区别：</h3><p>LateUpdate是在所有Update函数调用后被调用。这可用于调整脚本执行顺序。例如：当物体在Update里移动时，跟随物体的相机可以在LateUpdate里实现。<br>LateUpdate是晚于所有Update执行的。例如：游戏中有2个脚步，脚步1含有Update和LateUpdate，脚步2含有Update，那么当游戏执行时，每一帧都是把2个脚步中的Update执行完后才执行LateUpdate 。虽然是在同一帧中执行的，但是Update（渲染帧）会先执行，LateUpdate（渲染帧末尾）会晚执行。<br>现在假设有2个不同的脚本同时在Update中控制一个物体，那么当其中一个脚本改变物体方位、旋转或者其他参数时，另一个脚步也在改变这些东西，那么这个物体的方位、旋转就会出现一定的反复。如果还有个物体在Update中跟随这个物体移动、旋转的话，那跟随的物体就会出现抖动。 如果是在LateUpdate中跟随的话就会只跟随所有Update执行完后的最后位置、旋转，这样就防止了抖动。</p><p>IOS:</p><p>Application.dataPath             Application/xxxxxxxxx/xxx.app/Data<br>Application.streamAssetsPath     Application/xxxxxxxxx/xxx.app/Data/Raw<br>Application.persistentDataPath     Application/xxxxxxxxx/xxx.app/Documents<br>Application.temporaryCachePath  Application/xxxxxxxxx/xxx.app/Library/Caches</p><p>Android:</p><p>Application.dataPath             /data/app/xxx.xxx.xxx.apk<br>Application.streamAssetsPath     jar:file:///data/app/xxx.xxx.xxx.apk/!/assets<br>Application.persistentDataPath     /data/data/xxx.xxx.xxx/files<br>Application.temporaryCachePath  /data/data/xxx.xxx.xxx/cache</p><p>Windows:</p><p>Application.dataPath             /Assets<br>Application.streamAssetsPath     /Assets/StreamingAssets<br>Application.persistentDataPath     C:/Users/xxxx/AppData/LocalLow/CompanyName/ProductName<br>Application.temporaryCachePath  C:/Users/xxxx/AppData/Local/Temp/CompanyName/ProductName</p><p>Max:</p><p>Application.dataPath             /Assets<br>Application.streamAssetsPath     /Assets/StreamingAssets<br>Application.persistentDataPath     /Users/xxxx/Library/Caches/CompanyName/Product Name<br>Application.temporaryCachePath  /var/folders/57/6b4_9w8113x2fsmzx_yhrhvh0000gn/T/CompanyName/Product </p><h3 id="影响渲染顺序因素地总结"><a href="#影响渲染顺序因素地总结" class="headerlink" title="影响渲染顺序因素地总结"></a>影响渲染顺序因素地总结</h3><ol><li>Camrea Depth 相机组件上设置的相机深度，深度越大越靠后渲染。</li><li>Sorting Layer 在Tags &amp; Layers设置中可见。</li><li>Order In Layer 相当于Sorting Layer的子排序，用这个值做比较时只有都在同一层时才有效。</li><li>RenderQueue Shader中对Tags设置的”Queue”</li></ol><p>Camera Depth永远最高。Camera Depth小的一定先进渲染管线。<br>当Sorting Layer和Order in Layer相同时<br>RenderQueue小的先进渲染管线。</p><p>当Sorting Layer和Order In Layer不相同时！<br>当两个材质使用了不同的RenderQueue,且这两个RenderQueue都在[0~2500]或[2501~5000]时，SortingLayer和OrderInLayer的排序生效。<br>当两个材质使用了不同的RenderQueue,且这两个RenderQueue分别再[0~2500]或[2501~5000]时，则一定会按照RenderQueue绘制，无视SortingLayer,OrderInLayer的排序。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>约束</title>
      <link href="/2018/04/11/constraint/"/>
      <url>/2018/04/11/constraint/</url>
      
        <content type="html"><![CDATA[<div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>T:struct</td><td>类型参数必须是值类型。可以指定除Nullable以外的任何值类型。</td></tr><tr><td>T:class</td><td>类型参数必须是引用类型，包括任何类、接口、委托或数组类型。</td></tr><tr><td>T:new()</td><td>类型参数必须具有无参数的公共构造函数。当与其他约束一起使用时，new()约束必须最后指定。</td></tr><tr><td>T:&lt;接口名称&gt;</td><td>类型参数必须是指定的接口或实现指定的接口。可以指定多个接口约束。约束接口也可以是泛型的。</td></tr><tr><td>T:U</td><td>为T提供的类型参数必须是为U提供的参数或派生自为U提供的参数。这称为螺类型约束。</td></tr></tbody></table></div><pre><code>public class MyGenericClass&lt;T&gt; where T:IComparable {}class MyClassy&lt;T, U&gt;where T : classwhere U : struct {}public class MyGenericClass&lt;T&gt; where T: IComparable, new(){    T item = new T();}</code></pre><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyI</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dictionary</span>&lt;<span class="type">TKey, TVal</span>&gt;</span></span><br><span class="line"><span class="keyword">where</span> TKey: IComparable, IEnumerable</span><br><span class="line"><span class="keyword">where</span> TVal: MyI</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> void Add(Tkey key, TVal <span class="keyword">val</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>public bool MyMethod&lt;T&gt; (T t) where T: IMyInterface {}</code></pre><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">List</span>&lt;<span class="type">T</span>&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">void <span class="type">Add</span>&lt;<span class="type">U</span>&gt;(<span class="type">List</span>&lt;<span class="type">U</span>&gt; <span class="title">items</span>) <span class="keyword">where</span></span> <span class="type">U</span>: <span class="type">T</span> </span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>default</p><p>之所以会用到default关键字，是因为需要在不知道类型参数为值类型还是引用类型的情况下，为对象实例赋初值。</p><p>```<br>class TestDefault<t><br>{<br>    public T foo()<br>    {<br>        return default(T);<br>    }<br>}</t></p>]]></content>
      
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23种设计模式</title>
      <link href="/2018/04/11/23-Design-Patterns/"/>
      <url>/2018/04/11/23-Design-Patterns/</url>
      
        <content type="html"><![CDATA[<p>设计模式分为三大类：<br>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。<br>结构性模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。<br>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介模式、解释器模式。<br>其实还有两类：并发型模式和线程池模式。</p><p>设计模式六大原则：<br>总原则-开闭原则<br>对扩展开放，对修改封闭。在程序需要进行扩展的时候，不能去修改原有的代码，而是扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。<br>想要达到这样的效果，外面需要使用接口和抽象类等，后面的具体设计中我们会提到这点。</p><p>1、单一职责原则<br>不要存在多余一个导致类变更的原因，也就是说每个类应该实现单一的职责，否则就应该把类拆分。</p><p>2.里氏替换原则(Liskov Substitution Principle)<br>任何积累可以出现的地方，子类一定可以出现</p><p>6.合成复用原则(Composite Reuse Principle)<br>尽量首先使用合成/聚合的方式，而不是使用继承。</p><h1 id="单线程单例模式"><a href="#单线程单例模式" class="headerlink" title="单线程单例模式"></a>单线程单例模式</h1><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span> <span class="comment">// 密封防止继承</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance; <span class="comment">// 唯一的实例</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数外部无法创建实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全局唯一访问点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">GetInstance</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单线程单例模式的几个要点：</p><ol><li>Singleton模式的实例构造器可以设置为protected以允许子类派生。</li><li>Singleton模式一般不要ICloneable接口，因为这可能会导致多个对象实例，与Singleton模式的初衷违背。</li><li>Singleton模式一般不要支持序列化，因为这也有可能导致多个对象实例，同样与Singleton模式的初衷违背。</li><li>Singleton模式只考虑到了对象创建的工作，没有考虑到对象效果的工作。全局静态的放到托管堆中还可以接受？</li><li>不能应对多线程环境，在多线程环境下，使用Singleton模式仍然有可能得到Singleton类的多个实例对象。</li></ol><h1 id="工厂设计模式"><a href="#工厂设计模式" class="headerlink" title="工厂设计模式"></a>工厂设计模式</h1><h2 id="简单工厂设计模式"><a href="#简单工厂设计模式" class="headerlink" title="简单工厂设计模式"></a>简单工厂设计模式</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> FruitKind</span><br><span class="line">&#123;</span><br><span class="line">    Apple,</span><br><span class="line">    Pear,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Fruit</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">WhatIm</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Apple</span> : <span class="title">Fruit</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WhatIm</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"I am Apple"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Pear</span> : <span class="title">Fruit</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WhatIm</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"I am pear"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FruitFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title">CreateFruit</span>(<span class="params">FruitKind type</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(type)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> FruitKind.Apple:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Apple();</span><br><span class="line">            <span class="keyword">case</span> FruitKind.Pear:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Pear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Fruit a = FruitFactory.CreateFruit(FruitKind.Pear);</span><br><span class="line">        a.WhatIm();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不太喜欢损失性能和不容易看到内部的逻辑，所以上述不太喜欢。上述存在一个问题，产品内部随便折腾没啥问题，但是做一个新的产品就蛋疼了。</p><h2 id="工厂方法设计模式"><a href="#工厂方法设计模式" class="headerlink" title="工厂方法设计模式"></a>工厂方法设计模式</h2><ol><li>抽象产品类</li><li>具体产品类</li><li>抽象工厂类</li><li>具体工厂类<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> FruitKind</span><br><span class="line">&#123;</span><br><span class="line">    Apple,</span><br><span class="line">    Pear,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Fruit</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">WhatIm</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Apple</span> : <span class="title">Fruit</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WhatIm</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"I am Apple"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Pear</span> : <span class="title">Fruit</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WhatIm</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"I am pear"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">FruitFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Fruit <span class="title">CreateFruit</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PearFactory</span> : <span class="title">FruitFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Fruit <span class="title">CreateFruit</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Apple();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>上述代码解耦了，</p>]]></content>
      
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试1</title>
      <link href="/2018/04/11/Interface/"/>
      <url>/2018/04/11/Interface/</url>
      
        <content type="html"><![CDATA[<p>接口(Interface)是一种规划，为你定义了一系列的规则和任务，但不去实现它<br>类和结构体可以继承多个接口<br>抽象类表示该类中可能已经有一些的具体定义<br>生成的库在这里：<br>Temp\StagingArea\libs\armeabi-v7a\libil2cpp.so</p><p>符号表在这里，需要把扩展名弄成.so，才能被bugly的符号工具转换。<br>Temp\StagingArea\libs\armeabi-v7a\libil2cpp.so.debug</p><p>C++代码生成到这里，最好保存这个目录，以便对应看调用栈：<br>Temp\StagingArea\Il2Cpp\il2cppOutput</p><h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><p>会把所有插入其中的数据都当成了object类型来处理。<br>弊端：1、不是类型安全的；2、存在装箱拆箱操作</p><p>Add() //向数组中添加一个元素<br>Remove() //删除数组中的一个元素<br>RemoveAt(int i);//<br>//不是骨骼动画,可以用animator,/<br>//骨骼动画 animator只能用一个,<br>Reverse()//反转数组的元素<br>Sort()//从小到大排序数组的元素<br>Clone()//复制一个数组<br>//List<br>//可通过索引访问<br>在决定使用List还是使用ArrayList 类(两者具有类似的功能)时,记住List类在大多数情况下执行的更好并且是类型安全的,<br>如果对List类型T使用值类型,则需要考虑实现和装箱问题<br>如果对类型T实用值类型,则编译器将特别针对该值类型生成List类的实现,这意味着不必对<br>再提醒一下，模板容器里不要使用枚举。<br>比如Dictionary之类的，枚举会boxing，产生无用的GC<br>就用int替代吧</p><p>1.请描述游戏动画有哪几种，以及其原理。<br>答:主要有关节动画,单一网络模型动画(关键帧动画),骨骼动画.<br>关节动画把角色分为若干独立部分,一个部分对应一个网络模型,部分的动画连接成一个整体的动画,角色比较灵活Quake2中实用了这种动画.<br>单一网络模型动画由一个完整的网络模型构成,在动画序列的关键帧里记录各个顶点的原位置及其改变量,然后插值运算实现动画效果,角色动画较真实.<br>骨骼动画,广泛应用的动画方式,集成了以上两个方式的优点,骨骼按角色特点组成一定的层次结构,由关节相连,可做相对运动,皮肤作为单一网络蒙在骨骼之外,决定角色的外观,皮肤网络每一个顶点都会收到骨骼的影响,从而实现完美的动画.</p><h1 id="alpha-blend-工作原理"><a href="#alpha-blend-工作原理" class="headerlink" title="alpha blend 工作原理"></a>alpha blend 工作原理</h1><p>alpha blend用于做半透明效果.Color=(源颜色 <em> 源系数)OP(目标颜色 </em> 目标系数);其中OP(混合方式)有加,减,反减,取最小,取最大</p><h2 id="OpenGL-Alpha混合"><a href="#OpenGL-Alpha混合" class="headerlink" title="OpenGL Alpha混合"></a>OpenGL Alpha混合</h2><p>假设一种不透明的东西的颜色是A，另一种透明的东西颜色是B，那么透过B看A，看上去的颜色C就是B和A的混合颜色，可以用以下公式来模拟，设B物体的透明度为alpha（取值为0-1，0为完全透明，1为完全不透明）</p><pre><code>R(C)=alpha*R(B)+(1-alpha)R(A)G(C)=alpha*G(B)+(1-alpha)G(A)B(C)=alpha*B(B)+(1-alpha)G(A)</code></pre><p>3.写光照计算中的diffuse的计算公式<br>答:漫反射光(diffuse)计算公式为:ldiffuse = Dintensity<em>Dcolor</em>N.L;(Dintensity)表示漫反射强度,Dcolor表示漫反射光颜色,N为该点的法向量,L为光源向量<br>其他,3D渲染中,物体表面的光照计算公式为:<br>I = 环境关(lambient) + 漫反射光(ldiffuse) + 镜面高光(lspecular);<br>其中,环境光(ambient)计算公式为:</p><pre><code>lambient = Aintensity*Acolor;(Aintensity)表示环境光强度,Acolor表示环境光颜色</code></pre><p>镜面高光(specular)计算公式为:<br>lspecular = Sintensity<em>Scolor</em>(R.V)n;(Sintensity)表示镜面光照强度,Scolor表示镜面光颜色,R为光的反射向量,V为观察者向量<br>4.lod是什么，优缺点是什么<br>答:LOD技术即为Levels of Detail的简称,意为多细节层次.LOD技术根据模型的节点在显示环境中所处的位置和重要度,决定物体渲染的资源分配,降低非重要物体的面数和细节度,从而得到高效率的渲染运算<br>5.两种阴影判断的方法工作原理<br>6.MipMap是什么？作用？<br>答:在三维计算机图形的贴图渲染中有一个常用的技术成为Mipmapping,为了加快渲染速度和减少图像锯齿,贴图被处理成由一系列被预先计算和优化过的图片组成的文件,这样的贴图被称为MIP map或者mipmap<br>7.用u3d实现2d游戏，有几种方式？<br>答：一种用UI实现(GUI,NGUI…)，一种是采用3d实体对象（plane），绘制在3d对象上，调节摄像机，采用平行投影模式或则固定视角。<br>8.u3d中碰撞器和触发器的区别？<br>答：触发器只是碰撞器身上的一个属性，碰撞器是触发器的载体。<br>9.物体发生碰撞的必要条件<br>答：需要检测碰撞的物体身上存在刚体组件（或被检测物体），也要碰撞器collider<br>10.CharacterController和Rigidbody的区别<br>11.物体发生碰撞时，有几个阶段，分别对应的函数<br>答：排除触发，有3种，OnCollisionEnter(),OnCollisionStay(); OnCollisionExit()<br>12.u3d中，几种施加力的方式，描述出来。<br>答：<br>a)爆炸力（AddExplosionForce(force : float, forcePos : Vector3，radius : float, upwards : float, mode : ForceMode)），应用一个力到刚体来模拟爆炸效果,就是在爆炸力中心坐标position,搜索在radius范围内的刚体，对其释放力作用，超出radius范围的刚体不受力作用，爆炸力将随着刚体的距离线性减弱。<br>b)力AddForce(force : Vector3, mode : ForceMode),主要施力给一个刚，使其移动。<br>c)位置力AddForceAtPosition(force : Vector3, position : Vector3, mode : ForceMode), 在position施加一个力，施力的主体将会受到一个力和力矩。<br>d)相对力AddRelativeForce(force : Vector3, mode : ForceMode),类似于AddForce；<br>13.什么叫做链条关节<br>答:Hinge Joint ,他可以模拟两个物体见<br>14.物体自旋转使用的函数叫什么<br>答：transform.Rotate(eulerAngles : Vector3, relativeTo : Space = Space.self);<br>15.物体绕某点旋转使用函数叫什么<br>答：transform.RotateAround(point : Vector3, axis : Vector3, angles : float)<br>16.u3d提供了一个用于保存读取数据的类，（playerPrefs），请列出保存读取整形数据的函数<br>答：PlayerPrefs.GetInt(key : string, defaultValue : int = 0);<br>17.unity3d提供了几种光源，分别是什么<br>答：平行光,点光源，聚光灯，环境光<br>18.unity3d从唤醒到销毁有一段生命周期，请列出系统自己调用的几个重要方法。<br>答：void Awake(),void Start(), void Update(), void FixedUpdate(),void LateUpdate(), void OnGUI() ，void Reset(), OnDisable(), void OnDestroy()<br>19.物理更新一般在哪个系统函数里？<br>答：void FixedUpdate()<br>20.移动相机动作在哪个函数里，为什么在这个函数里。<br>答：void LateUpdate(),因为这个函数是在Update执行完毕才执行的，不然的话就有可能出现摄像机里面什么都看到的情况。<br>21.当游戏中需要频繁创建一个物体对象时，我们需要怎么做来节省内存。<br>Unity里有两种动态加载机制:一个是Resources.Load,另外一个通过AssetBundle,其实两者区别不大,Resources.Load就是从一个缺省打进程序包里的AssetBundle里加载资源,而一般AssetBundle文件需要你自己创建,运行时动态加载<br>AssetBundle运行时加载<br>AssetBundle.Unload(flase)是释放AssetBundle文件<br>22.一个场景放置多个camera并同时处于活动状态，会发生什么<br>23.简述prefab的用处和环境<br>24.如何销毁一个UnityEngine.Object以及其子类<br>25.为什么u3d会出现组件上数据丢失的情况<br>26.u3d下如何安全的在不同工程迁移asset数据<br>DrawCall优化<br>一 Mesh Renderer<br>二 Skinned Mesh Renderer<br>三 合并要求对比<br>四 总结<br>五 场景制作建议<br>DrawCall优化合并,即DrawCall Batching.通过减少Draw call数和对显卡性能的消耗来提高性能<br>一 Mesh Renderer<br>分为Dynamic Batching 和 Static Batching<br>Dynamic Batching<br>不需要任何操作,只要共享材质(即使是不同的Mesh模型也可以)<br>Unity中的内存种类实际上Unity游戏使用的内存一共有三种:程序代码,托管堆(Managed Heap)以及本机堆(Native Heap)<br>程序代码包括了所有的Unity引擎,使用的库,以及你所写的所有的游戏代码,在编译后,得到的运行文件将会被加载到设备中执行,并占用一定内存.<br>这部分内存实际上是没有办法去”管理的”</p><p>法线贴图<br>一: 法线贴图的原理<br>光照效果很大程度上是由垂直于物体表面的法线决定的,因为法线影响反射光的方向,均匀垂直的法线是镜面贴图但是有时候我们会给一个平面使用砖墙贴图,砖墙应该是凹凸不平的,而如果让砖墙使用该平面的法线的话,画面就很假,神马?一面墙像镜子一样反光<br>而如果按真实砖墙去做模型的话,即做高精度模型,一方面制作麻烦,另一方面运行时对性能的损耗很大.<br>法线贴图就是来解决这个问题的.法线贴图就是把法线信息存储在一张图里.使用发现贴图时,通常顶点数和三角形面数只有高精度模型的十分之一不到.<br>二: 法线贴图的实现<br>将材质贴图对应的法线绘制在一张贴图上,将贴图对应点的单位法线向量信息float3(x,y,z)存储在途中对应的颜色里<br>压缩法线贴图的好处:<br>压缩后的法线贴图,大小只有原来的1/4左右,故可以使用更大或者更多的贴图来提升画面品质.<br>Unity3D的法线贴图<br>Unity3D使用的压缩法线贴图是DXT5nm格式的,有A和G两个通道,对于法线(x,y,z) A对应x,G对应y<br>对压缩法线贴图的采样依然是如下函数</p><pre><code>float4 packedNormal = tex2D(_NormalMap, IN.uv_MainTex);</code></pre><p>packedNormal.w对应A通道,既法线的x<br>packedNormal.y对应G通道,既法线的y<br>Unity3D热更新全书-加载(一)从AssetBundle说起<br>Unity3D动态加载下载资源,有没有解,有,AssetBundle就是通用解,任何一本书都会花大幅篇章来介绍AssetBundle<br>我们也来说说AssetBundle<br>我们试全面分析一下Unity3D提供的资源加载机制<br>1.Resourecs//内嵌资源,使用方法Resources.Load,可以加载任意种类的资源,不能动态修改,卒<br>2.StreamingAssets//随包资源,使用方法IO或WWW.Load,WWW.Load可以加载任意种类资源,IO仅限bytes和text<br>3.WWW从网络下载并加载<br>4.WWW从网络加载AssetBundle<br>一和二显然不具有热更新的效果,这里就不做讨论<br>3 4都是从网络加载的,他们有什么区别呢<br>首先说3,这是没有缓冲的,我们显然不想让用户重复的浪费流量,不可取<br>然后是4,assetbundle提供了一个版本号来做缓冲对比,可以比较好的起到更新的目标<br>assetbundle原来就是Unity3D为我们准备的方案,难怪每本书都会大篇介绍AssetBundle,后文简称AB<br>每本书都告诉你,AB很强大,AB帮你解决了跨平台问题,帮你解决了依赖关系.<br>而这个系列,不打算只讲别人讲的东西,还有告诉你一些小秘密<br>AssetBundle是天使还是恶魔<br>首先AB的确很好很强大,他能收纳Unity自己的所有资源种类,贴图,材质,shader预设<br>然后可以每平台支持,这就是第一个陷进,注意是每平台都支持,不是多平台支持<br>每个平台都要单独导出,而每个平台到底差了些什么呢?nothing<br>而最大的质量差异,源自贴图<br>有些平台贴图不压缩,有些平台贴图要压缩,而且根据不通的平台特性,套用不通的压缩算法,先压过再存到包里<br>这就是AB帮你干的最主要的事情<br>听起来很贴心呢,等等,你是不是忘了一个特定的命题,这个命题叫做UI<br>压缩的图片会有质量损失,UI贴图我们通常是不压缩的<br>然后UI还会触及到AB的另一个问题<br>以NGUI为例,NGUI的资源关系比较复杂,有贴图-&gt;图集-&gt;布局<br>不同的布局经常交叉应用贴图<br>如果用AB想把每个界面分开打包,给用户最小的资源更新量,这个任务可以用来灾难来形容<br>最终热更新推送给用户的东西是以文件为单位的,而AB在小粒度文件并且之间有较为复杂的应用关系这种需求的下的使用是一场灾难<br>AB对每个平台的差异编译不是可选的,而是强制的,假如你有web,ios,android,三个平台,无论如何你都要导出三次<br>没了AssetBundle,我们怎么办<br>把碎片文件下载回来,并且组装<br>对于UI这个情景,是完全可行的,把布局和图集保存为文本形式,把文本和贴图下载回来,然后组装<br>对于其他场景片段,在有动画和贴图需要压缩的情况下,AB依然是唯一的选择<br>unity没有提供在运行时压缩压缩贴图的手段,动画也不容易存储,只能运行时压缩DXT,只有pc和wp8支持<br>对于各种各样的资源加载回特别凌乱么,不会<br>其实本质上可以统一成bytes的处理<br>texture可以从bytes加载<br>字符串可以从bytes加载<br>AB可以从bytes加载<br>自定义二进制存储,本身就是bytes<br>Unity3D热更新全书-加载(二)如何在不用AssetBundle的前提下动态加载预设<br>Unity3D的主要构成大家都知道,首先是场景图,场景图上的节点构成一棵树<br>每个节点对应一个GameObject对象<br>然后每个GameObject有若干个组件<br>有一些组件会与资源产生关系,比如MeshRenderer会关联材质,材质回关联shader和贴图<br>场景图的一部分回保存为一个预设,prefab<br>有时候我们会需要预设去复用,而预设的加载似乎只能通过AB去打包,其实不然,这里我们有一个开源的库就可以解决这个问题<br>为什么不使用AB,可以见上一篇,加载(一),不使用AB一份资源全平台同意,也没有痛苦的打包时间,资源依赖也很容易处置<br>Unity3d从唤醒到销毁有一段声明周期,调用的几个重要方法为<br>Awake-&gt;OnEnable-&gt;Start-&gt;Update-&gt;FixedUpdate-&gt;LateUpdate-&gt;OnGUI-&gt;Reset-&gt;OnDisable-&gt;OnDestroy<br>物理更新一般在FixedUpdate里,每固定帧绘制时执行一次,和update不同的是FixedUpdate是渲染帧执行,如果你的渲染效率低下的时候FixedUpdate调用次数就会跟着下降,FixedUpdate比较适用于物理引擎的计算,因为是跟每帧渲染有关,Update就比较适合做控制.<br>移动相机动作在LateUpdate函数,当所有Update结束才调用,比较适合用于命令脚本的执行,<br>当游戏中需要频繁创建一个物体对象时,做一个pool,游戏开始时预先实例化足够的数量,用的时候取,不用的时候回收.<br>1.什么是渲染管道?<br>是指在显示器上为了显示出图像而经过的一系列必要操作<br>渲染管道中有很多步骤,都要将几何体从一个坐标系中变换到另一个坐标系中.<br>本地坐标-&gt;视图坐标-&gt;背面裁剪-&gt;光照-&gt;裁剪-&gt;投影-&gt;视图变换-&gt;光栅化<br>优化内存:<br>1.自带压缩类库<br>2.将暂时不用的以后还需要实用的物体隐藏起来而不是直接Destroy掉<br>3.释放AssetBundle占用的资源<br>4.降低模型的片面数,降低模型的骨骼数量,降低贴图的大小<br>5.使用光照贴图,使用多层次细节(LOD),使用着色器(Shader),使用预设(Prefab)<br>资源加载:<br>1.Resources.Load();<br>2.AssetBundle<br>localPosition:自身位置,相对于父级的变换位置,Position:在世界坐标transform的位置<br>静态构造函数不允许访问修饰符,也不接受任何参数<br>碰撞器(Collider)有碰撞效果,IsTrigger=false,可以调用OnCollisionEnter/Stay/Exit函数<br>触发器(Trigger)没有碰撞效果,IsTrigger=true,可以调用OnTriggerEnter/Stay/Exit函数<br>2.物体发生碰撞的必要条件?<br>必须带有collider碰撞起和rigibody刚体属性或者人物控制器其实人物控制器就包含了前两者,另外一个也要带有Collider,Collider分类:网格碰撞器,盒子碰撞器,胶囊碰撞器,球型碰撞器,地形碰撞器<br>3.CharacterController和Rigidbody的区别?<br>Rigidbody具有完全真是物理的特性,而CharacterController可以说是受限的Rigidbody,具有一定的物理效果但不是完全真实的.<br>4.物体发生碰撞时,几种施加力的方式,描述出来?<br>rigidbody.AddForce/AddForceAtPosition,都是rigidbody的成员函数<br>5.物体发生碰撞时,有几个阶段,分别对应的函数<br>三个阶段,OnCollsionEnter/Stay/Exit函数<br>6.Unity3d提供了几种光源,分别是什么<br>共4中,DirectrionaLight,PointLight,SpotLight,AreaLight(用于烘培)<br>7.什么是协同程序?<br>在主线程运行时间同时开启另一段逻辑处理,来协助当前程序的执行,换句话说,开启协程就是开启一个线程,可以用来控制运动,序列以及对象的行为.<br>8.使用Unity3d实现2d游戏,有几种方式?<br>(1).使用本身GUI<br>(2).把相机的Projection(投影)值调位Orthographic(正交投影),不考虑z轴;<br>(3).使用2d插件,如:2DTollKit<br>9.下列代码在运行中回产生几个临时对象?<br>string a = new string(“abc”);<br>a = (a.ToUpper() + “123”).SubString(0, 2);<br>答:其实在C#第一行是会出错的(Java中倒是可行),应该这样初始化<br>string b = new string(new char[]{‘a’, ‘b’, ‘c’}}<br>10.请简述关键字Sealed用在类声明和函数声明时的作用<br>答:类声明时可防止其他类继承此类,在方法中声明则可防止派生类重写此方法<br>11.简述四元数的作用,四元数对欧拉角的优点?<br>答:四元数用于表示旋转<br>相对于欧拉角的优点:<br>(1).能进行增量旋转<br>(2).避免方向锁<br>(3)给定方位的表达方式有两种,互为负(欧拉角有无数种表达方式)<br>12.如何安全的在不用工程间安全的迁移asset数据,三种方法<br>答<br>(1).将Assets目录和Library目录一起迁移<br>(2)导出包<br>(3)用unity自带的assert server功能<br>13.当一个细小的高速物体碰撞另一个较大的物体时,会出现什么情况?如何避免?<br>穿透(碰撞检测失败)<br>14.MipMap是什么?作用?<br>在三维计算机图形的贴图渲染中有一个常用的技术被成为Mipmapping,为了加快渲染速度和减少图像锯齿,贴图被处理成为</p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>审查元数据并手机关于它的类型信息的能力<br>实现原理：在运行时根据程序集和其中的类型得到元数据<br>实现步骤:</p><ol><li>导入 using System.Reflection</li><li>Assembly.Load(“程序集”)加载一个程序集，返回类型是一个Assembly</li><li><p>得到程序集中所有类的名称</p><p> foreach(Type type in assembly.GetType())<br> {</p><pre><code> stromh t = type.name;</code></pre><p> }</p></li><li><p>Type type = assembly.GetType(“程序集.类名”); //获取当前类的类型</p></li><li>Activator.CreateInstance(type); // 创建此类型实例</li><li>MethodInfo mInfo = type.GetMethod(“方法名”);//获取当前方法</li><li>m.Info.Invok(null, 方法参数);</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unity-nature-review</title>
      <link href="/2018/04/10/unity-nature-review/"/>
      <url>/2018/04/10/unity-nature-review/</url>
      
        <content type="html"><![CDATA[<p>是否有多维子材质：多维子材质材质测试，三个子材质，50个物体，使用多维子材质12帧，330个dc，343面。拆开之后20帧，154dc，134面。多维子材质Unity无法动态合并。<br>叠加模式贴图，可以不用Alpha通道<br>特效粒子贴图是否合并<br>是否有些粒子能使用序列帧，不过和视角有关，去掉alpha贴图合并。<br>动画boneweight,没有特殊需要的情况下受两个骨骼影响就够了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>大端模式与小端模式</title>
      <link href="/2018/04/02/Unix/"/>
      <url>/2018/04/02/Unix/</url>
      
        <content type="html"><![CDATA[<h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><ul><li>Little-Endian         低位字节放在内存的低地址端，高位字节放在内存的高地址端。</li><li>Big-Endian            高位字节放在内存的高地址端，低位字节放在内存的低地址端。</li><li>Network byte order    TPC/IP各层协议将字节序定义为Big-Endian，因此TCP/IP协议中使用的字节序通常称之为网络字节序。</li></ul><h3 id="高-低地址端"><a href="#高-低地址端" class="headerlink" title="高/低地址端"></a>高/低地址端</h3><p>首先要知道C程序中内存的空间布局情况：在《C专家编程》和《Unix环境高级编程》中关于内存空间布局情况的说明，大致如下图：</p><p>——————————————— 最高内存地址 0xffffffff<br>栈底<br>栈<br>栈顶<br>NULL（空洞）<br>堆<br>未初始化的数据<br>正文段（代码段<br>——————————————— 最高内存地址 0x00000000</p><p>在内存分布中，栈是向下增长的，而堆是向上增长的。</p><p>加入在栈分配unisgned char buf[4]，他在栈上分布如下<br>栈底（高地址）<br>buf[3]<br>buf[2]<br>buf[1]<br>buf[0]<br>栈顶（低地址）</p><h3 id="高-低位字节"><a href="#高-低位字节" class="headerlink" title="高/低位字节"></a>高/低位字节</h3><p>在十进制中靠左边的是高位，靠右边的地址，在其它进制也是如此</p><p>unisgned int value = 0x12345678;</p><p>Big-Endian:低地址存放高位<br>栈底（高地址）<br>buf[3] (0x78)<br>buf[2] (0x56)<br>buf[1] (0x34)<br>buf[0] (0x12)<br>栈顶（低地址）</p><p>Litter-Endian:高地址存高位<br>栈顶（高地址）<br>buf[0] (0x78)<br>buf[1] (0x56)<br>buf[2] (0x34)<br>buf[3] (0x12)<br>栈底（低地址）</p><p><td bgcolor="orange"> 主机序（Host Order）就是遵循Little-Endian规则</td>。所以当两台主机之间通过TCP/IP协议进行通信的时候就需要调用相应的函数进行主机序（Little-Endian）和网络（Big-Endian）的转换。</p><h2 id="Big-Endian和Little-Endian优缺点"><a href="#Big-Endian和Little-Endian优缺点" class="headerlink" title="Big-Endian和Little-Endian优缺点"></a>Big-Endian和Little-Endian优缺点</h2><p>Big-Endian 优点：</p><ol><li>靠首先提取高位字节，总是可以在偏移位置为0的字节来确定这个数字是正数还是负数。</li><li>数值打印是按顺序存放的</li></ol><p>Litter-Endian 优点：</p><ol><li>数学计算，精度处理。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Unix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua refer manual</title>
      <link href="/2018/04/02/Lua-5-1-refer-manual/"/>
      <url>/2018/04/02/Lua-5-1-refer-manual/</url>
      
        <content type="html"><![CDATA[<p>Lua 是一个扩展式程序设计语言，它被设计成支持通用的过程式编程，并有相关数据描述的设施。 Lua 也能对面向对象编程，函数式编程，数据驱动式编程提供很好的支持。 它可以作为一个强大、轻量的脚本语言，供任何需要的程序使用。 Lua 以一个用 clean C 写成的库形式提供。（所谓 Clean C ，指的 ANSI C 和 C++ 中共通的一个子集）<br>作为一个扩展式语言，Lua 没有 “main” 程序的概念：它只能 嵌入 一个宿主程序中工作，这个宿主程序被称作 embedding program 或简称为 host 。 宿主程序可以通过调用函数执行一小段 Lua 代码，可以读写 Lua 变量，可以注入 C 函数让 Lua 代码调用。 这些扩展的 C 函数，可以大大的扩展了 Lua 可以处理事务的领域，这样就可以订制出各种语言， 而它们共享一个统一的句法格式的框架。 Lua 的官方发布版就包含了一个叫做 lua 的简单的宿主程序，它用 Lua 库提供了一个保证独立的 Lua 解释器。<br>Lua 是一个自由软件，它的使用许可决定了对它的使用过程一般没有任何保证。 这份手册中描述的东西的实现，可以在 Lua 的官方网站 www.lua.org 找到，<br>跟其它的许多参考手册一样，这份文档有些地方比较枯燥。 关于 Lua 的设计想法的探讨，可以看看 Lua 网站上提供的技术论文。 有关用 Lua 编程的细节介绍，可以读一下 Roberto 的书，Programming in Lua (Second Edition) 。</p><p>这一节从词法、语法、句法上描述 Lua 。 换句话说，这一节描述了哪些 token （符记）是有效的，它们如何被组合起来，这些组合方式有什么含义。<br>关于语言的构成概念将用常见的扩展 BNF 表达式写出。也就是这个样子： {a} 意思是 0 或多个 a ， [a] 意思是一个可选的 a 。 非最终的符号会保留原来的样子，关键字则看起来像这样 kword ， 其它最终的符号则写成 `=´ 。 完整的 Lua 语法可以在本手册最后找到。</p><p>Lua 中用到的 名字（也称作 标识符）可以是任何非数字开头的字母、数字、下划线组成的字符串。 这符合几乎所有编程语言中关于名字的定义。 （字母的定义依赖于当前环境：系统环境中定义的字母表中的字母都可以被用于标识符。） 标识符用来命名变量，或作为表的域名。</p><p>下面的关键字是保留的，不能用作名字：</p><pre><code>and       break     do        else      elseifend       false     for       function  ifin        local     nil       not       orrepeat    return    then      true      until     while</code></pre><p>Lua 是一个大小写敏感的语言： and 是一个保留字，但是 And 和 AND 则是两个不同的合法的名字。 一般约定，以下划线开头连接一串大写字母的名字（比如 _VERSION）被保留用于 Lua 内部全局变量。</p><p>下面这些是其它的 token ：</p><pre><code> +     -     *     /     %     ^     # ==    ~=    &lt;=    &gt;=    &lt;     &gt;     = (     )     {     }     [     ] ;     :     ,     .     ..    ...</code></pre><p>字符串既可以用一对单引号引起，也可以是双引号，里面还可以包含类似 C 的转义符： ‘\a’ （响铃）， ‘\b’ （退格）， ‘\f’ （表单）， ‘\n’ （换行）， ‘\r’ （回车）， ‘\t’ （横向制表）， ‘\v’ （纵向制表）， ‘\\’ （反斜杠）， ‘\”‘ （双引号）， 以及 ‘\’’ （单引号)。 而且，如果在一个反斜杠后跟了一个真正的换行符，其结果就是在字符串中产生一个换行符。 我们还可以用反斜杠加数字的形式 \ddd 来描述一个字符。这里， ddd 是一串最多三位的十进制数字。（注意，如果需要在这种描述方法后接一个是数字的字符， 那么反斜杠后必须写满三个数字。）Lua 中的字符串可以包含任何 8 位的值。包括用 ‘\0’ 表示的零。<br>只有在你需要把不同的引号、换行、反斜杠、或是零结束符这些字符置入字符串时， 你才必须使用转义符。别的任何字符都可以直接写在文本里。（一些控制符可以会影响文件系统造成某些问题， 但是不会引起 Lua 的任何问题。）<br>字符串还可以用一种长括号括起来的方式定义。 我们把两个正的方括号间插入 n 个等号定义为第 n 级正长括号。 就是说，0 级正的长括号写作 [[ ， 一级正的长括号写作 [=[ ，如此等等。 反的长扩展也作类似定义； 举个例子，4 级反的长括号写作 ]====] 。 一个长字符串可以由任何一级的正的长括号开始，而由第一个碰到的同级反的长括号结束。 整个词法分析过程将不受分行限制，不处理任何转意符，并且忽略掉任何不同级别的长括号。 这种方式描述的字符串可以包含任何东西，当然特定级别的反长括号除外。<br>另一个约定是，当正的长括号后面立即跟了一个换行符， 这个换行符就不包含在这个字符串内。 举个例子，假设一个系统使用 ASCII 码 （这时，’a’ 编码为 97 ，换行符编码为 10 ，’1’ 编码为 49 ）， 下面五种方式描述了完全相同的字符串：</p><pre><code> a = &#39;alo\n123&quot;&#39; a = &quot;alo\n123\&quot;&quot; a = &#39;\97lo\10\04923&quot;&#39; a = [[alo 123&quot;]] a = [==[ alo 123&quot;]==]</code></pre><p>数字常量可以分两部分写，十进制底数部分和十进制的指数部分。指数部分是可选的。 Lua 也支持十六进制整数常量，只需要在前面加上前缀 0x 。 下面是一些合法的数字常量的例子：</p><pre><code> 3   3.0   3.1416   314.16e-2   0.31416E1   0xff   0x56</code></pre><p>注释可以在除字符串内的任何地方是以两横 (—) 开始。 如果跟在两横后面的不是一个长括号，这就是一个短注释，它的作用范围直到行末； 否则就是一个长注释，其作用范围直到遇到反的长括号。 长注释通常被用来临时屏蔽代码块。<br>Lua 是一种 动态类型语言。 这意味着变量没有类型，只有值才有类型。 语言中不存在类型定义。而所有的值本身携带它们自己的类型信息。<br>Lua 中的所有值都是一致 (first-class) 的。 这意味着所有的值都可以被放在变量里，当作参数传递到另一个函数中，并被函数作为结果返回。<br>Lua 中有八种基本类型： nil, boolean, number, string, function, userdata, thread, and table. Nil 类型只有一种值 nil ，它的主要用途用于标表识和别的任何值的差异； 通常，当需要描述一个无意义的值时会用到它。 Boolean 类型只有两种值：false 和 true。 nil 和 false 都能导致条件为假；而另外所有的值都被当作真。 Number 表示实数（双精度浮点数）。 （编译一个其它内部数字类型的 Lua 解释器是件很容易的事；比如把内部数字类型改作 单精度浮点数或长整型。参见文件 luaconf.h 。） String 表示一串字符的数组。 Lua 是 8-bit clean 的： 字符串可以包含任何 8 位字符， 包括零结束符 (‘\0’) （参见 §2.1）。<br>Lua 可以调用（和处理）用 Lua 写的函数以及用 C 写的函数<br>userdata 类型用来将任意 C 数据保存在 Lua 变量中。 这个类型相当于一块原生的内存，除了赋值和相同性判断，Lua 没有为之预定义任何操作。 然而，通过使用 metatable （元表） ，程序员可以为 userdata 自定义一组操作。 userdata 不能在 Lua 中创建出来，也不能在 Lua 中修改。这样的操作只能通过 C API。 这一点保证了宿主程序完全掌管其中的数据。<br>thread 类型用来区别独立的执行线程，它被用来实现 coroutine （协同例程）。 不要把 Lua 线程跟操作系统的线程搞混。 Lua 可以在所有的系统上提供对 coroutine 的支持，即使系统并不支持线程。<br>table 类型实现了一个关联数组。也就是说， 数组可以用任何东西（除了nil）做索引，而不限于数字。 table 可以以不同类型的值构成；它可以包含所有的类型的值（除 nil 外）。 table 是 lua 中唯一的一种数据结构；它可以用来描述原始的数组、符号表、集合、 记录、图、树、等等。 用于表述记录时，lua 使用域名作为索引。 语言本身采用一种语法糖，支持以 a.name 的形式表示 a[“name”]。 有很多形式用于在 lua 中创建一个 table （参见 §2.5.7）。<br>跟索引一样， table 每个域中的值也可以是任何类型（除 nil外）。 特别的，因为函数本身也是值，所以 table 的域中也可以放函数。 这样 table 中就可以有一些 methods 了 。<br>table， function ，thread ，和 (full) userdata 这些类型的值是所谓的对象： 变量本身并不会真正的存放它们的值，而只是放了一个对对象的引用。 赋值，参数传递，函数返回，都是对这些对象的引用进行操作； 这些操作不会做暗地里做任何性质的拷贝。<br>库函数 type 可以返回一个描述给定值的类型的字符串。<br>Lua 提供运行时字符串到数字的自动转换。 任何对字符串的数学运算操作都会尝试用一般的转换规则把这个字符串转换成一个数字。 相反，无论何时，一个数字需要作为字符串来使用时，数字都会以合理的格式转换为字符串。 需要完全控制数字怎样转换为字符串，可以使用字符串库中的 format 函数 （参见 string.format）。<br>写上变量的地方意味着当以其保存的值来替代之。 Lua 中有三类变量：全局变量，局部变量，还有 table 的域。<br>一个单一的名字可以表示一个全局变量，也可以表示一个局部变量 （或者是一个函数的参数，这是一种特殊形式的局部变量）：</p><pre><code>var ::= Name</code></pre><p>Name 就是所定义的标识符。<br>任何变量都被假定为全局变量，除非显式的以 local 修饰定义。 局部变量有其作用范围： 局部变量可以被定义在它作用范围中的函数自由使用。<br>在变量的首次赋值之前，变量的值均为 nil。<br>方括号被用来对 table 作索引：</p><pre><code>var ::= prefixexp `[´ exp `]´</code></pre><p>对全局变量以及 table 域之访问的含义可以通过 metatable 来改变。 以取一个变量下标指向的量 t[i] 等价于调用 gettable_event(t,i)。 （参见 §2.8 ，有一份完整的关于 gettable_event 函数的说明。 这个函数并没有在 lua 中定义出来，也不能在 lua 中调用。 这里我们把它列出来只是方便说明。）</p><p>var.Name 这种语法只是一个语法糖，用来表示 var[“Name”]：</p><pre><code>var ::= prefixexp `.´ Name</code></pre><p>所有的全局变量都是放在一个特定 lua table 的诸个域中，这个特定的 table 叫作 environment （环境）table 或者简称为 环境 （参见 §2.9）。 每个函数都有对一个环境的引用， 所以一个函数中可见的所有全局变量都放在这个函数所引用的环境表（environment table）中。 当一个函数被创建出来，它会从创建它的函数中继承其环境，你可以调用 getfenv 取得其环境。 如果想改变环境，可以调用 setfenv。 （对于 C 函数，你只能通过 debug 库来改变其环境； 参见 §5.9）。</p><p>对一个全局变量 x 的访问 等价于 _env.x，而这又可以等价于</p><pre><code>gettable_event(_env, &quot;x&quot;)</code></pre><p>这里，_env 是当前运行的函数的环境。 （函数 gettable_event 的完整说明参见 §2.8。 这个函数并没有在 lua 中定义出来，也不能调用。 当然，_env 这个变量也同样没有在 Lua 中定义出来。 我们在这里使用它们，仅仅只是方便解释而已。）</p><p>2.4 - 语句段（Statement）<br>Lua 支持惯例形式的语句段，它和 Pascal 或是 C 很相象。 这个集合包括赋值，控制结构，函数调用，还有变量声明。</p><p>2.4.1 - Chunk（语句组）<br>Lua 的一个执行单元被称作 chunk。 一个 chunk 就是一串语句段，它们会被循序的执行。 每个语句段可以以一个分号结束：</p><pre><code>chunk ::= {stat [`;´]}</code></pre><p>这儿不允许有空的语句段，所以 ‘;;’ 是非法的。</p><p>lua 把一个 chunk 当作一个拥有不定参数的匿名函数 （参见 §2.5.9）处理。 正是这样，chunk 内可以定义局部变量，接收参数，并且返回值。</p><p>chunk 可以被保存在一个文件中，也可以保存在宿主程序的一个字符串中。 当一个 chunk 被执行，首先它会被预编译成虚拟机中的指令序列， 然后被虚拟机解释运行这些指令。</p><p>chunk 也可以被预编译成二进制形式；细节参考程序 luac。 用源码形式提供的程序和被编译过的二进制形式的程序是可以相互替换的； Lua 会自动识别文件类型并做正确的处理。</p><p>语句块是一列语句段；从语法上来说，一个语句块跟一个 chunk 相同：</p><pre><code>block ::= chunk</code></pre><p>一个语句块可以被显式的写成一个单独的语句段：</p><pre><code>stat ::= do block end</code></pre><p>显式的语句块对于控制变量的作用范围很有用。 有时候，显式的语句块被用来在另一个语句块中插入 return 或是 break （参见 §2.4.4）。</p><p>Lua 允许多重赋值。 因此，赋值的语法定义是等号左边放一系列变量， 而等号右边放一系列的表达式。 两边的元素都用逗号间开：</p><pre><code>stat ::= varlist1 `=´ explist1varlist1 ::= var {`,´ var}explist1 ::= exp {`,´ exp}</code></pre><p>在作赋值操作之前， 那一系列的右值会被对齐到左边变量需要的个数。 如果右值比需要的更多的话，多余的值就被扔掉。 如果右值的数量不够需求， 将会按所需扩展若干个 nil。 如果表达式列表以一个函数调用结束， 这个函数所返回的所有值都会在对齐操作之前被置入右值序列中。 （除非这个函数调用被用括号括了起来；参见 §2.5）。</p><p>赋值段首先会做运算完所有的表达式，然后仅仅做赋值操作。 因此，下面这段代码</p><pre><code> i = 3 i, a[i] = i+1, 20</code></pre><p>会把 a[3] 设置为 20，而不会影响到 a[4] 。 这是因为 a[i] 中的 i 在被赋值为 4 之前就被拿出来了（那时是 3 ）。 简单说 ，这样一行</p><pre><code> x, y = y, x</code></pre><p>可以用来交换 x 和 y 中的值。</p><p>对全局变量以及 table 中的域的赋值操作的含义可以通过 metatable 来改变。 对变量下标指向的赋值，即 t[i] = val 等价于 settable_event(t,i,val)。 （关于函数 settable_event 的详细说明，参见 §2.8。 这个函数并没有在 Lua 中定义出来，也不可以被调用。 这里我们列出来，仅仅出于方便解释的目的）</p><p>对于全局变量的赋值 x = val 等价于 _env.x = val，这个又可以等价于</p><pre><code>settable_event(_env, &quot;x&quot;, val)</code></pre><p>这里，_env 指的是正在运行中的函数的环境。 （变量 _env 并没有在 Lua 中定义出来。 我们仅仅出于解释的目的在这里写出来。）</p><p>if、 while、以及 repeat 这些控制结构符合通常的意义，而且也有类似的语法：</p><pre><code>stat ::= while exp do block endstat ::= repeat block until expstat ::= if exp then block {elseif exp then block} [else block] end</code></pre><p>Lua 也有一个 for 语句，它有两种形式。<br>控制结构中的条件表达式可以返回任何值。 false 和 nil 两者都被认为是假条件。 所有不同于 nil 和 false 的其它值都被认为是真 （特别需要注意的是，数字 0 和空字符串也被认为是真）。<br>在 repeat–until 循环中， 内部语句块的结束点不是在 until 这个关键字处， 它还包括了其后的条件表达式。 因此，条件表达式中可以使用循环内部语句块中的定义的局部变量。<br>return 被用于从函数或是 chunk（其实它就是一个函数）中 返回值。 函数和 chunk 可以返回不只一个值， 所以 return 的语法为</p><pre><code>stat ::= return [explist1]</code></pre><p>break 被用来结束 while、 repeat、或 for 循环， 它将忽略掉循环中下面的语句段的运行：</p><pre><code>stat ::= break</code></pre><p>break 跳出最内层的循环。<br>return 和 break 只能被写在一个语句块的最后一句。 如果你真的需要从语句块的中间 return 或是 break ， 你可以使用显式的声名一个内部语句块。 一般写作 do return end 或是 do break end， 可以这样写是因为现在 return 或 break 都成了一个语句块的最后一句了。</p><p>for 有两种形式：一种是数字形式，另一种是一般形式。</p><p>数字形式的 for 循环，通过一个数学运算不断的运行内部的代码块。 下面是它的语法：</p><pre><code>stat ::= for Name `=´ exp `,´ exp [`,´ exp] do block end</code></pre><p>block 将把 name 作循环变量。从第一个 exp 开始起，直到第二个 exp 的值为止，其步长为 第三个 exp 。 更确切的说，一个 for 循环看起来是这个样子</p><pre><code> for v = e1, e2, e3 do block end</code></pre><p>这等价于代码：</p><pre><code>do   local var, limit, step = tonumber(e1), tonumber(e2), tonumber(e3)   if not (var and limit and step) then error() end   while (step &gt; 0 and var &lt;= limit) or (step &lt;= 0 and var &gt;= limit) do     local v = var     block     var = var + step   endend</code></pre><p>注意下面这几点：</p><p>所有三个控制表达式都只被运算一次，表达式的计算在循环开始之前。 这些表达式的结果必须是数字。<br>var 、limit 、以及 step 都是一些不可见的变量。 这里给它们起的名字都仅仅用于解释方便。<br>如果第三个表达式（步长）没有给出，会把步长设为 1 。<br>你可以用 break 来退出 for 循环。<br>循环变量 v 是一个循环内部的局部变量； 当 for 循环结束后，你就不能在使用它。 如果你需要这个值，在退出循环前把它赋给另一个变量。<br>一般形式的 for 通过一个叫作迭代器（iterators）的函数工作。 每次迭代，迭代器函数都会被调用以产生一个新的值， 当这个值为 nil 时，循环停止。 一般形式的 for 循环的语法如下：</p><pre><code>stat ::= for namelist in explist1 do block endnamelist ::= Name {`,´ Name}</code></pre><p>for 语句好似这样</p><pre><code> for var_1, ···, var_n in explist do block end</code></pre><p>它等价于这样一段代码：</p><pre><code> do   local f, s, var = explist   while true do     local var_1, ···, var_n = f(s, var)     var = var_1     if var == nil then break end     block   end end</code></pre><p>注意以下几点：</p><p>explist 只会被计算一次。 它返回三个值， 一个迭代器函数，一个状态，一个迭代器的初始值。<br>f、 s、 以及 var 都是不可见的变量。 这里给它们起的名字都只是为了解说方便。<br>你可以使用 break 来跳出 for 循环。<br>循环变量 var_i 对于循环来说是一个局部变量； 你不可以在 for 循环结束后继续使用。 如果你需要保留这些值，那么就在循环结束前赋值到别的变量里去。<br>2.4.6 - 把函数调用作为语句段<br>为了允许使用可能的副作用， 函数调用可以被作为一个语句段执行：</p><pre><code>stat ::= functioncall</code></pre><p>在这种情况下，所有的返回值都被舍弃。 函数调用在 §2.5.8 中解释。</p><p>2.4.7 - 局部变量声名<br>局部变量可以在语句块中任何地方声名。 声名可以包含一个初始化赋值操作：</p><pre><code>stat ::= local namelist [`=´ explist1]</code></pre><p>如果有的话，初始化赋值操作的行为等同于赋值操作（参见 §2.4.3）。 否则，所有的变量将被初始化为 nil。</p><p>一个 chunk 同时也是一个语句块（参见 §2.4.1）， 所以局部变量可以放在 chunk 中那些显式注明的语句块之外。 这些局部变量的作用范围从声明起一直延伸到 chunk 末尾。</p><p>局部变量的可见规则在 §2.6 中解释。</p><p>2.5 - 表达式<br>Lua 中有这些基本表达式：</p><pre><code>exp ::= prefixexpexp ::= nil | false | trueexp ::= Numberexp ::= Stringexp ::= functionexp ::= tableconstructorexp ::= `...´exp ::= exp binop expexp ::= unop expprefixexp ::= var | functioncall | `(´ exp `)´</code></pre><p>数字和字符串在 §2.1 中解释； 变量在 §2.3 中解释； 函数定义在 §2.5.9 中解释； 函数调用在 §2.5.8 中解释； table 的构造在 §2.5.7 中解释； 可变参数的表达式写作三个点 (‘…’) ，它只能被用在有可变参数的函数中； 这些在 §2.5.9 中解释。</p><p>二元操作符包含有数学运算操作符（参见 §2.5.1）， 比较操作符（参见 §2.5.2），逻辑操作符（参见 §2.5.3）， 以及连接操作符（参见 §2.5.4）。 一元操作符包括负号（参见see §2.5.1）， 取反 not（参见 §2.5.3）， 和取长度操作符（参见 §2.5.5）。</p><p>函数调用和可变参数表达式都可以放在多重返回值中。 如果表达式作为一个独立语句段出现（参见 §2.4.6） （这只能是一个函数调用）， 它们的返回列表将被对齐到零个元素，也就是忽略所有返回值。 如果表达式用于表达式列表的最后（或者是唯一）的元素， 就不会有任何的对齐操作（除非函数调用用括号括起来）。 在任何其它的情况下，Lua 将把表达式结果看成单一元素， 忽略除第一个之外的任何值。</p><p>这里有一些例子：</p><pre><code> f()                -- 调整到 0 个结果 g(f(), x)          -- f() 被调整到一个结果 g(x, f())          -- g 被传入 x 加上所有 f() 的返回值 a,b,c = f(), x     -- f() 被调整到一个结果 （ c 在这里被赋为 nil ） a,b = ...          -- a 被赋值为可变参数中的第一个，                    -- b 被赋值为第二个 （如果可变参数中并没有对应的值，                    -- 这里 a 和 b 都有可能被赋为 nil） a,b,c = x, f()     -- f() 被调整为两个结果 a,b,c = f()        -- f() 被调整为三个结果 return f()         -- 返回 f() 返回的所有结果 return ...         -- 返回所有从可变参数中接收来的值 return x,y,f()     -- 返回 x, y, 以及所有 f() 的返回值 {f()}              -- 用 f() 的所有返回值创建一个列表 {...}              -- 用可变参数中的所有值创建一个列表 {f(), nil}         -- f() 被调整为一个结果</code></pre><p>被括号括起来的表达式永远被当作一个值。所以， (f(x,y,z)) 即使 f 返回多个值，这个表达式永远是一个单一值。 （(f(x,y,z)) 的值是 f 返回的第一个值。如果 f 不返回值的话，那么它的值就是 nil 。）</p><p>2.5.1 - 数学运算操作符<br>Lua 支持常见的数学运算操作符： 二元操作 + （加法）， - （减法），* （乘法）， / （除法）， % （取模），以及 ^ （幂）； 和一元操作 - （取负）。 如果对数字操作，或是可以转换为数字的字符串（参见 §2.2.1）， 所有这些操作都依赖它通常的含义。 幂操作可以对任何幂值都正常工作。比如， x^(-0.5) 将计算出 x 平方根的倒数。 取模操作被定义为</p><pre><code> a % b == a - math.floor(a/b)*b</code></pre><p>这就是说，其结果是商相对负无穷圆整后的余数。（译注：负数对正数取模的结果为正数）</p><p>2.5.2 - 比较操作符<br>Lua 中的比较操作符有</p><pre><code> ==    ~=    &lt;     &gt;     &lt;=    &gt;=</code></pre><p>这些操作的结果不是 false 就是 true。</p><p>等于操作 (==) 首先比较操作数的类型。 如果类型不同，结果就是 false。 否则，继续比较值。 数字和字符串都用常规的方式比较。 对象 （table ，userdata ，thread ，以及函数）以引用的形式比较： 两个对象只有在它们指向同一个东西时才认为相等。 每次你创建一个新对象（一个 table 或是 userdata ，thread 函数）， 它们都各不相同，即不同于上次创建的东西。</p><p>你可以改变 Lua 比较 table 和 userdata 的方式，这需要使用 “eq” 这个原方法 （参见 §2.8）。</p><p>§2.2.1 中提及的转换规则并不作用于比较操作。 所以， “0”==0 等于 false， 而且 t[0] 和 t[“0”] 描述的是 table 中不同的域。</p><p>操作符 ~= 完全等价于 (==) 操作的反值。</p><p>大小比较操作以以下方式进行。 如果参数都是数字，那么就直接做数字比较。 否则，如果参数都是字符串，就用字符串比较的方式进行。 再则，Lua 就试着调用 “lt” 或是 “le” 元方法 （参见 §2.8）。</p><p>2.5.3 - 逻辑操作符<br>Lua 中的逻辑操作符有 and, or, 以及 not。 和控制结构（参见 §2.4.4）一样， 所有的逻辑操作符把 false 和 nil 都作为假， 而其它的一切都当作真。</p><p>取反操作 not 总是返回 false 或 true 中的一个。 与操作符 and 在第一个参数为 false 或 nil 时 返回这第一个参数； 否则，and 返回第二个参数。 或操作符 or 在第一个参数不为 nil 也不为 false 时， 返回这第一个参数，否则返回第二个参数。 and 和 or 都遵循短路规则； 也就是说，第二个操作数只在需要的时候去求值。 这里有一些例子：</p><pre><code> 10 or 20            --&gt; 10 10 or error()       --&gt; 10 nil or &quot;a&quot;          --&gt; &quot;a&quot; nil and 10          --&gt; nil false and error()   --&gt; false false and nil       --&gt; false false or nil        --&gt; nil 10 and 20           --&gt; 20</code></pre><p>（在这本手册中， —&gt; 指前面表达式的结果。）</p><p>2.5.4 - 连接符<br>Lua 中字符串的连接操作符写作两个点 (‘..’)。 如果两个操作数都是字符串或都是数字，连接操作将以 §2.2.1 中提到的规则把其转换为字符串。 否则，会取调用元方法 “concat” （参见 §2.8）。</p><p>2.5.5 - 取长度操作符<br>取长度操作符写作一元操作 #。 字符串的长度是它的字节数（就是以一个字符一个字节计算的字符串长度）。</p><p>table t 的长度被定义成一个整数下标 n 。 它满足 t[n] 不是 nil 而 t[n+1] 为 nil； 此外，如果 t[1] 为 nil ，n 就可能是零。 对于常规的数组，里面从 1 到 n 放着一些非空的值的时候， 它的长度就精确的为 n，即最后一个值的下标。 如果数组有一个“空洞” （就是说，nil 值被夹在非空值之间）， 那么 #t 可能是指向任何一个是 nil 值的前一个位置的下标 （就是说，任何一个 nil 值都有可能被当成数组的结束）。</p><p>2.5.6 - 优先级<br>Lua 中操作符的优先级写在下表中，从低到高优先级排序：</p><pre><code> or and &lt;     &gt;     &lt;=    &gt;=    ~=    == .. +     - *     /     % not   #     - (unary) ^</code></pre><p>通常，你可以用括号来改变运算次序。 连接操作符 (‘..’) 和幂操作 (‘^’) 是从右至左的。 其它所有的操作都是从左至右。</p><p>2.5.7 - Table 构造<br>table 构造子是一个构造 table 的表达式。 每次构造子被执行，都会构造出一个新的 table 。 构造子可以被用来构造一个空的 table， 也可以用来构造一个 table 并初始化其中的一些域。 一般的构造子的语法如下</p><pre><code>tableconstructor ::= `{´ [fieldlist] `}´fieldlist ::= field {fieldsep field} [fieldsep]field ::= `[´ exp `]´ `=´ exp | Name `=´ exp | expfieldsep ::= `,´ | `;´</code></pre><p>每个形如 [exp1] = exp2 的域向 table 中增加新的一项， 其键值为 exp1 而值为 exp2。 形如 name = exp 的域等价于 [“name”] = exp。 最后，形如 exp 的域等价于 [i] = exp ， 这里的 i 是一个从 1 开始不断增长的数字。 这这个格式中的其它域不会破坏其记数。 举个例子：</p><pre><code> a = { [f(1)] = g; &quot;x&quot;, &quot;y&quot;; x = 1, f(x), [30] = 23; 45 }</code></pre><p>等价于</p><pre><code> do   local t = {}   t[f(1)] = g   t[1] = &quot;x&quot;         -- 1st exp   t[2] = &quot;y&quot;         -- 2nd exp   t.x = 1            -- t[&quot;x&quot;] = 1   t[3] = f(x)        -- 3rd exp   t[30] = 23   t[4] = 45          -- 4th exp   a = t end</code></pre><p>如果表单中最后一个域的形式是 exp ， 而且其表达式是一个函数调用或者是一个可变参数， 那么这个表达式所有的返回值将连续的进入列表 （参见 §2.5.8）。 为了避免这一点，你可以用括号把函数调用（或是可变参数）括起来 （参见 §2.5）。</p><p>初始化域表可以在最后多一个分割符， 这样设计可以方便由机器生成代码。</p><p>2.5.8 - 函数调用<br>Lua 中的函数调用的语法如下：</p><pre><code>functioncall ::= prefixexp args</code></pre><p>函数调用时，第一步，prefixexp 和 args 先被求值。 如果 prefixexp 的值的类型是 function， 那么这个函数就被用给出的参数调用。 否则 prefixexp 的元方法 “call” 就被调用， 第一个参数就是 prefixexp 的值，跟下来的是原来的调用参数 （参见 §2.8）。</p><p>这样的形式</p><pre><code>functioncall ::= prefixexp `:´ Name args</code></pre><p>可以用来调用 “方法”。 这是 Lua 支持的一种语法糖。像 v:name(args) 这个样子，被解释成 v.name(v,args)， 这里 v 只会被求值一次。</p><p>参数的语法如下：</p><pre><code>args ::= `(´ [explist1] `)´args ::= tableconstructorargs ::= String</code></pre><p>所有参数的表达式求值都在函数调用之前。 这样的调用形式 f{fields} 是一种语法糖用于表示 f({fields})； 这里指参数列表是一个单一的新创建出来的列表。 而这样的形式 f’string’ （或是 f”string” 亦或是 f[[string]]） 也是一种语法糖，用于表示 f(‘string’)； 这里指参数列表是一个单独的字符串。</p><p>因为表达式语法在 Lua 中比较自由， 所以你不能在函数调用的 ‘(‘ 前换行。 这个限制可以避免语言中的一些歧义。 比如你这样写</p><pre><code> a = f (g).x(a)</code></pre><p>Lua 将把它当作一个单一语句段， a = f(g).x(a) 。 因此，如果你真的想作为成两个语句段，你必须在它们之间写上一个分号。 如果你真的想调用 f， 你必须从 (g) 前移去换行。</p><p>这样一种调用形式：return functioncall 将触发一个尾调用。 Lua 实现了适当的尾部调用（或是适当的尾递归）： 在尾调用中， 被调用的函数重用调用它的函数的堆栈项。 因此，对于程序执行的嵌套尾调用的层数是没有限制的。 然而，尾调用将删除调用它的函数的任何调试信息。 注意，尾调用只发生在特定的语法下， 这时， return 只有单一函数调用作为参数； 这种语法使得调用函数的结果可以精确返回。 因此，下面这些例子都不是尾调用：</p><pre><code> return (f(x))        -- 返回值被调整为一个 return 2 * f(x) return x, f(x)       -- 最加若干返回值 f(x); return         -- 无返回值 return x or f(x)     -- 返回值被调整为一个</code></pre><p>2.5.9 - 函数定义<br>函数定义的语法如下：</p><pre><code>function ::= function funcbodyfuncbody ::= `(´ [parlist1] `)´ block end</code></pre><p>另外定义了一些语法糖简化函数定义的写法：</p><pre><code>stat ::= function funcname funcbodystat ::= local function Name funcbodyfuncname ::= Name {`.´ Name} [`:´ Name]</code></pre><p>这样的写法：</p><pre><code> function f () body end</code></pre><p>被转换成</p><pre><code> f = function () body end</code></pre><p>这样的写法：</p><pre><code> function t.a.b.c.f () body end</code></pre><p>被转换成</p><pre><code> t.a.b.c.f = function () body end</code></pre><p>这样的写法：</p><pre><code> local function f () body end</code></pre><p>被转换成</p><pre><code> local f; f = function () body end</code></pre><p>注意，并不是转换成</p><pre><code> local f = function () body end</code></pre><p>（这个差别只在函数体内需要引用 f 时才有。）</p><p>一个函数定义是一个可执行的表达式， 执行结果是一个类型为 function 的值。 当 Lua 预编译一个 chunk 的时候， chunk 作为一个函数，整个函数体也就被预编译了。 那么，无论何时 Lua 执行了函数定义， 这个函数本身就被实例化了（或者说是关闭了）。 这个函数的实例（或者说是 closure（闭包）） 是表达式的最终值。 相同函数的不同实例有可能引用不同的外部局部变量， 也可能拥有不同的环境表。</p><p>形参（函数定义需要的参数）是一些由实参（实际传入参数）的值初始化的局部变量：</p><pre><code>parlist1 ::= namelist [`,´ `...´] | `...´</code></pre><p>当一个函数被调用， 如果函数没有被定义为接收不定长参数，即在形参列表的末尾注明三个点 (‘…’)， 那么实参列表就会被调整到形参列表的长度， 变长参数函数不会调整实参列表； 取而代之的是，它将把所有额外的参数放在一起通过变长参数表达式传递给函数， 其写法依旧是三个点。 这个表达式的值是一串实参值的列表，看起来就跟一个可以返回多个结果的函数一样。 如果一个变长参数表达式放在另一个表达式中使用，或是放在另一串表达式的中间， 那么它的返回值就会被调整为单个值。 若这个表达式放在了一系列表达式的最后一个，就不会做调整了（除非用括号给括了起来）。</p><p>我们先做如下定义，然后再来看一个例子：</p><pre><code> function f(a, b) end function g(a, b, ...) end function r() return 1,2,3 end</code></pre><p>下面看看实参到形参数以及可变长参数的映射关系：</p><pre><code> CALL            PARAMETERS f(3)             a=3, b=nil f(3, 4)          a=3, b=4 f(3, 4, 5)       a=3, b=4 f(r(), 10)       a=1, b=10 f(r())           a=1, b=2 g(3)             a=3, b=nil, ... --&gt;  (nothing) g(3, 4)          a=3, b=4,   ... --&gt;  (nothing) g(3, 4, 5, 8)    a=3, b=4,   ... --&gt;  5  8 g(5, r())        a=5, b=1,   ... --&gt;  2  3</code></pre><p>结果由 return 来返回（参见 §2.4.4）。 如果执行到函数末尾依旧没有遇到任何 return 语句， 函数就不会返回任何结果。</p><p>冒号语法可以用来定义方法， 就是说，函数可以有一个隐式的形参 self。 因此，如下写法：</p><pre><code> function t.a.b.c:f (params) body end</code></pre><p>是这样一种写法的语法糖：</p><pre><code> t.a.b.c.f = function (self, params) body end</code></pre><p>2.6 - 可视规则<br>Lua 是一个有词法作用范围的语言。 变量的作用范围开始于声明它们之后的第一个语句段， 结束于包含这个声明的最内层语句块的结束点。 看下面这些例子：</p><pre><code> x = 10                -- 全局变量 do                    -- 新的语句块   local x = x         -- 新的一个 &#39;x&#39;, 它的值现在是 10   print(x)            --&gt; 10   x = x+1   do                  -- 另一个语句块     local x = x+1     -- 又一个 &#39;x&#39;     print(x)          --&gt; 12   end   print(x)            --&gt; 11 end print(x)              --&gt; 10  （取到的是全局的那一个）</code></pre><p>注意这里，类似 local x = x 这样的声明， 新的 x 正在被声明，但是还没有进入它的作用范围， 所以第二个 x 指向的是外面一层的变量。</p><p>因为有这样一个词法作用范围的规则， 所以可以在函数内部自由的定义局部变量并使用它们。 当一个局部变量被更内层的函数中使用的时候， 它被内层函数称作 upvalue（上值），或是 外部局部变量。</p><p>注意，每次执行到一个 local 语句都会定义出一个新的局部变量。 看看这样一个例子：</p><pre><code> a = {} local x = 20 for i=1,10 do   local y = 0   a[i] = function () y=y+1; return x+y end end</code></pre><p>这个循环创建了十个 closure（这指十个匿名函数的实例）。 这些 closure 中的每一个都使用了不同的 y 变量， 而它们又共享了同一份 x。</p><h3 id="error"><a href="#error" class="headerlink" title="error"></a>error</h3><pre><code>error(message[, level])</code></pre><ul><li>Level = 1[默认]：为调用error位置(文件+行号)</li><li>Level = 2：指出哪个调用error的函数的函数</li><li>Level = 0：不添加错误位置信息<br>因为 Lua 是一个嵌入式的扩展语言， 所有的 Lua 动作都是从宿主程序的 C 代码调用 Lua 库 （参见 lua_pcall）中的一个函数开始的。 在 Lua 编译或运行的任何时候发生了错误，控制权都会交还给 C ， 而 C 可以来做一些恰当的措施（比如打印出一条错误信息）。<br>Lua 代码可以显式的调用 error 函数来产生一条错误。 如果你需要在 Lua 中捕获发生的错误， 你可以使用 pcall 函数。</li></ul><h3 id="Metatable"><a href="#Metatable" class="headerlink" title="Metatable"></a>Metatable</h3><p>Lua 中的每个值都可以用一个 metatable。 这个 metatable 就是一个原始的 Lua table ， 它用来定义原始值在特定操作下的行为。 你可以通过在 metatable 中的特定域设一些值来改变拥有这个 metatable 的值 的指定操作之行为。 举例来说，当一个非数字的值作加法操作的时候， Lua 会检查它的 metatable 中 “__add” 域中的是否有一个函数。 如果有这么一个函数的话，Lua 调用这个函数来执行一次加法。<br>我们叫 metatable 中的键名为 事件 (event) ，把其中的值叫作 元方法 (metamethod)。 在上个例子中，事件是 “add” 而元方法就是那个执行加法操作的函数。<br>你可以通过 getmetatable 函数来查询到任何一个值的 metatable。<br>你可以通过 setmetatable 函数来替换掉 table 的 metatable 。 你不能从 Lua 中改变其它任何类型的值的 metatable （使用 debug 库例外）； 要这样做的话必须使用 C API 。<br>每个 table 和 userdata 拥有独立的 metatable （当然多个 table 和 userdata 可以共享一个相同的表作它们的 metatable）； 其它所有类型的值，每种类型都分别共享唯一的一个 metatable。 因此，所有的数字一起只有一个 metatable ，所有的字符串也是，等等。<br>一个 metatable 可以控制一个对象做数学运算操作、比较操作、连接操作、取长度操作、取下标操作时的行为， metatable 中还可以定义一个函数，让 userdata 作垃圾收集时调用它。 对于这些操作，Lua 都将其关联上一个被称作事件的指定健。 当 Lua 需要对一个值发起这些操作中的一个时， 它会去检查值中 metatable 中是否有对应事件。 如果有的话，键名对应的值（元方法）将控制 Lua 怎样做这个操作。<br>metatable 可以控制的操作已在下面列出来。 每个操作都用相应的名字区分。 每个操作的键名都是用操作名字加上两个下划线 ‘<strong>‘ 前缀的字符串； 举例来说，”add” 操作的键名就是字符串 “</strong>add”。 这些操作的语义用一个 Lua 函数来描述解释器如何执行更为恰当。<br>这里展示的用 Lua 写的代码仅作解说用； 实际的行为已经硬编码在解释器中，其执行效率要远高于这些模拟代码。 这些用于描述的的代码中用到的函数 （ rawget ， tonumber ，等等。） 都可以在 §5.1 中找到。 特别注意，我们使用这样一个表达式来从给定对象中提取元方法</p><pre><code> metatable(obj)[event]</code></pre><p>这个应该被解读作</p><pre><code> rawget(getmetatable(obj) or {}, event)</code></pre><p>这就是说，访问一个元方法不再会触发任何的元方法， 而且访问一个没有 metatable 的对象也不会失败（而只是简单返回 nil）。</p><p>“add”: + 操作。<br>下面这个 getbinhandler 函数定义了 Lua 怎样选择一个处理器来作二元操作。 首先，Lua 尝试第一个操作数。 如果这个东西的类型没有定义这个操作的处理器，然后 Lua 会尝试第二个操作数。</p><pre><code> function getbinhandler (op1, op2, event)   return metatable(op1)[event] or metatable(op2)[event] end</code></pre><p>通过这个函数， op1 + op2 的行为就是</p><pre><code> function add_event (op1, op2)   local o1, o2 = tonumber(op1), tonumber(op2)   if o1 and o2 then  -- 两个操作数都是数字？     return o1 + o2   -- 这里的 &#39;+&#39; 是原生的 &#39;add&#39;   else  -- 至少一个操作数不是数字时     local h = getbinhandler(op1, op2, &quot;__add&quot;)     if h then       -- 以两个操作数来调用处理器       return h(op1, op2)     else  -- 没有处理器：缺省行为       error(···)     end   end end&quot;sub&quot;: - 操作。 其行为类似于 &quot;add&quot; 操作。&quot;mul&quot;: * 操作。 其行为类似于 &quot;add&quot; 操作。&quot;div&quot;: / 操作。 其行为类似于 &quot;add&quot; 操作。&quot;mod&quot;: % 操作。 其行为类似于 &quot;add&quot; 操作， 它的原生操作是这样的 o1 - floor(o1/o2)*o2&quot;pow&quot;: ^ （幂）操作。 其行为类似于 &quot;add&quot; 操作， 它的原生操作是调用 pow 函数（通过 C math 库）。&quot;unm&quot;: 一元 - 操作。function unm_event (op)   local o = tonumber(op)   if o then  -- 操作数是数字？     return -o  -- 这里的 &#39;-&#39; 是一个原生的 &#39;unm&#39;   else  -- 操作数不是数字。     -- 尝试从操作数中得到处理器     local h = metatable(op).__unm     if h then       -- 以操作数为参数调用处理器       return h(op)     else  -- 没有处理器：缺省行为       error(···)     end   end end&quot;concat&quot;: .. （连接）操作， function concat_event (op1, op2)   if (type(op1) == &quot;string&quot; or type(op1) == &quot;number&quot;) and      (type(op2) == &quot;string&quot; or type(op2) == &quot;number&quot;) then     return op1 .. op2  -- 原生字符串连接   else     local h = getbinhandler(op1, op2, &quot;__concat&quot;)     if h then       return h(op1, op2)     else       error(···)     end   end end&quot;len&quot;: # 操作。 function len_event (op)   if type(op) == &quot;string&quot; then     return strlen(op)         -- 原生的取字符串长度   elseif type(op) == &quot;table&quot; then     return #op                -- 原生的取 table 长度   else     local h = metatable(op).__len     if h then       -- 调用操作数的处理器       return h(op)     else  -- 没有处理器：缺省行为       error(···)     end   end end</code></pre><p>关于 table 的长度参见 §2.5.5 。</p><p>“eq”: == 操作。 函数 getcomphandler 定义了 Lua 怎样选择一个处理器来作比较操作。 元方法仅仅在参于比较的两个对象类型相同且有对应操作相同的元方法时才起效。<br>     function getcomphandler (op1, op2, event)<br>       if type(op1) ~= type(op2) then return nil end<br>       local mm1 = metatable(op1)[event]<br>       local mm2 = metatable(op2)[event]<br>       if mm1 == mm2 then return mm1 else return nil end<br>     end<br>“eq” 事件按如下方式定义：</p><pre><code> function eq_event (op1, op2)   if type(op1) ~= type(op2) then  -- 不同的类型？     return false   -- 不同的对象   end   if op1 == op2 then   -- 原生的相等比较结果？     return true   -- 对象相等   end   -- 尝试使用元方法   local h = getcomphandler(op1, op2, &quot;__eq&quot;)   if h then     return h(op1, op2)   else     return false   end end</code></pre><p>a ~= b 等价于 not (a == b) 。</p><pre><code>&quot;lt&quot;: &lt; 操作。 function lt_event (op1, op2)   if type(op1) == &quot;number&quot; and type(op2) == &quot;number&quot; then     return op1 &lt; op2   -- 数字比较   elseif type(op1) == &quot;string&quot; and type(op2) == &quot;string&quot; then     return op1 &lt; op2   -- 字符串按逐字符比较   else     local h = getcomphandler(op1, op2, &quot;__lt&quot;)     if h then       return h(op1, op2)     else       error(···);     end   end end</code></pre><p>a &gt; b 等价于 b &lt; a.</p><pre><code>&quot;le&quot;: &lt;= 操作。 function le_event (op1, op2)   if type(op1) == &quot;number&quot; and type(op2) == &quot;number&quot; then     return op1 &lt;= op2   -- 数字比较   elseif type(op1) == &quot;string&quot; and type(op2) == &quot;string&quot; then     return op1 &lt;= op2   -- 字符串按逐字符比较   else     local h = getcomphandler(op1, op2, &quot;__le&quot;)     if h then       return h(op1, op2)     else       h = getcomphandler(op1, op2, &quot;__lt&quot;)       if h then         return not h(op2, op1)       else         error(···);       end     end   end end</code></pre><p>a &gt;= b 等价于 b &lt;= a 。 注意，如果元方法 “le” 没有提供，Lua 就尝试 “lt” ， 它假定 a &lt;= b 等价于 not (b &lt; a) 。</p><p>“index”: 取下标操作用于访问 table[key] 。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gettable_event</span> <span class="params">(table, key)</span></span></span><br><span class="line">    <span class="keyword">local</span> h</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(<span class="built_in">table</span>) == <span class="string">"table"</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> v = <span class="built_in">rawget</span>(<span class="built_in">table</span>, key)</span><br><span class="line">        <span class="keyword">if</span> v ~= <span class="literal">nil</span> <span class="keyword">then</span> <span class="keyword">return</span> v <span class="keyword">end</span></span><br><span class="line">        h = metatable(<span class="built_in">table</span>).<span class="built_in">__index</span></span><br><span class="line">        <span class="keyword">if</span> h == <span class="literal">nil</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="literal">nil</span> <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        h = metatable(<span class="built_in">table</span>).<span class="built_in">__index</span></span><br><span class="line">        <span class="keyword">if</span> h == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">error</span>(···);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(h) == <span class="string">"function"</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> h(<span class="built_in">table</span>, key)      <span class="comment">-- 调用处理器</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> h[key]          <span class="comment">-- 或是重复上述操作</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h3 id="newindex"><a href="#newindex" class="headerlink" title="newindex"></a>newindex</h3><p>赋值给指定下标 table[key] = value</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">settable_event</span> <span class="params">(table, key, value)</span></span></span><br><span class="line">    <span class="keyword">local</span> h</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(<span class="built_in">table</span>) == <span class="string">"table"</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> v = <span class="built_in">rawget</span>(<span class="built_in">table</span>, key)</span><br><span class="line">        <span class="keyword">if</span> v ~= <span class="literal">nil</span> <span class="keyword">then</span> </span><br><span class="line">            <span class="built_in">rawset</span>(<span class="built_in">table</span>, key, value) </span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        h = metatable(<span class="built_in">table</span>).<span class="built_in">__newindex</span></span><br><span class="line">        <span class="keyword">if</span> h == <span class="literal">nil</span> <span class="keyword">then</span> </span><br><span class="line">            <span class="built_in">rawset</span>(<span class="built_in">table</span>, key, value) </span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        h = metatable(<span class="built_in">table</span>).<span class="built_in">__newindex</span></span><br><span class="line">        <span class="keyword">if</span> h == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">error</span>(···)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(h) == <span class="string">"function"</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> h(<span class="built_in">table</span>, key,value)    <span class="comment">-- 调用处理器</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        h[key] = value             <span class="comment">-- 或是重复上述操作</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>“call”: 当 Lua 调用一个值时调用。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">function_event</span> <span class="params">(func, ...)</span></span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">type</span>(func) == <span class="string">"function"</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> func(...)   <span class="comment">-- 原生的调用</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">local</span> h = metatable(func).<span class="built_in">__call</span></span><br><span class="line">    <span class="keyword">if</span> h <span class="keyword">then</span></span><br><span class="line">      <span class="keyword">return</span> h(func, ...)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">error</span>(···)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h3 id="2-9-环境"><a href="#2-9-环境" class="headerlink" title="2.9 - 环境"></a>2.9 - 环境</h3><p>类型为 thread ，function ，以及 userdata 的对象，除了 metatable 外还可以用另外一个与之关联的被称作 它们的环境的一个表， 像 metatable 一样，环境也是一个常规的 table ，多个对象可以共享 同一个环境。<br>userdata 的环境在 Lua 中没有意义。 这个东西只是为了在程序员想把一个表关联到一个 userdata 上时提供便利。<br>关联在线程上的环境被称作全局环境。 全局环境被用作它其中的线程以及线程创建的非嵌套函数 （通过 loadfile ， loadstring 或是 load ）的缺省环境。 而且它可以被 C 代码直接访问（参见 §3.3）。<br>关联在 C 函数上的环境可以直接被 C 代码访问（参见 §3.3）。 它们会作为这个 C 函数中创建的其它函数的缺省环境。<br>关联在 Lua 函数上的环境用来接管在函数内对全局变量（参见 §2.3）的所有访问。 它们也会作为这个函数内创建的其它函数的缺省环境。<br>你可以通过调用 setfenv 来改变一个 Lua 函数 或是正在运行中的线程的环境。 而想操控其它对象（userdata、C 函数、其它线程）的环境的话，就必须使用 C API 。</p><h3 id="2-10-垃圾收集"><a href="#2-10-垃圾收集" class="headerlink" title="2.10 - 垃圾收集"></a>2.10 - 垃圾收集</h3><p>Lua 提供了一个自动的内存管理。 这就是说你不需要关心创建新对象的分配内存操作，也不需要在这些对象不再需要时的主动释放内存。 Lua 通过运行一个垃圾收集器来自动管理内存，以此一遍又一遍的回收死掉的对象 （这是指 Lua 中不再访问的到的对象）占用的内存。 Lua 中所有对象都被自动管理，包括： table, userdata、 函数、线程、和字符串。<br>Lua 实现了一个增量标记清除的收集器。 它用两个数字来控制垃圾收集周期： garbage-collector pause 和 garbage-collector step multiplier 。<br>garbage-collector pause 控制了收集器在开始一个新的收集周期之前要等待多久。 随着数字的增大就导致收集器工作工作的不那么主动。 小于 1 的值意味着收集器在新的周期开始时不再等待。 当值为 2 的时候意味着在总使用内存数量达到原来的两倍时再开启新的周期。<br>step multiplier 控制了收集器相对内存分配的速度。 更大的数字将导致收集器工作的更主动的同时，也使每步收集的尺寸增加。 小于 1 的值会使收集器工作的非常慢，可能导致收集器永远都结束不了当前周期。 缺省值为 2 ，这意味着收集器将以内存分配器的两倍速运行。<br>你可以通过在 C 中调用 lua_gc 或是在 Lua 中调用 collectgarbage 来改变这些数字。 两者都接受百分比数值（因此传入参数 100 意味着实际值 1 ）。 通过这些函数，你也可以直接控制收集器（例如，停止或是重启）。</p><h3 id="2-10-1-垃圾收集的元方法"><a href="#2-10-1-垃圾收集的元方法" class="headerlink" title="2.10.1 - 垃圾收集的元方法"></a>2.10.1 - 垃圾收集的元方法</h3><p>使用 C API　， 你可以给 userdata （参见 §2.8）设置一个垃圾收集的元方法。 这个元方法也被称为结束子。 结束子允许你用额外的资源管理器和 Lua 的内存管理器协同工作 （比如关闭文件、网络连接、或是数据库连接，也可以说释放你自己的内存）。<br>一个 userdata 可被回收，若它的 metatable 中有 __gc 这个域　， 垃圾收集器就不立即收回它。 取而代之的是，Lua 把它们放到一个列表中。 最收集结束后，Lua 针对列表中的每个 userdata 执行了下面这个函数的等价操作：</p><pre><code>function gc_event (udata)    local h = metatable(udata).__gc    if h then        h(udata)    endend</code></pre><p>在每个垃圾收集周期的结尾，每个在当前周期被收集起来的 userdata 的结束子会以 它们构造时的逆序依次调用。 也就是说，收集列表中，最后一个在程序中被创建的 userdata 的 结束子会被第一个调用。</p><p>2.10.2 - Weak Table（弱表）<br>weak table 是一个这样的 table，它其中的元素都被弱引用。 弱引用将被垃圾收集器忽略掉， 换句话说， 如果对一个对象的引用只有弱引用， 垃圾收集器将回收这个对象。</p><p>weak table 的键和值都可以是 weak 的。 如果一个 table 只有键是 weak 的，那么将运行收集器回收它们的键， 但是会阻止回收器回收对应的值。 而一个 table 的键和值都是 weak 时，就即允许收集器回收键又允许收回值。 任何情况下，如果键和值中任一个被回收了，整个键值对就会从 table 中拿掉。 table 的 weak 特性可以通过在它的 metatable 中设置 <strong>mode 域来改变。 如果 </strong>mode 域中是一个包含有字符 ‘k’ 的字符串时， table 的键就是 weak 的。 如果 __mode 域中是一个包含有字符 ‘v’ 的字符串时， table 的值就是 weak 的。</p><p>在你把一个 table 当作一个 metatable 使用之后， 就不能再修改 __mode 域的值。 否则，受这个 metatable 控制的 table 的 weak 行为就成了未定义的。</p><p>2.11 - Coroutine （协同例程）<br>Lua 支持 coroutine ，这个东西也被称为协同式多线程 (collaborative multithreading)　。 Lua 为每个 coroutine 提供一个独立的运行线路。 然而和多线程系统中的线程不同，coroutine 只在显式的调用了 yield 函数时才会挂起。</p><p>创建一个 coroutine 需要调用一次 coroutine.create 。 它只接收单个参数，这个参数是 coroutine 的主函数。 create 函数仅仅创建一个新的 coroutine 然后返回它的控制器 （一个类型为 thread 的对象）； 它并不会启动 coroutine 的运行。</p><p>当你第一次调用 coroutine.resume 时， 所需传入的第一个参数就是 coroutine.create 的返回值。 这时，coroutine 从主函数的第一行开始运行。 接下来传入 coroutine.resume 的参数将被传进 coroutine 的主函数。 在 coroutine 开始运行后，它讲运行到自身终止或是遇到一个 yields 。</p><p>coroutine 可以通过两种方式来终止运行： 一种是正常退出，指它的主函数返回（最后一条指令被运行后，无论有没有显式的返回指令）; 另一种是非正常退出，它发生在未保护的错误发生的时候。 第一种情况中， coroutine.resume 返回 true ， 接下来会跟着 coroutine 主函数的一系列返回值。 第二种发生错误的情况下， coroutine.resume 返回 false ， 紧接着是一条错误信息。</p><p>coroutine 中切换出去，可以调用 coroutine.yield。 当 coroutine 切出，与之配合的 coroutine.resume 就立即返回， 甚至在 yield 发生在内层的函数调用中也可以（就是说， 这不限于发生在主函数中，也可以是主函数直接或间接调用的某个函数里）。 在 yield 的情况下，coroutine.resume 也是返回 true， 紧跟着那些被传入 coroutine.yield 的参数。 等到下次你在继续同样的 coroutine ，将从调用 yield 的断点处运行下去。 断点处 yield 的返回值将是 coroutine.resume 传入的参数。</p><p>类似 coroutine.create ， coroutine.wrap 这个函数也将创建一个 coroutine ， 但是它并不返回 coroutine 本身，而是返回一个函数取而代之。一旦你调用这个返回函数，就会切入 coroutine 运行。 所有传入这个函数的参数等同于传入 coroutine.resume 的参数。 coroutine.wrap 会返回所有应该由除第一个（错误代码的那个布尔量） 之外的由 coroutine.resume 返回的值。 和 coroutine.resume 不同， coroutine.wrap 不捕获任何错误； 所有的错误都应该由调用者自己传递。</p><p>看下面这段代码展示的一个例子：</p><pre><code> function foo (a)   print(&quot;foo&quot;, a)   return coroutine.yield(2*a) end co = coroutine.create(function (a,b)       print(&quot;co-body&quot;, a, b)       local r = foo(a+1)       print(&quot;co-body&quot;, r)       local r, s = coroutine.yield(a+b, a-b)       print(&quot;co-body&quot;, r, s)       return b, &quot;end&quot; end) print(&quot;main&quot;, coroutine.resume(co, 1, 10)) print(&quot;main&quot;, coroutine.resume(co, &quot;r&quot;)) print(&quot;main&quot;, coroutine.resume(co, &quot;x&quot;, &quot;y&quot;)) print(&quot;main&quot;, coroutine.resume(co, &quot;x&quot;, &quot;y&quot;))</code></pre><p>当你运行它，将得到如下输出结果：</p><pre><code> co-body 1       10 foo     2 main    true    4 co-body r main    true    11      -9 co-body x       y main    true    10      end main    false   cannot resume dead coroutine</code></pre><p>3 - 程序接口（API）<br>这个部分描述了 Lua 的 C API ， 也就是宿主程序跟 Lua 通讯用的一组 C 函数。 所有的 API 函数按相关的类型以及常量都声明在头文件 lua.h 中。</p><p>虽然我们说的是“函数”，但一部分简单的 API 是以宏的形式提供的。 所有的这些宏都只使用它们的参数一次 （除了第一个参数，也就是 lua 状态机）， 因此你不需担心这些宏的展开会引起一些副作用。</p><p>在所有的 C 库中，Lua API 函数都不去检查参数的有效性和坚固性。 然而，你可以在编译 Lua 时加上打开一个宏开关来 开启 luaconf.h 文件中的宏 luai_apicheck 以改变这个行为。</p><h3 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h3><p>Lua 使用一个虚拟栈来和 C 传递值。 栈上的的每个元素都是一个 Lua 值 （nil，数字，字符串，等等）。</p><p>无论何时 Lua 调用 C，被调用的函数都得到一个新的栈， 这个栈独立于 C 函数本身的堆栈，也独立于以前的栈。 （译注：在 C 函数里，用 Lua API 不能访问到 Lua 状态机中本次调用之外的堆栈中的数据） 它里面包含了 Lua 传递给 C 函数的所有参数， 而 C 函数则把要返回的结果也放入堆栈以返回给调用者 （参见 lua_CFunction）。</p><p>方便起见，所有针对栈的 API 查询操作都不严格遵循栈的操作规则。 而是可以用一个索引来指向栈上的任何元素： 正的索引指的是栈上的绝对位置（从一开始）； 负的索引则指从栈顶开始的偏移量。 更详细的说明一下，如果堆栈有 n 个元素， 那么索引 1 表示第一个元素（也就是最先被压入堆栈的元素） 而索引 n 则指最后一个元素； 索引 -1 也是指最后一个元素（即栈顶的元素）， 索引 -n 是指第一个元素。 如果索引在 1 到栈顶之间（也就是，1 ≤ abs(index) ≤ top） 我们就说这是个有效的索引。</p><h3 id="堆栈尺寸"><a href="#堆栈尺寸" class="headerlink" title="堆栈尺寸"></a>堆栈尺寸</h3><p>当你使用 Lua API 时，就有责任保证其坚固性。 特别需要注意的是，你有责任控制不要堆栈溢出。你可以使用 lua_checkstack 这个函数来扩大可用堆栈的尺寸。<br>无论何时 Lua 调用 C ， 它都只保证 LUA_MINSTACK 这么多的堆栈空间可以使用。 LUA_MINSTACK 一般被定义为 20　，因此，只要你不是不断的把数据压栈，通常你不用关心堆栈大小。<br>所有的查询函数都可以接收一个索引，只要这个索引是任何栈提供的空间中的值。 栈能提供的最大空间是通过 lua_checkstack 来设置的。 这些索引被称作可接受的索引，通常我们把它定义为：</p><pre><code> (index &lt; 0 &amp;&amp; abs(index) &lt;= top) || (index &gt; 0 &amp;&amp; index &lt;= stackspace)</code></pre><p>注意，0 永远都不是一个可接受的索引。（译注：下文中凡提到的索引，没有特别注明的话，都指可接受的索引。）</p><h3 id="LUA-GLOBALSINDEX"><a href="#LUA-GLOBALSINDEX" class="headerlink" title="LUA_GLOBALSINDEX"></a>LUA_GLOBALSINDEX</h3><p>除了特别声明外，任何一个函数都可以接受另一种有效的索引，它们被称作“伪索引”。 这个可以帮助 C 代码访问一些并不在栈上的 Lua 值。 伪索引被用来访问线程的环境，函数的环境，注册表，还有 C 函数的 upvalue。<br>线程的环境（也就是全局变量放的地方）通常在伪索引 LUA_GLOBALSINDEX 处。 正在运行的 C 函数的环境则放在伪索引 LUA_ENVIRONINDEX 之处。<br>可以用常规的 table 操作来访问和改变全局变量的值，只需要指定环境表的位置。 举例而言，要访问全局变量的值，这样做：</p><pre><code>lua_getfield(L, LUA_GLOBALSINDEX, varname);</code></pre><h3 id="C-Closure"><a href="#C-Closure" class="headerlink" title="C Closure"></a>C Closure</h3><p>当 C 函数被创建出来，我们有可能会把一些值关联在一起， 也就是创建一个 C closure ； 这些被关联起来的值被叫做 upvalue ，它们可以在函数被调用的时候访问的到。 （参见 lua_pushcclosure ）。<br>无论何时去调用 C 函数，函数的 upvalue 都被放在指定的伪索引处。 我们可以用 lua_upvalueindex 这个宏来生成这些伪索引。 第一个关联到函数的值放在 lua_upvalueindex(1) 位置处，依次类推。 任何情况下都可以用 lua_upvalueindex(n) 产生一个 upvalue 的索引， 即使 n 大于实际的 upvalue 数量也可以。它都可以产生一个可接受但不一定有效的索引。</p><h3 id="LUA-REGISTRYINDEX"><a href="#LUA-REGISTRYINDEX" class="headerlink" title="LUA_REGISTRYINDEX"></a>LUA_REGISTRYINDEX</h3><p>Lua 提供了一个注册表，这是一个预定义出来的表，可以用来保存任何 C 代码想保存的 Lua 值。 这个表可以用伪索引 LUA_REGISTRYINDEX 来定位。 任何 C 库都可以在这张表里保存数据，为了防止冲突，你需要特别小心的选择键名。 一般的用法是，你可以用一个包含你的库名的字符串做为键名，或者可以取你自己 C 代码 中的一个地址，以 light userdata 的形式做键。<br>注册表里的整数健被用于补充库中实现的引用系统的工作，一般说来不要把它们用于别的用途。</p><h3 id="C-中的错误处理"><a href="#C-中的错误处理" class="headerlink" title="C 中的错误处理"></a>C 中的错误处理</h3><p>在内部实现中，Lua 使用了 C 的 longjmp 机制来处理错误。 （如果你使用 C++ 的话，也可以选择换用异常；参见 luaconf.h 文件。） 当 Lua 碰到任何错误（比如内存分配错误、类型错误、语法错误、还有一些运行时错误） 它都会产生一个错误出去； 也就是调用一个 long jump 。 在保护环境下，Lua 使用 setjmp 来设置一个恢复点； 任何发生的错误都会激活最近的一个恢复点。<br>几乎所有的 API 函数都可能产生错误，例如内存分配错误。 但下面的一些函数运行在保护环境中（也就是说它们创建了一个保护环境再在其中运行）， 因此它们不会产生错误出来： lua_newstate, lua_close, lua_load, lua_pcall, and lua_cpcall。</p><p>在 C 函数里，你也可以通过调用 lua_error 产生一个错误。</p><h3 id="lua-Alloc"><a href="#lua-Alloc" class="headerlink" title="lua_Alloc"></a>lua_Alloc</h3><pre><code>typedef void * (*lua_Alloc) (void *ud, void *ptr, size_t osize, size_t nsize);</code></pre><p>Lua 状态机中使用的内存分配器函数的类型。 内存分配函数必须提供一个功能类似于 realloc 但又不完全相同的函数。 它的参数有 ud ，一个由 lua_newstate 传给它的指针； ptr ，一个指向已分配出来或是将被重新分配或是要释放的内存块指针； osize ，内存块原来的尺寸； nsize ，新内存块的尺寸。 如果且只有 osize 是零时，ptr 为 NULL 。 当 nsize 是零，分配器必须返回 NULL； 如果 osize 不是零，分配器应当释放掉 ptr 指向的内存块。 当 nsize 不是零，若分配器不能满足请求时，分配器返回 NULL 。 当 nsize 不是零而 osize 是零时，分配器应该和 malloc 有相同的行为。 当 nsize 和 osize 都不是零时，分配器则应和 realloc 保持一样的行为。 Lua 假设分配器在 osize &gt;= nsize 时永远不会失败。</p><p>这里有一个简单的分配器函数的实现。 这个实现被放在补充库中，由 luaL_newstate 提供。</p><pre><code>static void *l_alloc (void *ud, void *ptr, size_t osize, size_t nsize) {    (void)ud;      (void)osize;  /* not used */    if (nsize == 0)     {        free(ptr);        return NULL;    }    else        return realloc(ptr, nsize);}</code></pre><p>这段代码假设 free(NULL) 啥也不影响，而且 realloc(NULL, size) 等价于 malloc(size)。 这两点是 ANSI C 保证的行为。</p><h3 id="lua-atpanic"><a href="#lua-atpanic" class="headerlink" title="lua_atpanic"></a>lua_atpanic</h3><pre><code>lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf);</code></pre><p>设置一个新的 panic （恐慌） 函数，并返回前一个。<br>如果在保护环境之外发生了任何错误， Lua 就会调用一个 panic 函数，接着调用 exit(EXIT_FAILURE)， 这样就开始退出宿主程序。 你的 panic 函数可以永远不返回（例如作一次长跳转）来避免程序退出。<br>panic 函数可以从栈顶取到出错信息。</p><h3 id="lua-call"><a href="#lua-call" class="headerlink" title="lua_call"></a>lua_call</h3><pre><code>void lua_call (lua_State *L, int nargs, int nresults);</code></pre><p>调用一个函数。<br>要调用一个函数请遵循以下协议： 首先，要调用的函数应该被压入堆栈； 接着，把需要传递给这个函数的参数按正序压栈； 这是指第一个参数首先压栈。 最后调用一下 lua_call； nargs 是你压入堆栈的参数个数。 当函数调用完毕后，所有的参数以及函数本身都会出栈。 而函数的返回值这时则被压入堆栈。 返回值的个数将被调整为 nresults 个， 除非 nresults 被设置成 LUA_MULTRET。 在这种情况下，所有的返回值都被压入堆栈中。 Lua 会保证返回值都放入栈空间中。 函数返回值将按正序压栈（第一个返回值首先压栈）， 因此在调用结束后，最后一个返回值将被放在栈顶。</p><p>被调用函数内发生的错误将（通过 longjmp）一直上抛。<br>下面的例子中，这行 Lua 代码等价于在宿主程序用 C 代码做一些工作：</p><pre><code> a = f(&quot;how&quot;, t.x, 14)</code></pre><p>这里是 C 里的代码：</p><pre><code> lua_getfield(L, LUA_GLOBALSINDEX, &quot;f&quot;);          /* 将调用的函数 */ lua_pushstring(L, &quot;how&quot;);                          /* 第一个参数 */ lua_getfield(L, LUA_GLOBALSINDEX, &quot;t&quot;);          /* table 的索引 */ lua_getfield(L, -1, &quot;x&quot;);         /* 压入 t.x 的值（第 2 个参数）*/ lua_remove(L, -2);                           /* 从堆栈中移去 &#39;t&#39; */ lua_pushinteger(L, 14);                           /* 第 3 个参数 */ lua_call(L, 3, 1); /* 调用 &#39;f&#39;，传入 3 个参数，并索取 1 个返回值 */ lua_setfield(L, LUA_GLOBALSINDEX, &quot;a&quot;);      /* 设置全局变量 &#39;a&#39; */</code></pre><p>注意上面这段代码是“平衡”的： 到了最后，堆栈恢复成原由的配置。 </p><h3 id="lua-CFunction"><a href="#lua-CFunction" class="headerlink" title="lua_CFunction"></a>lua_CFunction</h3><pre><code>typedef int (*lua_CFunction) (lua_State *L);</code></pre><p>C 函数的类型。<br>为了正确的和 Lua 通讯，C 函数必须使用下列 定义了参数以及返回值传递方法的协议： C 函数通过 Lua 中的堆栈来接受参数，参数以正序入栈（第一个参数首先入栈）。 因此，当函数开始的时候， lua_gettop(L) 可以返回函数收到的参数个数。 第一个参数（如果有的话）在索引 1 的地方，而最后一个参数在索引 lua_gettop(L) 处。 当需要向 Lua 返回值的时候，C 函数只需要把它们以正序压到堆栈上（第一个返回值最先压入）， 然后返回这些返回值的个数。 在这些返回值之下的，堆栈上的东西都会被 Lua 丢掉。 和 Lua 函数一样，从 Lua 中调用 C 函数也可以有很多返回值。</p><p>下面这个例子中的函数将接收若干数字参数，并返回它们的平均数与和：</p><pre><code> static int foo (lua_State *L) {   int n = lua_gettop(L);    /* 参数的个数 */   lua_Number sum = 0;   int i;   for (i = 1; i &lt;= n; i++) {     if (!lua_isnumber(L, i)) {       lua_pushstring(L, &quot;incorrect argument&quot;);       lua_error(L);     }     sum += lua_tonumber(L, i);   }   lua_pushnumber(L, sum/n);   /* 第一个返回值 */   lua_pushnumber(L, sum);     /* 第二个返回值 */   return 2;                   /* 返回值的个数 */ }</code></pre><h3 id="lua-checkstack"><a href="#lua-checkstack" class="headerlink" title="lua_checkstack"></a>lua_checkstack</h3><pre><code>int lua_checkstack (lua_State *L, int extra);</code></pre><p>确保堆栈上至少有 extra 个空位。 如果不能把堆栈扩展到相应的尺寸，函数返回 false 。 这个函数永远不会缩小堆栈； 如果堆栈已经比需要的大了，那么就放在那里不会产生变化。</p><h3 id="lua-close"><a href="#lua-close" class="headerlink" title="lua_close"></a>lua_close</h3><pre><code>void lua_close (lua_State *L);</code></pre><p>销毁指定 Lua 状态机中的所有对象（如果有垃圾收集相关的元方法的话，会调用它们），并且释放状态机中使用的所有动态内存。 在一些平台上，你可以不必调用这个函数， 因为当宿主程序结束的时候，所有的资源就自然被释放掉了。 另一方面，长期运行的程序，比如一个后台程序或是一个 web 服务器， 当不再需要它们的时候就应该释放掉相关状态机。这样可以避免状态机扩张的过大。</p><h3 id="lua-concat"><a href="#lua-concat" class="headerlink" title="lua_concat"></a>lua_concat</h3><pre><code>void lua_concat (lua_State *L, int n);</code></pre><p>连接栈顶的 n 个值， 然后将这些值出栈，并把结果放在栈顶。如果 n 为 1 ，结果就是一个字符串放在栈上（即，函数什么都不做）； 如果 n 为 0 ，结果是一个空串。 连接依照 Lua 中创建语义完成（参见 §2.5.4 ）。</p><h3 id="lua-cpcall"><a href="#lua-cpcall" class="headerlink" title="lua_cpcall"></a>lua_cpcall</h3><pre><code>int lua_cpcall (lua_State *L, lua_CFunction func, void *ud);</code></pre><p>以保护模式调用 C 函数 func 。 func 只有能从堆栈上拿到一个参数，就是包含有 ud 的 light userdata。 当有错误时， lua_cpcall 返回和 lua_pcall 相同的错误代码， 并在栈顶留下错误对象； 否则它返回零，并不会修改堆栈。 所有从 func 内返回的值都会被扔掉。</p><h3 id="lua-createtable"><a href="#lua-createtable" class="headerlink" title="lua_createtable"></a>lua_createtable</h3><pre><code>void lua_createtable (lua_State *L, int narr, int nrec);</code></pre><p>创建一个新的空 table 压入堆栈。 这个新 table 将被预分配 narr 个元素的数组空间 以及 nrec 个元素的非数组空间。 当你明确知道表中需要多少个元素时，预分配就非常有用。 如果你不知道，可以使用函数 lua_newtable。</p><h3 id="lua-dump"><a href="#lua-dump" class="headerlink" title="lua_dump"></a>lua_dump</h3><pre><code>int lua_dump (lua_State *L, lua_Writer writer, void *data);</code></pre><p>把函数 dump 成二进制 chunk 。 函数接收栈顶的 Lua 函数做参数，然后生成它的二进制 chunk 。 若被 dump 出来的东西被再次加载，加载的结果就相当于原来的函数。 当它在产生 chunk 的时候，lua_dump 通过调用函数 writer （参见 lua_Writer） 来写入数据，后面的 data 参数会被传入 writer 。<br>最后一次由写入器 (writer) 返回值将作为这个函数的返回值返回； 0 表示没有错误。</p><p>这个函数不会把 Lua 返回弹出堆栈。</p><h3 id="lua-equal"><a href="#lua-equal" class="headerlink" title="lua_equal"></a>lua_equal</h3><pre><code>int lua_equal (lua_State *L, int index1, int index2);</code></pre><p>如果依照 Lua 中 == 操作符语义，索引 index1 和 index2 中的值相同的话，返回 1 。 否则返回 0 。 如果任何一个索引无效也会返回 0。</p><h3 id="lua-error"><a href="#lua-error" class="headerlink" title="lua_error"></a>lua_error</h3><pre><code>int lua_error (lua_State *L);</code></pre><p>产生一个 Lua 错误。 错误信息（实际上可以是任何类型的 Lua 值）必须被置入栈顶。 这个函数会做一次长跳转，因此它不会再返回。 （参见 luaL_error）。</p><h3 id="lua-gc"><a href="#lua-gc" class="headerlink" title="lua_gc"></a>lua_gc</h3><pre><code>int lua_gc (lua_State *L, int what, int data);</code></pre><p>控制垃圾收集器。<br>这个函数根据其参数 what 发起几种不同的任务：</p><p>LUA_GCSTOP: 停止垃圾收集器。<br>LUA_GCRESTART: 重启垃圾收集器。<br>LUA_GCCOLLECT: 发起一次完整的垃圾收集循环。<br>LUA_GCCOUNT: 返回 Lua 使用的内存总量（以 K 字节为单位）。<br>LUA_GCCOUNTB: 返回当前内存使用量除以 1024 的余数。<br>LUA_GCSTEP: 发起一步增量垃圾收集。 步数由 data 控制（越大的值意味着越多步）， 而其具体含义（具体数字表示了多少）并未标准化。 如果你想控制这个步数，必须实验性的测试 data 的值。 如果这一步结束了一个垃圾收集周期，返回返回 1 。<br>LUA_GCSETPAUSE: 把 data/100 设置为 garbage-collector pause 的新值（参见 §2.10）。 函数返回以前的值。<br>LUA_GCSETSTEPMUL: 把 arg/100 设置成 step multiplier （参见 §2.10）。 函数返回以前的值。</p><h3 id="lua-getallocf"><a href="#lua-getallocf" class="headerlink" title="lua_getallocf"></a>lua_getallocf</h3><pre><code>lua_Alloc lua_getallocf (lua_State *L, void **ud);</code></pre><p>返回给定状态机的内存分配器函数。 如果 ud 不是 NULL ，Lua 把调用 lua_newstate 时传入的那个指针放入 *ud 。</p><h3 id="lua-getfenv"><a href="#lua-getfenv" class="headerlink" title="lua_getfenv"></a>lua_getfenv</h3><pre><code>void lua_getfenv (lua_State *L, int index);</code></pre><p>把索引处值的环境表压入堆栈。</p><h3 id="lua-getfield"><a href="#lua-getfield" class="headerlink" title="lua_getfield"></a>lua_getfield</h3><pre><code>void lua_getfield (lua_State *L, int index, const char *k);</code></pre><p>把 t[k] 值压入堆栈， 这里的 t 是指有效索引 index 指向的值。 在 Lua 中，这个函数可能触发对应 “index” 事件的元方法 （参见 §2.8）。</p><h3 id="lua-getglobal"><a href="#lua-getglobal" class="headerlink" title="lua_getglobal"></a>lua_getglobal</h3><pre><code>void lua_getglobal(lua_State *L, const char *name);</code></pre><p>把全局变量name里的值压入堆栈。 这个是用一个宏定义出来的：</p><pre><code> #define lua_getglobal(L,s)  lua_getfield(L, LUA_GLOBALSINDEX, s)</code></pre><h3 id="lua-getmetatable"><a href="#lua-getmetatable" class="headerlink" title="lua_getmetatable"></a>lua_getmetatable</h3><pre><code>int lua_getmetatable (lua_State *L, int index);</code></pre><p>把给定索引指向的值的元表压入堆栈。 如果索引无效，或是这个值没有元表， 函数将返回 0 并且不会向栈上压任何东西。</p><h3 id="lua-gettable"><a href="#lua-gettable" class="headerlink" title="lua_gettable"></a>lua_gettable</h3><pre><code>void lua_gettable (lua_State *L, int index);</code></pre><p>把 t[k] 值压入堆栈， 这里的 t 是指有效索引 index 指向的值， 而 k 则是栈顶放的值。<br>这个函数会弹出堆栈上的 key （把结果放在栈上相同位置）。 在 Lua 中，这个函数可能触发对应 “index” 事件的元方法。</p><h3 id="lua-gettop"><a href="#lua-gettop" class="headerlink" title="lua_gettop"></a>lua_gettop</h3><pre><code>int lua_gettop(lua_State *L);</code></pre><p>返回栈顶元素的索引。 因为索引是从 1 开始编号的， 所以这个结果等于堆栈上的元素个数（因此返回 0 表示堆栈为空）。</p><h3 id="lua-insert"><a href="#lua-insert" class="headerlink" title="lua_insert"></a>lua_insert</h3><pre><code>void lua_insert (lua_State *L, int index);</code></pre><p>把栈顶元素插入指定的有效索引处， 并依次移动这个索引之上的元素。 不要用伪索引来调用这个函数， 因为伪索引不是真正指向堆栈上的位置。</p><h3 id="lua-Integer"><a href="#lua-Integer" class="headerlink" title="lua_Integer"></a>lua_Integer</h3><pre><code>typedef ptrdiff_t lua_Integer;</code></pre><p>这个类型被用于 Lua API 接收整数值。<br>缺省时这个被定义为 ptrdiff_t ， 这个东西通常是机器能处理的最大整数类型。</p><h3 id="lua-isboolean"><a href="#lua-isboolean" class="headerlink" title="lua_isboolean"></a>lua_isboolean</h3><pre><code>int lua_isboolean (lua_State *L, int index);</code></pre><p>当给定索引的值类型为 boolean 时，返回 1 ，否则返回 0 。</p><h3 id="lua-iscfunction"><a href="#lua-iscfunction" class="headerlink" title="lua_iscfunction"></a>lua_iscfunction</h3><pre><code>int lua_iscfunction (lua_State *L, int index);</code></pre><p>当给定索引的值是一个 C 函数时，返回 1 ，否则返回 0 。</p><h3 id="lua-isfunction"><a href="#lua-isfunction" class="headerlink" title="lua_isfunction"></a>lua_isfunction</h3><pre><code>int lua_isfunction (lua_State *L, int index);</code></pre><p>当给定索引的值是一个函数（ C 或 Lua 函数均可）时，返回 1 ，否则返回 0 。</p><h3 id="lua-islightuserdata"><a href="#lua-islightuserdata" class="headerlink" title="lua_islightuserdata"></a>lua_islightuserdata</h3><pre><code>int lua_islightuserdata (lua_State *L, int index);</code></pre><p>当给定索引的值是一个 light userdata 时，返回 1 ，否则返回 0 。</p><h3 id="lua-isnil"><a href="#lua-isnil" class="headerlink" title="lua_isnil"></a>lua_isnil</h3><pre><code>int lua_isnil (lua_State *L, int index);</code></pre><p>当给定索引的值是 nil 时，返回 1 ，否则返回 0 。</p><h3 id="lua-isnumber"><a href="#lua-isnumber" class="headerlink" title="lua_isnumber"></a>lua_isnumber</h3><pre><code>int lua_isnumber (lua_State *L, int index);</code></pre><p>当给定索引的值是一个数字，或是一个可转换为数字的字符串时，返回 1 ，否则返回 0 。</p><h3 id="lua-isstring"><a href="#lua-isstring" class="headerlink" title="lua_isstring"></a>lua_isstring</h3><pre><code>int lua_isstring (lua_State *L, int index);</code></pre><p>当给定索引的值是一个字符串或是一个数字（数字总能转换成字符串）时，返回 1 ，否则返回 0 。</p><h3 id="lua-istable"><a href="#lua-istable" class="headerlink" title="lua_istable"></a>lua_istable</h3><pre><code>int lua_istable (lua_State *L, int index);</code></pre><p>当给定索引的值是一个 table 时，返回 1 ，否则返回 0 。</p><h3 id="lua-isthread"><a href="#lua-isthread" class="headerlink" title="lua_isthread"></a>lua_isthread</h3><pre><code>int lua_isthread (lua_State *L, int index);</code></pre><p>当给定索引的值是一个 thread 时，返回 1 ，否则返回 0 。</p><h3 id="lua-isuserdata"><a href="#lua-isuserdata" class="headerlink" title="lua_isuserdata"></a>lua_isuserdata</h3><pre><code>int lua_isuserdata (lua_State *L, int index);</code></pre><p>当给定索引的值是一个 userdata （无论是完整的 userdata 还是 light userdata ）时，返回 1 ，否则返回 0 。</p><h3 id="lua-lessthan"><a href="#lua-lessthan" class="headerlink" title="lua_lessthan"></a>lua_lessthan</h3><pre><code>int lua_lessthan (lua_State *L, int index1, int index2);</code></pre><p>如果索引 index1 处的值小于 索引 index2 处的值时，返回 1 ； 否则返回 0 。 其语义遵循 Lua 中的 &lt; 操作符（就是说，有可能调用元方法）。 如果任何一个索引无效，也会返回 0 。</p><h3 id="lua-load"><a href="#lua-load" class="headerlink" title="lua_load"></a>lua_load</h3><pre><code>int lua_load (lua_State *L, lua_Reader reader, void *data, const char *chunkname);</code></pre><p>加载一个 Lua chunk 。 如果没有错误， lua_load 把一个编译好的 chunk 作为一个 Lua 函数压入堆栈。 否则，压入出错信息。 lua_load 的返回值可以是：</p><p>0: 没有错误；<br>LUA_ERRSYNTAX: 在预编译时碰到语法错误；<br>LUA_ERRMEM: 内存分配错误。<br>这个函数仅仅加栽 chunk ；而不会去运行它。</p><p>lua_load 会自动检测 chunk 是文本的还是二进制的， 然后做对应的加载操作（参见程序 luac）。<br>lua_load 函数使用一个用户提供的 reader 函数来 读取 chunk （参见 lua_Reader）。 data 参数会被传入读取器函数。<br>chunkname 这个参数可以赋予 chunk 一个名字， 这个名字被用于出错信息和调试信息。</p><h3 id="lua-newstate"><a href="#lua-newstate" class="headerlink" title="lua_newstate"></a>lua_newstate</h3><pre><code>lua_State *lua_newstate (lua_Alloc f, void *ud);</code></pre><p>创建的一个新的独立的状态机。 如果创建不了（因为内存问题）返回 NULL 。 参数 f 是一个分配器函数； Lua 将通过这个函数做状态机内所有的内存分配操作。 第二个参数 ud ，这个指针将在每次调用分配器时被直接传入。</p><h3 id="lua-newtable"><a href="#lua-newtable" class="headerlink" title="lua_newtable"></a>lua_newtable</h3><pre><code>void lua_newtable (lua_State *L);</code></pre><p>创建一个空 table ，并将之压入堆栈。 它等价于 lua_createtable(L, 0, 0) 。</p><h3 id="lua-newthread"><a href="#lua-newthread" class="headerlink" title="lua_newthread"></a>lua_newthread</h3><pre><code>lua_State *lua_newthread (lua_State *L);</code></pre><p>创建一个新线程，并将其压入堆栈， 并返回维护这个线程的 lua_State 指针。 这个函数返回的新状态机共享原有状态机中的所有对象（比如一些 table）， 但是它有独立的执行堆栈。<br>没有显式的函数可以用来关闭或销毁掉一个线程。 线程跟其它 Lua 对象一样是垃圾收集的条目之一。</p><h3 id="lua-newuserdata"><a href="#lua-newuserdata" class="headerlink" title="lua_newuserdata"></a>lua_newuserdata</h3><pre><code>void *lua_newuserdata (lua_State *L, size_t size);</code></pre><p>这个函数分配分配一块指定大小的内存块， 把内存块地址作为一个完整的 userdata 压入堆栈，并返回这个地址。<br>userdata 代表 Lua 中的 C 值。 完整的 userdata 代表一块内存。 它是一个对象（就像 table 那样的对象）： 你必须创建它，它有着自己的元表，而且它在被回收时，可以被监测到。 一个完整的 userdata 只和它自己相等（在等于的原生作用下）。<br>当 Lua 通过 gc 元方法回收一个完整的 userdata 时， Lua 调用这个元方法并把 userdata 标记为已终止。 等到这个 userdata 再次被收集的时候，Lua 会释放掉相关的内存。</p><h3 id="lua-next"><a href="#lua-next" class="headerlink" title="lua_next"></a>lua_next</h3><pre><code>int lua_next (lua_State *L, int index);</code></pre><p>从栈上弹出一个 key（键）， 然后把索引指定的表中 key-value（健值）对压入堆栈 （指定 key 后面的下一 (next) 对）。 如果表中以无更多元素， 那么 lua_next 将返回 0 （什么也不压入堆栈）。<br>典型的遍历方法是这样的：</p><pre><code>/* table 放在索引 &#39;t&#39; 处 */lua_pushnil(L);  /* 第一个 key */while (lua_next(L, t) != 0) {    /* 用一下 &#39;key&#39; （在索引 -2 处） 和 &#39;value&#39; （在索引 -1 处） */    printf(&quot;%s - %s\n&quot;,    lua_typename(L, lua_type(L, -2)),    lua_typename(L, lua_type(L, -1)));    /* 移除 &#39;value&#39; ；保留 &#39;key&#39; 做下一次迭代 */    lua_pop(L, 1);}</code></pre><p>在遍历一张表的时候， 不要直接对 key 调用 lua_tolstring ， 除非你知道这个 key 一定是一个字符串。 调用 lua_tolstring 有可能改变给定索引位置的值； 这会对下一次调用 lua_next 造成影响。</p><h3 id="lua-Number"><a href="#lua-Number" class="headerlink" title="lua_Number"></a>lua_Number</h3><pre><code>typedef double lua_Number;</code></pre><p>Lua 中数字的类型。 确省是 double ，但是你可以在 luaconf.h 中修改它。<br>通过修改配置文件你可以改变 Lua 让它操作其它数字类型（例如：float 或是 long ）。</p><h3 id="lua-objlen"><a href="#lua-objlen" class="headerlink" title="lua_objlen"></a>lua_objlen</h3><pre><code>size_t lua_objlen (lua_State *L, int index);</code></pre><p>返回指定的索引处的值的长度。 对于 string ，那就是字符串的长度； 对于 table ，是取长度操作符 (‘#’) 的结果； 对于 userdata ，就是为其分配的内存块的尺寸； 对于其它值，为 0 。</p><h3 id="lua-pcall"><a href="#lua-pcall" class="headerlink" title="lua_pcall"></a>lua_pcall</h3><pre><code>lua_pcall (lua_State *L, int nargs, int nresults, int errfunc);</code></pre><p>以保护模式调用一个函数。<br>nargs 和 nresults 的含义与 lua_call 中的相同。 如果在调用过程中没有发生错误， lua_pcall 的行为和 lua_call 完全一致。 但是，如果有错误发生的话， lua_pcall 会捕获它， 然后把单一的值（错误信息）压入堆栈，然后返回错误码。 同 lua_call 一样， lua_pcall 总是把函数本身和它的参数从栈上移除。<br>如果 errfunc 是 0 ， 返回在栈顶的错误信息就和原始错误信息完全一致。 否则，errfunc 就被当成是错误处理函数在栈上的索引。 （在当前的实现里，这个索引不能是伪索引。） 在发生运行时错误时， 这个函数会被调用而参数就是错误信息。 错误处理函数的返回值将被 lua_pcall 作为出错信息返回在堆栈上。<br>典型的用法中，错误处理函数被用来在出错信息上加上更多的调试信息，比如栈跟踪信息 (stack traceback) 。 这些信息在 lua_pcall 返回后，因为栈已经展开 (unwound) ， 所以收集不到了。<br>lua_pcall 函数在调用成功时返回 0 ， 否则返回以下（定义在 lua.h 中的）错误代码中的一个：</p><p>LUA_ERRRUN: 运行时错误。<br>LUA_ERRMEM: 内存分配错误。 对于这种错，Lua 调用不了错误处理函数。<br>LUA_ERRERR: 在运行错误处理函数时发生的错误。</p><h3 id="lua-pop"><a href="#lua-pop" class="headerlink" title="lua_pop"></a>lua_pop</h3><pre><code>void lua_pop (lua_State *L, int n);</code></pre><p>从堆栈中弹出 n 个元素。</p><h3 id="lua-pushboolean"><a href="#lua-pushboolean" class="headerlink" title="lua_pushboolean"></a>lua_pushboolean</h3><pre><code>void lua_pushboolean (lua_State *L, int b);</code></pre><p>把 b 作为一个 boolean 值压入堆栈。</p><h3 id="lua-pushcclosure"><a href="#lua-pushcclosure" class="headerlink" title="lua_pushcclosure"></a>lua_pushcclosure</h3><pre><code>void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n);</code></pre><p>把一个新的 C closure 压入堆栈。<br>当创建了一个 C 函数后，你可以给它关联一些值，这样就是在创建一个 C closure ； 接下来无论函数何时被调用，这些值都可以被这个函数访问到。 为了将一些值关联到一个 C 函数上， 首先这些值需要先被压入堆栈（如果有多个值，第一个先压）。 接下来调用 lua_pushcclosure 来创建出 closure 并把这个 C 函数压到堆栈上。 参数 n 告之函数有多少个值需要关联到函数上。 lua_pushcclosure 也会把这些值从栈上弹出。</p><h3 id="lua-pushcfunction"><a href="#lua-pushcfunction" class="headerlink" title="lua_pushcfunction"></a>lua_pushcfunction</h3><pre><code>void lua_pushcfunction (lua_State *L, lua_CFunction f);</code></pre><p>将一个 C 函数压入堆栈。 这个函数接收一个 C 函数指针，并将一个类型为 function 的 Lua 值 压入堆栈。当这个栈顶的值被调用时，将触发对应的 C 函数。<br>注册到 Lua 中的任何函数都必须遵循正确的协议来接收参数和返回值 （参见 lua_CFunction）。</p><p>lua_pushcfunction 是作为一个宏定义出现的：</p><pre><code> #define lua_pushcfunction(L,f)  lua_pushcclosure(L,f,0)</code></pre><h3 id="lua-pushfstring"><a href="#lua-pushfstring" class="headerlink" title="lua_pushfstring"></a>lua_pushfstring</h3><pre><code>const char *lua_pushfstring (lua_State *L, const char *fmt, ...);</code></pre><p>把一个格式化过的字符串压入堆栈，然后返回这个字符串的指针。 它和 C 函数 sprintf 比较像，不过有一些重要的区别：<br>摸你需要为结果分配空间： 其结果是一个 Lua 字符串，由 Lua 来关心其内存分配 （同时通过垃圾收集来释放内存）。<br>这个转换非常的受限。 不支持 flag ，宽度，或是指定精度。 它只支持下面这些： ‘%%’ （插入一个 ‘%’）， ‘%s’ （插入一个带零终止符的字符串，没有长度限制）， ‘%f’ （插入一个 lua_Number）， ‘%p’ （插入一个指针或是一个十六进制数）， ‘%d’ （插入一个 int)， ‘%c’ （把一个 int 作为一个字符插入）。</p><h3 id="lua-pushinteger"><a href="#lua-pushinteger" class="headerlink" title="lua_pushinteger"></a>lua_pushinteger</h3><pre><code>void lua_pushinteger (lua_State *L, lua_Integer n);</code></pre><p>把 n 作为一个数字压栈。</p><h2 id="lua-pushlightuserdata"><a href="#lua-pushlightuserdata" class="headerlink" title="lua_pushlightuserdata"></a>lua_pushlightuserdata</h2><pre><code>void lua_pushlightuserdata (lua_State *L, void *p);</code></pre><p>把一个 light userdata 压栈。<br>userdata 在 Lua 中表示一个 C 值。 light userdata 表示一个指针。 它是一个像数字一样的值： 你不需要专门创建它，它也没有独立的 metatable ， 而且也不会被收集（因为从来不需要创建）。 只要表示的 C 地址相同，两个 light userdata 就相等。</p><h3 id="lua-pushlstring"><a href="#lua-pushlstring" class="headerlink" title="lua_pushlstring"></a>lua_pushlstring</h3><pre><code>void lua_pushlstring (lua_State *L, const char *s, size_t len);</code></pre><p>把指针 s 指向的长度为 len 的字符串压栈。 Lua 对这个字符串做一次内存拷贝（或是复用一个拷贝）， 因此 s 处的内存在函数返回后，可以释放掉或是重用于其它用途。 字符串内可以保存有零字符。</p><h3 id="lua-pushnil"><a href="#lua-pushnil" class="headerlink" title="lua_pushnil"></a>lua_pushnil</h3><pre><code>void lua_pushnil (lua_State *L);</code></pre><p>把一个 nil 压栈。</p><h3 id="lua-pushnumber"><a href="#lua-pushnumber" class="headerlink" title="lua_pushnumber"></a>lua_pushnumber</h3><pre><code>void lua_pushnumber (lua_State *L, lua_Number n);</code></pre><p>把一个数字 n 压栈。</p><h3 id="lua-pushstring"><a href="#lua-pushstring" class="headerlink" title="lua_pushstring"></a>lua_pushstring</h3><pre><code>void lua_pushstring (lua_State *L, const char *s);</code></pre><p>把指针s指向的以零结尾的字符串压栈。 Lua 这个字符串做一次内存拷贝（或是复用一个拷贝）， 因此 s 处的内存在函数返回后，可以释放掉或是重用于其它用途。 字符串中不能包含有零字符；第一个碰到的零字符会认为是字符串的结束。</p><h3 id="lua-pushthread"><a href="#lua-pushthread" class="headerlink" title="lua_pushthread"></a>lua_pushthread</h3><pre><code>int lua_pushthread (lua_State *L);</code></pre><p>把 L 中提供的线程压栈。 如果这个线程是当前状态机的主线程的话，返回 1 。</p><h3 id="lua-pushvalue"><a href="#lua-pushvalue" class="headerlink" title="lua_pushvalue"></a>lua_pushvalue</h3><pre><code>void lua_pushvalue(lua_State *L, int index);</code></pre><p>把堆栈上给定有效处索引处的元素作一个拷贝压栈。</p><h3 id="lua-pushvfstring"><a href="#lua-pushvfstring" class="headerlink" title="lua_pushvfstring"></a>lua_pushvfstring</h3><pre><code>const char *lua_pushvfstring (lua_State *L, const char *fmt, va_list argp);</code></pre><p>等价于 lua_pushfstring， 不过是用 va_list 接收参数，而不是用可变数量的实际参数。</p><h3 id="lua-rawequal"><a href="#lua-rawequal" class="headerlink" title="lua_rawequal"></a>lua_rawequal</h3><pre><code>int lua_rawequal (lua_State *L, int index1, int index2);</code></pre><p>如果两个索引 index1 和 index2 处的值简单地相等 （不调用元方法）则返回 1 。 否则返回 0 。 如果任何一个索引无效也返回 0 。</p><h3 id="lua-rawget"><a href="#lua-rawget" class="headerlink" title="lua_rawget"></a>lua_rawget</h3><pre><code>void lua_rawget (lua_State *L, int index);</code></pre><p>类似于 lua_gettable， 但是作一次直接访问（不触发元方法）。</p><h3 id="lua-rawgeti"><a href="#lua-rawgeti" class="headerlink" title="lua_rawgeti"></a>lua_rawgeti</h3><pre><code>void lua_rawgeti (lua_State *L, int index, int n);</code></pre><p>把 t[n] 的值压栈， 这里的 t 是指给定索引 index 处的一个值。这是一个直接访问；就是说，它不会触发元方法。</p><h3 id="lua-rawset"><a href="#lua-rawset" class="headerlink" title="lua_rawset"></a>lua_rawset</h3><pre><code>void lua_rawset (lua_State *L, int index);</code></pre><p>类似于 lua_settable ，但是是作一个直接赋值（不触发元方法）。</p><h3 id="lua-rawseti"><a href="#lua-rawseti" class="headerlink" title="lua_rawseti"></a>lua_rawseti</h3><pre><code>void lua_rawseti (lua_State *L, int index, int n);</code></pre><p>等价于 t[n] = v， 这里的 t 是指给定索引 index 处的一个值， 而 v 是栈顶的值。函数将把这个值弹出栈。 赋值操作是直接的；就是说，不会触发元方法。</p><h3 id="lua-Reader"><a href="#lua-Reader" class="headerlink" title="lua_Reader"></a>lua_Reader</h3><pre><code>typedef const char * (*lua_Reader) (lua_State *L, void *data, size_t *size);</code></pre><p>lua_load 用到的读取器函数， 每次它需要一块新的 chunk 的时候， lua_load 就调用读取器， 每次都会传入一个参数 data 。 读取器需要返回含有新的 chunk 的一块内存的指针， 并把 size 设为这块内存的大小。 内存块必须在下一次函数被调用之前一直存在。 读取器可以通过返回一个 NULL 来指示 chunk 结束。 读取器可能返回多个块，每个块可以有任意的大于零的尺寸。</p><h3 id="lua-register"><a href="#lua-register" class="headerlink" title="lua_register"></a>lua_register</h3><pre><code>void lua_register (lua_State *L, const char *name, lua_CFunction f);</code></pre><p>把 C 函数 f 设到全局变量 name 中。 它通过一个宏定义：</p><pre><code> #define lua_register(L,n,f) \        (lua_pushcfunction(L, f), lua_setglobal(L, n))</code></pre><h3 id="lua-remove"><a href="#lua-remove" class="headerlink" title="lua_remove"></a>lua_remove</h3><pre><code>void lua_remove (lua_State *L, int index);</code></pre><p>从给定有效索引处移除一个元素， 把这个索引之上的所有元素移下来填补上这个空隙。 不能用伪索引来调用这个函数， 因为伪索引并不指向真实的栈上的位置。</p><h3 id="lua-replace"><a href="#lua-replace" class="headerlink" title="lua_replace"></a>lua_replace</h3><pre><code>void lua_replace (lua_State *L, int index);</code></pre><p>把栈顶元素移动到给定位置（并且把这个栈顶元素弹出）， 不移动任何元素（因此在那个位置处的值被覆盖掉）。</p><h3 id="lua-resume"><a href="#lua-resume" class="headerlink" title="lua_resume"></a>lua_resume</h3><pre><code>int lua_resume (lua_State *L, int narg);</code></pre><p>在给定线程中启动或继续一个 coroutine 。<br>要启动一个 coroutine 的话，首先你要创建一个新线程 （参见 lua_newthread ）； 然后把主函数和若干参数压到新线程的堆栈上； 最后调用 lua_resume ， 把 narg 设为参数的个数。 这次调用会在 coroutine 挂起时或是结束运行后返回。 当函数返回时，堆栈中会有传给 lua_yield 的所有值， 或是主函数的所有返回值。 如果 coroutine 切换时，lua_resume 返回 LUA_YIELD ， 而当 coroutine 结束运行且没有任何错误时，返回 0 。 如果有错则返回错误代码（参见 lua_pcall）。 在发生错误的情况下， 堆栈没有展开， 因此你可以使用 debug API 来处理它。 出错信息放在栈顶。 要继续运行一个 coroutine 的话，你把需要传给 yield 作结果的返回值压入堆栈，然后调用 lua_resume 。</p><h3 id="lua-setallocf"><a href="#lua-setallocf" class="headerlink" title="lua_setallocf"></a>lua_setallocf</h3><pre><code>void lua_setallocf (lua_State *L, lua_Alloc f, void *ud);</code></pre><p>把指定状态机的分配器函数换成带上指针 ud 的 f 。</p><h3 id="lua-setfenv"><a href="#lua-setfenv" class="headerlink" title="lua_setfenv"></a>lua_setfenv</h3><pre><code>int lua_setfenv (lua_State *L, int index);</code></pre><p>从堆栈上弹出一个 table 并把它设为指定索引处值的新环境。 如果指定索引处的值即不是函数又不是线程或是 userdata ， lua_setfenv 会返回 0 ， 否则返回 1 。</p><h3 id="lua-setfield"><a href="#lua-setfield" class="headerlink" title="lua_setfield"></a>lua_setfield</h3><pre><code>void lua_setfield (lua_State *L, int index, const char *k);</code></pre><p>做一个等价于 t[k] = v 的操作， 这里 t 是给出的有效索引 index 处的值， 而 v 是栈顶的那个值。<br>这个函数将把这个值弹出堆栈。 跟在 Lua 中一样，这个函数可能触发一个 “newindex” 事件的元方法 （参见 §2.8）。</p><h3 id="lua-setglobal"><a href="#lua-setglobal" class="headerlink" title="lua_setglobal"></a>lua_setglobal</h3><pre><code>void lua_setglobal (lua_State *L, const char *name);</code></pre><p>从堆栈上弹出一个值，并将其设到全局变量 name 中。 它由一个宏定义出来：</p><pre><code>#define lua_setglobal(L,s)   lua_setfield(L, LUA_GLOBALSINDEX, s)</code></pre><h3 id="lua-setmetatable"><a href="#lua-setmetatable" class="headerlink" title="lua_setmetatable"></a>lua_setmetatable</h3><pre><code>int lua_setmetatable (lua_State *L, int index);</code></pre><p>把一个 table 弹出堆栈，并将其设为给定索引处的值的 metatable 。</p><h3 id="lua-settable"><a href="#lua-settable" class="headerlink" title="lua_settable"></a>lua_settable</h3><pre><code>void lua_settable(lua_State *L, int index);</code></pre><p>作一个等价于 t[k] = v的操作，这里t是一个给定有效索引 index 处的值， v 指栈顶的值， 而 k 是栈顶之下的那个值。这个函数会把键和值都从堆栈中弹出。 和在 Lua 中一样，这个函数可能触发 “newindex” 事件的元方法。</p><h3 id="lua-settop"><a href="#lua-settop" class="headerlink" title="lua_settop"></a>lua_settop</h3><pre><code>void lua_settop(lua_State *L, int index);</code></pre><p>参数允许传入任何可接受的索引以及0。它将把堆栈的栈顶设为这个索引。如果新的栈顶比原来的大，超出部分的新元素将被填为nil。如果index为0，把栈上所有元素移除。</p><p>lua_State<br>typedef struct lua_State lua_State;<br>一个不透明的结构，它保存了整个 Lua 解释器的状态。 Lua 库是完全可重入的： 它没有任何全局变量。 （译注：从 C 语法上来说，也不尽然。例如，在 table 的实现中 用了一个静态全局变量 dummynode_ ，但这在正确使用时并不影响可重入性。 只是万一你错误链接了 lua 库，不小心在同一进程空间中存在两份 lua 库实现的代码的话， 多份 dummynode_ 不同的地址会导致一些问题。） 所有的信息都保存在这个结构中。</p><p>这个状态机的指针必须作为第一个参数传递给每一个库函数。 lua_newstate 是一个例外， 这个函数会从头创建一个 Lua 状态机。</p><h3 id="lua-status"><a href="#lua-status" class="headerlink" title="lua_status"></a>lua_status</h3><pre><code>int lua_status (lua_State *L);</code></pre><p>返回线程 L 的状态。<br>正常的线程状态是 0 。 当线程执行完毕或发生一个错误时，状态值是错误码。 如果线程被挂起，状态为 LUA_YIELD 。</p><h3 id="lua-toboolean"><a href="#lua-toboolean" class="headerlink" title="lua_toboolean"></a>lua_toboolean</h3><pre><code>int lua_toboolean (lua_State *L, int index);</code></pre><p>把指定的索引处的的Lua值转换为一个C中的boolean值（ 0 或是 1 ）。 和 Lua 中做的所有测试一样， lua_toboolean 会把任何 不同于 false 和 nil 的值当作 1 返回； 否则就返回 0 。 如果用一个无效索引去调用也会返回 0 。 （如果你想只接收真正的 boolean 值，就需要使用 lua_isboolean 来测试值的类型。）</p><h3 id="lua-tocfunction"><a href="#lua-tocfunction" class="headerlink" title="lua_tocfunction"></a>lua_tocfunction</h3><pre><code>lua_CFunction lua_tocfunction (lua_State *L, int index);</code></pre><p>把给定索引处的 Lua 值转换为一个 C 函数。 这个值必须是一个 C 函数；如果不是就返回 NULL 。</p><h3 id="lua-tointeger"><a href="#lua-tointeger" class="headerlink" title="lua_tointeger"></a>lua_tointeger</h3><pre><code>lua_Integer lua_tointeger (lua_State *L, int idx);</code></pre><p>把给定索引处的 Lua 值转换为 lua_Integer 这样一个有符号整数类型。 这个 Lua 值必须是一个数字或是一个可以转换为数字的字符串 （参见 §2.2.1）； 否则，lua_tointeger 返回 0 。<br>如果数字不是一个整数， 截断小数部分的方式没有被明确定义。</p><h3 id="lua-tolstring"><a href="#lua-tolstring" class="headerlink" title="lua_tolstring"></a>lua_tolstring</h3><pre><code>const char *lua_tolstring (lua_State *L, int index, size_t *len);</code></pre><p>把给定索引处的 Lua 值转换为一个 C 字符串。 如果 len 不为 NULL ， 它还把字符串长度设到 *len 中。 这个 Lua 值必须是一个字符串或是一个数字； 否则返回返回 NULL 。 如果值是一个数字，lua_tolstring 还会把堆栈中的那个值的实际类型转换为一个字符串。 （当遍历一个表的时候，把 lua_tolstring 作用在键上，这个转换有可能导致 lua_next 弄错。）</p><p>lua_tolstring 返回 Lua 状态机中 字符串的以对齐指针。 这个字符串总能保证 （ C 要求的）最后一个字符为零 (‘\0’) ， 而且它允许在字符串内包含多个这样的零。 因为 Lua 中可能发生垃圾收集， 所以不保证 lua_tolstring 返回的指针， 在对应的值从堆栈中移除后依然有效。</p><h3 id="lua-tonumber"><a href="#lua-tonumber" class="headerlink" title="lua_tonumber"></a>lua_tonumber</h3><pre><code>lua_Number lua_tonumber (lua_State *L, int index);</code></pre><p>把给定索引处的 Lua 值转换为 lua_Number 这样一个 C 类型（参见 lua_Number ）。 这个 Lua 值必须是一个数字或是一个可转换为数字的字符串 （参见 §2.2.1 ）； 否则，lua_tonumber 返回 0 。</p><h3 id="lua-topointer"><a href="#lua-topointer" class="headerlink" title="lua_topointer"></a>lua_topointer</h3><pre><code>const void *lua_topointer (lua_State *L, int index);</code></pre><p>把给定索引处的值转换为一般的 C 指针 (void*) 。 这个值可以是一个 userdata ，table ，thread 或是一个 function ； 否则，lua_topointer 返回 NULL 。 不同的对象有不同的指针。 不存在把指针再转回原有类型的方法。<br>这个函数通常只为产生 debug 信息用。</p><h3 id="lua-tostring"><a href="#lua-tostring" class="headerlink" title="lua_tostring"></a>lua_tostring</h3><pre><code>const char *lua_tostring (lua_State *L, int index);</code></pre><p>等价于 lua_tolstring ，而参数 len 设为 NULL 。</p><h3 id="lua-tothread"><a href="#lua-tothread" class="headerlink" title="lua_tothread"></a>lua_tothread</h3><pre><code>lua_State *lua_tothread (lua_State *L, int index);</code></pre><p>把给定索引处的值转换为一个 Lua 线程（由 lua_State* 代表）。 这个值必须是一个线程；否则函数返回 NULL 。</p><h3 id="lua-touserdata"><a href="#lua-touserdata" class="headerlink" title="lua_touserdata"></a>lua_touserdata</h3><pre><code>void *lua_touserdata (lua_State *L, int index);</code></pre><p>如果给定索引处的值是一个完整的userdata ，函数返回内存块的地址。 如果值是一个 light userdata ，那么就返回它表示的指针。 否则，返回 NULL 。</p><h3 id="lua-type"><a href="#lua-type" class="headerlink" title="lua_type"></a>lua_type</h3><pre><code>int lua_type (lua_State *L, int index);</code></pre><p>返回给定索引处的值的类型， 当索引无效时则返回 LUA_TNONE （那是指一个指向堆栈上的空位置的索引）。 lua_type 返回的类型是一些个在 lua.h 中定义的常量： LUA_TNIL ， LUA_TNUMBER ， LUA_TBOOLEAN ， LUA_TSTRING ， LUA_TTABLE ， LUA_TFUNCTION ， LUA_TUSERDATA ， LUA_TTHREAD ， LUA_TLIGHTUSERDATA 。</p><h3 id="lua-typename"><a href="#lua-typename" class="headerlink" title="lua_typename"></a>lua_typename</h3><pre><code>const char *lua_typename  (lua_State *L, int tp);</code></pre><p>返回 tp 表示的类型名， 这个 tp 必须是 lua_type 可能返回的值中之一。</p><h3 id="lua-Writer"><a href="#lua-Writer" class="headerlink" title="lua_Writer"></a>lua_Writer</h3><p>typedef int (<em>lua_Writer) (lua_State </em>L, const void<em> p, size_t sz, void</em> ud);</p><p>由 lua_dump 用到的写入器函数。 每次 lua_dump 产生了一块新的 chunk ，它都会调用写入器。 传入要写入的缓存 (p) 和它的尺寸 (sz) ， 还有 lua_dump 的参数 data 。<br>写入器会返回一个错误码： 0 表示没有错误； 别的值均表示一个错误，并且会让 lua_dump 停止再次调用写入器。</p><h3 id="lua-xmove"><a href="#lua-xmove" class="headerlink" title="lua_xmove"></a>lua_xmove</h3><pre><code>void lua_xmove (lua_State *from, lua_State *to, int n);</code></pre><p>传递 同一个 全局状态机下不同线程中的值。<br>这个函数会从 from 的堆栈中弹出 n 个值， 然后把它们压入 to 的堆栈中。</p><h3 id="lua-yield"><a href="#lua-yield" class="headerlink" title="lua_yield"></a>lua_yield</h3><pre><code>int lua_yield  (lua_State *L, int nresults);</code></pre><p>切出一个 coroutine 。<br>这个函数只能在一个 C 函数的返回表达式中调用。如下：</p><pre><code> return lua_yield (L, nresults);</code></pre><p>当一个 C 函数这样调用 lua_yield ， 正在运行中的 coroutine 将从运行中挂起， 然后启动这个 coroutine 用的那次对 lua_resume 的调用就返回了。 参数 nresults 指的是堆栈中需要返回的结果个数，这些返回值将被传递给 lua_resume 。</p><p>3.8 - 调试接口<br>Lua 没有内建的调试设施。 取而代之的是提供了一些函数接口和钩子。 利用这些接口，可以做出一些不同类型的调试器， 性能分析器，或是其它一些需要从解释器中取到“内部信息”的工具。</p><h3 id="lua-Debug"><a href="#lua-Debug" class="headerlink" title="lua_Debug"></a>lua_Debug</h3><pre><code>typedef struct lua_Debug {     int event;    const char *name;           /* (n) */    const char *namewhat;       /* (n) */    const char *what;           /* (S) */    const char *source;         /* (S) */    int currentline;            /* (l) */    int nups;                   /* (u) upvalue 个数 */    int linedefined;            /* (S) */    int lastlinedefined;        /* (S) */    char short_src[LUA_IDSIZE]; /* (S) */    /* 私有部分 */    其它域} lua_Debug;</code></pre><p>一个用来携带活动中函数的各种信息的结构。 lua_getstack 仅填写这个结构中的私有部分， 这些部分以后会用到。 调用 lua_getinfo 则可以填上 lua_Debug 中有用信息的那些域。</p><p>lua_Debug 中的各个域有下列含义：</p><p>source: 如果函数是定义在一个字符串中，source 就是这个字符串。 如果函数定义在一个文件中， source 是一个以 ‘@’ 开头的文件名。<br>short_src: 一个“可打印版本”的 source，用于出错信息。<br>linedefined: 函数定义开始处的行号。<br>lastlinedefined: 函数定义结束处的行号。<br>what: 如果函数是一个 Lua 函数，则为一个字符串 “Lua” ； 如果是一个 C 函数，则为 “C”； 如果它是一个 chunk 的主体部分，则为 “main”； 如果是一个作了尾调用的函数，则为 “tail” 。 别的情况下，Lua 没有关于函数的别的信息。<br>currentline: 给定函数正在执行的那一行。 当提供不了行号信息的时候，currentline 被设为 -1 。<br>name: 给定函数的一个合理的名字。 因为 Lua 中的函数也是一个值， 所以它们没有固定的名字： 一些函数可能是全局复合变量的值， 另一些可能仅仅只是被保存在一个 table 中。 lua_getinfo 函数会检查函数是这样被调用的，以此来找到一个适合的名字。 如果它找不到名字，name 就被设置为 NULL 。<br>namewhat: 结实 name 域。 namewhat 的值可以是 “global”, “local”, “method”, “field”, “upvalue”, 或是 “” （空串）。 这取决于函数怎样被调用。 （Lua 用空串表示其它选项都不符合）<br>nups: 函数的 upvalue 的个数。</p><h3 id="lua-gethook"><a href="#lua-gethook" class="headerlink" title="lua_gethook"></a>lua_gethook</h3><pre><code>lua_Hook lua_gethook (lua_State *L);</code></pre><p>返回当前的钩子函数。</p><h3 id="lua-gethookcount"><a href="#lua-gethookcount" class="headerlink" title="lua_gethookcount"></a>lua_gethookcount</h3><pre><code>int lua_gethookcount (lua_State *L);</code></pre><p>返回当前钩子记数。</p><h3 id="lua-gethookmask"><a href="#lua-gethookmask" class="headerlink" title="lua_gethookmask"></a>lua_gethookmask</h3><pre><code>int lua_gethookmask (lua_State *L);</code></pre><p>返回当前的钩子掩码 (mask) 。</p><h3 id="lua-getinfo"><a href="#lua-getinfo" class="headerlink" title="lua_getinfo"></a>lua_getinfo</h3><pre><code>int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar);</code></pre><p>返回一个指定的函数或函数调用的信息。<br>当用于取得一次函数调用的信息时， 参数 ar 必须是一个有效的活动的记录。 这条记录可以是前一次调用 lua_getstack 得到的， 或是一个钩子 （参见 lua_Hook）得到的参数。<br>用于获取一个函数的信息时，可以把这个函数压入堆栈， 然后把 what 字符串以字符 ‘&gt;’ 起头。 （这个情况下，lua_getinfo 从栈顶上弹出函数。） 例如，想知道函数 f 在哪一行定义的， 你可以下下列代码：</p><pre><code>lua_Debug ar;lua_getfield(L, LUA_GLOBALSINDEX, &quot;f&quot;);  /* 取到全局变量 &#39;f&#39; */lua_getinfo(L, &quot;&gt;S&quot;, &amp;ar);printf(&quot;%d\n&quot;, ar.linedefined);</code></pre><p>what 字符串中的每个字符都筛选出结构 ar 结构中一些域用于填充，或是把一个值压入堆栈：</p><p>‘n’: 填充 name 及 namewhat 域；<br>‘S’: 填充 source， short_src， linedefined， lastlinedefined，以及 what 域；<br>‘l’: 填充 currentline 域；<br>‘u’: 填充 nups 域；<br>‘f’: 把正在运行中指定级别处函数压入堆栈； （译注：一般用于获取函数调用中的信息， 级别是由 ar 中的私有部分来提供。 如果用于获取静态函数，那么就直接把指定函数重新压回堆栈， 但这样做通常无甚意义。）<br>‘L’: 压一个 table 入栈，这个 table 中的整数索引用于描述函数中哪些行是有效行。 （有效行指有实际代码的行， 即你可以置入断点的行。 无效行包括空行和只有注释的行。）<br>这个函数出错会返回 0 （例如，what 中有一个无效选项）。</p><h3 id="lua-getlocal"><a href="#lua-getlocal" class="headerlink" title="lua_getlocal"></a>lua_getlocal</h3><pre><code>const char *lua_getlocal (lua_State *L, lua_Debug *ar, int n);</code></pre><p>从给定活动记录中获取一个局部变量的信息。 参数 ar 必须是一个有效的活动的记录。 这条记录可以是前一次调用 lua_getstack 得到的， 或是一个钩子 （参见 lua_Hook）得到的参数。 索引 n 用于选择要检阅哪个局部变量 （ 1 表示第一个参数或是激活的第一个局部变量，以此类推，直到最后一个局部变量）。 lua_getlocal 把变量的值压入堆栈并返回它的名字。<br>以 ‘(‘ （正小括号）开始的变量指内部变量 （循环控制变量，临时变量，C 函数局部变量）。<br>当索引大于局部变量的个数时，返回 NULL （什么也不压入）。</p><h3 id="lua-getstack"><a href="#lua-getstack" class="headerlink" title="lua_getstack"></a>lua_getstack</h3><pre><code>int lua_getstack (lua_State *L, int level, lua_Debug *ar);</code></pre><p>获取解释器的运行时栈的信息。<br>这个函数用正在运行中的给定级别处的函数的活动记录来填写 lua_Debug 结构的一部分。 0 级表示当前运行的函数， 而 n+1 级处的函数就是调用第 n 级函数的那一个。 如果没有错误，lua_getstack 返回 1 ； 当调用传入的级别大于堆栈深度的时候，返回 0 。</p><h3 id="lua-getupvalue"><a href="#lua-getupvalue" class="headerlink" title="lua_getupvalue"></a>lua_getupvalue</h3><pre><code>const char *lua_getupvalue (lua_State *L, int funcindex, int n);</code></pre><p>获取一个 closure 的 upvalue 信息。 （对于 Lua 函数，upvalue 是函数需要使用的外部局部变量， 因此这些变量被包含在 closure 中。） lua_getupvalue 获取第 n 个 upvalue ， 把这个 upvalue 的值压入堆栈，并且返回它的名字。 funcindex 指向堆栈上 closure 的位置。 （ 因为 upvalue 在整个函数中都有效，所以它们没有特别的次序。 因此，它们以字母次序来编号。）</p><p>当索引号比 upvalue 数量大的时候，返回 NULL （而且不会压入任何东西） 对于 C 函数，这个函数用空串 “” 表示所有 upvalue 的名字。</p><h3 id="lua-Hook"><a href="#lua-Hook" class="headerlink" title="lua_Hook"></a>lua_Hook</h3><pre><code>typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);</code></pre><p>用于调试的钩子函数类型。<br>无论何时钩子被调用，它的参数 ar 中的 event 域 都被设为触发钩子的事件。 Lua 把这些事件定义为以下常量： LUA_HOOKCALL， LUA_HOOKRET, LUA_HOOKTAILRET， LUA_HOOKLINE， and LUA_HOOKCOUNT。 除此之外，对于 line 事件，currentline 域也被设置。 要想获得 ar 中的其他域， 钩子必须调用 lua_getinfo。 对于返回事件，event 的正常值可能是 LUA_HOOKRET， 或者是 LUA_HOOKTAILRET 。 对于后一种情况，Lua 会对一个函数做的尾调用也模拟出一个返回事件出来； 对于这个模拟的返回事件，调用 lua_getinfo 没有什么作用。<br>当 Lua 运行在一个钩子内部时，它将屏蔽掉其它对钩子的调用。 也就是说，如果一个钩子函数内再调回 Lua 来执行一个函数或是一个 chunk ， 这个执行操作不会触发任何的钩子。</p><h3 id="lua-sethook"><a href="#lua-sethook" class="headerlink" title="lua_sethook"></a>lua_sethook</h3><pre><code>int lua_sethook (lua_State *L, lua_Hook f, int mask, int count);</code></pre><p>设置一个调试用钩子函数。</p><p>参数 f 是钩子函数。 mask 指定在哪些事件时会调用： 它由下列一组位常量构成 LUA_MASKCALL， LUA_MASKRET， LUA_MASKLINE， 以及 LUA_MASKCOUNT。 参数 count 只在 mask 中包含有 LUA_MASKCOUNT 才有意义。 对于每个事件，钩子被调用的情况解释如下：<br>call hook: 在解释器调用一个函数时被调用。 钩子将于 Lua 进入一个新函数后，函数获取参数前被调用。<br>return hook: 在解释器从一个函数中返回时调用。 钩子将于 Lua 离开函数之前的那一刻被调用。 你无权访问被函数返回出去的那些值。 （译注：原文 (You have no access to the values to be returned by the function) 如此。 但“无权访问”一词值得商榷。 某些情况下你可以访问到一些被命名为 (*temporary) 的局部变量， 那些索引被排在最后的 (<em>temporary) 变量指的就是返回值。 但是由于 Lua 对特殊情况做了一些优化，比如直接返回一个被命名的局部变量， 那么就找不到对应的 (</em>temporary) 变量了。本质上，返回值一定存在于此刻的局部变量中， 并且可以访问它，只是无法确定是哪些罢了。至于这个时候函数体内的其它局部变量， 是不保证有效的。进入 return hook 的那一刻起，实际已经退出函数内部的运行环节， 返回值占用的局部变量空间以后的部分，都有可能因 hook 本身复用它们而改变。）<br>line hook: 在解释器准备开始执行新的一行代码时， 或是跳转到这行代码中时（即使在同一行内跳转）被调用。 （这个事件仅仅在 Lua 执行一个 Lua 函数时发生。）<br>count hook: 在解释器每执行 count 条指令后被调用。 （这个事件仅仅在 Lua 执行一个 Lua 函数时发生。）<br>钩子可以通过设置 mask 为零屏蔽。</p><h3 id="lua-setlocal"><a href="#lua-setlocal" class="headerlink" title="lua_setlocal"></a>lua_setlocal</h3><pre><code>const char *lua_setlocal (lua_State *L, lua_Debug *ar, int n);</code></pre><p>设置给定活动记录中的局部变量的值。 参数 ar 与 n 和 lua_getlocal 中的一样 （参见 lua_getlocal）。 lua_setlocal 把栈顶的值赋给变量然后返回变量的名字。 它会将值从栈顶弹出。<br>当索引大于局部变量的个数时，返回 NULL （什么也不弹出）。</p><h3 id="lua-setupvalue"><a href="#lua-setupvalue" class="headerlink" title="lua_setupvalue"></a>lua_setupvalue</h3><pre><code>const char *lua_setupvalue (lua_State *L, int funcindex, int n);</code></pre><p>设置 closure 的 upvalue 的值。 它把栈顶的值弹出并赋于 upvalue 并返回 upvalue 的名字。 参数 funcindex 与 n 和 lua_getupvalue 中的一样 （参见 lua_getupvalue）。<br>当索引大于 upvalue 的个数时，返回 NULL （什么也不弹出）。</p><p>4 - The Auxiliary Library<br>The auxiliary library provides several convenient functions to interface C with Lua. While the basic API provides the primitive functions for all interactions between C and Lua, the auxiliary library provides higher-level functions for some common tasks.</p><p>All functions from the auxiliary library are defined in header file lauxlib.h and have a prefix luaL_.</p><p>All functions in the auxiliary library are built on top of the basic API, and so they provide nothing that cannot be done with this API.</p><p>Several functions in the auxiliary library are used to check C function arguments. Their names are always luaL_check<em> or luaL_opt\</em>. All of these functions raise an error if the check is not satisfied. Because the error message is formatted for arguments (e.g., “bad argument #1”), you should not use these functions for other stack values.</p><p>4.1 - Functions and Types<br>Here we list all functions and types from the auxiliary library in alphabetical order.</p><h3 id="luaL-addchar"><a href="#luaL-addchar" class="headerlink" title="luaL_addchar"></a>luaL_addchar</h3><pre><code>void luaL_addchar (luaL_Buffer *B, char c);</code></pre><p>Adds the character c to the buffer B (see luaL_Buffer).</p><h3 id="luaL-addlstring"><a href="#luaL-addlstring" class="headerlink" title="luaL_addlstring"></a>luaL_addlstring</h3><pre><code>void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l);</code></pre><p>Adds the string pointed to by s with length l to the buffer B (see luaL_Buffer). The string may contain embedded zeros.</p><h3 id="luaL-addsize"><a href="#luaL-addsize" class="headerlink" title="luaL_addsize"></a>luaL_addsize</h3><pre><code>void luaL_addsize (luaL_Buffer *B, size_t n);</code></pre><p>Adds to the buffer B (see luaL_Buffer) a string of length n previously copied to the buffer area (see luaL_prepbuffer).</p><h3 id="luaL-addstring"><a href="#luaL-addstring" class="headerlink" title="luaL_addstring"></a>luaL_addstring</h3><pre><code>void luaL_addstring (luaL_Buffer *B, const char *s);</code></pre><p>Adds the zero-terminated string pointed to by s to the buffer B (see luaL_Buffer). The string may not contain embedded zeros.</p><h3 id="luaL-addvalue"><a href="#luaL-addvalue" class="headerlink" title="luaL_addvalue"></a>luaL_addvalue</h3><pre><code>void luaL_addvalue (luaL_Buffer *B);</code></pre><p>Adds the value at the top of the stack to the buffer B (see luaL_Buffer). Pops the value.<br>This is the only function on string buffers that can (and must) be called with an extra element on the stack, which is the value to be added to the buffer.</p><h3 id="luaL-argcheck"><a href="#luaL-argcheck" class="headerlink" title="luaL_argcheck"></a>luaL_argcheck</h3><pre><code>void luaL_argcheck (lua_State *L, int cond, int narg, const char *extramsg);</code></pre><p>Checks whether cond is true. If not, raises an error with the following message, where func is retrieved from the call stack:</p><pre><code> bad argument #&lt;narg&gt; to &lt;func&gt; (&lt;extramsg&gt;)</code></pre><h3 id="luaL-argerror"><a href="#luaL-argerror" class="headerlink" title="luaL_argerror"></a>luaL_argerror</h3><pre><code>int luaL_argerror (lua_State *L, int narg, const char *extramsg);</code></pre><p>Raises an error with the following message, where func is retrieved from the call stack:</p><pre><code> bad argument #&lt;narg&gt; to &lt;func&gt; (&lt;extramsg&gt;)</code></pre><p>This function never returns, but it is an idiom to use it in C functions as return luaL_argerror(args).</p><h3 id="luaL-Buffer"><a href="#luaL-Buffer" class="headerlink" title="luaL_Buffer"></a>luaL_Buffer</h3><p>typedef struct luaL_Buffer luaL_Buffer;<br>Type for a string buffer.<br>A string buffer allows C code to build Lua strings piecemeal. Its pattern of use is as follows:<br>First you declare a variable b of type luaL_Buffer.<br>Then you initialize it with a call luaL_buffinit(L, &amp;b).<br>Then you add string pieces to the buffer calling any of the luaL_add* functions.<br>You finish by calling luaL_pushresult(&amp;b). This call leaves the final string on the top of the stack.<br>During its normal operation, a string buffer uses a variable number of stack slots. So, while using a buffer, you cannot assume that you know where the top of the stack is. You can use the stack between successive calls to buffer operations as long as that use is balanced; that is, when you call a buffer operation, the stack is at the same level it was immediately after the previous buffer operation. (The only exception to this rule is luaL_addvalue.) After calling luaL_pushresult the stack is back to its level when the buffer was initialized, plus the final string on its top.</p><h3 id="luaL-buffinit"><a href="#luaL-buffinit" class="headerlink" title="luaL_buffinit"></a>luaL_buffinit</h3><pre><code>void luaL_buffinit (lua_State *L, luaL_Buffer *B);</code></pre><p>Initializes a buffer B. This function does not allocate any space; the buffer must be declared as a variable (see luaL_Buffer).</p><h3 id="luaL-callmeta"><a href="#luaL-callmeta" class="headerlink" title="luaL_callmeta"></a>luaL_callmeta</h3><pre><code>int luaL_callmeta (lua_State *L, int obj, const char *e);</code></pre><p>Calls a metamethod.<br>If the object at index obj has a metatable and this metatable has a field e, this function calls this field and passes the object as its only argument. In this case this function returns 1 and pushes onto the stack the value returned by the call. If there is no metatable or no metamethod, this function returns 0 (without pushing any value on the stack).</p><h3 id="luaL-checkany"><a href="#luaL-checkany" class="headerlink" title="luaL_checkany"></a>luaL_checkany</h3><pre><code>void luaL_checkany (lua_State *L, int narg);</code></pre><p>Checks whether the function has an argument of any type (including nil) at position narg.</p><h3 id="luaL-checkint"><a href="#luaL-checkint" class="headerlink" title="luaL_checkint"></a>luaL_checkint</h3><pre><code>int luaL_checkint (lua_State *L, int narg);</code></pre><p>Checks whether the function argument narg is a number and returns this number cast to an int.</p><h3 id="luaL-checkinteger"><a href="#luaL-checkinteger" class="headerlink" title="luaL_checkinteger"></a>luaL_checkinteger</h3><pre><code>lua_Integer luaL_checkinteger (lua_State *L, int narg);</code></pre><p>Checks whether the function argument narg is a number and returns this number cast to a lua_Integer.</p><h3 id="luaL-checklong"><a href="#luaL-checklong" class="headerlink" title="luaL_checklong"></a>luaL_checklong</h3><pre><code>long luaL_checklong (lua_State *L, int narg);</code></pre><p>Checks whether the function argument narg is a number and returns this number cast to a long.</p><h3 id="luaL-checklstring"><a href="#luaL-checklstring" class="headerlink" title="luaL_checklstring"></a>luaL_checklstring</h3><pre><code>const char *luaL_checklstring (lua_State *L, int narg, size_t *l);</code></pre><p>Checks whether the function argument narg is a string and returns this string; if l is not NULL fills *l with the string’s length.</p><p>luaL_checknumber<br>lua_Number luaL_checknumber (lua_State *L, int narg);<br>Checks whether the function argument narg is a number and returns this number.</p><h3 id="luaL-checkoption"><a href="#luaL-checkoption" class="headerlink" title="luaL_checkoption"></a>luaL_checkoption</h3><pre><code>int luaL_checkoption (lua_State *L, int narg, const char *def, const char *const lst[]);</code></pre><p>Checks whether the function argument narg is a string and searches for this string in the array lst (which must be NULL-terminated). Returns the index in the array where the string was found. Raises an error if the argument is not a string or if the string cannot be found.<br>If def is not NULL, the function uses def as a default value when there is no argument narg or if this argument is nil.<br>This is a useful function for mapping strings to C enums. (The usual convention in Lua libraries is to use strings instead of numbers to select options.)</p><p>luaL_checkstack<br>void luaL_checkstack (lua_State <em>L, int sz, const char </em>msg);<br>Grows the stack size to top + sz elements, raising an error if the stack cannot grow to that size. msg is an additional text to go into the error message.</p><p>luaL_checkstring<br>const char <em>luaL_checkstring (lua_State </em>L, int narg);<br>Checks whether the function argument narg is a string and returns this string.</p><p>luaL_checktype<br>void luaL_checktype (lua_State *L, int narg, int t);<br>Checks whether the function argument narg has type t.</p><p>luaL_checkudata<br>void <em>luaL_checkudata (lua_State </em>L, int narg, const char *tname);<br>Checks whether the function argument narg is a userdata of the type tname (see luaL_newmetatable).</p><p>luaL_dofile<br>int luaL_dofile (lua_State <em>L, const char </em>filename);<br>Loads and runs the given file. It is defined as the following macro:</p><pre><code> (luaL_loadfile(L, filename) || lua_pcall(L, 0, LUA_MULTRET, 0))</code></pre><p>It returns 0 if there are no errors or 1 in case of errors.</p><p>luaL_dostring<br>int luaL_dostring (lua_State <em>L, const char </em>str);<br>Loads and runs the given string. It is defined as the following macro:</p><pre><code> (luaL_loadstring(L, str) || lua_pcall(L, 0, LUA_MULTRET, 0))</code></pre><p>It returns 0 if there are no errors or 1 in case of errors.</p><h3 id="luaL-error"><a href="#luaL-error" class="headerlink" title="luaL_error"></a>luaL_error</h3><pre><code>int luaL_error (lua_State *L, const char *fmt, ...);</code></pre><p>Raises an error. The error message format is given by fmt plus any extra arguments, following the same rules of lua_pushfstring. It also adds at the beginning of the message the file name and the line number where the error occurred, if this information is available.<br>This function never returns, but it is an idiom to use it in C functions as return luaL_error(args).</p><h3 id="luaL-getmetafield"><a href="#luaL-getmetafield" class="headerlink" title="luaL_getmetafield"></a>luaL_getmetafield</h3><pre><code>int luaL_getmetafield (lua_State *L, int obj, const char *e);</code></pre><p>Pushes onto the stack the field e from the metatable of the object at index obj. If the object does not have a metatable, or if the metatable does not have this field, returns 0 and pushes nothing.</p><h3 id="luaL-getmetatable"><a href="#luaL-getmetatable" class="headerlink" title="luaL_getmetatable"></a>luaL_getmetatable</h3><pre><code>void luaL_getmetatable (lua_State *L, const char *tname);</code></pre><p>Pushes onto the stack the metatable associated with name tname in the registry (see luaL_newmetatable).</p><h3 id="luaL-gsub"><a href="#luaL-gsub" class="headerlink" title="luaL_gsub"></a>luaL_gsub</h3><pre><code>const char *luaL_gsub (lua_State *L, const char *s, const char *p, const char *r);</code></pre><p>Creates a copy of string s by replacing any occurrence of the string p with the string r. Pushes the resulting string on the stack and returns it.</p><h3 id="luaL-loadbuffer"><a href="#luaL-loadbuffer" class="headerlink" title="luaL_loadbuffer"></a>luaL_loadbuffer</h3><pre><code>int luaL_loadbuffer (lua_State *L, const char *buff, size_t sz, const char *name);</code></pre><p>Loads a buffer as a Lua chunk. This function uses lua_load to load the chunk in the buffer pointed to by buff with size sz.<br>This function returns the same results as lua_load. name is the chunk name, used for debug information and error messages.</p><h3 id="luaL-loadfile"><a href="#luaL-loadfile" class="headerlink" title="luaL_loadfile"></a>luaL_loadfile</h3><pre><code>int luaL_loadfile (lua_State *L, const char *filename);</code></pre><p>Loads a file as a Lua chunk. This function uses lua_load to load the chunk in the file named filename. If filename is NULL, then it loads from the standard input. The first line in the file is ignored if it starts with a #.<br>This function returns the same results as lua_load, but it has an extra error code LUA_ERRFILE if it cannot open/read the file.<br>As lua_load, this function only loads the chunk; it does not run it.</p><h3 id="luaL-loadstring"><a href="#luaL-loadstring" class="headerlink" title="luaL_loadstring"></a>luaL_loadstring</h3><pre><code>int luaL_loadstring (lua_State *L, const char *s);</code></pre><p>Loads a string as a Lua chunk. This function uses lua_load to load the chunk in the zero-terminated string s.<br>This function returns the same results as lua_load.<br>Also as lua_load, this function only loads the chunk; it does not run it.</p><h3 id="luaL-newmetatable"><a href="#luaL-newmetatable" class="headerlink" title="luaL_newmetatable"></a>luaL_newmetatable</h3><pre><code>int luaL_newmetatable (lua_State *L, const char *tname);</code></pre><p>If the registry already has the key tname, returns 0. Otherwise, creates a new table to be used as a metatable for userdata, adds it to the registry with key tname, and returns 1.<br>In both cases pushes onto the stack the final value associated with tname in the registry.</p><h3 id="luaL-newstate"><a href="#luaL-newstate" class="headerlink" title="luaL_newstate"></a>luaL_newstate</h3><pre><code>lua_State *luaL_newstate (void);</code></pre><p>Creates a new Lua state. It calls lua_newstate with an allocator based on the standard C realloc function and then sets a panic function (see lua_atpanic) that prints an error message to the standard error output in case of fatal errors.<br>Returns the new state, or NULL if there is a memory allocation error.</p><h3 id="luaL-openlibs"><a href="#luaL-openlibs" class="headerlink" title="luaL_openlibs"></a>luaL_openlibs</h3><pre><code>void luaL_openlibs (lua_State *L);</code></pre><p>Opens all standard Lua libraries into the given state.</p><p>luaL_optint<br>int luaL_optint (lua_State *L, int narg, int d);<br>If the function argument narg is a number, returns this number cast to an int. If this argument is absent or is nil, returns d. Otherwise, raises an error.</p><h3 id="luaL-optinteger"><a href="#luaL-optinteger" class="headerlink" title="luaL_optinteger"></a>luaL_optinteger</h3><pre><code>lua_Integer luaL_optinteger (lua_State *L,                         int narg,                         lua_Integer d);</code></pre><p>If the function argument narg is a number, returns this number cast to a lua_Integer. If this argument is absent or is nil, returns d. Otherwise, raises an error.</p><h3 id="luaL-optlong"><a href="#luaL-optlong" class="headerlink" title="luaL_optlong"></a>luaL_optlong</h3><pre><code>long luaL_optlong (lua_State *L, int narg, long d);</code></pre><p>If the function argument narg is a number, returns this number cast to a long. If this argument is absent or is nil, returns d. Otherwise, raises an error.</p><h3 id="luaL-optlstring"><a href="#luaL-optlstring" class="headerlink" title="luaL_optlstring"></a>luaL_optlstring</h3><pre><code>const char *luaL_optlstring (lua_State *L, int narg, const char *d, size_t *l);</code></pre><p>If the function argument narg is a string, returns this string. If this argument is absent or is nil, returns d. Otherwise, raises an error.<br>If l is not NULL, fills the position *l with the results’s length.</p><h3 id="luaL-optnumber"><a href="#luaL-optnumber" class="headerlink" title="luaL_optnumber"></a>luaL_optnumber</h3><pre><code>lua_Number luaL_optnumber (lua_State *L, int narg, lua_Number d);</code></pre><p>If the function argument narg is a number, returns this number. If this argument is absent or is nil, returns d. Otherwise, raises an error.</p><h3 id="luaL-optstring"><a href="#luaL-optstring" class="headerlink" title="luaL_optstring"></a>luaL_optstring</h3><pre><code>const char *luaL_optstring (lua_State *L, int narg, const char *d);</code></pre><p>If the function argument narg is a string, returns this string. If this argument is absent or is nil, returns d. Otherwise, raises an error.</p><h3 id="luaL-prepbuffer"><a href="#luaL-prepbuffer" class="headerlink" title="luaL_prepbuffer"></a>luaL_prepbuffer</h3><pre><code>char *luaL_prepbuffer (luaL_Buffer *B);</code></pre><p>Returns an address to a space of size LUAL_BUFFERSIZE where you can copy a string to be added to buffer B (see luaL_Buffer). After copying the string into this space you must call luaL_addsize with the size of the string to actually add it to the buffer.</p><h3 id="luaL-pushresult"><a href="#luaL-pushresult" class="headerlink" title="luaL_pushresult"></a>luaL_pushresult</h3><pre><code>void luaL_pushresult (luaL_Buffer *B);</code></pre><p>Finishes the use of buffer B leaving the final string on the top of the stack.</p><h3 id="luaL-ref"><a href="#luaL-ref" class="headerlink" title="luaL_ref"></a>luaL_ref</h3><pre><code>int luaL_ref (lua_State *L, int t);</code></pre><p>Creates and returns a reference, in the table at index t, for the object at the top of the stack (and pops the object).<br>A reference is a unique integer key. As long as you do not manually add integer keys into table t, luaL_ref ensures the uniqueness of the key it returns. You can retrieve an object referred by reference r by calling lua_rawgeti(L, t, r). Function luaL_unref frees a reference and its associated object.</p><p>If the object at the top of the stack is nil, luaL_ref returns the constant LUA_REFNIL. The constant LUA_NOREF is guaranteed to be different from any reference returned by luaL_ref.</p><h3 id="luaL-Reg"><a href="#luaL-Reg" class="headerlink" title="luaL_Reg"></a>luaL_Reg</h3><pre><code>typedef struct luaL_Reg {  const char *name;  lua_CFunction func;} luaL_Reg;</code></pre><p>Type for arrays of functions to be registered by luaL_register. name is the function name and func is a pointer to the function. Any array of luaL_Reg must end with an sentinel entry in which both name and func are NULL.</p><h3 id="luaL-register"><a href="#luaL-register" class="headerlink" title="luaL_register"></a>luaL_register</h3><pre><code>void luaL_register (lua_State *L,                    const char *libname,                    const luaL_Reg *l);</code></pre><p>Opens a library.</p><p>When called with libname equal to NULL, it simply registers all functions in the list l (see luaL_Reg) into the table on the top of the stack.<br>When called with a non-null libname, luaL_register creates a new table t, sets it as the value of the global variable libname, sets it as the value of package.loaded[libname], and registers on it all functions in the list l. If there is a table in package.loaded[libname] or in variable libname, reuses this table instead of creating a new one.<br>In any case the function leaves the table on the top of the stack.</p><h3 id="luaL-typename"><a href="#luaL-typename" class="headerlink" title="luaL_typename"></a>luaL_typename</h3><p>const char <em>luaL_typename (lua_State </em>L, int idx);<br>Returns the name of the type of the value at index idx.</p><p>luaL_typerror<br>int luaL_typerror (lua_State <em>L, int narg, const char </em>tname);<br>Generates an error with a message like the following:</p><pre><code> location: bad argument narg to &#39;func&#39; (tname expected, got rt)</code></pre><p>where location is produced by luaL_where, func is the name of the current function, and rt is the type name of the actual argument.</p><h3 id="luaL-unref"><a href="#luaL-unref" class="headerlink" title="luaL_unref"></a>luaL_unref</h3><pre><code>void luaL_unref (lua_State *L, int t, int ref);</code></pre><p>Releases reference ref from the table at index t (see luaL_ref). The entry is removed from the table, so that the referred object can be collected. The reference ref is also freed to be used again.</p><p>If ref is LUA_NOREF or LUA_REFNIL, luaL_unref does nothing.</p><h3 id="luaL-where"><a href="#luaL-where" class="headerlink" title="luaL_where"></a>luaL_where</h3><pre><code>void luaL_where (lua_State *L, int lvl);</code></pre><p>Pushes onto the stack a string identifying the current position of the control at level lvl in the call stack. Typically this string has the following format:</p><pre><code> chunkname:currentline:</code></pre><p>Level 0 is the running function, level 1 is the function that called the running function, etc.<br>This function is used to build a prefix for error messages.</p><p>Standard Libraries<br>The standard Lua libraries provide useful functions that are implemented directly through the C API. Some of these functions provide essential services to the language (e.g., type and getmetatable); others provide access to “outside” services (e.g., I/O); and others could be implemented in Lua itself, but are quite useful or have critical performance requirements that deserve an implementation in C (e.g., sort).</p><p>All libraries are implemented through the official C API and are provided as separate C modules. Currently, Lua has the following standard libraries:</p><p>basic library;<br>package library;<br>string manipulation;<br>table manipulation;<br>mathematical functions (sin, log, etc.);<br>input and output;<br>operating system facilities;<br>debug facilities.<br>Except for the basic and package libraries, each library provides all its functions as fields of a global table or as methods of its objects.</p><p>To have access to these libraries, the C host program should call the luaL_openlibs function, which opens all standard libraries. Alternatively, it can open them individually by calling luaopen_base (for the basic library), luaopen_package (for the package library), luaopen_string (for the string library), luaopen_table (for the table library), luaopen_math (for the mathematical library), luaopen_io (for the I/O and the Operating System libraries), and luaopen_debug (for the debug library). These functions are declared in lualib.h and should not be called directly: you must call them like any other Lua C function, e.g., by using lua_call.</p><p>The basic library provides some core functions to Lua. If you do not include this library in your application, you should check carefully whether you need to provide implementations for some of its facilities.</p><h3 id="assert-v-message"><a href="#assert-v-message" class="headerlink" title="assert (v [, message])"></a>assert (v [, message])</h3><p>Issues an error when the value of its argument v is false (i.e., nil or false); otherwise, returns all its arguments. message is an error message; when absent, it defaults to “assertion failed!”<br>collectgarbage (opt [, arg])<br>This function is a generic interface to the garbage collector. It performs different functions according to its first argument, opt:</p><p>“stop”: stops the garbage collector.<br>“restart”: restarts the garbage collector.<br>“collect”: performs a full garbage-collection cycle.<br>“count”: returns the total memory in use by Lua (in Kbytes).<br>“step”: performs a garbage-collection step. The step “size” is controlled by arg (larger values mean more steps) in a non-specified way. If you want to control the step size you must experimentally tune the value of arg. Returns true if the step finished a collection cycle.<br>“setpause”: sets arg/100 as the new value for the pause of the collector (see §2.10).<br>“setstepmul”: sets arg/100 as the new value for the step multiplier of the collector (see §2.10).<br>dofile (filename)<br>Opens the named file and executes its contents as a Lua chunk. When called without arguments, dofile executes the contents of the standard input (stdin). Returns all values returned by the chunk. In case of errors, dofile propagates the error to its caller (that is, dofile does not run in protected mode).<br>error (message [, level])<br>Terminates the last protected function called and returns message as the error message. Function error never returns.<br>Usually, error adds some information about the error position at the beginning of the message. The level argument specifies how to get the error position. With level 1 (the default), the error position is where the error function was called. Level 2 points the error to where the function that called error was called; and so on. Passing a level 0 avoids the addition of error position information to the message.</p><p>_G<br>A global variable (not a function) that holds the global environment (that is, _G._G = _G). Lua itself does not use this variable; changing its value does not affect any environment, nor vice-versa. (Use setfenv to change environments.)<br>getfenv (f)<br>Returns the current environment in use by the function. f can be a Lua function or a number that specifies the function at that stack level: Level 1 is the function calling getfenv. If the given function is not a Lua function, or if f is 0, getfenv returns the global environment. The default for f is 1.<br>getmetatable (object)<br>If object does not have a metatable, returns nil. Otherwise, if the object’s metatable has a “__metatable” field, returns the associated value. Otherwise, returns the metatable of the given object.</p><p>ipairs (t)<br>Returns three values: an iterator function, the table t, and 0, so that the construction</p><pre><code> for i,v in ipairs(t) do body end</code></pre><p>will iterate over the pairs (1,t[1]), (2,t[2]), ···, up to the first integer key absent from the table.</p><p>load (func [, chunkname])<br>Loads a chunk using function func to get its pieces. Each call to func must return a string that concatenates with previous results. A return of nil (or no value) signals the end of the chunk.</p><p>If there are no errors, returns the compiled chunk as a function; otherwise, returns nil plus the error message. The environment of the returned function is the global environment.</p><p>chunkname is used as the chunk name for error messages and debug information.</p><p>loadfile ([filename])<br>Similar to load, but gets the chunk from file filename or from the standard input, if no file name is given.</p><p>loadstring (string [, chunkname])<br>Similar to load, but gets the chunk from the given string.</p><p>To load and run a given string, use the idiom</p><pre><code> assert(loadstring(s))()</code></pre><p>next (table [, index])<br>Allows a program to traverse all fields of a table. Its first argument is a table and its second argument is an index in this table. next returns the next index of the table and its associated value. When called with nil as its second argument, next returns an initial index and its associated value. When called with the last index, or with nil in an empty table, next returns nil. If the second argument is absent, then it is interpreted as nil. In particular, you can use next(t) to check whether a table is empty.</p><p>The order in which the indices are enumerated is not specified, even for numeric indices. (To traverse a table in numeric order, use a numerical for or the ipairs function.)</p><p>The behavior of next is undefined if, during the traversal, you assign any value to a non-existent field in the table. You may however modify existing fields. In particular, you may clear existing fields.</p><h3 id="pairs-t"><a href="#pairs-t" class="headerlink" title="pairs (t)"></a>pairs (t)</h3><p>Returns three values: the next function, the table t, and nil, so that the construction</p><pre><code> for k,v in pairs(t) do body end</code></pre><p>will iterate over all key–value pairs of table t.</p><p>See function next for the caveats of modifying the table during its traversal.</p><h3 id="pcall-f-arg1-···"><a href="#pcall-f-arg1-···" class="headerlink" title="pcall (f, arg1, ···)"></a>pcall (f, arg1, ···)</h3><p>Calls function f with the given arguments in protected mode. This means that any error inside f is not propagated; instead, pcall catches the error and returns a status code. Its first result is the status code (a boolean), which is true if the call succeeds without errors. In such case, pcall also returns all results from the call, after this first result. In case of any error, pcall returns false plus the error message.</p><h3 id="print-···"><a href="#print-···" class="headerlink" title="print (···)"></a>print (···)</h3><p>Receives any number of arguments, and prints their values to stdout, using the tostring function to convert them to strings. print is not intended for formatted output, but only as a quick way to show a value, typically for debugging. For formatted output, use string.format.<br>rawequal (v1, v2)<br>Checks whether v1 is equal to v2, without invoking any metamethod. Returns a boolean.<br>rawget (table, index)<br>Gets the real value of table[index], without invoking any metamethod. table must be a table; index may be any value.<br>rawset (table, index, value)<br>Sets the real value of table[index] to value, without invoking any metamethod. table must be a table, index any value different from nil, and value any Lua value.<br>This function returns table.</p><p>select (index, ···)<br>If index is a number, returns all arguments after argument number index. Otherwise, index must be the string “#”, and select returns the total number of extra arguments it received.</p><p>setfenv (f, table)<br>Sets the environment to be used by the given function. f can be a Lua function or a number that specifies the function at that stack level: Level 1 is the function calling setfenv. setfenv returns the given function.</p><p>As a special case, when f is 0 setfenv changes the environment of the running thread. In this case, setfenv returns no values.</p><p>setmetatable (table, metatable)<br>Sets the metatable for the given table. (You cannot change the metatable of other types from Lua, only from C.) If metatable is nil, removes the metatable of the given table. If the original metatable has a “__metatable” field, raises an error.</p><p>This function returns table.</p><p>tonumber (e [, base])<br>Tries to convert its argument to a number. If the argument is already a number or a string convertible to a number, then tonumber returns this number; otherwise, it returns nil.<br>An optional argument specifies the base to interpret the numeral. The base may be any integer between 2 and 36, inclusive. In bases above 10, the letter ‘A’ (in either upper or lower case) represents 10, ‘B’ represents 11, and so forth, with ‘Z’ representing 35. In base 10 (the default), the number may have a decimal part, as well as an optional exponent part (see §2.1). In other bases, only unsigned integers are accepted.</p><p>tostring (e)<br>Receives an argument of any type and converts it to a string in a reasonable format. For complete control of how numbers are converted, use string.format.<br>If the metatable of e has a “__tostring” field, then tostring calls the corresponding value with e as argument, and uses the result of the call as its result.</p><p>type (v)<br>Returns the type of its only argument, coded as a string. The possible results of this function are “nil” (a string, not the value nil), “number”, “string”, “boolean”, “table”, “function”, “thread”, and “userdata”.<br>unpack (list [, i [, j]])<br>Returns the elements from the given table. This function is equivalent to<br>     return list[i], list[i+1], ···, list[j]<br>except that the above code can be written only for a fixed number of elements. By default, i is 1 and j is the length of the list, as defined by the length operator (see §2.5.5).</p><p>_VERSION<br>A global variable (not a function) that holds a string containing the current interpreter version. The current contents of this variable is “Lua 5.1”.<br>xpcall (f, err)<br>This function is similar to pcall, except that you can set a new error handler.</p><p>xpcall calls function f in protected mode, using err as the error handler. Any error inside f is not propagated; instead, xpcall catches the error, calls the err function with the original error object, and returns a status code. Its first result is the status code (a boolean), which is true if the call succeeds without errors. In this case, xpcall also returns all results from the call, after this first result. In case of any error, xpcall returns false plus the result from err.</p><h3 id="Coroutine-Manipulation"><a href="#Coroutine-Manipulation" class="headerlink" title="Coroutine Manipulation"></a>Coroutine Manipulation</h3><p>The operations related to coroutines comprise a sub-library of the basic library and come inside the table coroutine. </p><p>coroutine.create (f)<br>Creates a new coroutine, with body f. f must be a Lua function. Returns this new coroutine, an object with type “thread”.</p><p>coroutine.resume (co [, val1, ···])<br>Starts or continues the execution of coroutine co. The first time you resume a coroutine, it starts running its body. The values val1, ··· are passed as the arguments to the body function. If the coroutine has yielded, resume restarts it; the values val1, ··· are passed as the results from the yield.</p><p>If the coroutine runs without any errors, resume returns true plus any values passed to yield (if the coroutine yields) or any values returned by the body function (if the coroutine terminates). If there is any error, resume returns false plus the error message.</p><p>coroutine.running ()<br>Returns the running coroutine, or nil when called by the main thread.</p><p>coroutine.status (co)<br>Returns the status of coroutine co, as a string: “running”, if the coroutine is running (that is, it called status); “suspended”, if the coroutine is suspended in a call to yield, or if it has not started running yet; “normal” if the coroutine is active but not running (that is, it has resumed another coroutine); and “dead” if the coroutine has finished its body function, or if it has stopped with an error.</p><p>coroutine.wrap (f)<br>Creates a new coroutine, with body f. f must be a Lua function. Returns a function that resumes the coroutine each time it is called. Any arguments passed to the function behave as the extra arguments to resume. Returns the same values returned by resume, except the first boolean. In case of error, propagates the error.</p><p>coroutine.yield (···)<br>Suspends the execution of the calling coroutine. The coroutine cannot be running a C function, a metamethod, or an iterator. Any arguments to yield are passed as extra results to resume.</p><h3 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h3><p>The package library provides basic facilities for loading and building modules in Lua. It exports two of its functions directly in the global environment: require and module. Everything else is exported in a table package.<br>module (name [, ···])<br>Creates a module. If there is a table in package.loaded[name], this table is the module. Otherwise, if there is a global table t with the given name, this table is the module. Otherwise creates a new table t and sets it as the value of the global name and the value of package.loaded[name]. This function also initializes t._NAME with the given name, t._M with the module (t itself), and t._PACKAGE with the package name (the full module name minus last component; see below). Finally, module sets t as the new environment of the current function and the new value of package.loaded[name], so that require returns t.</p><p>If name is a compound name (that is, one with components separated by dots), module creates (or reuses, if they already exist) tables for each component. For instance, if name is a.b.c, then module stores the module table in field c of field b of global a.</p><p>This function may receive optional options after the module name, where each option is a function to be applied over the module.</p><p>require (modname)<br>Loads the given module. The function starts by looking into the package.loaded table to determine whether modname is already loaded. If it is, then require returns the value stored at package.loaded[modname]. Otherwise, it tries to find a loader for the module.</p><p>To find a loader, first require queries package.preload[modname]. If it has a value, this value (which should be a function) is the loader. Otherwise require searches for a Lua loader using the path stored in package.path. If that also fails, it searches for a C loader using the path stored in package.cpath. If that also fails, it tries an all-in-one loader (see below).</p><p>When loading a C library, require first uses a dynamic link facility to link the application with the library. Then it tries to find a C function inside this library to be used as the loader. The name of this C function is the string “luaopen_” concatenated with a copy of the module name where each dot is replaced by an underscore. Moreover, if the module name has a hyphen, its prefix up to (and including) the first hyphen is removed. For instance, if the module name is a.v1-b.c, the function name will be luaopen_b_c.</p><p>If require finds neither a Lua library nor a C library for a module, it calls the all-in-one loader. This loader searches the C path for a library for the root name of the given module. For instance, when requiring a.b.c, it will search for a C library for a. If found, it looks into it for an open function for the submodule; in our example, that would be luaopen_a_b_c. With this facility, a package can pack several C submodules into one single library, with each submodule keeping its original open function.</p><p>Once a loader is found, require calls the loader with a single argument, modname. If the loader returns any value, require assigns the returned value to package.loaded[modname]. If the loader returns no value and has not assigned any value to package.loaded[modname], then require assigns true to this entry. In any case, require returns the final value of package.loaded[modname].</p><p>If there is any error loading or running the module, or if it cannot find any loader for the module, then require signals an error.</p><p>package.cpath<br>The path used by require to search for a C loader.</p><p>Lua initializes the C path package.cpath in the same way it initializes the Lua path package.path, using the environment variable LUA_CPATH (plus another default path defined in luaconf.h).</p><p>package.loaded<br>A table used by require to control which modules are already loaded. When you require a module modname and package.loaded[modname] is not false, require simply returns the value stored there.</p><p>package.loadlib (libname, funcname)<br>Dynamically links the host program with the C library libname. Inside this library, looks for a function funcname and returns this function as a C function. (So, funcname must follow the protocol (see lua_CFunction)).</p><p>This is a low-level function. It completely bypasses the package and module system. Unlike require, it does not perform any path searching and does not automatically adds extensions. libname must be the complete file name of the C library, including if necessary a path and extension. funcname must be the exact name exported by the C library (which may depend on the C compiler and linker used).</p><p>This function is not supported by ANSI C. As such, it is only available on some platforms (Windows, Linux, Mac OS X, Solaris, BSD, plus other Unix systems that support the dlfcn standard).</p><p>package.path<br>The path used by require to search for a Lua loader.</p><p>At start-up, Lua initializes this variable with the value of the environment variable LUA_PATH or with a default path defined in luaconf.h, if the environment variable is not defined. Any “;;” in the value of the environment variable is replaced by the default path.</p><p>A path is a sequence of templates separated by semicolons. For each template, require will change each interrogation mark in the template by filename, which is modname with each dot replaced by a “directory separator” (such as “/“ in Unix); then it will try to load the resulting file name. So, for instance, if the Lua path is</p><pre><code> &quot;./?.lua;./?.lc;/usr/local/?/init.lua&quot;</code></pre><p>the search for a Lua loader for module foo will try to load the files ./foo.lua, ./foo.lc, and /usr/local/foo/init.lua, in that order.</p><p>package.preload<br>A table to store loaders for specific modules (see require).</p><p>package.seeall (module)<br>Sets a metatable for module with its __index field referring to the global environment, so that this module inherits values from the global environment. To be used as an option to function module.</p><p>5.4 - String Manipulation<br>This library provides generic functions for string manipulation, such as finding and extracting substrings, and pattern matching. When indexing a string in Lua, the first character is at position 1 (not at 0, as in C). Indices are allowed to be negative and are interpreted as indexing backwards, from the end of the string. Thus, the last character is at position -1, and so on.</p><p>The string library provides all its functions inside the table string. It also sets a metatable for strings where the __index field points to the string table. Therefore, you can use the string functions in object-oriented style. For instance, string.byte(s, i) can be written as s:byte(i).</p><p>string.byte (s [, i [, j]])<br>Returns the internal numerical codes of the characters s[i], s[i+1], ···, s[j]. The default value for i is 1; the default value for j is i.<br>Note that numerical codes are not necessarily portable across platforms.</p><p>string.char (···)<br>Receives zero or more integers. Returns a string with length equal to the number of arguments, in which each character has the internal numerical code equal to its corresponding argument.<br>Note that numerical codes are not necessarily portable across platforms.</p><p>string.dump (function)<br>Returns a string containing a binary representation of the given function, so that a later loadstring on this string returns a copy of the function. function must be a Lua function without upvalues.</p><p>string.find (s, pattern [, init [, plain]])<br>Looks for the first match of pattern in the string s. If it finds a match, then find returns the indices of s where this occurrence starts and ends; otherwise, it returns nil. A third, optional numerical argument init specifies where to start the search; its default value is 1 and may be negative. A value of true as a fourth, optional argument plain turns off the pattern matching facilities, so the function does a plain “find substring” operation, with no characters in pattern being considered “magic”. Note that if plain is given, then init must be given as well.<br>If the pattern has captures, then in a successful match the captured values are also returned, after the two indices.</p><p>string.format (formatstring, ···)<br>Returns a formatted version of its variable number of arguments following the description given in its first argument (which must be a string). The format string follows the same rules as the printf family of standard C functions. The only differences are that the options/modifiers *, l, L, n, p, and h are not supported and that there is an extra option, q. The q option formats a string in a form suitable to be safely read back by the Lua interpreter: the string is written between double quotes, and all double quotes, newlines, embedded zeros, and backslashes in the string are correctly escaped when written. For instance, the call<br>     string.format(‘%q’, ‘a string with “quotes” and \n new line’)<br>will produce the string:</p><pre><code> &quot;a string with \&quot;quotes\&quot; and \  new line&quot;</code></pre><p>The options c, d, E, e, f, g, G, i, o, u, X, and x all expect a number as argument, whereas q and s expect a string.</p><p>This function does not accept string values containing embedded zeros.</p><p>string.gmatch (s, pattern)<br>Returns an iterator function that, each time it is called, returns the next captures from pattern over string s.<br>If pattern specifies no captures, then the whole match is produced in each call.</p><p>As an example, the following loop</p><pre><code> s = &quot;hello world from Lua&quot; for w in string.gmatch(s, &quot;%a+&quot;) do   print(w) end</code></pre><p>will iterate over all the words from string s, printing one per line. The next example collects all pairs key=value from the given string into a table:</p><pre><code> t = {} s = &quot;from=world, to=Lua&quot; for k, v in string.gmatch(s, &quot;(%w+)=(%w+)&quot;) do   t[k] = v end</code></pre><p>string.gsub (s, pattern, repl [, n])<br>Returns a copy of s in which all occurrences of the pattern have been replaced by a replacement string specified by repl, which may be a string, a table, or a function. gsub also returns, as its second value, the total number of substitutions made.<br>If repl is a string, then its value is used for replacement. The character % works as an escape character: any sequence in repl of the form %n, with n between 1 and 9, stands for the value of the n-th captured substring (see below). The sequence %0 stands for the whole match. The sequence %% stands for a single %.</p><p>If repl is a table, then the table is queried for every match, using the first capture as the key; if the pattern specifies no captures, then the whole match is used as the key.</p><p>If repl is a function, then this function is called every time a match occurs, with all captured substrings passed as arguments, in order; if the pattern specifies no captures, then the whole match is passed as a sole argument.</p><p>If the value returned by the table query or by the function call is a string or a number, then it is used as the replacement string; otherwise, if it is false or nil, then there is no replacement (that is, the original match is kept in the string).</p><p>The optional last parameter n limits the maximum number of substitutions to occur. For instance, when n is 1 only the first occurrence of pattern is replaced.</p><p>Here are some examples:</p><pre><code> x = string.gsub(&quot;hello world&quot;, &quot;(%w+)&quot;, &quot;%1 %1&quot;) --&gt; x=&quot;hello hello world world&quot; x = string.gsub(&quot;hello world&quot;, &quot;%w+&quot;, &quot;%0 %0&quot;, 1) --&gt; x=&quot;hello hello world&quot; x = string.gsub(&quot;hello world from Lua&quot;, &quot;(%w+)%s*(%w+)&quot;, &quot;%2 %1&quot;) --&gt; x=&quot;world hello Lua from&quot; x = string.gsub(&quot;home = $HOME, user = $USER&quot;, &quot;%$(%w+)&quot;, os.getenv) --&gt; x=&quot;home = /home/roberto, user = roberto&quot; x = string.gsub(&quot;4+5 = $return 4+5$&quot;, &quot;%$(.-)%$&quot;, function (s)       return loadstring(s)()     end) --&gt; x=&quot;4+5 = 9&quot; local t = {name=&quot;lua&quot;, version=&quot;5.1&quot;} x = string.gsub(&quot;$name%-$version.tar.gz&quot;, &quot;%$(%w+)&quot;, t) --&gt; x=&quot;lua-5.1.tar.gz&quot;</code></pre><p>string.len (s)<br>Receives a string and returns its length. The empty string “” has length 0. Embedded zeros are counted, so “a\000bc\000” has length 5.<br>string.lower (s)<br>Receives a string and returns a copy of this string with all uppercase letters changed to lowercase. All other characters are left unchanged. The definition of what an uppercase letter is depends on the current locale.<br>string.match (s, pattern [, init])<br>Looks for the first match of pattern in the string s. If it finds one, then match returns the captures from the pattern; otherwise it returns nil. If pattern specifies no captures, then the whole match is returned. A third, optional numerical argument init specifies where to start the search; its default value is 1 and may be negative.<br>string.rep (s, n)<br>Returns a string that is the concatenation of n copies of the string s.<br>string.reverse (s)<br>Returns a string that is the string s reversed.<br>string.sub (s, i [, j])<br>Returns the substring of s that starts at i and continues until j; i and j may be negative. If j is absent, then it is assumed to be equal to -1 (which is the same as the string length). In particular, the call string.sub(s,1,j) returns a prefix of s with length j, and string.sub(s, -i) returns a suffix of s with length i.<br>string.upper (s)<br>Receives a string and returns a copy of this string with all lowercase letters changed to uppercase. All other characters are left unchanged. The definition of what a lowercase letter is depends on the current locale.<br>5.4.1 - Patterns<br>Character Class:<br>A character class is used to represent a set of characters. The following combinations are allowed in describing a character class:</p><p>x: (where x is not one of the magic characters ^$()%.[]*+-?) represents the character x itself.<br>.: (a dot) represents all characters.<br>%a: represents all letters.<br>%c: represents all control characters.<br>%d: represents all digits.<br>%l: represents all lowercase letters.<br>%p: represents all punctuation characters.<br>%s: represents all space characters.<br>%u: represents all uppercase letters.<br>%w: represents all alphanumeric characters.<br>%x: represents all hexadecimal digits.<br>%z: represents the character with representation 0.<br>%x: (where x is any non-alphanumeric character) represents the character x. This is the standard way to escape the magic characters. Any punctuation character (even the non magic) can be preceded by a ‘%’ when used to represent itself in a pattern.<br>[set]: represents the class which is the union of all characters in set. A range of characters may be specified by separating the end characters of the range with a ‘-‘. All classes %x described above may also be used as components in set. All other characters in set represent themselves. For example, [%w_] (or [_%w]) represents all alphanumeric characters plus the underscore, [0-7] represents the octal digits, and [0-7%l%-] represents the octal digits plus the lowercase letters plus the ‘-‘ character.<br>The interaction between ranges and classes is not defined. Therefore, patterns like [%a-z] or [a-%%] have no meaning.</p><blockquote id="fn_set"><sup>set</sup>. represents the complement of set, where set is interpreted as above.<a href="#reffn_set" title="Jump back to footnote [set] in the text."> &#8617;</a></blockquote><p>For all classes represented by single letters (%a, %c, etc.), the corresponding uppercase letter represents the complement of the class. For instance, %S represents all non-space characters.</p><p>The definitions of letter, space, and other character groups depend on the current locale. In particular, the class [a-z] may not be equivalent to %l.</p><p>Pattern Item:<br>A pattern item may be</p><p>a single character class, which matches any single character in the class;<br>a single character class followed by ‘<em>‘, which matches 0 or more repetitions of characters in the class. These repetition items will always match the longest possible sequence;<br>a single character class followed by ‘+’, which matches 1 or more repetitions of characters in the class. These repetition items will always match the longest possible sequence;<br>a single character class followed by ‘-‘, which also matches 0 or more repetitions of characters in the class. Unlike ‘</em>‘, these repetition items will always match the shortest possible sequence;<br>a single character class followed by ‘?’, which matches 0 or 1 occurrence of a character in the class;<br>%n, for n between 1 and 9; such item matches a substring equal to the n-th captured string (see below);<br>%bxy, where x and y are two distinct characters; such item matches strings that start with x, end with y, and where the x and y are balanced. This means that, if one reads the string from left to right, counting +1 for an x and -1 for a y, the ending y is the first y where the count reaches 0. For instance, the item %b() matches expressions with balanced parentheses.<br>Pattern:<br>A pattern is a sequence of pattern items. A ‘^’ at the beginning of a pattern anchors the match at the beginning of the subject string. A ‘$’ at the end of a pattern anchors the match at the end of the subject string. At other positions, ‘^’ and ‘$’ have no special meaning and represent themselves.</p><p>Captures:<br>A pattern may contain sub-patterns enclosed in parentheses; they describe captures. When a match succeeds, the substrings of the subject string that match captures are stored (captured) for future use. Captures are numbered according to their left parentheses. For instance, in the pattern “(a<em>(.)%w(%s</em>))”, the part of the string matching “a<em>(.)%w(%s</em>)” is stored as the first capture (and therefore has number 1); the character matching “.” is captured with number 2, and the part matching “%s*” has number 3.</p><p>As a special case, the empty capture () captures the current string position (a number). For instance, if we apply the pattern “()aa()” on the string “flaaap”, there will be two captures: 3 and 5.</p><p>A pattern cannot contain embedded zeros. Use %z instead.</p><p>5.5 - Table Manipulation<br>This library provides generic functions for table manipulation. It provides all its functions inside the table table.</p><p>Most functions in the table library assume that the table represents an array or a list. For these functions, when we talk about the “length” of a table we mean the result of the length operator.</p><p>table.concat (table [, sep [, i [, j]]])<br>Given an array where all elements are strings or numbers, returns table[i]..sep..table[i+1] ··· sep..table[j]. The default value for sep is the empty string, the default for i is 1, and the default for j is the length of the table. If i is greater than j, returns the empty string.<br>table.insert (table, [pos,] value)<br>Inserts element value at position pos in table, shifting up other elements to open space, if necessary. The default value for pos is n+1, where n is the length of the table (see §2.5.5), so that a call table.insert(t,x) inserts x at the end of table t.</p><p>table.maxn (table)<br>Returns the largest positive numerical index of the given table, or zero if the table has no positive numerical indices. (To do its job this function does a linear traversal of the whole table.)</p><p>table.remove (table [, pos])<br>Removes from table the element at position pos, shifting down other elements to close the space, if necessary. Returns the value of the removed element. The default value for pos is n, where n is the length of the table, so that a call table.remove(t) removes the last element of table t.</p><p>table.sort (table [, comp])<br>Sorts table elements in a given order, in-place, from table[1] to table[n], where n is the length of the table. If comp is given, then it must be a function that receives two table elements, and returns true when the first is less than the second (so that not comp(a[i+1],a[i]) will be true after the sort). If comp is not given, then the standard Lua operator &lt; is used instead.<br>The sort algorithm is not stable; that is, elements considered equal by the given order may have their relative positions changed by the sort.</p><p>5.6 - Mathematical Functions<br>This library is an interface to the standard C math library. It provides all its functions inside the table math.</p><p>math.abs (x)<br>Returns the absolute value of x.</p><p>math.acos (x)<br>Returns the arc cosine of x (in radians).</p><p>math.asin (x)<br>Returns the arc sine of x (in radians).</p><p>math.atan (x)<br>Returns the arc tangent of x (in radians).</p><p>math.atan2 (x, y)<br>Returns the arc tangent of x/y (in radians), but uses the signs of both parameters to find the quadrant of the result. (It also handles correctly the case of y being zero.)</p><p>math.ceil (x)<br>Returns the smallest integer larger than or equal to x.</p><p>math.cos (x)<br>Returns the cosine of x (assumed to be in radians).</p><p>math.cosh (x)<br>Returns the hyperbolic cosine of x.</p><p>math.deg (x)<br>Returns the angle x (given in radians) in degrees.</p><p>math.exp (x)<br>Returns the the value ex.</p><p>math.floor (x)<br>Returns the largest integer smaller than or equal to x.</p><p>math.fmod (x, y)<br>Returns the remainder of the division of x by y.</p><p>math.frexp (x)<br>Returns m and e such that x = m2e, e is an integer and the absolute value of m is in the range [0.5, 1) (or zero when x is zero).</p><p>math.huge<br>The value HUGE_VAL, a value larger than or equal to any other numerical value.</p><p>math.ldexp (m, e)<br>Returns m2e (e should be an integer).</p><p>math.log (x)<br>Returns the natural logarithm of x.</p><p>math.log10 (x)<br>Returns the base-10 logarithm of x.</p><p>math.max (x, ···)<br>Returns the maximum value among its arguments.</p><p>math.min (x, ···)<br>Returns the minimum value among its arguments.</p><p>math.modf (x)<br>Returns two numbers, the integral part of x and the fractional part of x.</p><p>math.pi<br>The value of pi.</p><p>math.pow (x, y)<br>Returns xy. (You can also use the expression x^y to compute this value.)</p><p>math.rad (x)<br>Returns the angle x (given in degrees) in radians.</p><p>math.random ([m [, n]])<br>This function is an interface to the simple pseudo-random generator function rand provided by ANSI C. (No guarantees can be given for its statistical properties.)</p><p>When called without arguments, returns a pseudo-random real number in the range [0,1). When called with a number m, math.random returns a pseudo-random integer in the range [1, m]. When called with two numbers m and n, math.random returns a pseudo-random integer in the range [m, n].</p><p>math.randomseed (x)<br>Sets x as the “seed” for the pseudo-random generator: equal seeds produce equal sequences of numbers.</p><p>math.sin (x)<br>Returns the sine of x (assumed to be in radians).</p><p>math.sinh (x)<br>Returns the hyperbolic sine of x.</p><p>math.sqrt (x)<br>Returns the square root of x. (You can also use the expression x^0.5 to compute this value.)</p><p>math.tan (x)<br>Returns the tangent of x (assumed to be in radians).</p><p>math.tanh (x)<br>Returns the hyperbolic tangent of x.</p><p>5.7 - Input and Output Facilities<br>The I/O library provides two different styles for file manipulation. The first one uses implicit file descriptors; that is, there are operations to set a default input file and a default output file, and all input/output operations are over these default files. The second style uses explicit file descriptors.</p><p>When using implicit file descriptors, all operations are supplied by table io. When using explicit file descriptors, the operation io.open returns a file descriptor and then all operations are supplied as methods of the file descriptor.</p><p>The table io also provides three predefined file descriptors with their usual meanings from C: io.stdin, io.stdout, and io.stderr.</p><p>Unless otherwise stated, all I/O functions return nil on failure (plus an error message as a second result) and some value different from nil on success.</p><p>io.close ([file])<br>Equivalent to file:close(). Without a file, closes the default output file.</p><p>io.flush ()<br>Equivalent to file:flush over the default output file.</p><p>io.input ([file])<br>When called with a file name, it opens the named file (in text mode), and sets its handle as the default input file. When called with a file handle, it simply sets this file handle as the default input file. When called without parameters, it returns the current default input file.</p><p>In case of errors this function raises the error, instead of returning an error code.</p><p>io.lines ([filename])<br>Opens the given file name in read mode and returns an iterator function that, each time it is called, returns a new line from the file. Therefore, the construction</p><pre><code> for line in io.lines(filename) do body end</code></pre><p>will iterate over all lines of the file. When the iterator function detects the end of file, it returns nil (to finish the loop) and automatically closes the file.</p><p>The call io.lines() (with no file name) is equivalent to io.input():lines(); that is, it iterates over the lines of the default input file. In this case it does not close the file when the loop ends.</p><p>io.open (filename [, mode])<br>This function opens a file, in the mode specified in the string mode. It returns a new file handle, or, in case of errors, nil plus an error message.</p><p>The mode string can be any of the following:</p><p>“r”: read mode (the default);<br>“w”: write mode;<br>“a”: append mode;<br>“r+”: update mode, all previous data is preserved;<br>“w+”: update mode, all previous data is erased;<br>“a+”: append update mode, previous data is preserved, writing is only allowed at the end of file.<br>The mode string may also have a ‘b’ at the end, which is needed in some systems to open the file in binary mode. This string is exactly what is used in the standard C function fopen.</p><p>io.output ([file])<br>Similar to io.input, but operates over the default output file.</p><p>io.popen (prog [, mode])<br>Starts program prog in a separated process and returns a file handle that you can use to read data from this program (if mode is “r”, the default) or to write data to this program (if mode is “w”).</p><p>This function is system dependent and is not available on all platforms.</p><p>io.read (···)<br>Equivalent to io.input():read.</p><p>io.tmpfile ()<br>Returns a handle for a temporary file. This file is opened in update mode and it is automatically removed when the program ends.</p><p>io.type (obj)<br>Checks whether obj is a valid file handle. Returns the string “file” if obj is an open file handle, “closed file” if obj is a closed file handle, or nil if obj is not a file handle.</p><p>io.write (···)<br>Equivalent to io.output():write.</p><p>file:close ()<br>Closes file. Note that files are automatically closed when their handles are garbage collected, but that takes an unpredictable amount of time to happen.</p><p>file:flush ()<br>Saves any written data to file.</p><p>file:lines ()<br>Returns an iterator function that, each time it is called, returns a new line from the file. Therefore, the construction</p><pre><code> for line in file:lines() do body end</code></pre><p>will iterate over all lines of the file. (Unlike io.lines, this function does not close the file when the loop ends.)</p><p>file:read (···)<br>Reads the file file, according to the given formats, which specify what to read. For each format, the function returns a string (or a number) with the characters read, or nil if it cannot read data with the specified format. When called without formats, it uses a default format that reads the entire next line (see below).</p><p>The available formats are</p><p>“<em>n”: reads a number; this is the only format that returns a number instead of a string.<br>“</em>a”: reads the whole file, starting at the current position. On end of file, it returns the empty string.<br>“*l”: reads the next line (skipping the end of line), returning nil on end of file. This is the default format.<br>number: reads a string with up to this number of characters, returning nil on end of file. If number is zero, it reads nothing and returns an empty string, or nil on end of file.<br>file:seek ([whence] [, offset])<br>Sets and gets the file position, measured from the beginning of the file, to the position given by offset plus a base specified by the string whence, as follows:</p><p>“set”: base is position 0 (beginning of the file);<br>“cur”: base is current position;<br>“end”: base is end of file;<br>In case of success, function seek returns the final file position, measured in bytes from the beginning of the file. If this function fails, it returns nil, plus a string describing the error.</p><p>The default value for whence is “cur”, and for offset is 0. Therefore, the call file:seek() returns the current file position, without changing it; the call file:seek(“set”) sets the position to the beginning of the file (and returns 0); and the call file:seek(“end”) sets the position to the end of the file, and returns its size.</p><p>file:setvbuf (mode [, size])<br>Sets the buffering mode for an output file. There are three available modes:</p><p>“no”: no buffering; the result of any output operation appears immediately.<br>“full”: full buffering; output operation is performed only when the buffer is full (or when you explicitly flush the file (see io.flush)).<br>“line”: line buffering; output is buffered until a newline is output or there is any input from some special files (such as a terminal device).<br>For the last two cases, sizes specifies the size of the buffer, in bytes. The default is an appropriate size.</p><p>file:write (···)<br>Writes the value of each of its arguments to the file. The arguments must be strings or numbers. To write other values, use tostring or string.format before write.</p><p>5.8 - Operating System Facilities<br>This library is implemented through table os.</p><p>os.clock ()<br>Returns an approximation of the amount in seconds of CPU time used by the program.</p><p>os.date ([format [, time]])<br>Returns a string or a table containing date and time, formatted according to the given string format.</p><p>If the time argument is present, this is the time to be formatted (see the os.time function for a description of this value). Otherwise, date formats the current time.</p><p>If format starts with ‘!’, then the date is formatted in Coordinated Universal Time. After this optional character, if format is the string “*t”, then date returns a table with the following fields: year (four digits), month (1—12), day (1—31), hour (0—23), min (0—59), sec (0—61), wday (weekday, Sunday is 1), yday (day of the year), and isdst (daylight saving flag, a boolean).</p><p>If format is not “*t”, then date returns the date as a string, formatted according to the same rules as the C function strftime.</p><p>When called without arguments, date returns a reasonable date and time representation that depends on the host system and on the current locale (that is, os.date() is equivalent to os.date(“%c”)).</p><p>os.difftime (t2, t1)<br>Returns the number of seconds from time t1 to time t2. In POSIX, Windows, and some other systems, this value is exactly t2-t1.</p><p>os.execute ([command])<br>This function is equivalent to the C function system. It passes command to be executed by an operating system shell. It returns a status code, which is system-dependent. If command is absent, then it returns nonzero if a shell is available and zero otherwise.</p><p>os.exit ([code])<br>Calls the C function exit, with an optional code, to terminate the host program. The default value for code is the success code.</p><p>os.getenv (varname)<br>Returns the value of the process environment variable varname, or nil if the variable is not defined.</p><p>os.remove (filename)<br>Deletes the file or directory with the given name. Directories must be empty to be removed. If this function fails, it returns nil, plus a string describing the error.</p><p>os.rename (oldname, newname)<br>Renames file or directory named oldname to newname. If this function fails, it returns nil, plus a string describing the error.</p><p>os.setlocale (locale [, category])<br>Sets the current locale of the program. locale is a string specifying a locale; category is an optional string describing which category to change: “all”, “collate”, “ctype”, “monetary”, “numeric”, or “time”; the default category is “all”. The function returns the name of the new locale, or nil if the request cannot be honored.</p><p>When called with nil as the first argument, this function only returns the name of the current locale for the given category.</p><p>os.time ([table])<br>Returns the current time when called without arguments, or a time representing the date and time specified by the given table. This table must have fields year, month, and day, and may have fields hour, min, sec, and isdst (for a description of these fields, see the os.date function).</p><p>The returned value is a number, whose meaning depends on your system. In POSIX, Windows, and some other systems, this number counts the number of seconds since some given start time (the “epoch”). In other systems, the meaning is not specified, and the number returned by time can be used only as an argument to date and difftime.</p><p>os.tmpname ()<br>Returns a string with a file name that can be used for a temporary file. The file must be explicitly opened before its use and explicitly removed when no longer needed.</p><p>5.9 - The Debug Library<br>This library provides the functionality of the debug interface to Lua programs. You should exert care when using this library. The functions provided here should be used exclusively for debugging and similar tasks, such as profiling. Please resist the temptation to use them as a usual programming tool: they can be very slow. Moreover, several of its functions violate some assumptions about Lua code (e.g., that variables local to a function cannot be accessed from outside or that userdata metatables cannot be changed by Lua code) and therefore can compromise otherwise secure code.</p><p>All functions in this library are provided inside the debug table. All functions that operate over a thread have an optional first argument which is the thread to operate over. The default is always the current thread.</p><p>debug.debug ()<br>Enters an interactive mode with the user, running each string that the user enters. Using simple commands and other debug facilities, the user can inspect global and local variables, change their values, evaluate expressions, and so on. A line containing only the word cont finishes this function, so that the caller continues its execution.</p><p>Note that commands for debug.debug are not lexically nested within any function, and so have no direct access to local variables.</p><p>debug.getfenv (o)<br>Returns the environment of object o.<br>debug.gethook ([thread])<br>Returns the current hook settings of the thread, as three values: the current hook function, the current hook mask, and the current hook count (as set by the debug.sethook function).</p><p>debug.getinfo ([thread,] function [, what])<br>Returns a table with information about a function. You can give the function directly, or you can give a number as the value of function, which means the function running at level function of the call stack of the given thread: level 0 is the current function (getinfo itself); level 1 is the function that called getinfo; and so on. If function is a number larger than the number of active functions, then getinfo returns nil.</p><p>The returned table may contain all the fields returned by lua_getinfo, with the string what describing which fields to fill in. The default for what is to get all information available, except the table of valid lines. If present, the option ‘f’ adds a field named func with the function itself. If present, the option ‘L’ adds a field named activelines with the table of valid lines.</p><p>For instance, the expression debug.getinfo(1,”n”).name returns a name of the current function, if a reasonable name can be found, and the expression debug.getinfo(print) returns a table with all available information about the print function.</p><p>debug.getlocal ([thread,] level, local)<br>This function returns the name and the value of the local variable with index local of the function at level level of the stack. (The first parameter or local variable has index 1, and so on, until the last active local variable.) The function returns nil if there is no local variable with the given index, and raises an error when called with a level out of range. (You can call debug.getinfo to check whether the level is valid.)</p><p>Variable names starting with ‘(‘ (open parentheses) represent internal variables (loop control variables, temporaries, and C function locals).</p><p>debug.getmetatable (object)<br>Returns the metatable of the given object or nil if it does not have a metatable.</p><p>debug.getregistry ()<br>Returns the registry table (see §3.5).</p><p>debug.getupvalue (func, up)<br>This function returns the name and the value of the upvalue with index up of the function func. The function returns nil if there is no upvalue with the given index.</p><p>debug.setfenv (object, table)<br>Sets the environment of the given object to the given table. Returns object.</p><p>debug.sethook ([thread,] hook, mask [, count])<br>Sets the given function as a hook. The string mask and the number count describe when the hook will be called. The string mask may have the following characters, with the given meaning:</p><p>“c”: The hook is called every time Lua calls a function;<br>“r”: The hook is called every time Lua returns from a function;<br>“l”: The hook is called every time Lua enters a new line of code.<br>With a count different from zero, the hook is called after every count instructions.</p><p>When called without arguments, debug.sethook turns off the hook.</p><p>When the hook is called, its first parameter is a string describing the event that has triggered its call: “call”, “return” (or “tail return”), “line”, and “count”. For line events, the hook also gets the new line number as its second parameter. Inside a hook, you can call getinfo with level 2 to get more information about the running function (level 0 is the getinfo function, and level 1 is the hook function), unless the event is “tail return”. In this case, Lua is only simulating the return, and a call to getinfo will return invalid data.</p><p>debug.setlocal ([thread,] level, local, value)<br>This function assigns the value value to the local variable with index local of the function at level level of the stack. The function returns nil if there is no local variable with the given index, and raises an error when called with a level out of range. (You can call getinfo to check whether the level is valid.) Otherwise, it returns the name of the local variable.</p><p>debug.setmetatable (object, table)<br>Sets the metatable for the given object to the given table (which can be nil).</p><p>debug.setupvalue (func, up, value)<br>This function assigns the value value to the upvalue with index up of the function func. The function returns nil if there is no upvalue with the given index. Otherwise, it returns the name of the upvalue.</p><p>debug.traceback ([thread,] [message] [, level])<br>Returns a string with a traceback of the call stack. An optional message string is appended at the beginning of the traceback. An optional level number tells at which level to start the traceback (default is 1, the function calling traceback).</p><p>6 - Lua Stand-alone<br>Although Lua has been designed as an extension language, to be embedded in a host C program, it is also frequently used as a stand-alone language. An interpreter for Lua as a stand-alone language, called simply lua, is provided with the standard distribution. The stand-alone interpreter includes all standard libraries, including the debug library. Its usage is:</p><pre><code> lua [options] [script [args]]</code></pre><p>The options are:</p><p>-e stat: executes string stat;<br>-l mod: “requires” mod;<br>-i: enters interactive mode after running script;<br>-v: prints version information;<br>—: stops handling options;<br>-: executes stdin as a file and stops handling options.<br>After handling its options, lua runs the given script, passing to it the given args as string arguments. When called without arguments, lua behaves as lua -v -i when the standard input (stdin) is a terminal, and as lua - otherwise.</p><p>Before running any argument, the interpreter checks for an environment variable LUA_INIT. If its format is @filename, then lua executes the file. Otherwise, lua executes the string itself.</p><p>All options are handled in order, except -i. For instance, an invocation like</p><pre><code> $ lua -e&#39;a=1&#39; -e &#39;print(a)&#39; script.lua</code></pre><p>will first set a to 1, then print the value of a (which is ‘1’), and finally run the file script.lua with no arguments. (Here $ is the shell prompt. Your prompt may be different.)</p><p>Before starting to run the script, lua collects all arguments in the command line in a global table called arg. The script name is stored at index 0, the first argument after the script name goes to index 1, and so on. Any arguments before the script name (that is, the interpreter name plus the options) go to negative indices. For instance, in the call</p><pre><code> $ lua -la b.lua t1 t2</code></pre><p>the interpreter first runs the file a.lua, then creates a table</p><pre><code> arg = { [-2] = &quot;lua&quot;, [-1] = &quot;-la&quot;,         [0] = &quot;b.lua&quot;,         [1] = &quot;t1&quot;, [2] = &quot;t2&quot; }</code></pre><p>and finally runs the file b.lua. The script is called with arg[1], arg[2], ··· as arguments; it can also access these arguments with the vararg expression ‘…’.</p><p>In interactive mode, if you write an incomplete statement, the interpreter waits for its completion by issuing a different prompt.</p><p>If the global variable _PROMPT contains a string, then its value is used as the prompt. Similarly, if the global variable _PROMPT2 contains a string, its value is used as the secondary prompt (issued during incomplete statements). Therefore, both prompts can be changed directly on the command line. For instance,</p><pre><code> $ lua -e&quot;_PROMPT=&#39;myprompt&gt; &#39;&quot; -i</code></pre><p>(the outer pair of quotes is for the shell, the inner pair is for Lua), or in any Lua programs by assigning to _PROMPT. Note the use of -i to enter interactive mode; otherwise, the program would just end silently right after the assignment to _PROMPT.</p><p>To allow the use of Lua as a script interpreter in Unix systems, the stand-alone interpreter skips the first line of a chunk if it starts with #. Therefore, Lua scripts can be made into executable programs by using chmod +x and the #! form, as in</p><pre><code> #!/usr/local/bin/lua</code></pre><p>(Of course, the location of the Lua interpreter may be different in your machine. If lua is in your PATH, then</p><pre><code> #!/usr/bin/env lua</code></pre><p>is a more portable solution.)</p><p>7 - Incompatibilities with the Previous Version<br>Here we list the incompatibilities that you may found when moving a program from Lua 5.0 to Lua 5.1. You can avoid most of the incompatibilities compiling Lua with appropriate options (see file luaconf.h). However, all these compatibility options will be removed in the next version of Lua.</p><p>7.1 - Changes in the Language<br>The vararg system changed from the pseudo-argument arg with a table with the extra arguments to the vararg expression. (See compile-time option LUA_COMPAT_VARARG in luaconf.h.)<br>There was a subtle change in the scope of the implicit variables of the for statement and for the repeat statement.<br>The long string/long comment syntax ([[string]]) does not allow nesting. You can use the new syntax ([=[string]=]) in these cases. (See compile-time option LUA_COMPAT_LSTR in luaconf.h.)<br>7.2 - Changes in the Libraries<br>Function string.gfind was renamed string.gmatch. (See compile-time option LUA_COMPAT_GFIND in luaconf.h.)<br>When string.gsub is called with a function as its third argument, whenever this function returns nil or false the replacement string is the whole match, instead of the empty string.<br>Function table.setn was deprecated. Function table.getn corresponds to the new length operator (#); use the operator instead of the function. (See compile-time option LUA_COMPAT_GETN in luaconf.h.)<br>Function loadlib was renamed package.loadlib. (See compile-time option LUA_COMPAT_LOADLIB in luaconf.h.)<br>Function math.mod was renamed math.fmod. (See compile-time option LUA_COMPAT_MOD in luaconf.h.)<br>Functions table.foreach and table.foreachi are deprecated. You can use a for loop with pairs or ipairs instead.<br>There were substantial changes in function require due to the new module system. However, the new behavior is mostly compatible with the old, but require gets the path from package.path instead of from LUA_PATH.<br>Function collectgarbage has different arguments. Function gcinfo is deprecated; use collectgarbage(“count”) instead.<br>7.3 - Changes in the API<br>The luaopen_* functions (to open libraries) cannot be called directly, like a regular C function. They must be called through Lua, like a Lua function.<br>Function lua_open was replaced by lua_newstate to allow the user to set a memory-allocation function. You can use luaL_newstate from the standard library to create a state with a standard allocation function (based on realloc).<br>Functions luaL_getn and luaL_setn (from the auxiliary library) are deprecated. Use lua_objlen instead of luaL_getn and nothing instead of luaL_setn.<br>Function luaL_openlib was replaced by luaL_register.<br>Function luaL_checkudata now throws an error when the given value is not a userdata of the expected type. (In Lua 5.0 it returned NULL.)<br>8 - The Complete Syntax of Lua<br>Here is the complete syntax of Lua in extended BNF. (It does not describe operator precedences.)</p><pre><code>chunk ::= {stat [`;´]} [laststat [`;´]]block ::= chunkstat ::=  varlist1 `=´ explist1 |      functioncall |      do block end |      while exp do block end |      repeat block until exp |      if exp then block {elseif exp then block} [else block] end |      for Name `=´ exp `,´ exp [`,´ exp] do block end |      for namelist in explist1 do block end |      function funcname funcbody |      local function Name funcbody |      local namelist [`=´ explist1] laststat ::= return [explist1] | breakfuncname ::= Name {`.´ Name} [`:´ Name]varlist1 ::= var {`,´ var}var ::=  Name | prefixexp `[´ exp `]´ | prefixexp `.´ Name namelist ::= Name {`,´ Name}explist1 ::= {exp `,´} expexp ::=  nil | false | true | Number | String | `...´ | function |      prefixexp | tableconstructor | exp binop exp | unop exp prefixexp ::= var | functioncall | `(´ exp `)´functioncall ::=  prefixexp args | prefixexp `:´ Name args args ::=  `(´ [explist1] `)´ | tableconstructor | String function ::= function funcbodyfuncbody ::= `(´ [parlist1] `)´ block endparlist1 ::= namelist [`,´ `...´] | `...´tableconstructor ::= `{´ [fieldlist] `}´fieldlist ::= field {fieldsep field} [fieldsep]field ::= `[´ exp `]´ `=´ exp | Name `=´ exp | expfieldsep ::= `,´ | `;´binop ::= `+´ | `-´ | `*´ | `/´ | `^´ | `%´ | `..´ |      `&lt;´ | `&lt;=´ | `&gt;´ | `&gt;=´ | `==´ | `~=´ |      and | orunop ::= `-´ | not | `#´</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#</title>
      <link href="/2018/04/02/CSharp/"/>
      <url>/2018/04/02/CSharp/</url>
      
        <content type="html"><![CDATA[<h1 id="internal、sealed"><a href="#internal、sealed" class="headerlink" title="internal、sealed"></a>internal、sealed</h1><p><strong>internal</strong>：本应用程序使用，其它进程无法使用</p><p><strong>sealed（密封）</strong>：由它修饰的类、方法、属性将不能被继承或是重写。sealed 必须和override一起使用<br>sealed修饰符表示密封用于类时，表示该类<font color="red"><strong>不能被继承</strong></font>，不能和abstract同时使用，<font color="red"><strong>不能被实例化</strong></font>。密封类不能用作基类、也不能继承，而抽象类总是希望被继承的。</p><h1 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h1><p>fixed 语句可防止垃圾回收器重新定位可移动的变量。 fixed 语句仅允许存在于不安全的上下文中。 Fixed 还可用于创建固定大小的缓冲区。</p><p>fixed 语句将为托管变量设置一个指针，并在该语句的执行过程中“单边锁定”该变量。 如果没有 fixed，指向可移动的托管变量的指针将几乎没有什么用处，因为垃圾回收可能会不可预见地重新定位变量。 C# 编译器只允许将指针分配给 fixed 语句中的托管变量。</p><ol><li>不支持持多继承，C#类始终继承一个基类（如果未在声明中指定一个基类，则继承自System.Object)</li><li>如果对类没有定义显示构造函数，则编译器将提供默认的构造函数，以初始化这些类的成员字段。但是，如果显式添加了构造函数，就可以有效控制整个构造过程。派生类通过使用:base()语法可以显式调用基类的构造函数</li><li>override 具有override关键字修饰符的方法是对基类中同名方法的新实现，基类中的同名方法必须声明为virtual或abstract类型。给基类中的方法添加virtual关键字表示可以重写它的实现。new static 和 virtual关键字不能与override访问修饰符同时使用。</li><li>virtual 支持多态，不能与static override同时使用</li><li>abstract 一个抽象类包含抽象方法和非抽象方法，抽象方法只存放函数原型，不涉及主体代码，override关键字可在派生类中抽象方法，经override声明重写的方法称为重写基类方法，其签名必须与override方法的签名相同。只是不能被实例化，除此以外具有类的其他特性，重要的是抽象类可以包含抽象方法，这是普通类所不能的。抽象方法只能声明于抽象方法中，且不包含任何实现，派生类必须覆盖它们。</li><li>interface 包含未实现的方法声明，派生类必须实现未实现的方法，抽象类是抽象方法，接口则是所有成员，接口包含属性，索引器事件</li></ol><h1 id="索引器"><a href="#索引器" class="headerlink" title="索引器"></a>索引器</h1><p>索引器允许类或者结构的实例按照于数组相同的方法进行索引取值，索引器与属性类似，不同的是索引器的访问时带参的</p><ul><li>索引器的索引值(Index)类型不受限制</li><li>索引器允许重载</li><li>索引器不是一个变量</li></ul><h2 id="索引器和属性的不同点"><a href="#索引器和属性的不同点" class="headerlink" title="索引器和属性的不同点"></a>索引器和属性的不同点</h2><ul><li>属性以名称来标识，索引器以函数形式标识</li><li>索引器可以被重载，属性不可以</li><li>索引器不能声明为static，属性可以</li></ul><h1 id="interface、abstract"><a href="#interface、abstract" class="headerlink" title="interface、abstract"></a>interface、abstract</h1><div class="table-container"><table><thead><tr><th></th><th>abstract</th><th>interface</th></tr></thead><tbody><tr><td>能否实例化</td><td>不能</td><td>不能</td></tr></tbody></table></div><h2 id="抽象类和接口的区别："><a href="#抽象类和接口的区别：" class="headerlink" title="抽象类和接口的区别："></a>抽象类和接口的区别：</h2><ul><li>类是对对象的抽象，可以把抽象类理解为把类当作对象，抽象成的类叫抽象类，而接口只是一个行为的规范或规定，</li><li>接口基本上不具备类型的任何具体特点，它仅仅承诺了能够调用的方法</li><li>抽象类比较细，而接口比较简单</li></ul><h2 id="抽象类和接口的使用"><a href="#抽象类和接口的使用" class="headerlink" title="抽象类和接口的使用"></a>抽象类和接口的使用</h2><ul><li>如果预计要创建组件的多个版本，则创建抽象类。抽象类提供简单的方法来控制组件版本。</li><li>抽象类主要用于关系密切的对象；而接口适合为不相关的类提供通用功能</li></ul><h1 id="Marshal"><a href="#Marshal" class="headerlink" title="Marshal"></a>Marshal</h1><p>提供了一个方法集合，这些方法用于分配非托管内存、复制非托管内存块、将托管类型转换为非托管类型，此外还提供了在于非托管代码交互时使用的其他方法</p><p>命名空间：System.Runtime.InteropServices<br>程序集：mscorlib</p><p>AllocHGlobal(int32); // 通过使用指定的字节数，从进程的非托管内存中分配内存<br>SizeOf(Type)返回非托管类型的大小(以字节为单位)</p><h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">PGExt</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">PG_GetComponent</span>(<span class="params"><span class="keyword">this</span> List&lt;Component&gt; components</span>) <span class="keyword">where</span> T : Component</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = components.Count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> p = components[i] <span class="keyword">as</span> T;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">object</span>)p != <span class="literal">null</span>) <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么这里会有一个this关键字，做什么用？其实这就是扩展方法！这个扩展方法在静态类中声明，定义一个静态方法，其中第一个参数定义可它的扩展类型，PG_GetComponent方法扩展了List类，因为它的第一个参数定义了List类型，为了区分扩展方法和一般的静态方法，扩展方法还需要给第一个参数使用this关键字。</p><p>现在就可以使用带List类型的PG_GetComponent方法了：</p><pre><code>var mf = cacheComponents.PG_GetComponent&lt;MeshFilter&gt;();</code></pre><h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><ol><li>GC不能自动释放非托管资源。</li><li>GC并不是实时性的。</li></ol><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>volatile关键字指示一个字段可以由多个同时执行的线程修改。声明volatile的字段不受编译器优化的限制。这样可以确保该字段在任何时间呈现的都是最新的值。</p><p>volatile修饰符通常用于由多个线程访问但不使用lock语句对访问进行序列化的字段。</p><p>volatile关键字可应用于以下类型的字段：</p><ul><li>引用类型</li><li>指针类型（在不安全的上下文中）。请注意，虽然指针本身可以是可变的，但是它指向的对象不能是可变的。换句话说，无法声明“指向可变对象的指针”。</li><li>类型，如sbyte、byte、short、ushort、int、uint、。</li><li>引用类型的泛型类型参数。</li><li>IntPtr和UIntPtr</li></ul><h1 id="事件和委托"><a href="#事件和委托" class="headerlink" title="事件和委托"></a>事件和委托</h1><p>联系：事件是一种特殊的委托，均类似于C中的函数指针，讲一个方法通过参数传到别的方法中，通过别的方法来调用。</p><p>区别：体现在封装性。事件是订阅发布的机制。<br>委托可以在类的外部直接赋值，直接调用。即可以直接使用：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">A</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">Say</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="keyword">public</span> Say m_Say;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">B</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Say</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"Say What?"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            A a = <span class="keyword">new</span> A();</span><br><span class="line">            B b = <span class="keyword">new</span> B();</span><br><span class="line">            a.m_Say = b.Say;</span><br><span class="line">            a.m_Say();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>事件不可以在类的外部直接赋值，且不可以直接赋值调用。<br>步骤：</p><ol><li>创建一个委托</li><li>将创建的委托与特定事件关联</li><li>编写C#事件处理程序</li><li>利用编写的C#事件处理程序生成一个委托实例</li><li>把这个委托实例添加到事件对象的事件列表中去，这个过程又叫订阅事件</li></ol><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">A</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 定义一个委托</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">Say</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="comment">// 定义一个事件</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">event</span> Say m_eventSay;</span><br><span class="line">        <span class="comment">// 引发事件的方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Begin</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            m_eventSay(); <span class="comment">// 被引发的事件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">B</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Say</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"Say What?"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            A a = <span class="keyword">new</span> A(); <span class="comment">// 实例化事件发布者</span></span><br><span class="line">            B b = <span class="keyword">new</span> B(); <span class="comment">// 实例化事件订阅者</span></span><br><span class="line">            <span class="comment">// 订阅事件</span></span><br><span class="line">            a.m_eventSay += <span class="keyword">new</span> A.Say(b.Say);</span><br><span class="line">            <span class="comment">// 引发事件</span></span><br><span class="line">            a.Begin();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>const:指定该成员的值只读，不允许修改。<br>event:声明一个事件。<br>extern:指示方法在外部实现</p><h1 id="堆栈和堆-Heap-amp-Stack"><a href="#堆栈和堆-Heap-amp-Stack" class="headerlink" title="堆栈和堆 Heap &amp; Stack"></a>堆栈和堆 Heap &amp; Stack</h1><p>首先堆栈和堆（托管堆）都在进程的虚拟内存中。（在32位处理器上每个进程的虚拟内存为4GB）<br>栈是内存中完全用于存储局部变量或成员（值类型数据）的高效区域，但其大小有限制。<br>托管堆占内存比栈大得多，当访问速度较慢。托管堆只用于分配内存。<br>在创建值类型数据时，在栈上分配内存；<br>当创建引用型类型数据时，在托管堆上分配并返回对象的引用。注意这个对象的引用，像其他局部变量一样也是保存在栈中，该引用指向的值则位于托管堆中。<br>如果创建一个包含值类型的引用类型，比如数组，其元素的值也是存放在托管堆中的某个地方，由使用该实体的变量引用；而值类型存储在使用它们的地方，有几处在使用，就有几个副本存在。<br>对于引用类型，如果在声明变量的时候没有使用new运算符，运行时不会给它分配托管堆的内存空间，而是在栈上给它分配一个包含null的值的引用。对于值类型，运行时会给它分配栈上的空间，并且调用构造函数来初始化对象的状态。</p><h2 id="堆栈stack"><a href="#堆栈stack" class="headerlink" title="堆栈stack"></a>堆栈stack</h2><p>堆栈中存储值类型<br>堆栈实际上是向下填充，即由高内存地址指向低内存地址填充。<br>堆栈的工作方式是先分配内存的变量后后释放（先进后出原则）。<br>堆栈的变量是从下向上释放，这样就保证了堆栈中先进后出的规则不与变量的生命周期起冲突<br>堆栈的性能非常高，但是对于所有的变量来说不太灵活，而且变量的生命周期必须嵌套。<br>通常我们希望使用一种方法分配内存来存储数据，并且方法退出后很长一段时间内数据仍然可以使用。此时就要用到堆（托管堆）</p><h2 id="堆（托管堆）heap"><a href="#堆（托管堆）heap" class="headerlink" title="堆（托管堆）heap"></a>堆（托管堆）heap</h2><p><font color="blue">堆（托管堆）存储引用类型。</font><br>引用类型共有四种：类类型、接口类型、数组类型和委托类型。<br>所有引用类型变量所引用的对象，其内存都是托管堆中分配的。<br>严格地说，我们常说的“对象变量”其实是类类型的引用变量。但在实际中人们经常将引用类型的变量简称为“对象变量”，用它来指代所有四种类型的引用变量。<br>此堆非彼堆，.NET中的堆由垃圾收集器自动管理。<br>与堆栈不同，堆是从下往上分配，所以自动的空间都在已用空间的上面。<br>比如创建一个对象：</p><pre><code>Customer cus;cus = new Customer();</code></pre><p>声明一个Customer的引用cus，在堆栈上给这个引用分配存储空间。这仅仅只是一个引用，不是实际的Customer对象！<br>cus占4个字节的空间，包含了存储Customer的引用地址。<br>接着分配堆上的内存以存储Customer对象的实例，假定Customer对象的实例是32字节，为了在堆上找到一个存储Customer对象的存储位置。<br>.NET运行库在堆中搜索第一个从未使用的，32字节的连续块存储Customer对象的实例。<br>然后把分配给Customer对象实例的地址赋给cus变量。</p><p>从这个例子中可以看出，建立对象引用的过程比建立值变量的过程复杂，且不能避免性能的降低！<br>实际上就是.NET运行库中保存堆的状态信息，在堆中添加新数据时，堆栈中的引用变量也要更新。性能上损失很多。<br>有种机制在分配变量内存的时候，不会受到堆栈的限制：把一个引用变量的值赋给一个相同类型的变量，那么这两个变量就引用同一个堆中对象。<br>当一个应用变量出作用域时，它会从堆栈中删除。但引用对象的数据仍然保留在堆中，一直到程序结束或者该数据不被任何变量应用时，垃圾收集器会删除它。</p><p>装箱转化<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">class Boxing</span><br><span class="line">&#123;</span><br><span class="line">    public static void Main()</span><br><span class="line">    &#123;</span><br><span class="line">        int i = 110;</span><br><span class="line">        object obj = i;</span><br><span class="line">        Console.WriteLine(<span class="string">"i=&#123;0&#125;,obj = &#123;1&#125;"</span>,i,obj);</span><br><span class="line">        obj = 330;</span><br><span class="line">        Console.WriteLine(<span class="string">"i = &#123;0&#125;,obj=&#123;1&#125;"</span>,i,obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义整数类型变量的时候，这个变量占用的内存是内存占中分配的，第二句是装箱操作将变量110存放到了内存堆中，而定义object对象类型的变量Obj则在内存栈中，并指向int类型的数值110，而该数值是赋给变量i的数值副本。<br>内存格局通常分为四个区<br>全局数据区：存放全局变量，静态数据，常量<br>代码区：存放所有的程序代码<br>栈区：存放为运行而分配的局部变量，参数，返回数据，返回地址等。</p><p>值类型变量和引用类型变量的内存分配模型也不一样。为了理解清楚这个问题，首先先区分两种不同类型的内存区域：线程堆栈（Thread Stack）和托管堆（Managed Heap）。每个正在运行的程序都对应着一个进程（process），在一个进程内部，可以有一个或多个线程（thread），每个线程都拥有一块“自留地”，称为“线程堆栈”，大小为1M，用于保存自身的一些数据，比如函数中定义的局部变量、函数调用的传参值，这部分内存区域的分配与回收不需要人为干涉。</p><p><font color="blue">所有值类型的变量都是在线程堆栈中分配的。</font><br>另一块内存区域成为“堆（heap）”，在.NET托管环境下，堆由CLR进行管理，所以又称为“托管堆（managed heap）”。</p><p><font color="red">用new关键字创建的类的对象时，分配给对象的内存单元就位于托管堆中。</font><br>在程序中我们可以随意地使用new 关键字创建多个对象，因此，托管堆中的内存资源是可以动态申请并使用的，当然使用完了必须归还。</p><p>对象变量的相互赋值不会导致对象自身被复制，其结果是两个对象变量指向同一对象。另外，由于对象变量是一个局部变量，因为，对象变量本身是位于线程堆栈中的。<br>严格区分<strong>对象变量</strong>和<strong>对象变量所引用的对象</strong>，是面向对象编程的关键之一。</p><h2 id="托管堆"><a href="#托管堆" class="headerlink" title="托管堆"></a>托管堆</h2><p>.NET框架包含一个托管堆，所有的.NET语言在分配引用类型对象时都要使用它。像值类型这样的轻量级对象始终分配在栈中，但是所有的<strong>类实例</strong>和<strong>数组</strong>都被生成在一个内存池中，这个内存池就是托管堆。</p><p>垃圾收集器算法：</p><ul><li>将所有的托管内存标记为垃圾</li><li>寻找正被使用的内存块，并将他们标记为有效</li><li>释放所有没有被使用的内存块</li><li>整理堆以减少碎片</li></ul><h2 id="托管堆优化"><a href="#托管堆优化" class="headerlink" title="托管堆优化"></a>托管堆优化</h2><p>看上去很简单，但是垃圾收集器实际采用的步骤和堆管理系统的其它部分并非微不足道，其中尝尝涉及为提高性能而作的优化设计。举例来说，垃圾收集遍历整个内存池具有很高的开销。然而，研究表明大部分的托管堆上分配的对象只有很短的生存期，因此堆被分为三个段，称作generations。新分配的对象被放在generation 0中。这个generation是最先被回收的-在这个generation中最有可能找到不再使用的内存，由于它的尺寸很小（小到足以放进处理器的L2 cache中），因此在它里面的回收将是最快和最高效的。<br>托管堆的另外一种优化操作与locality of reference规则有关。该规则表明，一起分配的对象经常被一起使用。如果对象们在堆中位置很紧凑的话，高速缓存的性能将会得到提高。由于托管堆的天性，对象们总是被分配在连续的地址上，托管堆总是保持紧凑，结果使得对象们始终彼此靠近，永远不会分得很远。这一点与标准提供的非托管代码形成了鲜明的对比，在标准堆中，堆很容易变成碎片，而且一起分配的对象经常分得很远。<br>还有一种优化是与大对象有关的。通常，大对象具有很长的生存期。当一个大对象在.NET托管堆中产生时，它被分配在堆的一个特殊部分中，这部分堆永远不会被整理。因此移动大对象所带来的开销超过了整理这部分堆所能提高的性能。</p><h2 id="关于外部资源（External-Resources）的问题"><a href="#关于外部资源（External-Resources）的问题" class="headerlink" title="关于外部资源（External Resources）的问题"></a>关于外部资源（External Resources）的问题</h2><p>垃圾收集器能够有效地管理从托管堆中释放的资源，但是资源回收操作只有在内存紧张而触发一个回收动作时才执行。那么，累时怎样来管理像数据库连接或者窗口句柄这样有限的资源的呢？等待，直到垃圾回收被触发之后在清理数据库连接或者文件句柄并不是一个好方法，这会严重降低系统的性能。<br>所有拥有外部资源的类，在这些资源已经不再用到的时候，都应当执行Close或者Dispose方法。<br>需要清理外部资源的类还应当实现一个终止操作（finalizer）。在C#中，创建终止操作的首选方式是在析构函数中实现，而在Framework层，终止操作的实现则是通过重载System.Object.Finalize方法。以下两种实现终止操作的方法是等效的：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">~OverdueBookLocator()</span><br><span class="line">&#123;</span><br><span class="line">    Dispose(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Finalize</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">base</span>.Finalize();</span><br><span class="line">    Dispose(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在C#中，同时在Finalize方法和析构函数实现终止操作将会导致错误的产生。<br>除非你有足够的理由，否则你不应该创建析构函数或者Finalize方法。终止操作会降低系统的性能，并且增加执行期的内存开销。同时，由于终止操作被执行的方式，你并不能保证何时一个终止操作被执行。</p><h2 id="内存分配和垃圾回收的细节"><a href="#内存分配和垃圾回收的细节" class="headerlink" title="内存分配和垃圾回收的细节"></a>内存分配和垃圾回收的细节</h2><p>对GC有了一个总体印象之后，让我们来讨论关于托管堆中的分配与回收工作的细节。托管堆看起来与我们已经熟悉的C++编程中的传统的堆一点都不像。在传统的堆中，数据结构习惯于使用大块的空闲内存。在其中查找特定大小的内存块是一件很耗时的工作，尤其是当内存中充满碎片的时候。与此不同，在托管堆中，内存被组成连续的数组，指针总是巡着已经被使用的内存和未被使用的内存之间的边界移动。当内存被分配的时候，指针只是简单地递增—由此而来的一个好处是，分配操作的效率得到了很大的提升。<br>当对象被分配的时候，它们一开始被generation 0中。当generation 0的大小快要达到它的上限的时候，一个只在generation 0中执行的回收操作被触发。由于generation 0的大小很小，因此这将是一个非常快的GC过程。这个GC过程的结果是将generation 0彻底的刷新了一遍。不再使用的对象被释放，正在使用的对象被整理并移入generation 1中。<br>当generation 1的大小随着generation 0中移入的对象数量的增加而接近它的上限的时候，一个回收动作被触发在generation 0和generation 1中执行GC过程。如同在generation 0中一样，不再使用的对象被释放，正在被使用的对象被整理并移入下一个generation中。大部分GC过程的主要目标是generation 0，因为在generation 0中最优可能存在大量的已不再使用的临时对象。对generation 2的回收过程具有很高的开销，并且此过程只有在generation 0和generation 1的GC过程不能释放足够的内存时才会被触发。如果对generation 2的GC过程仍然不能释放足够的内存，那么系统就会抛出OutOfMemoryException异常。<br>带有终止操作的对象的垃圾收集过程要稍微复杂一些。当一个带有终止操作的对象被标记为垃圾时，它并不会被立即释放。相反，它会被放置一个终止队列（finalizetion queue）中，此队列为这个对象建立一个引用，来避免这个对象被回收。后台线程为队列中的每个对象执行它们各自的终止操作，并且将已经执行过终止操作的对象从终止队列中删除。只有那些已经执行过终止操作的对象才会在下一次垃圾回收过程中被内存中删除。这样做的一个后果是，等待被终止的对象有可能在它被清除之前，被移入更高一级的generation中，从而增加它被清除的延迟时间。<br>需要执行终止操作的对象应当事先IDisposable接口，以便程序通过此接口快速执行终止动作。IDisposable接口包含一个Dispose方法。这个方法被用来释放外部资源并抑制终止操作。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverdueBookLocator</span>:</span>IDisposable</span><br><span class="line">&#123;</span><br><span class="line">    ~OverdueBookLocator()</span><br><span class="line">    &#123;</span><br><span class="line">        InternalDispose(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        InternalDispose(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">InternalDispose</span><span class="params">(<span class="keyword">bool</span> disposing)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (disposing)</span><br><span class="line">        &#123;</span><br><span class="line">            GC.SuppressFinalize(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="栈和托管堆"><a href="#栈和托管堆" class="headerlink" title="栈和托管堆"></a>栈和托管堆</h2><p>通用类型系统（CTS）区分两种基本类型：值类型和引用类型。它们之间的根本区别在于它们在内存中的存储方式。.NET使用两种不同的物理内存来存储数据<font color="orange">栈和托管堆</font><br><img src="/2018/04/02/CSharp/1.png"><br>值类型总是内存中占用一个预定义的字节数（例如，int类型占4个字节，而string类型占用的字节数会根据字符串的长度而不同）。当声明一个值类型变量时，会在栈中分配适当大小的内存（除了引用类型的值类型成员外，如类的int字段）。内存中的这个空间用来存储变量所包含的值。.NET维护一个栈指针，它包含栈中下一个可用的内存空间的地址。当一个变量离开作用域时，栈指针指向下移动被释放变量所占用的字节数。所以它仍指向下一个可用地址。<br>引用变量也利用栈，但这时候栈包含的只是对另一个内存位置的引用，而不是实际值。这个位置是托管堆中的一个地址，和栈一样，他也维护一个指针，包含堆中下一个可用的内存地址。但是，堆不是先入后出的，因为对对象的引用可在我们的程序中传递（例如，作为参数传递给方法调用）。堆中的对象不会在程序的一个预定点离开作用域。为了在不适用在堆中分配的内存时将它释放。.NET定期执行垃圾回收器，垃圾垃圾递归检查应用程序中所有对象的引用。引用不再有效的对象使用的内存无法从程序中访问，该内存就可以回收。</p><h2 id="类型层次结构"><a href="#类型层次结构" class="headerlink" title="类型层次结构"></a>类型层次结构</h2><p>CTS定义了一种类型层级结构，该结构不仅仅描述了不同预定义类型，还指出了用户定义类型的层次结构的位置。</p><img src="/2018/04/02/CSharp/2.png">]]></content>
      
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xxsy-sence-merge-render</title>
      <link href="/2018/04/02/xxsy-sence-merge-render/"/>
      <url>/2018/04/02/xxsy-sence-merge-render/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PJ04</title>
      <link href="/2018/04/02/xxsy-skill/"/>
      <url>/2018/04/02/xxsy-skill/</url>
      
        <content type="html"><![CDATA[<h1 id="normal-logic"><a href="#normal-logic" class="headerlink" title="normal_logic"></a>normal_logic</h1><div class="table-container"><table><thead><tr><th>Index</th><th>Type</th><th>Data1</th><th>Data2</th><th>Data3</th><th>Data4</th><th>Data5</th></tr></thead><tbody><tr><td>1</td><td>随机移动</td></tr><tr><td>2</td><td>固定线路</td></tr><tr><td>3</td><td>跟随逻辑</td></tr><tr><td>4</td><td>恐惧逻辑</td></tr><tr><td>5</td><td>飞行逻辑</td></tr><tr><td>6</td></tr><tr><td>7</td></tr><tr><td>8</td><td>怪物闲聊</td><td></td><td>talk_list.id</td><td>起始延迟时间</td><td></td><td>间隔时间</td></tr><tr><td>9</td><td>宠物跟随</td></tr><tr><td>20</td><td>怪物边聊边走</td></tr></tbody></table></div><h1 id="refresh-table"><a href="#refresh-table" class="headerlink" title="refresh_table"></a>refresh_table</h1><div class="table-container"><table><thead><tr><th>物体id</th><th>刷新方式</th></tr></thead><tbody><tr><td>cha_list.id</td><td>0手动1刷一次2死亡复合3条件</td></tr></tbody></table></div><h1 id="talk-list"><a href="#talk-list" class="headerlink" title="talk_list"></a>talk_list</h1><div class="table-container"><table><thead><tr><th>事件类型</th><th>事件id</th></tr></thead><tbody><tr><td>4，驾云/瞬移</td><td>trans_cmn.id</td></tr></tbody></table></div>]]></content>
      
      
      
        <tags>
            
            <tag> Pj04 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL</title>
      <link href="/2018/04/01/opengl/"/>
      <url>/2018/04/01/opengl/</url>
      
        <content type="html"><![CDATA[<h1 id="颜色缓冲区"><a href="#颜色缓冲区" class="headerlink" title="颜色缓冲区"></a>颜色缓冲区</h1><p>颜色缓冲区（COLOR_BUFFER）就是帧缓冲区（FRAME_BUFFER），你需要渲染的场景最终每一个像素都要写入该缓冲区，然后由它渲染到屏幕上显示。</p><h1 id="深度缓冲区"><a href="#深度缓冲区" class="headerlink" title="深度缓冲区"></a>深度缓冲区</h1><p>深度缓冲区（DEPTH_BUFFER）与帧缓冲区对应，用于记录上面每个像素的深度值，通过深度缓冲区，我们就可以进行深度测试，从而确定像素的遮挡关系，保证渲染正确。</p><h1 id="模版缓冲区"><a href="#模版缓冲区" class="headerlink" title="模版缓冲区"></a>模版缓冲区</h1><p>模版缓冲区（STENCIL_BUFFER）与深度缓冲大小相同，通过设置模版缓冲每个像素的值，我们可以指定在渲染的时候只渲染某些像素，从而可以达到一些特殊的效果。</p><h1 id="Texture-Wrapping"><a href="#Texture-Wrapping" class="headerlink" title="Texture Wrapping"></a>Texture Wrapping</h1><p>通常，纹理坐标的范围在(0,0)到(1,1)之间，但是假如我们制定的坐标在这之外呢？<br>OpenGL会如何做出反应？默认情况下，OpenGL会重复绘制纹理图，不过，OpenGL也提供了更多的选择方案：</p><ul><li>GL_REPEAT：默认方案，重复纹理图片</li><li>GL_MIRRORED_REPEAT：类似于默认方法，不过每次重复的时候进行镜像重复。</li><li>GL_CLAMP_TP_EDGE：将坐标限制在0到1之间。超出的坐标会重复绘制边缘的像素，变成一种扩展边缘的图案。</li><li>GL_CLAMP_TO_BORDER：超出的坐标将会被绘制成用户指定的边界颜色</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法</title>
      <link href="/2018/03/29/Red-Black-Tree/"/>
      <url>/2018/03/29/Red-Black-Tree/</url>
      
        <content type="html"><![CDATA[<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>红黑树是一种自平衡二叉查找树。</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>1.节点是红色或黑色。<br>2.根节点是黑色<br>3.每个叶节点（NIL或空节点）是黑色<br>4.每个红色节点的两个子节点都是黑色的（也就是说不存在两个连续的红色节点）；<br>5.从任意一个节点到其叶子节点都包含相同数目的黑色节点；</p><h1 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h1><h2 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h2><p>1.本身首先是一棵二叉搜索树<br>2.带有平衡条件：每个节点的左右子树的高度之差的绝对值（平衡因子）最多为1.</p><h2 id="节点数"><a href="#节点数" class="headerlink" title="节点数"></a>节点数</h2><h2 id="STL和Linux都使用红黑树作为平衡树的实现"><a href="#STL和Linux都使用红黑树作为平衡树的实现" class="headerlink" title="STL和Linux都使用红黑树作为平衡树的实现"></a>STL和Linux都使用红黑树作为平衡树的实现</h2><p>1.如果插入一个node引起了树的不平衡，AVL和RB-Tree都是最多只需要2次旋转操作，即两者都是O(1)；但是在删除node引起树的不平衡时，最坏情况下，AVL需要维护从被删node到root这条路径上所有node的平衡性，因此需要旋转的两级O(logN)，而RB-Tree最多只需要3次旋转，只需要O(1)的复杂度。<br>2.其次，AVL的结构相较RB-Tree来说更为平衡，在插入和删除node更容易引起Tree的unbalance，因此在大量数据需要插入或删除时，AVL需要rebalance的频率会更高。因此，RB-Tree在需要大量插入和删除node的场景下，效率更高。自然，由于AVL高度平衡，因此AVL的search效率更高。<br>3.map的实现只是折衷了两者在search、insert以及delete下的效率。总体来说，RB-tree的统计行能是高于AVL的。</p><h1 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>1.若左子树不空，则左子树所有节点的值均小于或等于它的根节点的值；<br>2.若右子树不空，则右子树所有节点的值均大于或等于它的根节点的值；<br>3.左、右子树也分别为二叉排序树；</p><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>步骤：若根节点的关键字值等于查找的关键字，成功。<br>否则，若小于根节点的关键字值，递归查左子树。<br>P(n)=O(logn)</p><h2 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h2><h3 id="前序非递归遍历"><a href="#前序非递归遍历" class="headerlink" title="前序非递归遍历"></a>前序非递归遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder_traversal_iteratively</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    s.push(root);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    TreeNode* last_pop = root;</span><br><span class="line">    <span class="keyword">while</span> (!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode* top = s.top();</span><br><span class="line">        <span class="keyword">if</span> (top-&gt;left != <span class="number">0</span> &amp;&amp; top-&gt;left != last_pop &amp;&amp; top-&gt;right != last_pop)</span><br><span class="line">        &#123;</span><br><span class="line">            s.push(top-&gt;left);</span><br><span class="line">            <span class="built_in">cout</span> &gt;&gt; top-&gt;left-&gt;val &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (top-&gt;right != <span class="number">0</span> &amp;&amp; top-&gt;right != last_pop &amp;&amp; (top-&gt;left == <span class="number">0</span> || top-&gt;left == last_pop))</span><br><span class="line">        &#123;</span><br><span class="line">            s.push(top-&gt;right);</span><br><span class="line">            <span class="built_in">cout</span> &gt;&gt; top-&gt;right-&gt;val &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            s.pop();</span><br><span class="line">            last_pop = top;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Hash-散列函数"><a href="#Hash-散列函数" class="headerlink" title="Hash(散列函数)"></a>Hash(散列函数)</h1><p>给定M，存在函数f(key)，对任意给定给定的关键字key，代入函数厚若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash)表，函数(key)为哈希(Hash)函数。<br>如果key不相同，但是f(k1)=f(k2),这种现象成为碰撞(Collision)</p><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>1.直接寻址发：取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key) = a * key + b,其中a和b为常熟（这种散列函数叫做自身函数）。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Objective-C</title>
      <link href="/2018/03/24/Objective-C/"/>
      <url>/2018/03/24/Objective-C/</url>
      
        <content type="html"><![CDATA[<h1 id="Objective-C-C的超集"><a href="#Objective-C-C的超集" class="headerlink" title="Objective-C: C的超集"></a>Objective-C: C的超集</h1><p>Objective-C是C语言的严格超集—任何C语言不经修改可以直接通过Objective-C编译器</p><h1 id="Objective-C代码文件的扩展名"><a href="#Objective-C代码文件的扩展名" class="headerlink" title="Objective-C代码文件的扩展名"></a>Objective-C代码文件的扩展名</h1><p>.h  头文件<br>.m  源代码文件，包含Objective-C和C代码<br>.mm 源代码文件，包含Objective-C、C、C++代码，仅在你的Objective-C代码中确实需要使用C++类或者特性的时候采用这种扩展名</p><p>当你需要在源代码中包含头文件的时候，你可以使用标准的#include编译选项，但是Objective-C提供了更好的方法。#import选项和#include选项完全相同，只是它可以确保相同的文件只会被包含一次。Objective-C的例子和文档都倾向于使用#import。</p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p>C++调用方法</p><pre><code>obj.method(argument);</code></pre><p>Objective-C调用方法</p><pre><code>[obj method: argument];</code></pre><p>类声明总是由@interface编译选项开始，由@end选项结束。<br><img src="http://oxcvfpext.bkt.clouddn.com/Objective-C-1.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@interface MyObject: NSObject&#123;</span><br><span class="line">    int memberVar1; // 实体变量</span><br><span class="line">    id </span><br><span class="line">&#125;</span><br><span class="line">+(return_type) class_method; //类方法</span><br><span class="line"></span><br><span class="line">-(return_type) instance_method1; //实例方法</span><br><span class="line">-(void)fbSendInviteByID: (NSDictionary*)info</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>方法前面+/-号代表函数的类型：加号(+)代表类方法(class method),不需要实例就可以调用，与C++的静态函数(static member function)相似。减号(-)即是一般的实例方法(instance method)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(void)setColorToRed: (float)red Green: ()</span><br></pre></td></tr></table></figure></p><h1 id="pragma-mark"><a href="#pragma-mark" class="headerlink" title="pragma mark"></a>pragma mark</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity热更新方案-ILRuntime</title>
      <link href="/2018/03/23/Unity-ILRuntime/"/>
      <url>/2018/03/23/Unity-ILRuntime/</url>
      
        <content type="html"><![CDATA[<p>ILRuntime的优势同市面上的其他热更方案相比，ILRuntime主要有以下优点：</p><ul><li>无缝访问C#工程的线程代码，无需额外抽象脚本API</li><li>直接使用VS2015进行开发，ILRuntime的解释编译引擎支持.Net 4.6编译的DLL</li><li>执行效率是L#的10-20倍</li><li>选择性的CLR绑定使跨域调用更快速，绑定后跨域调用的性能能达到slua的2倍左右(从脚本调用GameObject之类的接口)</li><li>支持跨域集成</li><li>完整的泛型支持</li><li>拥有Vs2015调试插件，可以实现真机源码级调试(WIP)</li></ul><p><a href="https://github.com/Ourpalm/ILRuntime" target="_blank" rel="noopener">https://github.com/Ourpalm/ILRuntime</a><br><a href="https://ourpalm.github.io/ILRuntime/public/v1/guide/tutorial.html" target="_blank" rel="noopener">https://ourpalm.github.io/ILRuntime/public/v1/guide/tutorial.html</a></p><p>如果你希望在Unity中使用ILRuntime,推荐的方式是直接使用ILRuntime源代码，这样ILRuntime可以根据你的发布设置自动进行优化。</p><p>你需要将下列源代码目录复制到Unity工程的Assets目录：</p><ul><li>Mono.Cecil.20</li><li>Mono.Cecil.Pdb</li><li>ILRuntime</li></ul><p>需要注意的是，需要删除这些目录里面的bin、obj、Properties子目录，以及.csproj文件。此外由于ILRuntime使用了unsafe代码来优化执行效率，所以你需要在Unity中开启unsafe模式：</p><ul><li>在Assets目录里建立一个名为smcs.rsp的文本文件</li><li>在smcs.rsp文件中假如-unsafe</li></ul><p>如果你使用的是Unity5.4及以前的版本，并且使用的编译设置是.Net 2.0而不是.Net 2.0 Subset的话，你需要将上述说明中的smcs.rsp文件名改为gmcs.rsp。<br>如果你使用的是Unity5.5以上的版本，你需要将上述说明的smcs.rsp文件名改为mcs.rsp</p><h2 id="从Visual-Studio开始"><a href="#从Visual-Studio开始" class="headerlink" title="从Visual Studio开始"></a>从Visual Studio开始</h2><p>如果你希望在VisiualStudio的C#项目中使用ILRuntime，你只需要引用编译好的ILRuntime.dll,Mono.Cecil.20.dll以及Mono.Cecil.Pdb即可。</p><h3 id="使用之前"><a href="#使用之前" class="headerlink" title="使用之前"></a>使用之前</h3><p>ILRuntime项目提供了一个测试用例工程ILRuntimeTest,用来验证ILRuntime的正常运行，在运行测试用例前，需要手动生成一下TestCases里面的工程，生成DLL文件。</p><h2 id><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Skinned Mesh原理解析</title>
      <link href="/2018/03/23/Unity-Skinned-Mesh/"/>
      <url>/2018/03/23/Unity-Skinned-Mesh/</url>
      
        <content type="html"><![CDATA[<h1 id="一、3D模型动画基本原理和分类"><a href="#一、3D模型动画基本原理和分类" class="headerlink" title="一、3D模型动画基本原理和分类"></a>一、3D模型动画基本原理和分类</h1><p>3D模型动画的基本原理是让模型中各定点的位置随时间变化。主要种类由Morph动画，关节动画和骨骼蒙皮动画(Skinned Mesh)。从动画数据的角度来说，三者一般都采用关键帧技术，即只给出关键帧的数据，其他帧的数据使用插值得到。但由于这三种技术的不同，关键帧的数据是不一样的。</p><p>Morph(渐变，变形)动画是直接指定动画每一帧的顶点位置，其动画关键中存储的是Mesh所有顶点在关键帧对应时刻的位置。</p><p>关节动画的模型不是一个整体的Mesh，而是分成很多部分(Mesh),通过一个父子层级结构将这些分散的Mesh组织在一起，父Mesh带动其子Mesh运动，各mesh中的顶点坐标定义在自己的坐标系中，这样各个Mesh是作为一个整体参与运动的。动画帧中设置各子Mesh相对于Mesh的变化（主要是旋转，当然也可以包括移动和缩放），通过子到父，一级级的变化累加（当然从技术上，如果是矩阵操作是累乘）得到该Mesh在整个动画模型所在的坐标空间中的变换（从本文的视角来说就是世界坐标系了，下同），从而确定每个Mesh在世界坐标系中的位置和方向，然后以Mesh为单位渲染即可。关节动画的问题是，各部分Mesh中的顶点时固定在其Mesh坐标系中的，这样在两个mesh结合处就可能产生裂缝。</p><p>第三类就是骨骼蒙皮动画即Skinned Mesh了，骨骼蒙皮动画的出现解决了关节动画的裂缝问题，而且效果非常酷，骨骼动画的基本原理可概括为：在骨骼控制下，通过顶点混合动态计算蒙皮网格的顶点，而骨骼的运动相对于其父骨骼，并由动画关键帧数据驱动。一个骨骼动画通常包括骨骼层次结构数据，网格(Mesh)数据，网格蒙皮数据(skin info)和骨骼的动画(关键帧)数据。</p><h1 id="二、Skinned-Mesh-原理和结构分析"><a href="#二、Skinned-Mesh-原理和结构分析" class="headerlink" title="二、Skinned Mesh 原理和结构分析"></a>二、Skinned Mesh 原理和结构分析</h1><p>Skinned Mesh中文一般乘坐骨骼蒙皮动画，这种动画包含骨骼(Bone)和蒙皮(Skinned Mesh)两个部分，Bone的层次结构和关节动画类似，Mesh则和关节动画不同：关节动画中时使用多个分散的Mesh,而Skinned Mesh中的Mesh是一个整体，也就是说只有一个mesh,实际上如果没有骨骼让Mesh运动变形，Mesh就和静态模型一样了，Skinned Mesh技术的精华在于蒙皮，所谓的皮并不是模型的贴图，而是mesh本身，蒙皮是将mesh中的顶点附着（绑定）在骨骼之上，而且每个顶点可以被多个骨骼所控制，这样的关节处的顶点由于同时收到了父子骨骼的拉扯而改变位置就消除了裂缝。</p><h2 id="1-理解骨骼和骨骼层次结构-Bone-Hierarchy"><a href="#1-理解骨骼和骨骼层次结构-Bone-Hierarchy" class="headerlink" title="1.理解骨骼和骨骼层次结构(Bone Hierarchy)"></a>1.理解骨骼和骨骼层次结构(Bone Hierarchy)</h2><p>首先要明确一个观念：骨骼决定了模型整体在世界坐标系中的位置和朝向。<br>先看看静态模型吧，静态模型没有骨骼，我们在世界坐标系中放置静态模型时，只要指定模型自身坐标系在世界坐标系中的位置和朝向。在骨骼动画中，不是把Mesh直接放到世界坐标系中，Mesh只是作为Skin使用的，是依附骨骼的，真正决定模型在世界坐标系中的位置和朝向的是骨骼。在渲染静态模型时，由于模型的顶点都是定义在模型坐标系中的，所以各顶点只要经过模型坐标系到世界坐标系的变换就可以进行渲染。而对于骨骼动画，设置模型的位置和朝向，实际实在设置根骨骼的位置和朝向，然后根据骨骼层级结构中父子骨骼之间的变换关系计算出各个骨骼的位置和朝向，然后根据骨骼堆Mesh中顶点的绑定计算出顶点在世界坐标系中的坐标，从而堆顶点进行渲染，要记住，在骨骼动画中，骨骼才是模型主题，Mesh不过是一层皮，一件衣服。<br>如何理解骨骼？请看第二个管娘：骨骼可理解为一个坐标空间。<br>在一些文章中往往会提到关节和骨骼，那么关节是什么？骨骼有事什么？下图是一个手臂的骨骼层次的实例。<br><img src="http://oxcvfpext.bkt.clouddn.com/Unity-Skinned-Mesh-1.png"><br>骨骼只是一个形象的说法，实际上骨骼可理解为一个坐标空间，关节可理解为骨骼坐标空间的远点。关节的位置由它在父骨骼坐标空间中描述，上图中由三块骨骼，分别是手臂，前臂和两个手指。Clavicle(骨锁)是一个关节，它是上臂的原点，同样肘关节(elbow joint)是前臂的原点，腕关节(wrist)是手指骨骼的远点。关节既决定了骨骼空间的位置，旋转和缩放分量决定了骨骼空间的旋转和缩放。我们来看前臂这个骨骼，其原点位置位于上臂上某处的，对于上臂来说，它知道自己的坐标空间某处(即肘关节所在的位置)有一个子空间，那就是前臂，至于前臂里面是啥就不考虑了。当前臂绕肘关节旋转时，实际是前臂坐标空间在旋转，从而其中包含的子空间也在绕肘关节旋转，这个例子中是finger骨骼。和实际生物骨骼不同的是，我们这里的骨骼并没有实质的骨头，所以前臂旋转时，他自己没啥可转的，改变的只是坐标空间的朝向。你可以说上图蓝线在转，但实际蓝线并不存在，蓝线只是画上去表示骨骼之间关系的，真正转的是骨骼空间，我们能看到在转的是wrist joint,也就是两个finger骨骼的坐标空间，因为他们是子空间，会跟随父空间运动，就好比跟着地球转一样。</p><p>骨骼就是坐标空间，骨骼层次就是嵌套的坐标空间。关节只是描述骨骼的位置即骨骼自己的坐标空间原点再其父空间中的位置，绕关节旋转是指骨骼坐标空间(包括所有子空间)自身的旋转。但还有两个可能的疑问，一是骨骼的长度，由于骨骼是坐标空间没有所谓的长度和宽度限制，我们看到的长度一方面是蒙皮后的结果，而另一方面子骨骼的原点(也就是关节)的位置往往决定了视觉上父骨骼的长度，比如这里upper arm线段的长度实际是由elbow joint的位置决定的。第二个问题，实际上我们的例子中手指没有子骨骼，所以那个端点并不存在，那是为了方便演示画上去的。实际问题中总有最下层的骨骼，他们不能决定其他骨骼了，他们的作用只剩下控制Mesh顶点了。对了，那么手指的长度如何确定？我们看到的长度应该是手指部分的顶点和蒙皮决定的，也就是由Mesh中属于手指的那些点离腕关节的距离决定。</p><p>经过一段长篇大论，我们终于弄清楚骨骼和骨骼层次结构了，但是为什么要将骨骼组织成层次结构呢？答案是为了做动画方便，设想如果只有一块骨骼，那么让他动起来太简单了，动画每一帧直接指定他的位置即可，如果是n块呢？通过组成一个层次结构，就可以通过父骨骼控制子骨骼的运动，牵一发而动全身，改变某骨骼时并不需要设置其子骨骼的位置，子骨骼的位置会通过计算自动得到，上问已经说过，父子骨骼之间的关系可以理解为，子骨骼位于父骨骼的坐标系中，我们知道物体在坐标系中可以平移变换，以及自身的旋转和缩放。子骨骼在父骨骼的坐标系中也可以做这些变换来改变自己在其父骨骼坐标系中的位置和朝向等，那么如何表示呢？由于4x4矩阵可以同时表示上述三种变换，所以一般描述骨骼在其父骨骼坐标系时使用一个举证，也就是DirectX SkinnedMesh中的FramrTrnsformMatrix。实际上这不是唯一的方法，但应该是公认的方法因为矩阵不光可以同时表示多种变换还可以方便的通过连乘进行变换的组合，这在层次结构中非常方便。在本文的例子-最简单的skinned mesh示例中，我只演示了评议变换，所以只用一个3d坐标就可以表示子骨骼在父骨骼的位置。下面是Bone Class最初的定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bone</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">float</span> m_x, m_y, m_z;<span class="comment">//这个坐标是定义在父骨骼坐标系中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同时增加了一组坐标，存放计算好的世界坐标系。<br>将各个骨骼相关于相对于父骨骼摆放好，就形成了一个骨骼层次结构的初始坐标，所谓初始是指定义骨骼层次时，后来动画改变了骨骼的相对位置，准确的说一般是改变了骨骼自身的旋转而位置保持不变。</p><p>假设我们通过某种方法建立了骨骼层次结构，那么每一块骨骼的位置都依赖于其父骨骼的位置，而跟骨骼没有父，他的位置就是整个骨骼体系在世界坐标系中的位置。可以认为root的父就是世界坐标系。但是初始位置时，跟骨骼一般不是世界原点的，比如使用3d max character studio创建的biped骨架时，一般两脚之间时世界原点，而根骨骼-骨盆位于原点上方(+z轴上)。这有什么关系呢，其实也没什么大不了的，只是我们在指定骨骼动画模型整体坐标时，比如设定坐标(0,0,0),则根骨骼-骨盆被置于世界原点，假如xy平面时地面，那么人下个身子到地面下了。我们想让两脚之间算作人的原点，这样设定(0,0,0)的坐标时人就站在地面上了，所以可以在两脚之间设定一个额外的根骨骼放到世界原点上，或者这个骨骼并不需要真实存在，只是在你的骨骼模型结构中保存骨盆骨骼到世界原点的变换矩阵。在微软X文件中，一般有一个Scene_Root节点，这算一个额外的骨骼吧，他的变换矩阵为单位阵，表示他初始位于世界原点，而真正骨骼的跟Bip01,作为Scene_root的子骨骼，其变换矩阵表示相对于root的位置。说这么多其实我只是像解释下，为什么要存在Scenen_Root这种额外的骨骼，以及加深理解骨骼定位骨骼动画模型整体的世界坐标的作用。</p><p>有了骨骼类，现在让我们看一下建立骨骼层次的代码，在bone class中增加一个构造函数和两个成员函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bone</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Bone(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z): m_pSibling(<span class="literal">NULL</span>),m_pFirstChild(<span class="literal">NULL</span>),m_pFather(<span class="literal">NULL</span>),</span><br><span class="line">    m_x(x),m_y(y),m_z(z)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetFirstChild</span><span class="params">(Bone *pChild)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        m_pFirstChild = pChild;</span><br><span class="line">        m_pFirstChild-&gt;m_pFather = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetSibling</span><span class="params">(Bone *pSibling)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        m_pSibling = pSibling;</span><br><span class="line">        m_pSibling-&gt;m_pFather = m_pFather;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意我增加了一个成员变量，Bone* m_pFather,这是指向父骨骼的指针，在这个例子中计算骨骼动画时本不需要这个指针，但我为了画一条从父骨骼关节到子骨骼关节的连线，增加了它，因为每个骨骼只有第一子骨骼的指针，绘制父骨骼时从父到子画线就只能画一条，所以记录每个骨骼的父，在胡子hi子骨骼时画这根线。</p><p>有了这个函数，就可以创建骨骼层次了，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Bone * g_boneRoot;</span><br><span class="line">Bone * g_bone1, *g_bone32, *g_bone22;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildBones</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_boneRoot = <span class="keyword">new</span> Bone(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    g_bone1 = <span class="keyword">new</span> Bone(<span class="number">0.1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    g_bone21 = <span class="keyword">new</span> Bone(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.1</span>,<span class="number">0</span>);</span><br><span class="line">    g_bone22 = <span class="keyword">new</span> Bone(<span class="number">0.1</span>, <span class="number">0.0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    g_boneRoot-&gt;SetFirstChild(g_bone1);</span><br><span class="line">    gbone1-&gt;SetFirstChild(g_bone21);</span><br><span class="line">    g_bone21-&gt;SetSibling(g_bone22);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来是骨骼层次中最核心的部分，更新骨骼！由于动画的作用，某个骨骼的变化(TransformMatrix)变了，这时就要根据新的变化来计算，所以这个过程一般乘坐UpdateBoneMatrix。因为骨骼的变化都是相对父的，要变换顶点必须使用世界变换矩阵，所以这个过程根据更新了某些骨骼的骨骼变换矩阵(TransformMatrix)计算出所有骨骼的世界变换矩阵(CombinedMatrix)。在本文的例子中，骨骼只能平移，甚至我们没有用矩阵，所以当有骨骼变动时要做的只是直接计算骨骼的世界坐标，因此函数命名为ComputeWorldPos,相当于UpdateBoneMatrix后再用顶点相乘CombinedMatrix。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bone</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//give father's world pos, compute the bone's world pos</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ComputeWorldPos</span><span class="params">(<span class="keyword">float</span> fatherWX, <span class="keyword">float</span> fatherWY, <span class="keyword">float</span> WZ)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        m_wx = fatherWX + m_x;</span><br><span class="line">        m_wy = fatherWY + m_y;</span><br><span class="line">        m_wz = fatherWZ + m_z;</span><br><span class="line">        <span class="keyword">if</span> (m_pSibling != <span class="literal">NULL</span>)</span><br><span class="line">            m_pSibling-&gt;ComputeWorldPos(fatherWX, fatherWY, fatherWZ);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_pFirstChild != <span class="literal">NULL</span>)</span><br><span class="line">            m_pFirstChild-&gt;ComputreWorldPos(m_wx, m_wy, m_wz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中的递归调用使用了微软例子的思想。</p><p>有了上述函数，当某骨骼运动时就可以让其子骨骼跟随运动了，但是怎么让骨骼运动呢？这就是动画问题了，我不打算在这个简单的例子中使用关键帧动画，而只是通过程序每帧改变某些骨骼的位置，DEMO中的animateBones就是做这个的，你可以在里面改变不同的骨骼看看效果。在本文下面会对骨骼的关键帧动画做简单的讨论。</p><h2 id="2-蒙皮信息和蒙皮过程"><a href="#2-蒙皮信息和蒙皮过程" class="headerlink" title="2.蒙皮信息和蒙皮过程"></a>2.蒙皮信息和蒙皮过程</h2><h3 id="2-1-Skin-info的定义"><a href="#2-1-Skin-info的定义" class="headerlink" title="2-1 Skin info的定义"></a>2-1 Skin info的定义</h3><p>上文曾讨论过，Skinned Mesh中Mesh时作为皮肤使用，蒙在骨骼之上的。为了让普通的Mesh具有蒙皮的功能，必须添加蒙皮信息，即Skin info。我们知道mesh是由顶点构成的，建模时顶点是定义在模型自身坐标系的，即相对于Mesh原点的，而骨骼动画中决定模型顶点最终世界坐标的是骨骼，所以要让骨骼决定顶点的世界坐标，这就要将顶点和骨骼联系起来，Skin info正是起了这个作用。下面是DEMO中顶点类的定义的代码片段：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_BONE_PER_VERTEX 4</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> m_x, m_y, m_z;<span class="comment">//local pos in mesh space</span></span><br><span class="line">    <span class="keyword">float</span> m_wX, m_wY, m_wZ; <span class="comment">// blended vertex pos, in world space</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// skin info</span></span><br><span class="line">    <span class="keyword">int</span> m_boneNum;</span><br><span class="line">    Bone * m_bones[MAX_BONE_PER_VERTEX];</span><br><span class="line">    <span class="keyword">float</span> m_boneWeights[MAX_BONE_PER_VERTEX];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顶点的Skin info包含影响该顶点的骨骼数目，只想这些骨骼的指针，这些骨骼作用于该顶点的权重(Skin weight)。由于只是一个简单的例子，这儿没有考虑优化，所以用静态数组存放骨骼指针和权重，且实际引擎中Skin info的定义方式不一定是这样的，但基本原理一致。</p><p>MAX_BONE_PER_VERTEX在这儿用来设置可同时影响顶点的最大骨骼数，实际上由于这个DEMO是手工进行Vertex Blending并且没有硬件加速，以及为了确保速度，一般会定义最大骨骼数。另外在本Demo中，Skin info是手工设定的，而实际项目中，一般是在建模软件中生成这些信息并导出。</p><p>Skin info 的作用是使用各个骨骼的变换矩阵对顶点进行变换并乘以权重，这样某块骨骼只能对该顶点产生部分影响。各骨骼权重之和应该为1.</p><p>Skin info是针对顶点的，然后在使用Skin info前我们必须要使用Bone Offset Matrix对顶点进行变换，下面具体讨论Bone offset Matrix。（写下这句话的时候我感觉不妥，因为实际是先将所有的矩阵相乘最后在用作顶点，这儿是按照理论上的顺序进行讲述吧，请不要与实际情况混肴，其实他们也并不矛盾。而且在我们的DEMO中由于没有使用矩阵，所以变换的顺序和理论顺序是一致的）</p><h3 id="2-2-Bone-Offset-Matrix的含义和计算方法"><a href="#2-2-Bone-Offset-Matrix的含义和计算方法" class="headerlink" title="2-2 Bone Offset Matrix的含义和计算方法"></a>2-2 Bone Offset Matrix的含义和计算方法</h3><p>上文已经说过：“骨骼动画中决定模型顶点最终世界坐标的是骨骼，所以要让骨骼决定顶点的世界坐标”，现在让我们看下顶点受一块骨骼的作用的坐标变换过程：<br>    mesh vertex(defined in mesh space)——&gt;Bone space——&gt;world<br>从这个过程中可以看出，需要首先将模型顶点从模型空间变换到某块骨骼自身的骨骼空间，然后才能利用骨骼的世界变换计算顶点的世界坐标。Bone Offset Matrix的作用正是将模型从顶点空间变换到骨骼空间。那么Bone Offset Matrix如何得到呢？下面具体分析：</p><p>Mesh space是建模时使用的空间，mesh中顶点的位置相对于这个空间的原点定义。比如在3dmax中建模时(视xy平面为地面，+z朝上)，可将模型两脚之间的中点作为Mesh空间的原点，并将其放置在世界原点，这样左脚上某一顶点坐标是(10,10,2),右脚上堆成的一点坐标是(-10,10,2)，头顶的坐标是(0,0,170)。由于此时Mesh空间和世界空间重合，上述坐标即在Mesh空间也是世界空间，换句话说，此时实际是以世界空间作为Mesh空间了。在骨骼动画中，在世界中放置的是骨骼而不是Mesh，所以这个区别并不重要。在3d max中添加骨骼的时候，也是将骨骼放入世界空间中，并调整骨骼的相对位置是得和mesh相吻合（即设置骨骼的TransformMatrix),得到股价的初始姿势以及相应的Transform Matrix(按惯例模型做成两臂侧平举直立，骨骼也要适合这个姿态)。由于骨骼的Transform Matrix(作用是将顶点从骨骼空间变换到上层空间)是基于其父骨骼空间的，只有根骨骼的Transform是基于世界空间的，所以要通过自下而上一层层Tranform变换(如果使用行向量右乘矩阵，这个Transform的累计过程就是C=MboneMfatherMgrandpar..Mroot),得到该骨骼在世界空间上的变换矩阵-Combined Transform Matrix,即通过这个矩阵可将该顶点从骨骼空间变换到世界空间。那么这个矩阵的逆矩阵就可以将世界空间中的顶点变换到某块骨骼的骨骼空间。由于Mesh实际上就是定义在世界空间了，所以这个逆矩阵就是Offset Matrix。即OffsetMatrix就是骨骼在初始位置（没有经过任何动画改变）时将bone变换到世界空间的矩阵(CombinedTransformMatrix)的逆矩阵，有一些资料称之为InverseMatrix。在几何流水线中，是通过变换矩阵将顶点变换到上层空间，最终得到世界坐标，逆矩阵则作相反的事，所以Inverse这种提法也符合惯例。那么Offset这种提法从字面上怎么理解呢？Offset即骨骼相对世界原点的偏移，世界原点加上这个偏移就变成骨骼空间的原点，同样定义在世界空间中的点经过这个偏移矩阵的作用也被变换成骨骼空间了。从另一角度理解，在动画中模型中顶点的位置是根据骨骼位置动态计算的，也就是说顶点跟着骨骼动，但首先必须确定顶点和骨骼之间的相对位置（即顶点在该骨骼坐标系中的位置），一个骨骼可能对应很多顶点，如果要保存这个相对位置每个顶点对于每块受控制的骨骼都要保存，这样就要保存太多的矩阵了。。所以只保存mesh空间到骨骼空间的变换（即OffsetMatrix),然后通过这个变换计算每个顶点在该骨骼空间中的坐标，所以OffsetMatrix也反应了mesh和每块骨骼的相对位置，只是这个位置是间接的通过和世界坐标空间的关系表达的，在初始位置将骨骼按照模型的形状摆好的关键之处。</p><p>以上的分析是通过mesh space和world space重合得到Offset Matrix的计算方法。那么如果他们不重合呢？那就要先计算顶点从mesh space变换到world space的变换矩阵，并乘上（还是右乘为例）Combined Matrix的Inverse Matrix从而得到Offset Matrix。但是这不是找麻烦吗，因为Mesh的原点在哪里并不重要，为啥不让他们重合呢？</p><p>还有一个问题是，既然Offset Matrix可以计算出来，为啥还要在骨骼动画文件中同时提供TransformMatrix和OffsetMatrix呢？实际上文件中确实可以不提供OffsetMatrix,而只在载入时计算，但TransformMatrix不可缺少，动画关键帧数据一般只存储骨骼的旋转和跟骨骼的位置，骨骼见的相对位置还是要靠TransformMatrix提供。在微软的X文件结构中提供了OffsetMatrix,原因是什么呢？我不知道。我猜想一个可能的原因是为了兼容性和灵活性，比如mesh并没有定义在世界坐标系，而是作为一个object放置在3d max中，在导出骨骼动画时不能简单的认为mesh的顶点坐标时相对于世界远点的，还要把这个object的位置考虑进去，于是导出插件要计算OffsetMatrix并保存在x文件中以避免兼容性问题。</p><p>关于OffsetMatrix和TransformMatrix含有评议，旋转和缩放的讨论：</p><p>首先，OffsetMatrix取决于骨骼的初始位置(即TransformMatrix),由于骨骼动画中我们使用的动画中的位置，初始位置时什么样并不重要，所以可以在初始位置中包含平移，而旋转和缩放在动画中设置(一般也仅仅使用旋转，这也是为啥动画通常中可以用一个四元数表示骨骼的关键帧)。在这种情况下，OffsetMatrix只包含平移即可。因此一些引擎的Bone中不存放Transform矩阵，而只存放骨骼在父骨骼空间的坐标，然后旋转只在动画帧中设置，最基本的骨骼动画即可实现。但也可在Transform和Offset Matrix中包括旋转和缩放，这样可以提供创建动画时的容错性。</p><p>在本文的DEMO中，我们也没有使用矩阵保存Bone Offset，而只用了一个坐标保存偏移位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoneOffset</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">float</span> m_offx, m_offy, m_offz;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在Bone class中，有一个方法用来计算Bone Offset</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bone</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BoneOffset m_boneOffset;</span><br><span class="line">    <span class="comment">//called after ComputeWorldPos() when bone loaded but not animated</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ComputeBoneOffset</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        m_boneOffset.m_offx = -m_wx;</span><br><span class="line">        m_boneOffset.m_offy = -m_wy;</span><br><span class="line">        m_boneOffset.m_offz = -m_wz;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_pSibling != <span class="literal">NULL</span>)</span><br><span class="line">            m_pSibing-&gt;ComputeBoneOffset();</span><br><span class="line">        <span class="keyword">if</span> (m_pFirstChild != <span class="literal">NULL</span>)</span><br><span class="line">            m_pFirstChild-&gt;ComputeBoneOffset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在ComputeBoneOffset()中，使用计算好的骨骼的世界坐标来计算bone offset,这儿的计算只是取一个负数，在实际引擎中，如果bone offset是一个矩阵，这儿就应该是求逆矩阵，其实由于旋转矩阵是正交的，只要求出旋转矩阵的转置矩阵。注意由于我们计算Bone offset时是使用计算好的世界坐标，所以在这之前必须在初始位置时对根骨骼调用ComputeWorldPos()以计算出各个骨骼在初始位置时的世界坐标。</p><h3 id="2-3-最终：顶点混合-vertex-blending"><a href="#2-3-最终：顶点混合-vertex-blending" class="headerlink" title="2-3 最终：顶点混合(vertex blending)"></a>2-3 最终：顶点混合(vertex blending)</h3><p>现在我们有了Skin info,有了Bone Offset。现在开始做顶点混合，这是骨骼动画的精髓所在，正是这个技术消除了关节处的裂缝。顶点混合后得到了顶点新的世界坐标，对所有的顶点执行vertex blending后，从Mesh的角度看，Mesh deform(变形)了，变成动画需要的形状了。</p><p>首先，让我们看看使用单块骨骼对顶点进行作用的过程以下是DEMO中的相关代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ComputerWorldPosByBone</span><span class="params">(Bone *pBone, <span class="keyword">float</span> &amp;outx, <span class="keyword">float</span> &amp;outY, <span class="keyword">float</span> &amp;outZ)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">//step1: transform vertex from mesh space to bone space</span></span><br><span class="line">        outX = m_x + pBone-&gt;m_boneOffset.m_offx;</span><br><span class="line">        outY = m_y + pBone-&gt;m_boneOffset.m_offy;</span><br><span class="line">        outZ = m_z + pBone-&gt;m_boneOffset.m_offz;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//step2: transform vertex bone space to world space</span></span><br><span class="line">        outX += pBone-&gt;m_wx;</span><br><span class="line">        outY += pBone-&gt;m_wy;</span><br><span class="line">        outZ += pBone-&gt;m_wz;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>这个函数使用一块骨骼对顶点进行变换，将顶点Mesh坐标系变换到世界坐标系，这儿使用了骨骼的Bone Offset Matrix和Combined Transform Matrix</p><p>对于多块骨骼，对每块骨骼执行这个过程并将结果根据权重混合(即vertex blending)就得到顶点最终的世界坐标。进行vertex blending的代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BlendVertex</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">//do the vertex blending,get the vertex's pos in world space</span></span><br><span class="line">        m_wX = <span class="number">0</span>;</span><br><span class="line">        m_wY = <span class="number">0</span>;</span><br><span class="line">        m_wZ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_boneNum; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">float</span> tx, ty, tz;</span><br><span class="line">            ComputeWorldPosByBone(m_bones[i], tx, ty, tz);</span><br><span class="line">            tx *= m_boneWeights[i];</span><br><span class="line">            ty *= m_boneWeights[i];</span><br><span class="line">            tz *= m_boneWeights[i];</span><br><span class="line"></span><br><span class="line">            m_wX += tx;</span><br><span class="line">            m_wY += ty;</span><br><span class="line">            m_wZ += tz;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这些函数我都放在Vertex类中了，因为只是一个简单DEMO所以没有特别考虑类结构问题，在BlendVertex()中，遍历影响该顶点的所有骨骼，用每块骨骼计算出顶点的世界坐标，然后使用Skin Weight对这些坐标进行加权平均。tx,ty,tz是某块骨骼作用后顶点的世界坐标乘以权重后的值，这些值相加后就是最终的世界坐标了。</p><p>现在让我们用一个工时回顾以下Vertex blending的整个过程(使用矩阵变换)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vworld = Vmesh * BoneOffsetMatrix1 * CombindMatrix1 * Weight1</span><br><span class="line">+ Vmesh* BoneOffsetMatrix2 * CombineMatrix2*Wright2</span><br><span class="line">+ ...</span><br><span class="line">+ Vmesh * BoneOffsetMatrixn * CombindMatrixN * WeightN</span><br></pre></td></tr></table></figure><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>从结构上看，SkinnedMesh包括：动画数据，骨骼数据，包括Skin info的Mesh数据，以及Bone Offset Matrix。</p><p>从过程上看，载入阶段：载入并建立骨骼层次结构，计算或载入Bone Offset Matrix,载入Mesh数据和Skin info(具体的实现不同的引擎可能都不一样)。运行阶段：根据时间从动画数据中获取骨骼当前时刻的Transfrom Matrix，调用UpdateBoneMatrix计算出各骨骼的CombineMatrix,对于每个顶点根据Skin info进行Vertex Blending计算出顶点的世界坐标，最终进行模型的渲染。</p><h1 id="三、关于本文的例子"><a href="#三、关于本文的例子" class="headerlink" title="三、关于本文的例子"></a>三、关于本文的例子</h1><p>这个例子做了尽可能的简化，只包含一个cpp文件，使用OpenGL和GLUT作为渲染器和框架，仅有400多行代码。例子中手工创建了一个骨骼层次和Mesh，手工设置Skin info并自动计算BoneOffset,使用程序控制骨骼平移演示了骨骼层次的运动和骨骼影响下Mesh顶点的运动，例子中甚至没有使用矩阵。本例子仅作理解骨骼动画只用。<br><img src="http://oxcvfpext.bkt.clouddn.com/Unity-Skinned-Mesh-2.png"><br>截图中绿色网格是模型原始形状，蓝色是骨骼，红色是动画时模型形状，DEMO中左数第二个骨骼做上下运动，最下方的骨骼做x方向平移。DEMO没有使用旋转，而实际的骨骼动画中往往没有平移只有旋转的，因为胳膊只能转不能边长，但原理一致。<br>(这个公式使用的是行向量左乘矩阵)<br>由于BoneOffsetMatrix和Combined Matrix都是矩阵，可以先相乘这样就减少了很多计算了，在实际游戏中可以VS进行硬件加速计算。<br>代码的执行过程为，初始化时：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">buildBones();<span class="comment">//创建骨骼层次</span></span><br><span class="line">buildMesh();<span class="comment">//创建mesh,设置skin info，计算bone offset </span></span><br><span class="line">```</span><br><span class="line">每帧运行时：</span><br><span class="line">```C++</span><br><span class="line"><span class="comment">//draw original mesh</span></span><br><span class="line">g_mesh-&gt;DrawStaticMesh(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//move bones</span></span><br><span class="line">animateBones();</span><br><span class="line"></span><br><span class="line"><span class="comment">//update all bone's pos in bone tree</span></span><br><span class="line">g_boneRoot-&gt;ComputeWorldPos(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//update vertex pos by bones,using vertex blending</span></span><br><span class="line">g_mesh-&gt;UpdateVertices();</span><br><span class="line"></span><br><span class="line"><span class="comment">//draw deformed mesh</span></span><br><span class="line">g_mesh-&gt;Draw();</span><br><span class="line"></span><br><span class="line"><span class="comment">//draw bone</span></span><br><span class="line">g_boneRoot-&gt;Draw();</span><br></pre></td></tr></table></figure></p><p>为保证文本的完整性，下面贴出所有代码。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A simplest Skinned Mesh demo</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GL/glut.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL 0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoneOffset</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="comment">//BoneOffset transform a vertex from mesh space to bone space.</span></span><br><span class="line">    <span class="comment">//In other words, it is the offset from mesh space to a bone's space.</span></span><br><span class="line">    <span class="comment">//For each bone, there is a BoneOffest.</span></span><br><span class="line">    <span class="comment">//If we add the offset to the vertex's pos (in mesh space), we get the vertex's pos in bone space</span></span><br><span class="line">    <span class="comment">//For example: if a vertex's pos in mesh space is (100,0,0), the bone offset is (-20,0,0), so the vertex's pos in bone space is (80,0,0)</span></span><br><span class="line">    <span class="comment">//Actually, BoneOffset is the invert transform of that we place a bone in mesh space, that is (-20,0,0) means the bone is at (20,0,0) in mesh space</span></span><br><span class="line">    <span class="keyword">float</span> m_offx , m_offy , m_offz ;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bone</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    Bone () &#123;&#125;</span><br><span class="line">    Bone ( <span class="keyword">float</span> x , <span class="keyword">float</span> y , <span class="keyword">float</span> z ):m_pSibling (<span class="literal">NULL</span> ),m_pFirstChild (<span class="literal">NULL</span> ),m_pFather (<span class="literal">NULL</span> ),m_x (x ),m_y (y ),m_z (z )&#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~Bone () &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Bone * m_pSibling ;</span><br><span class="line">    Bone * m_pFirstChild ;</span><br><span class="line">    Bone * m_pFather ; <span class="comment">//only for draw bone</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetFirstChild</span> <span class="params">(Bone * pChild )</span> </span>&#123; m_pFirstChild = pChild ; m_pFirstChild -&gt;m_pFather = <span class="keyword">this</span> ; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetSibling</span> <span class="params">(Bone * pSibling )</span> </span>&#123; m_pSibling = pSibling ; m_pSibling -&gt;m_pFather = m_pFather ; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> m_x , m_y , m_z ; <span class="comment">//pos in its parent's space</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> m_wx , m_wy , m_wz ; <span class="comment">//pos in world space</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//give father's world pos, compute the bone's world pos</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ComputeWorldPos</span> <span class="params">( <span class="keyword">float</span> fatherWX , <span class="keyword">float</span> fatherWY , <span class="keyword">float</span> fatherWZ )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       m_wx = fatherWX +m_x ;</span><br><span class="line">       m_wy = fatherWY +m_y ;</span><br><span class="line">       m_wz = fatherWZ +m_z ;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (m_pSibling !=<span class="literal">NULL</span> )</span><br><span class="line">           m_pSibling -&gt;ComputeWorldPos (fatherWX , fatherWY , fatherWZ );</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (m_pFirstChild !=<span class="literal">NULL</span> )</span><br><span class="line">           m_pFirstChild -&gt;ComputeWorldPos (m_wx , m_wy , m_wz );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BoneOffset m_boneOffset ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//called after compute world pos when bone loaded but not animated</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ComputeBoneOffset</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       m_boneOffset .m_offx = -m_wx ;</span><br><span class="line">       m_boneOffset .m_offy = -m_wy ;</span><br><span class="line">       m_boneOffset .m_offz = -m_wz ;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (m_pSibling !=<span class="literal">NULL</span> )</span><br><span class="line">           m_pSibling -&gt;ComputeBoneOffset ();</span><br><span class="line">       <span class="keyword">if</span> (m_pFirstChild !=<span class="literal">NULL</span> )</span><br><span class="line">           m_pFirstChild -&gt;ComputeBoneOffset ();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Draw</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       glColor3f (<span class="number">0</span>,<span class="number">0</span>,<span class="number">1.0</span>);</span><br><span class="line">       glPointSize (<span class="number">4</span>);</span><br><span class="line">       glBegin (GL_POINTS );</span><br><span class="line">       glVertex3f (m_wx ,m_wy ,m_wz );</span><br><span class="line">       glEnd ();</span><br><span class="line">       <span class="keyword">if</span> (m_pFather !=<span class="literal">NULL</span> )</span><br><span class="line">       &#123;</span><br><span class="line">           glBegin (GL_LINES );</span><br><span class="line">              glVertex3f (m_pFather -&gt;m_wx ,m_pFather -&gt;m_wy ,m_pFather -&gt;m_wz );</span><br><span class="line">              glVertex3f (m_wx ,m_wy ,m_wz );</span><br><span class="line">           glEnd ();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (m_pSibling !=<span class="literal">NULL</span> )</span><br><span class="line">           m_pSibling -&gt;Draw ();</span><br><span class="line">       <span class="keyword">if</span> (m_pFirstChild !=<span class="literal">NULL</span> )</span><br><span class="line">           m_pFirstChild -&gt;Draw ();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_BONE_PER_VERTEX 4</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    Vertex ():m_boneNum (<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ComputeWorldPosByBone</span> <span class="params">(Bone * pBone , <span class="keyword">float</span> &amp; outX , <span class="keyword">float</span> &amp; outY , <span class="keyword">float</span> &amp; outZ )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="comment">//step1: transform vertex from mesh space to bone space</span></span><br><span class="line">       outX = m_x +pBone -&gt;m_boneOffset .m_offx ;</span><br><span class="line">       outY = m_y +pBone -&gt;m_boneOffset .m_offy ;</span><br><span class="line">       outZ = m_z +pBone -&gt;m_boneOffset .m_offz ;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//step2: transform vertex from bone space to world sapce</span></span><br><span class="line">       outX += pBone -&gt;m_wx ;</span><br><span class="line">       outY += pBone -&gt;m_wy ;</span><br><span class="line">       outZ += pBone -&gt;m_wz ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BlendVertex</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="comment">//do the vertex blending,get the vertex's pos in world space</span></span><br><span class="line"></span><br><span class="line">       m_wX = <span class="number">0</span>;</span><br><span class="line">       m_wY = <span class="number">0</span>;</span><br><span class="line">       m_wZ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> ( <span class="keyword">int</span> i =<span class="number">0</span>; i &lt;m_boneNum ; ++i )        </span><br><span class="line">       &#123;            </span><br><span class="line">       <span class="keyword">float</span> tx , ty , tz ;            </span><br><span class="line">       ComputeWorldPosByBone (m_bones [i ], tx , ty , tz );            </span><br><span class="line">       tx *= m_boneWeights [i ];            </span><br><span class="line">       ty *= m_boneWeights [i ];            </span><br><span class="line">       tz *= m_boneWeights [i ];            </span><br><span class="line">       m_wX += tx ;            </span><br><span class="line">       m_wY += ty ;            </span><br><span class="line">       m_wZ += tz ;        </span><br><span class="line">       &#125;     </span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="keyword">float</span> m_x , m_y , m_z ; </span><br><span class="line">    <span class="comment">//local pos in mesh space     </span></span><br><span class="line">    <span class="keyword">float</span> m_wX , m_wY , m_wZ ; </span><br><span class="line">    <span class="comment">//blended vertex pos, in world space     </span></span><br><span class="line">    <span class="comment">//skin info     </span></span><br><span class="line">    <span class="keyword">int</span> m_boneNum ;     </span><br><span class="line">    Bone * m_bones [MAX_BONE_PER_VERTEX ];     </span><br><span class="line">    <span class="keyword">float</span> m_boneWeights [MAX_BONE_PER_VERTEX ];     </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetBoneAndWeight</span> <span class="params">( <span class="keyword">int</span> index , Bone * pBone , <span class="keyword">float</span> weight )</span>     </span></span><br><span class="line"><span class="function">    </span>&#123;        </span><br><span class="line">    m_bones [index ] = pBone ;        </span><br><span class="line">    m_boneWeights [index ] = weight ;     </span><br><span class="line">   &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//----------------------------------------------------------- </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SkinMesh</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">public</span> :     </span><br><span class="line">    SkinMesh ():m_vertexNum (<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;     </span><br><span class="line"></span><br><span class="line">    SkinMesh ( <span class="keyword">int</span> vertexNum ):m_vertexNum (vertexNum )     </span><br><span class="line">    &#123;        </span><br><span class="line">        m_vertexs = <span class="keyword">new</span> Vertex [vertexNum ];     </span><br><span class="line">    &#125;     </span><br><span class="line"></span><br><span class="line">    ~SkinMesh ()     </span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="keyword">if</span> (m_vertexNum &gt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">delete</span> [] m_vertexs ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">UpdateVertices</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> ( <span class="keyword">int</span> i =<span class="number">0</span>; i &lt;m_vertexNum ; ++i )</span><br><span class="line">       &#123;</span><br><span class="line">           m_vertexs [i ].BlendVertex ();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DrawStaticMesh</span> <span class="params">( <span class="keyword">float</span> x , <span class="keyword">float</span> y , <span class="keyword">float</span> z )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       glColor3f (<span class="number">0</span>,<span class="number">1.0</span>,<span class="number">0</span>);</span><br><span class="line">       glPointSize (<span class="number">4</span>);</span><br><span class="line">       glBegin (GL_POINTS );</span><br><span class="line">       <span class="keyword">for</span> ( <span class="keyword">int</span> i =<span class="number">0</span>; i &lt;m_vertexNum ; ++i )</span><br><span class="line">           glVertex3f (m_vertexs [i ].m_x +x ,m_vertexs [i ].m_y +y ,m_vertexs [i ].m_z +z );</span><br><span class="line">       glEnd ();</span><br><span class="line"></span><br><span class="line">       glBegin (GL_LINE_LOOP );</span><br><span class="line">       <span class="keyword">for</span> ( <span class="keyword">int</span> i =<span class="number">0</span>; i &lt;m_vertexNum ; ++i )</span><br><span class="line">           glVertex3f (m_vertexs [i ].m_x +x ,m_vertexs [i ].m_y +y ,m_vertexs [i ].m_z +z );</span><br><span class="line">       glEnd ();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Draw</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       glColor3f (<span class="number">1.0</span>,<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">       glPointSize (<span class="number">4</span>);</span><br><span class="line">       glBegin (GL_POINTS );</span><br><span class="line">       <span class="keyword">for</span> ( <span class="keyword">int</span> i =<span class="number">0</span>; i &lt;m_vertexNum ; ++i )</span><br><span class="line">           glVertex3f (m_vertexs [i ].m_wX ,m_vertexs [i ].m_wY ,m_vertexs [i ].m_wZ );</span><br><span class="line">       glEnd ();</span><br><span class="line"></span><br><span class="line">       glBegin (GL_LINE_LOOP );</span><br><span class="line">       <span class="keyword">for</span> ( <span class="keyword">int</span> i =<span class="number">0</span>; i &lt;m_vertexNum ; ++i )            glVertex3f (m_vertexs [i ].m_wX ,m_vertexs [i ].m_wY ,m_vertexs [i ].m_wZ );        glEnd ();     &#125;     <span class="keyword">int</span> m_vertexNum ;     Vertex * m_vertexs ; <span class="comment">//array of vertices in mesh &#125;; //-------------------------------------------------------------- Bone * g_boneRoot ; Bone * g_bone1 , *g_bone2 , *g_bone31 , *g_bone32 ; void buildBones () &#123;     g_boneRoot = new Bone (0, 0, 0);     g_bone1 = new Bone (0.2, 0, 0);     g_bone2 = new Bone (0.2, 0, 0);     g_bone31 = new Bone (0.2, 0.1, 0);     g_bone32 = new Bone (0.2, -0.1, 0);     g_boneRoot -&gt;SetFirstChild (g_bone1 );</span></span><br><span class="line">    g_bone1 -&gt;SetFirstChild (g_bone2 );</span><br><span class="line">    g_bone2 -&gt;SetFirstChild (g_bone31 );</span><br><span class="line">    g_bone31 -&gt;SetSibling (g_bone32 );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteBones</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> g_boneRoot ;</span><br><span class="line">    <span class="keyword">delete</span> g_bone1 ;</span><br><span class="line">    <span class="keyword">delete</span> g_bone2 ;</span><br><span class="line">    <span class="keyword">delete</span> g_bone31 ;</span><br><span class="line">    <span class="keyword">delete</span> g_bone32 ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">animateBones</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> dir =<span class="number">-1</span>, dir2 =<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//animate bones manually</span></span><br><span class="line"></span><br><span class="line">    g_bone1 -&gt;m_y +=<span class="number">0.00001f</span>*dir ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (g_bone1 -&gt;m_y m_y &gt;<span class="number">0.2</span>)</span><br><span class="line">       dir *=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    g_bone32 -&gt;m_x +=<span class="number">0.00001f</span>*dir2 ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (g_bone32 -&gt;m_x m_x &gt;<span class="number">0.2</span>)</span><br><span class="line">       dir2 *=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SkinMesh * g_mesh ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildMesh</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> _meshData []=</span><br><span class="line">    &#123; <span class="comment">//x,y,z</span></span><br><span class="line">       <span class="number">-0.1</span>,<span class="number">0.05</span>,<span class="number">0</span>,</span><br><span class="line">       <span class="number">0.1</span>,<span class="number">0.05</span>,<span class="number">0</span>,</span><br><span class="line">       <span class="number">0.3</span>,<span class="number">0.05</span>,<span class="number">0</span>,</span><br><span class="line">       <span class="number">0.45</span>,<span class="number">0.06</span>,<span class="number">0</span>,</span><br><span class="line">       <span class="number">0.6</span>,<span class="number">0.15</span>,<span class="number">0</span>,</span><br><span class="line">       <span class="number">0.65</span>,<span class="number">0.1</span>,<span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">       <span class="number">0.5</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">       <span class="number">0.65</span>,<span class="number">-0.1</span>,<span class="number">0</span>,</span><br><span class="line">       <span class="number">0.6</span>,<span class="number">-0.15</span>,<span class="number">0</span>,</span><br><span class="line">       <span class="number">0.45</span>,<span class="number">-0.06</span>,<span class="number">0</span>,</span><br><span class="line">       <span class="number">0.3</span>,<span class="number">-0.05</span>,<span class="number">0</span>,</span><br><span class="line">       <span class="number">0.1</span>,<span class="number">-0.05</span>,<span class="number">0</span>,</span><br><span class="line">       <span class="number">-0.1</span>,<span class="number">-0.05</span>,<span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> _skinInfo []=</span><br><span class="line">    &#123; <span class="comment">//bone_num,bone id(0,1,2,31 or 32), bone weight 1~4,</span></span><br><span class="line">       <span class="number">1</span>,  <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>,    <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">       <span class="number">2</span>,  <span class="number">0</span>,  <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">       <span class="number">2</span>,  <span class="number">1</span>,  <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>,  <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">       <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">31</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0.3</span>, <span class="number">0.7</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">       <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">31</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0.2</span>, <span class="number">0.8</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">       <span class="number">1</span>,  <span class="number">31</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line"></span><br><span class="line">       <span class="number">2</span>,  <span class="number">31</span>, <span class="number">32</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line"></span><br><span class="line">       <span class="number">1</span>,  <span class="number">32</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">       <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">32</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0.2</span>, <span class="number">0.8</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">       <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">32</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0.3</span>, <span class="number">0.7</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">       <span class="number">2</span>,  <span class="number">1</span>,  <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>,  <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">       <span class="number">2</span>,  <span class="number">0</span>,  <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">       <span class="number">1</span>,  <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>,    <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> vertexNum = <span class="keyword">sizeof</span> (_meshData )/( <span class="keyword">sizeof</span> ( <span class="keyword">float</span> )*<span class="number">3</span>);</span><br><span class="line">    g_mesh = <span class="keyword">new</span> SkinMesh (vertexNum );</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i =<span class="number">0</span>; i m_vertexs [i ].m_x = _meshData [i *<span class="number">3</span>];</span><br><span class="line">       g_mesh -&gt;m_vertexs [i ].m_y = _meshData [i *<span class="number">3</span>+<span class="number">1</span>];</span><br><span class="line">       g_mesh -&gt;m_vertexs [i ].m_z = _meshData [i *<span class="number">3</span>+<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//set skin info</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i =<span class="number">0</span>; i m_vertexs [i ].m_boneNum = _skinInfo [i *<span class="number">9</span>];</span><br><span class="line">       <span class="keyword">for</span> ( <span class="keyword">int</span> j =<span class="number">0</span>; j &lt;g_mesh -&gt;m_vertexs [i ].m_boneNum ; ++j )</span><br><span class="line">       &#123;</span><br><span class="line">           Bone * pBone = g_boneRoot ;</span><br><span class="line">           <span class="keyword">if</span> (_skinInfo [i *<span class="number">9</span>+<span class="number">1</span>+j ]==<span class="number">1</span>)</span><br><span class="line">              pBone = g_bone1 ;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (_skinInfo [i *<span class="number">9</span>+<span class="number">1</span>+j ]==<span class="number">2</span>)</span><br><span class="line">              pBone = g_bone2 ;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (_skinInfo [i *<span class="number">9</span>+<span class="number">1</span>+j ]==<span class="number">31</span>)</span><br><span class="line">              pBone = g_bone31 ;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (_skinInfo [i *<span class="number">9</span>+<span class="number">1</span>+j ]==<span class="number">32</span>)</span><br><span class="line">              pBone = g_bone32 ;</span><br><span class="line"></span><br><span class="line">           g_mesh -&gt;m_vertexs [i ].SetBoneAndWeight (j , pBone , _skinInfo [i *<span class="number">9</span>+<span class="number">5</span>+j ]);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//compute bone offset</span></span><br><span class="line">    g_boneRoot -&gt;ComputeWorldPos (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    g_boneRoot -&gt;ComputeBoneOffset ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> deleteMesh ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> g_mesh ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> myInit ()</span><br><span class="line">&#123;</span><br><span class="line">    buildBones ();</span><br><span class="line">    buildMesh ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> myQuit ()</span><br><span class="line">&#123;</span><br><span class="line">    deleteBones ();</span><br><span class="line">    deleteMesh ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> myReshape ( <span class="keyword">int</span> width , <span class="keyword">int</span> height )</span><br><span class="line">&#123;</span><br><span class="line">    GLfloat h = (GLfloat ) height / (GLfloat ) width ;</span><br><span class="line"></span><br><span class="line">    glViewport (<span class="number">0</span>, <span class="number">0</span>, (GLint ) width , (GLint ) height );</span><br><span class="line">    glMatrixMode (GL_PROJECTION );</span><br><span class="line">    glLoadIdentity ();</span><br><span class="line"><span class="comment">//  glFrustum(-1.0, 1.0, -h, h, 5.0, 60.0);</span></span><br><span class="line">    glFrustum (<span class="number">-1.0</span>, <span class="number">1.0</span>, -h , h , <span class="number">1.0</span>, <span class="number">100.0</span>);</span><br><span class="line">    glMatrixMode (GL_MODELVIEW );</span><br><span class="line">    glLoadIdentity ();</span><br><span class="line">    glTranslatef (<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> myDisplay ( <span class="keyword">void</span> )</span><br><span class="line">&#123;</span><br><span class="line">    glClear (GL_COLOR_BUFFER_BIT );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//draw original mesh</span></span><br><span class="line">    g_mesh -&gt;DrawStaticMesh (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//move bones</span></span><br><span class="line">    animateBones ();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//update all bone's pos in bone tree</span></span><br><span class="line">    g_boneRoot -&gt;ComputeWorldPos (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//update vertex pos by bones, using vertex blending</span></span><br><span class="line">    g_mesh -&gt;UpdateVertices ();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//draw deformed mesh</span></span><br><span class="line">    g_mesh -&gt;Draw ();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//draw bone</span></span><br><span class="line">    g_boneRoot -&gt;Draw ();</span><br><span class="line"></span><br><span class="line">    glFlush ();</span><br><span class="line">    glutSwapBuffers ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> myIdle ( <span class="keyword">void</span> )</span><br><span class="line">&#123;</span><br><span class="line">    myDisplay ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main ( <span class="keyword">int</span> argc , <span class="keyword">char</span> *argv [])</span><br><span class="line">&#123;</span><br><span class="line">    glutInit (&amp;argc , argv );</span><br><span class="line">    glutInitDisplayMode (GLUT_RGB | GLUT_DEPTH | GLUT_DOUBLE );</span><br><span class="line">    glutInitWindowPosition (<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    glutInitWindowSize (<span class="number">640</span>, <span class="number">480</span>);</span><br><span class="line">    glutCreateWindow ( <span class="string">"A simplest skinned mesh DEMO, by happyfirecn@yahoo.com.cn"</span> );</span><br><span class="line"></span><br><span class="line">    glutDisplayFunc (myDisplay );</span><br><span class="line">    glutReshapeFunc (myReshape );</span><br><span class="line">    glutIdleFunc (myIdle );</span><br><span class="line"></span><br><span class="line">    myInit ();</span><br><span class="line">    glutMainLoop ();</span><br><span class="line">    myQuit ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>//</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Actor模型原理</title>
      <link href="/2018/03/23/actor/"/>
      <url>/2018/03/23/actor/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Actor模型"><a href="#1-Actor模型" class="headerlink" title="1.Actor模型"></a>1.Actor模型</h1><p>在使用Java进行并发编程时需要特别的关注锁和内存原子性等一系列线程问题，而Actor模型内部的状态由它自己维护即它内部数据只能由它自己修改（通过消息传递来进行状态修改），所以使用Actors模型进行并发编程可以很好避免这些问题，Actor由状态(state),行为(Behavior)和邮箱(mailBox)三部分组成<br>1.状态(state):Actor中的状态指的是Actor对象的变量信息，状态由Actor自己管理，避免了并发环境下的锁和内存原子性等问题<br>2.行为(Behavior):行为指的是Actor中计算逻辑，通过Actor接收到消息来改变Actor的状态<br>3.邮箱(mailBox):邮箱是Actor和Actor之间的通信桥梁，邮箱内部通过FIFO消息队列来存储发送发Actor消息，接收方Actor从邮箱队列中获取消息</p><p>Actor的基础就是消息传递</p><h1 id="2-使用Actor模型的好处"><a href="#2-使用Actor模型的好处" class="headerlink" title="2.使用Actor模型的好处"></a>2.使用Actor模型的好处</h1><p>1.事件驱动—Actor之间的通信是异步的，即使Actor在发送消息后也无需阻塞或者等待就能够处理其他事件<br>2.强隔离性—Actor中的方法不能由外部部署直接调用，所有的一切都通过消息传递进行的，从而避免了Actor之间的数据共享，想要观察到另一个Actor的状态变化只能通过消息传递进行询问<br>3.位置透明—无论Actor地址实在本地还是在远程机上对于代码来说都是一样的<br>4.轻量性—Actor是非常轻量的计算单机，单个Actor仅占400多字节，只需少量内存就能达到高并发</p><h1 id="3-Actor模型原理"><a href="#3-Actor模型原理" class="headerlink" title="3.Actor模型原理"></a>3.Actor模型原理</h1><p>以下通过学生于教师之间的邮件通信来理解akka中的Actor模型</p><h2 id="学生-教师的消息传递"><a href="#学生-教师的消息传递" class="headerlink" title="学生-教师的消息传递"></a>学生-教师的消息传递</h2><p>首先只考虑学生单向发送消息给教师（学生—》教师），如下图：<br><img src="http://oxcvfpext.bkt.clouddn.com/actor-1.png"><br>图解：<br>1.学生创建一个ActorSystem<br>2.通过ActorSystem创建ActorRef，将QuoteRequest消息发送到ActorRef(教师代理)<br>3.ActorRef(教师代理)消息传到Dispatcher中<br>4.Dispather依次的将消息发送到TeacherActor邮箱中<br>5.Dispather将邮箱推送到一条线程中<br>6.邮箱取出一条消息并委派给TeacherActor的Receiver方法</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>简单介绍多进程和多线程服务器</title>
      <link href="/2018/03/22/thread-process/"/>
      <url>/2018/03/22/thread-process/</url>
      
        <content type="html"><![CDATA[<h1 id="首先贴下多进程单线程和单进程多线程的特点："><a href="#首先贴下多进程单线程和单进程多线程的特点：" class="headerlink" title="首先贴下多进程单线程和单进程多线程的特点："></a>首先贴下多进程单线程和单进程多线程的特点：</h1><p>多进程：有独立的地址空间，进程之间不共享内存和变量，但可以通过共享内存实现，每个进程只有一个线程，一般用于单机系统开发。<br>多线程：在同一个进程下所有线程可以共享内存和变量。<br>而共同点是，同开辟的进程数/线程数多余系统cpu核数时，无法继续提供应用的性能。<br>而多线程架构的服务器，只要适当将一些任务分出来用新的进程启动，就可以扩展成分布式架构，使用tcp通信即可。当然多进程也可以这么干，通信方式也是使用tcp。<br>而操作系统对于线程的切换是比进程的切换要快。</p><h1 id="下面先介绍下多进程单线程服务器架构，以单机系统为例："><a href="#下面先介绍下多进程单线程服务器架构，以单机系统为例：" class="headerlink" title="下面先介绍下多进程单线程服务器架构，以单机系统为例："></a>下面先介绍下多进程单线程服务器架构，以单机系统为例：</h1><p>下贴架构图：<br><img src="http://oxcvfpext.bkt.clouddn.com/thread-process-1.png"><br>一个游戏服大概就有这几个进程。<br>router:作用如其名，路由。每个功能进程启动时，会先连接router,router会给连上来的进程分配一个唯一标识，所有功能进程都是靠这个router进程通信。<br>login:登录服务器，client登录验证在这个进程进行。<br>login:玩家单人逻辑操作处理进程，login会将登录的玩家平台到这些logic上。<br>global_login:全局操作进程，多人玩法的功能，例如战斗匹配，工会等操作会放在这里进行。<br>log:游戏日志输出进程，所有功能进程的日志输出都发到这个进程，log进程会输出到磁盘文件。<br>db:redis作为内存数据库，Mysql作为数据持久化，其它功能进程取数据都会发送请求到db。<br>back:后台进程，集成了一个http服务器。处理http请求，这里可以集成一些第三方服务功能，如gm指令。</p><p>以上每个进程都是单线程，所以无需考虑锁的问题。<br>对于每个进程收发数据：<br>    发数据：直接把{target_id:data}发送到router<br>    收数据：帧驱动，如100ms主动向router询问是否有数据，有则取过来处理。<br>单机系统下，如果采用共享内存方式，通信效率将非常高。<br>所以多进程的服务器架构设计起来还是比较简单的。</p><h1 id="在介绍下多线程服务器架构，这里我想介绍actor模型。"><a href="#在介绍下多线程服务器架构，这里我想介绍actor模型。" class="headerlink" title="在介绍下多线程服务器架构，这里我想介绍actor模型。"></a>在介绍下多线程服务器架构，这里我想介绍actor模型。</h1><p><img src="http://oxcvfpext.bkt.clouddn.com/thread-process-2.png"><br>一个Actor指的是一个最基本的计算单元。它能接收一个消息并且基于其执行计算。<br>这个理念很像面向对象语言，一个对象接受一条消息（方法调用），然后根据接受的消息做事（调用了哪个方法）。<br>Actors一大重要特征在于actors之间相互隔离，它们并不互相共享内存。这点区别于上述的对象。也就是说，一个actor能维持一个私有的状态，并且这个状态不可能被另一个actor所改变。<br>每个Actor都有一个邮箱，用于接受其他actor发送的消息。</p><p>这里重点讲一下Actor模型的调度是怎样做的。<br>Actor模型实际上可以有成千上万个，但目前一台通用服务器最多只有24核，当然不可能也开成千上万个线程。</p><p>我们可以把Actor简单想象成这样一个类实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Actor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process_1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process_2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fetch_msg</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> actor_id;</span><br><span class="line">        <span class="built_in">string</span> actor_name;</span><br><span class="line">        <span class="built_in">list</span>&lt;msg&gt; msg_queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个Actor定义了自己实现的功能(process_1,process_2)<br>当msg_queue邮箱有消息到来的时候，就调用fetch_msg取获取这些消息进程处理。<br>这一步就靠调度线程来做了。</p><p>Actor模型的调度实现起码要有：<br>    1.一个位于主线程的Actor队列，如global_queue<actor*> gq,当某个Actor收到消息时，就会被放进这个gp，等待工作线程进行调度。<br>    2.n个工作线程，这个就要根据机器的核数来决定开多少个了，例如只是一台双核的机器，那么开一个就好了，开多了会浪费时间在线程切换上，得不尝试。<br>每个工作线程做的事件很简单，向主线程询问任务，获取任务，处理任务，然后又继续询问，大致如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    task_list = fetch_task();</span><br><span class="line">    process_task(task_list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></actor*></p><p>所以一个Actor的创建和调度过程如下：<br>1.在主线程创建并放入管理列表<br>2.其他actor往本actor发送消息，消息进入msg_queue,本actor进入global_queue等待调度。<br>3.有工作线程处理完一堆任务了，向主线程询问任务，主线程把本actor分配给这个工作线程。<br>4.该工作线程取出msg，调用actor相应处理函数处理这个消息。</p><p>所以可见，actor数目于工作线程数目没有必然的关系，当然理想状态是，每个actor都有自己的处理线程，这里有消息来到时，就可以马上处理，不用等待。</p><p>理论上，actor开的越多，业务逻辑就分的越细，每次处理的时间就越短，只要actor的数目超过线程数，就可以最大限度利用多核的优势，cpu的调度就越充分。所以actor模型设计关键在于如何将业务逻辑平摊到更多的actor上，而不是集中，例如上面提到global_logic是多人玩法的业务逻辑，只要一细分，可以分成帮会actor,组队actor,战斗actor等等，这样三个消息同时就有机会被三个cpu处理，而不是固定只有一个。</p><p>Actor可以理解成用户级别的进程，于操作系统级别的进程分离，即使开很多Actor，只要工作线程数目设计合理（&lt;=系统cpu核数),就能保证线程能一直在同一个cpu上进行操作，减少线程切换的消耗，这对于cpu核数小的机器非常游泳，而对于像24核的机器，因为开辟的线程数是配置的，所以也很好规划一台机器能部署多少个服。<br>而多线程如果要对某些功能进程扩展，如增加login,增加Logic,就是要增加一个系统线程，一旦进程超过cpu核，就会有时间浪费在切换线程上了，这是一个缺点。<br>而Actor模型本身是优秀的，但是Actor的调度算法会有很多中实现，而且必然涉及到锁的涉及，这就需要设计者的设计功力了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM的新生代、老年代、MinorGC、MajorGC</title>
      <link href="/2018/03/21/JVM-heap/"/>
      <url>/2018/03/21/JVM-heap/</url>
      
        <content type="html"><![CDATA[<p>JVM中的堆，一般分为三大部分：新生代、老年代、永久代：<br>一、新生代<br>主要时用来存放新生的对象。一般占据堆的1/3空间。由于频繁创建对象，所以新生代会频繁发MinorGC进行垃圾回收。<br>新生代又分为Eden区、ServivorFrom、ServivorTo三个区。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM初探：内存分配、GC原理与垃圾收集器</title>
      <link href="/2018/03/21/JVM/"/>
      <url>/2018/03/21/JVM/</url>
      
        <content type="html"><![CDATA[<p>JVM内存的分配与回收大致可分为如下4个步骤：何时分配-》怎样分配-》何时回收-》怎样回收，除了在概念上可简单认为new时分配外，我们着重介绍后面三个步骤</p><h1 id="1-怎样分配-》JVM内存分配策略"><a href="#1-怎样分配-》JVM内存分配策略" class="headerlink" title="1.怎样分配-》JVM内存分配策略"></a>1.怎样分配-》JVM内存分配策略</h1><p>对象内存主要分配在Eden区，如果启用了本地线程分配缓存，则有限在TLAB上分配，少数情况能会直接分配在老年代，或被拆分成标量类型在栈上分配（JIT优化）。分配的规则并不是百分百固定，细节主要取决于垃圾收集器组合，以及VM内存相关的参数。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>String-StringBuffer-StringBuilder</title>
      <link href="/2018/03/21/String-StringBuffer-StringBuilder/"/>
      <url>/2018/03/21/String-StringBuffer-StringBuilder/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h1><p>String 字符串常量<br>StringBuffer 字符串变量（线程安全）<br>StringBuilder 字符串变量（非线程安全）<br>String类型和StringBuffer类型的主要性能区别其实在于String是不可变的对象，因此每次对String类型进行改变的时候其实都等同于生成了一个新的String对象，然后将指针指向新的String对象，所以经常改变内容的字符串最好不要用String，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后，JVM的GC就会开始工作，</p><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p>String和JAVA中的一样</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity手游开发-使用Lua来开发大型游戏（下）</title>
      <link href="/2018/03/19/Unity-Lua-2/"/>
      <url>/2018/03/19/Unity-Lua-2/</url>
      
        <content type="html"><![CDATA[<h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><p>Hotfix的基本原理依然是基于动态语言的Reload功能，更加准确的说是Function Reload。下图简单描述了整个Hotfix的流程：<br><img src="http://oxcvfpext.bkt.clouddn.com/Unity-Lua-2-1.png"><br>更加具体地可以描述为：<br>1.程序发现要修复的bug，编写特殊的Hotfix代码进行修复，测试通过后上传svn服务器；<br>2.通过发布指令，将svn上更新后的Hotfix代码同步到服务器上；<br>3.服务器发现Hotfix代码有更新，则将其压缩序列化后通过socket发送给所有在线的客户端，同时带上字符串的MD5值供客户端验证；<br>4.客户端收到Hotfix消息之后，首先反序列化数据得到代码内容，校验MD5值之后，如果和本地已经执行过的Hotfix的MD5值，则执行替换逻辑，并记录当前已经执行过的Hotfix的MD5值，如果相同则不再执行；<br>5.客户端连接服务器的时候会主动请求一次Hotfix。</p><h1 id="实现方式-项目通过打一个更新包来实现，如果是表格的话可以走Hotfix"><a href="#实现方式-项目通过打一个更新包来实现，如果是表格的话可以走Hotfix" class="headerlink" title="实现方式(项目通过打一个更新包来实现，如果是表格的话可以走Hotfix)"></a>实现方式(项目通过打一个更新包来实现，如果是表格的话可以走Hotfix)</h1><p>执行Hotfix执行的代码非常简单，基于loadstring函数即可：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> f = loadstring(GameContent.HotfixData)</span><br><span class="line"><span class="keyword">if</span> f <span class="keyword">then</span></span><br><span class="line">    ClientUtils.trycall(f)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>这里的实现就没有reload那么复杂，但是也是有一定的限制，比如local的函数或者在闭包的函数依然很难做正确的hotfix,需要编写特殊的Hotfix代码。</p><h2 id="向lua中注册c函数的过程是通过lua-pushcclosure-luaState-fn-n-函数实现的"><a href="#向lua中注册c函数的过程是通过lua-pushcclosure-luaState-fn-n-函数实现的" class="headerlink" title="向lua中注册c函数的过程是通过lua_pushcclosure(luaState, fn, n)函数实现的"></a>向lua中注册c函数的过程是通过lua_pushcclosure(luaState, fn, n)函数实现的</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown</title>
      <link href="/2018/03/19/markdown/"/>
      <url>/2018/03/19/markdown/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity-Lua</title>
      <link href="/2018/03/19/Unity-Lua-1/"/>
      <url>/2018/03/19/Unity-Lua-1/</url>
      
        <content type="html"><![CDATA[<p>逻辑使用脚本来做的好处：</p><ul><li>使用脚本语言的动态特性，客户端可以做Hotfix,服务器可以做Refresh，无论在运营还是开发期这一特性都很有用；</li><li>脚本语言在虚拟机运行，有效控制崩溃率</li><li>上手难度低<br>缺点是运行效率低，但是之前看的LuaJit的效率只是略低于c（有待验证),动态语言容易出一些运行时错误（一般是语法错误），但是调试难度在真机下相对容易一些<br>lua的集成在目前维护的这个项目集成了uLua(感觉算是toLua的前身吧)和sLua(腾讯的SDK集成的).具体性能对比自己就不测试了，（懒）<br>在这里可以看到<a href="http://link.zhihu.com/?target=http%3A//qiankanglai.me/2016/07/31/unity-lua/" target="_blank" rel="noopener">http://link.zhihu.com/?target=http%3A//qiankanglai.me/2016/07/31/unity-lua/</a><h1 id="性能差异的可能原因之一"><a href="#性能差异的可能原因之一" class="headerlink" title="性能差异的可能原因之一"></a>性能差异的可能原因之一</h1>个人感觉ToLua在属性操作方面性能较好，而Vectore的向量操作，因为可能会有Lua层的优化，即在Lua层完全实现了对应的操作（vector.bytes),因此需要针对源码进行详细的对比。至于性能差异的原因，我没有从Lua虚拟机的实现部分分析，只是查看两种生成的Warp后的接口进行一个简单的猜想。<br>选取同一个接口进行对比，UnityEngine.Animator的GetFloat接口，ToLua的实现如下：<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))</span>]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetFloat</span>(<span class="params">IntPtr L</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> count = LuaDLL.lua_gettop(L);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">2</span> &amp;&amp; TypeChecker.CheckTypes(L, <span class="number">1</span>, <span class="keyword">typeof</span>(UnityEngine.Animator), <span class="keyword">typeof</span>(<span class="keyword">int</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            UnityEngine.Animator obj = (UnityEngine.Animator)ToLua.ToObject(L, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> arg0 = (<span class="keyword">int</span>)LuaDLL.lua_tonumber(L, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">float</span> o = obj.GetFloat(arg0);</span><br><span class="line">            LuaDLL.lua_pushnumber(L, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此处省略另一个重载接口</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> LuaDLL.luaL_throw(L, <span class="string">"invalid arguments to method: UnityEngine.Animator.GetFloat"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> LuaDLL.toluaL_exception(L, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>SLua生成的代码如下：<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))</span>]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetFloat</span>(<span class="params">IntPtr l</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> argc = LuaDLL.lua_gettop(l);</span><br><span class="line">        <span class="keyword">if</span>(matchType(l, argc, <span class="number">2</span>, <span class="keyword">typeof</span>(<span class="keyword">int</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            UnityEngine.Animator self = (UnityEngine.Animator)checkSelf(l);</span><br><span class="line">            System.Int32 a1;</span><br><span class="line">            checkType(l, <span class="number">2</span>, <span class="keyword">out</span> a1);</span><br><span class="line">            <span class="keyword">var</span> ret = self.GetFloat(a1);</span><br><span class="line">            pushValue(<span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">            pushValue(<span class="number">1</span>, ret);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> error(<span class="number">1</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们注意到，这一函数只需要一个返回值的，但是SLua往栈里pushValue了两个值，然后返回2。SLua使用一个单独的值来表示函数运行的结果，这对于错误可以进行更好的处理，但是多出的压栈和出栈操作有额外的性能消耗。</p><h1 id="导出方式对比"><a href="#导出方式对比" class="headerlink" title="导出方式对比"></a>导出方式对比</h1><p>ToLua导出的使用的是白名单的方式，在CustomeSetting.cs文件中定义的接口才会导出，也提供了导出引擎所有的接口功能；而SLua是以黑名单的方式进行，默认提供的功能是导出了除了黑名单中的所有模块接口，也是了一个导出最简接口的方式。<br>从使用角度来看，SLua黑名单的方式在开发期比较方便，默认会导出所有接口，因此不需要每次想要增加一个已经存在的类Lua接口都要自己定义然后重新导出，发布的时候也可以使用最简接口。维护起来ToLua因为所有的导出类都是我们自己定义的，因此更加清晰明确。<br>鉴于这部分内容有源码可以进行修改 ，因此不是一个核心需要考虑的内容，两种方式各有利弊。</p><h1 id="如何使用Lua语言"><a href="#如何使用Lua语言" class="headerlink" title="如何使用Lua语言"></a>如何使用Lua语言</h1><p>在进行了初步集成后，怎样让开发人员可以更好地使用Lua语言是接下来面临的问题。<br>ToLua对应有一套之前uLua作者开发的<a href="https://github.com/jarjin/LuaFramework_UGUI" target="_blank" rel="noopener">LuaFramework</a>，这一框架集成了脚本打包和二进制脚本读取，UI制作流程等多个功能，但是也如作者自己所有，这一框架最初源自一个示例形式的Demo，因此其中代码有很多部分是和示例写死的绑定的逻辑，比如启动逻辑，Lua二进制脚本的加载需要手动指定等等。<br>相对应的，SLua也有多套已经开源的框架，其中最为完善的<a href="https://github.com/mr-kelly/KSFramework" target="_blank" rel="noopener">KSFramwork</a>，这套框架集成了资源打包，导表，Lua热重载在内的多个功能，而且代码质量初步开起来还不错，因此最后我们决定把KSFramwork中的SLua部分替换成ToLua的部分来结合使用。<br>改造的过程还比较简单，由于该部分使用Lua耦合的只有两块内容，一是UIControler部分，二是LuaBehavior部分，所有的接口都由LuaModule模块提供。因此改造的过程也就比较明确了：<br>1.删除源代码中的SLua部分，接入ToLua的部分；<br>2.使用ToLua重写LuaModule的实现；<br>3.改造LuaUIController，使用新的LuaModule接口实现之前的功能；<br>4.改造LuaBehavior模块；<br>代码删除和LuaModule模块的重新实现都比较简单，着重介绍一下LuaUIController和LuaBehavior模块的改造。</p><h1 id="改造初衷"><a href="#改造初衷" class="headerlink" title="改造初衷"></a>改造初衷</h1><p>之前的KSFramwork还是一个核心逻辑在C#，Lua只承载UI等逻辑的模块，其实目前逻辑也是这样的，但是个人比较同意“轻引擎，重脚本”，引擎可以看作渲染，资源加载，音效等功能的提供者，脚本逻辑负责使用这些功能构建游戏内容。那这样大部分与逻辑相关的控制权就应该从引擎交给脚本来进行。Unity作为一个比较特殊的例子，虽然对于它来说，C#部分已经是脚本了，但是对于希望着重使用Lua脚本的我们来说，因为C#不可更新，因此被视作了引擎部分。<br>最为简单的设计就是当引擎初始化完毕之后，通过一个接口调用把后续的逻辑都交由脚本来控制，大部分与游戏玩法相关的模型加载、声音播放、特效播放、动画等由脚本控制。tick逻辑为了减少调用次数，没帧也由引擎调用注册的一个脚本接口进行统一调用，脚本层自己做分发。</p><h1 id="LuaUIController的改造"><a href="#LuaUIController的改造" class="headerlink" title="LuaUIController的改造"></a>LuaUIController的改造</h1><p>LuaUIController原始的方式是在C#层通过ui模块的名称加载对应的一个lua文件，获取一个lua table 进行缓存，在比如OnInit等需要接口调用的地方查找这个table中对应的函数进行调用。这种方式的界面是由C#层的逻辑来驱动加载和显示的，而且在加载过程要有文件的搜索和检查过程。<br>这样会存在一个问题，就是脚本层的逻辑无法或者很难或者很难去控制界面对象的生命周期。针对资源的生命周期，“谁创建谁管理”的策略不在可以很方便地来明确责任的划分，因此要进行改造。<br>改造的方向很简单，讲界面在家和显示的接口开放到Lua层，然后在创建的时候由lua层传递一个table对象进来，C#中进行缓存，当界面资源异步加载完毕，需要进行接口调用的地方的实现与之前保存一致。这样，界面资源的生命周期全部交由脚本层来管理，在脚本构建一个结构合理功能齐全的UIManager来进行一些功能的封装，就可以满足大部分的需求。</p><h1 id="LuaBehavior的改造"><a href="#LuaBehavior的改造" class="headerlink" title="LuaBehavior的改造"></a>LuaBehavior的改造</h1><p>MonoBehavior是Unity为了方便开发而提供的一个很好的功能，脚本以组件的方式挂接在GameObject身上，就可以在Awake,Start,Update等接口中处理想要的逻辑。为了能够继续使用Unity的这一特性，在Lua层也实现了一个简单的LuaBehavior封装。<br>KSFramwork中的思路非常简单，同样根据名称来把一个LuaBehavior和一个Lua脚本进行绑定，在对应的逻辑中调用与之对应的接口就可以了，比如Awake接口的实现如下：<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">string</span>.IsNullOrEmpty(LuaPath))</span><br><span class="line">    &#123;</span><br><span class="line">        Init();</span><br><span class="line">        CallLuaFunction(<span class="string">"Awake"</span>);</span><br><span class="line">    &#125;<span class="comment">//else Null Lua Path, pass Awake!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>CallLuaFunction的实现也很明确，从缓存的lua table中获取名称为Awake的function进行调用。这种方式没有问题，但是当场景中挂在了LuaBehavior(项目中是LuaComponent)的GameObject很多的时候，每一帧都会有非常多次的update(这个函数就不要暴露了),这个调用从C#层传递到Lua层，有很多额外的性能消耗。<br>前文也提到了，比较好的方式是没帧只有一个C#到Lua层的Update方法调用，然后脚本层自己做分发。因此，针对这一需求，我们使用ToLua#自带的LuaLooper来实现的这一功能。<br>LuaLooper(项目是自己包装的一个luatimer)是全局只创建一个的MonoBehaviour,注意这里只创建一个只由逻辑来决定的，而不是一个单例模式。这里针对单例模式适合场合的讨论不再展开，此处由逻辑来保证只有一个Looper存在是一件比较合理的事情，预留了一些扩展的可能。<br>LuaLooper以时间的方式讲三种Update分发出去：Update,LateUpdate,FixedUpdate,它在自己对应的函数中调用luaState的对应函数来将事件告知脚本，脚本中需要的模块向分发模块注册回调来监听事件,就可以做到每帧只有一次Update调用了。<br>具体的代码实现可以去看ToLua#中的LuaLooper.cs的类实现。<br>-注意 这里有一个小心的点是当事件在脚本层分发的时候，要注意执行时序问题的影响，最好能够保证任意的执行顺序都可以不影响游戏逻辑的结果，否则可能会出现很难查的诡异bug。<br>对于Awake,Start等一次性调用的函数，由于不是频繁的逻辑，因此保留了原始的实现方式，这样可以让Lua层对应的代码实现更加简洁。而使用事件注册的方式，让不需要update逻辑的脚本没有任何额外的性能消耗。</p>]]></content>
      
      
      
        <tags>
            
            <tag> lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XCAAFS</title>
      <link href="/2018/03/18/XCAAFS/"/>
      <url>/2018/03/18/XCAAFS/</url>
      
        <content type="html"><![CDATA[<p>负载均衡服务器，应用在登录模块上，开新服的时候入口流量会增大，一段时间以后流量会递减或者趋于平缓，市面上已经有了成熟的解决方案了。<br>一般最常用，最简单的也是基于DNS的负载均衡系统了</p>]]></content>
      
      
      
        <tags>
            
            <tag> server </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http</title>
      <link href="/2018/03/18/http/"/>
      <url>/2018/03/18/http/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是http"><a href="#什么是http" class="headerlink" title="什么是http"></a>什么是http</h1><p>超文本传输协议（HTTP）的设计目的是保证客户机与服务器之间的通信。<br>HTTP的工作方式客户端和服务器之前的请求-应答协议</p><h1 id="两种HTTP请求方法：GET和POST"><a href="#两种HTTP请求方法：GET和POST" class="headerlink" title="两种HTTP请求方法：GET和POST"></a>两种HTTP请求方法：GET和POST</h1><ul><li>GET - 从指定的资源请求数据</li><li>POST - 向指定的资源提交要被处理的数据</li></ul><h1 id="GET方法"><a href="#GET方法" class="headerlink" title="GET方法"></a>GET方法</h1><p>请注意，查询字符串（名称/值对）是在GET请求的URL中发送的：</p><pre><code>/test/deme_from.asp?name1=value1&amp;name2=value2</code></pre><p>有关GET请求的其它一些注释：</p><ul><li>GET请求可被缓存</li><li>GET请求保留在浏览器历史纪录中</li><li>GET请求可悲收藏为书签</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>openresty</title>
      <link href="/2018/03/18/openresty/"/>
      <url>/2018/03/18/openresty/</url>
      
        <content type="html"><![CDATA[<p>/usr/local/openresty/luajit:luajit环境，luajit类似于java的jit,即即时编译，lua是一种解释语言，通过luajit可以即时编译lua代码到机器代码，得到很好的性能。<br>/usr/local/openresty/lualib:要使用的lua库，里边提供了一些默认的lua库，如redis,json库等，也可以把自己开发的或者第三方放在这；<br>/usr/local/openresty/nginx:安装的nginx</p><p>/usr/local/openresty/nginx/sbin/nginx -V     查看nginx版本和安装的模块</p><h1 id="启动-nginx"><a href="#启动-nginx" class="headerlink" title="启动 nginx"></a>启动 nginx</h1><pre><code>nginx -p `pwd`/ -c conf/nginx.conf</code></pre><h1 id="重启nginx"><a href="#重启nginx" class="headerlink" title="重启nginx"></a>重启nginx</h1><pre><code>/usr/local/openresty/nginx/sbin/nginx -s reload</code></pre><h1 id="nginx-pid-no-file"><a href="#nginx-pid-no-file" class="headerlink" title="nginx.pid no file"></a>nginx.pid no file</h1><p>nginx -c /home/www/conf/nginx.conf</p><h1 id="add-header-directive-is-not-allowed-here-in"><a href="#add-header-directive-is-not-allowed-here-in" class="headerlink" title="add_header directive is not allowed here in"></a>add_header directive is not allowed here in</h1>]]></content>
      
      
      
        <tags>
            
            <tag> openresty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity打包详细流程</title>
      <link href="/2018/03/13/Unity-PGK/"/>
      <url>/2018/03/13/Unity-PGK/</url>
      
        <content type="html"><![CDATA[<p>打包策略：按照目录划分<br>目录进行分类<br>配置文件如下：<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"AssetBundleInfo"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"assetBundleName"</span>: <span class="string">"ui.bytes"</span>,</span><br><span class="line">            <span class="string">"dirPrefix"</span>: [</span><br><span class="line">                <span class="string">"Art/ResExport/GUI/"</span>,</span><br><span class="line">                <span class="string">"Art/GUI/Atlas/"</span>,</span><br><span class="line">                <span class="string">"res/GUI/res/"</span>,</span><br><span class="line">                <span class="string">"res/GUI/"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"assetBundleName"</span>: <span class="string">"ui_font.bytes"</span>,</span><br><span class="line">            <span class="string">"dirPrefix"</span>: [</span><br><span class="line">                <span class="string">"res/GUI/res/Font/"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"assetBundleName"</span>: <span class="string">"particles.bytes"</span>,</span><br><span class="line">            <span class="string">"dirPrefix"</span>: [</span><br><span class="line">                <span class="string">"res/Particles/"</span>,</span><br><span class="line">                <span class="string">"Art/Particles/"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"assetBundleName"</span>: <span class="string">"gfx.bytes"</span>,</span><br><span class="line">            <span class="string">"dirPrefix"</span>: [</span><br><span class="line">                <span class="string">"res/FX/"</span>,</span><br><span class="line">                <span class="string">"res/SkillWarning/"</span>,</span><br><span class="line">                <span class="string">"res/Shader/"</span>,</span><br><span class="line">                <span class="string">"PluginsScripts/NGUI/Resources/Shaders/"</span>,</span><br><span class="line">                <span class="string">"Art/Graphics/shader/"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"assetBundleName"</span>: <span class="string">"misc.bytes"</span>,</span><br><span class="line">            <span class="string">"dirPrefix"</span>: [</span><br><span class="line">                <span class="string">"Art/"</span>,</span><br><span class="line">                <span class="string">"res/"</span>,</span><br><span class="line">                <span class="string">"Resources/"</span>,</span><br><span class="line">                <span class="string">"Plugins/"</span>,</span><br><span class="line">                <span class="string">"PluginsScripts/"</span>,</span><br><span class="line">                <span class="string">"Models/"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"assetBundleName"</span>: .bytes<span class="string">",</span></span><br><span class="line"><span class="string">"</span>dirPrefix<span class="string">": [</span></span><br><span class="line"><span class="string">"</span>Scenes/Assets Skyboxes/<span class="string">"</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">"</span>assetBundleName<span class="string">": "</span>scenes.bytes<span class="string">",</span></span><br><span class="line"><span class="string">"</span>dirPrefix<span class="string">": [</span></span><br><span class="line"><span class="string">"</span>res/Scenes/<span class="string">",</span></span><br><span class="line"><span class="string">"</span>Scenes/<span class="string">"</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">],</span></span><br><span class="line"><span class="string">"</span>PackageInfo<span class="string">": [</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">"</span>pkgName<span class="string">": "</span>cfg<span class="string">",</span></span><br><span class="line"><span class="string">"</span>dirPrefix<span class="string">": [</span></span><br><span class="line"><span class="string">"</span>cfg/<span class="string">"</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">"</span>pkgName<span class="string">": "</span>lang<span class="string">",</span></span><br><span class="line"><span class="string">"</span>dirPrefix<span class="string">": [</span></span><br><span class="line"><span class="string">"</span>Assets/Art/lang<span class="string">"</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">"</span>pkgName<span class="string">": "</span>code<span class="string">",</span></span><br><span class="line"><span class="string">"</span>dirPrefix<span class="string">": [</span></span><br><span class="line"><span class="string">"</span>cfg/<span class="string">",</span></span><br><span class="line"><span class="string">"</span>mb/<span class="string">",</span></span><br><span class="line"><span class="string">"</span>Lua/<span class="string">"</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">"</span>pkgName<span class="string">": "</span>gfx<span class="string">",</span></span><br><span class="line"><span class="string">"</span>dirPrefix<span class="string">": [</span></span><br><span class="line"><span class="string">"</span>FX/<span class="string">",</span></span><br><span class="line"><span class="string">"</span>MaterialEx/<span class="string">",</span></span><br><span class="line"><span class="string">"</span>Shader/<span class="string">",</span></span><br><span class="line"><span class="string">"</span>SkillWarning/<span class="string">",</span></span><br><span class="line"><span class="string">"</span>Textures/<span class="string">",</span></span><br><span class="line"><span class="string">"</span>Still/<span class="string">",</span></span><br><span class="line"><span class="string">"</span>bones/<span class="string">",</span></span><br><span class="line"><span class="string">"</span>weapons/<span class="string">",</span></span><br><span class="line"><span class="string">"</span>Equips/<span class="string">"</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">"</span>pkgName<span class="string">": "</span>gui<span class="string">",</span></span><br><span class="line"><span class="string">"</span>dirPrefix<span class="string">": [</span></span><br><span class="line"><span class="string">"</span>GUI/<span class="string">"</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">"</span>pkgName<span class="string">": "</span>particles<span class="string">",</span></span><br><span class="line"><span class="string">"</span>dirPrefix<span class="string">": [</span></span><br><span class="line"><span class="string">"</span>Particles/<span class="string">",</span></span><br><span class="line"><span class="string">"</span>Assets/Art/Particles/<span class="string">"</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">"</span>pkgName<span class="string">": "</span>scenes<span class="string">",</span></span><br><span class="line"><span class="string">"</span>dirPrefix<span class="string">": [</span></span><br><span class="line"><span class="string">"</span>Scenes/<span class="string">",</span></span><br><span class="line"><span class="string">"</span>scn/<span class="string">"</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">"</span>pkgName<span class="string">": "</span>sounds<span class="string">",</span></span><br><span class="line"><span class="string">"</span>dirPrefix<span class="string">": [</span></span><br><span class="line"><span class="string">"</span>Sounds/<span class="string">",</span></span><br><span class="line"><span class="string">"</span>Assets/Art/Sounds/<span class="string">"</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">"</span>pkgName<span class="string">": "</span>animations<span class="string">",</span></span><br><span class="line"><span class="string">"</span>dirPrefix<span class="string">": [</span></span><br><span class="line"><span class="string">"</span>Animations/<span class="string">"</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">"</span>pkgName<span class="string">": "</span>scenes_mesh<span class="string">",</span></span><br><span class="line"><span class="string">"</span>dirPrefix<span class="string">": [</span></span><br><span class="line"><span class="string">"</span>Assets/Art/Scene/_Mesh/<span class="string">"</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">"</span>pkgName<span class="string">": "</span>scenes_assets<span class="string">",</span></span><br><span class="line"><span class="string">"</span>dirPrefix<span class="string">": [</span></span><br><span class="line"><span class="string">"</span>Assets/Scenes/<span class="string">"</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">"</span>pkgName<span class="string">": "</span>models<span class="string">",</span></span><br><span class="line"><span class="string">"</span>dirPrefix<span class="string">": [</span></span><br><span class="line"><span class="string">"</span>Assets/Models/<span class="string">"</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">"</span>pkgName<span class="string">": "</span>misc<span class="string">",</span></span><br><span class="line"><span class="string">"</span>dirPrefix<span class="string">": [</span></span><br><span class="line"><span class="string">"</span>Assets/<span class="string">"</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">"</span>pkgName<span class="string">": "</span>pandora<span class="string">",</span></span><br><span class="line"><span class="string">"</span>dirPrefix<span class="string">": [</span></span><br><span class="line"><span class="string">"</span>pandora/<span class="string">"</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p><p>不使用Resources的原因是，打包程序的时候会将Resources目录下的全部文件都加密压缩达到包内，这样如果我们想使用assetbundle方式打小包就不行了（比如更新包）。<br>1.多语言文件先导入<br>2.根据配置文件生成包信息，AssetBundleInfo,AssetBundleIndex<br>3.处理Res目录资源<br>4.AssetDatabase.GetDependencies<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> nameParam = <span class="keyword">new</span> <span class="keyword">string</span>[<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">string</span>[] <span class="title">GetDirectDeps</span>(<span class="params"><span class="keyword">string</span> uri</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DepInfo depInfo = <span class="keyword">new</span> DepInfo();</span><br><span class="line">    nameParam[<span class="number">0</span>] = uri;</span><br><span class="line">    <span class="keyword">var</span> deps = AssetDatabase.GetDependenices(nameParem, <span class="literal">true</span>);<span class="comment">//查找这个资源引用了哪些资源,cs和js文件不用处理</span></span><br><span class="line">    depInfos[uri] = depInfo;<span class="comment">//global</span></span><br><span class="line">    <span class="keyword">return</span> deps;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">string</span>[] <span class="title">MakeDepends</span>(<span class="params"><span class="keyword">string</span> uri</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> deps = GetDirectDeps(uri);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addPkgFile</span>(<span class="params"><span class="keyword">string</span> filePath, <span class="keyword">bool</span> isCompress, <span class="keyword">string</span> accessPath, <span class="keyword">byte</span> fileType, <span class="keyword">byte</span> loadType</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    accessPath = accessPath.ToLower();</span><br><span class="line">    PkgInfo.FileInfo fileInfo = NewPkgFileInfo(filePath, isCompress, accessPath, )</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> IEnumerator <span class="title">ProcessSounds</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    titleText = <span class="string">"处理音频"</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">string</span> soundsDir = Application.dataPath + <span class="string">"/Art/Sounds"</span>;</span><br><span class="line">    <span class="keyword">if</span> (System.IO.Exists(soundsDir))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> rootSize = Application.dataPath.Length - <span class="number">6</span>;<span class="comment">//Assets</span></span><br><span class="line">        <span class="keyword">string</span>[] file = System.IO.Directory.GetFiles(soundsDir, <span class="string">"*.bank"</span>, SearchOption.AllDirectories);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> file <span class="keyword">in</span> files)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">string</span> path = file.SubString(rootSize).ToLower().Replace(<span class="string">'\\'</span>, <span class="string">'/'</span>);</span><br><span class="line">            addPkgFile(path, <span class="literal">false</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            addFileProcessed.Add(path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> IEnumerator <span class="title">DoProcess</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">yield</span> return <span class="title">ProcessRes</span>(<span class="params">resUri</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (!isRuning) <span class="keyword">yield</span> <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> return <span class="title">ProcessSounds</span>(<span class="params"></span>)</span>;<span class="comment">//smod,因为unity自带的容易崩溃</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mono-1</title>
      <link href="/2018/03/13/Mono-1/"/>
      <url>/2018/03/13/Mono-1/</url>
      
        <content type="html"><![CDATA[<p>Mono主要包含了C#的编译器，CLI(Common Language Infrastructure)实现和一系列相关的开发工具。</p><h1 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h1><p>msc:<br>    msc: Mono实现的基于Ecma标准的C#编译器。<br>    class:CLI的C#的实现。类似于Android中的Java蹭，应用程序看到的是这一层提供的接口。这一层是平台无关的。<br>    ilasm:反汇编器，将Native code反汇编成bytecode。<br>mono:<br>    mini:JIT编译器，将bytecode编译成native code。<br>    metadata:Mono的runtime,CLI的Native级的下实现。<br>    io-layer:与操作系统的接口实现，像socket,thread,mutex这些。<br>liggc:GC实现的一部分。</p><h1 id="Mono主要工作框架"><a href="#Mono主要工作框架" class="headerlink" title="Mono主要工作框架"></a>Mono主要工作框架</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">mini/main.c:main()</span><br><span class="line">    mono_main_with_options()</span><br><span class="line">        mono_mian()</span><br><span class="line">            mini_ini()</span><br><span class="line">            mono_assembly_open()</span><br><span class="line">            main_thread_handler()<span class="comment">//assembly(也就是bytecode)的编译执行</span></span><br><span class="line">            mini_cleanup()</span><br><span class="line">main_thread_handler()</span><br><span class="line">    mono_jit_exec()</span><br><span class="line">        mono_assembly_get_image()<span class="comment">//得到image信息，如"test.ext"</span></span><br><span class="line">        mono_image_get_entry_point()<span class="comment">//得到类，方法信息</span></span><br><span class="line">        mono_runtime_run_main(method,argc,argv,<span class="keyword">NULL</span>)</span><br><span class="line">            mono_thread_set_main(mono_thread_current());<span class="comment">//把当前线程设为主线程</span></span><br><span class="line">            mono_assembly_set_main()</span><br><span class="line">            mono_runtime_exec_main() <span class="comment">//编译及调用目标方法</span></span><br><span class="line">mono_runtime_exec_main()</span><br><span class="line">    mono_runtime_invoke(method, <span class="keyword">NULL</span>, pa, exc)<span class="comment">//要调用的方法，如"ClassName::Main()"</span></span><br><span class="line">        default_mono_runtime_invoke()<span class="comment">//实际上是调用了mono_jit_runtime_invoke()</span></span><br><span class="line">            info-&gt;compiled_method = mono_jit_compile_method_with_opt(method)<span class="comment">//编译目标函数</span></span><br><span class="line">            info-&gt;runtime_invoke = mono_jit_compile_method()<span class="comment">//编译目标函数的runtime wrapper</span></span><br><span class="line">                mono_jit_compile_method_with_opt(method,default_opt,&amp;ex)</span><br><span class="line">            runtime_invoke=info-&gt;runtime_invoke</span><br><span class="line">            runtime_invoke(obj,pararms,exc,info-&gt;compiled_method)<span class="comment">//调用wrapper,wrapper会调用目标方法</span></span><br><span class="line">mono_jit_compile_method_with_opt()</span><br><span class="line">    mono_jit_compile_method_inner()</span><br><span class="line">        mini_method_compile(method, opt, target_domain, <span class="keyword">TRUE</span>, <span class="keyword">FALSE</span>, <span class="number">0</span>)<span class="comment">//通过JIT编译给定方法</span></span><br><span class="line">        mono_runtime_class_init_full()<span class="comment">//初始化方法所在对象</span></span><br><span class="line">            method=mono_class_get_cctor()<span class="comment">//得到类的构造函数</span></span><br><span class="line">            <span class="keyword">if</span>(do_initialization)<span class="comment">//对象需要初始化</span></span><br><span class="line">                mono_runtime_invoke()<span class="comment">//调用相应构造函数来构造对象，如"System.console:.cctor()"</span></span><br><span class="line">                    mono_jit_runtime_invoke()</span><br></pre></td></tr></table></figure><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><p>垃圾回收(GC)是CLI中很重要的部分，</p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>应用程序或者Mono runtime中的一些异步恩物可以交由单独线程完成。Mono中提供了两个线程池:async_tp和async_io_tp。往线程池加线程函数为threadpool_append_jobs()，当第一次试图往里边加线程时，会进行初始化，起一个”Monitor”线程(该线程执行monotor_thread())。现在假设</p><h1 id="Mono内存"><a href="#Mono内存" class="headerlink" title="Mono内存"></a>Mono内存</h1><p>内存占用：</p><ol><li>库代码：Unity库、第三方库</li><li>Native堆：资源、Unity逻辑、第三方逻辑</li><li>Mono堆：C#代码</li></ol><p>Unity游戏逻辑代码所使用的语言为C#，我们知道C#代码所占用的内存又称为mono内存，由于Unity它是通过mono来跨平台解析并运行C#代码的，它在Android系统上面，因此游戏的lib目录下存在的libmono.so文件，就是mono在Android系统上的实现。</p><p>C#的代码是通过mono来解析执行的，所需要的内存字然也是由mono来进行分配管理，下面来介绍一个mono的内存管理策略以及内存泄漏分析。</p><h1 id="Mono内存管理的基本策略"><a href="#Mono内存管理的基本策略" class="headerlink" title="Mono内存管理的基本策略"></a>Mono内存管理的基本策略</h1><p>Mono通过垃圾回收机制(GarbageCollect，简称GC)堆内存进行管理。Mono内存分为两部分，已用内存(used)和堆内存(heap)，已用内存它指的是mono实际需要使用的内存，堆内存指的是mono向操作系统申请的内存，两者的差值就是mono的空闲内存。</p><p>当mono需要分配内存时，首先是会查看空闲内存是否足够，若足够的话，则是直接在空闲内存中分配，否则mono会进行一次GC以释放更多的内存，如果GC之后仍然没有足够的空闲内存，则mono会向操作系统申请内存，并扩充堆内存。</p><p>C/C++ Mono运行时 托管代码(CIL)</p><p>将Mono运行时潜入应用，可以分为三个步骤：</p><ol><li>编译C++程序和链接</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Mono </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试经历</title>
      <link href="/2018/03/13/interview-1/"/>
      <url>/2018/03/13/interview-1/</url>
      
        <content type="html"><![CDATA[<ul><li>程序的优化处理，这个是面试考察的重点，内存的管理也是Unity开发的重中之重。内存管理无非就是对内存的使用，针对UI的内存管理使用的图集方式，Unity自身的图集功能浪费内存，比如2048 * 2048的图集大小，它占的内存是4M，也就是说不管图集是否填满，它都需要在内存中开辟4M的空间，但是如果使用Texture Packer工具就可以节省没有填满的空间，针对大量UI的加载可以采用分类打包图集的方法处理。当然内存池的使用也是可以应用到UI的管理，另外就是3D场景资源的管理，需要场景图片有自己的图库，这样图片可以重复利用，另外模型的面熟，骨骼数量，材质数量都是需要去关注。</li><li>内存优化还需要涉及到图片的格式，不带Alpha通道的图片采用jpg格式，带有Alpha通过的采用png格式，这是一种处理方式，另外一种处理方式就是将Alpha通道单独拿出来，所有的图片都是jpg格式，然后用带有Alpha通道的图片跟jpg格式文件进行结合使用。</li><li>在结构涉及方面，就要注意了，代码的编写，比如常用的设计模式，工厂模式，单例模式，MVC模式，FSM模式，观察者模式等，这些模式作为开发者必须要掌握的。</li><li>八、接下来就是Shader的编写了，可以使用Shader Forge编辑器，对于一些材质渲染非常好用，这个可以作为读者学习Shader的工具。</li><li>九、另外对于C#中定义的String，StringBuilder或者List,ArrayList等它们之间的区分要搞清楚。</li><li>十、不同机型的适配处理，技术验证等。</li><li>十一、热更新技术的实现，市面上应用比较广的ulua作为脚本语言架构设计。</li><li>十二、作为客户端开发者也需要了解网络方面的知识，比如tcp,udp,http这些协议的处理方式。</li><li>十三、场景、导航、寻路</li><li>十四、作为渲染场景的后处理方式，比如Bloom,Blur,HDR,SSAO,PSSM等等。</li><li>十五、C#中的事件监听，委托的使用也要熟练掌握。</li><li>十六、协程与多线程的区别。</li><li>十七、文本文件的加载，比如json,xml,csv,二进制等等。</li></ul><p>GC是Mono运行时的机智，而非Unity3D引擎的机制，所以GC也主要是针对Mono对象来说的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"lyf"</span>);</span><br></pre></td></tr></table></figure><p>在运行时涉及了几个String Object<br>两个，一个是字符串字面量”lyf”所对应的，驻留(intern)在一个全局共享的字符串常量池中的实例，i另一个是通过new String(String)创建并初始化的、内容于”lyf”相同的实例</p><h1 id="OpenGL中要用到哪几种buffer"><a href="#OpenGL中要用到哪几种buffer" class="headerlink" title="OpenGL中要用到哪几种buffer"></a>OpenGL中要用到哪几种buffer</h1><p>帧缓冲(Frame Buffer)<br>颜色缓冲(Color Buffer)<br>模版缓冲(Stencil Buffer)<br>顶点缓冲(Vertice Buffer)<br>深度缓冲(Depth Buffer)</p><h1 id="冰川网络面试"><a href="#冰川网络面试" class="headerlink" title="冰川网络面试"></a>冰川网络面试</h1><p>由于很久没有复习，导致笔试面试猜的抠脚，冰川给我整体印象还是不错的，人力小姐姐说是600人的大公司，可惜我进不去了。</p><h2 id="笔试题"><a href="#笔试题" class="headerlink" title="笔试题"></a>笔试题</h2><p>1.啥子是泛型？给你一个CBase基类，写一个继承CBase的泛型。<br>百度答：所谓泛型，即通过参数化类型来实现在同一份代码操作多种数据类型。<br>我答：类的数据成员不固定，成员函数的返回值和传参类型不固定的，这样的方式叫做泛型。本想说这样的类叫做泛型类，但是人家问的是泛型，只能说这样的方式了。</p><p>我不知道写一个继承CBase的泛型考点是啥子，然后我就开始瞎写<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CDrive</span>:<span class="title">public</span> <span class="title">CBase</span> <span class="comment">// 为毛还要加public，难道还有公有继承，保护继承，私有继承？？？</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> Do&lt;T&gt;(T t) <span class="comment">// 这他妈写的什么玩意。</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.Awake,Start,OnEnable的执行顺序<br>简直简单的一逼，Awake-&gt;OnEnable-&gt;Start<br>3.啥子是反射？写一段加载程序集，然后获取类型Type，然后通过方法名调用<br>网上答案：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InvokeReflection</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Learn00();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Learn00</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * System.Reflection.Assembly类有两个静态方法：Assembly.Load(string assemblyname)和Assembly.LoadFrom(string filename) 。</span></span><br><span class="line"><span class="comment">         * 通常用这两个方法把程序集加载到应用程序域中。 如果你希望加载的程序集超出了CLR的预定探查范围，你可以用Assembly.LoadFrom直接从一个文件位置加载程序集。</span></span><br><span class="line"><span class="comment">         * Assembly.LoadFrom()和Assembly.LoadFile()，两者的主要区别有两点：</span></span><br><span class="line"><span class="comment">         * 一：Assembly.LoadFile()只载入指定的dll文件，而不会自动加载相关的dll文件。如果下文例子使用Assembly.LoadFile()加载SayHello.dll，那么程序就只会加载</span></span><br><span class="line"><span class="comment">         * SayHello.dll而不会去加载SayHello.dll引用的BaseClass.dll文件。</span></span><br><span class="line"><span class="comment">         * 二：Assembly.LoadFrom()载入一个Assembly时，会先检查前面是否已经载入过相同名字的Assembly；Assembly.LoadFile()则不会做类似的检查。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//C:\Users\Administrator\Desktop\New Unity Project\Assets\DLL</span></span><br><span class="line">        Assembly assemly2 = Assembly.LoadFrom(<span class="string">@"C:\Users\Administrator\Desktop\New Unity Project\Assets\Scripts\TestReflection.dll"</span>);</span><br><span class="line">        Assembly assemly1 = Assembly.LoadFile(<span class="string">@"C:\Users\Administrator\Desktop\New Unity Project\Assets\Scripts\TestReflection.dll"</span>);</span><br><span class="line">        Assembly assemly = Assembly.Load(<span class="string">"TestReflection"</span>);<span class="comment">//1填加DLL</span></span><br><span class="line">        Type testType = assemly.GetType(<span class="string">"HaiLan.TestReflection.TestReflectionDLL"</span>);<span class="comment">//2获取对应的类信息，需要填加对应的命名空间</span></span><br><span class="line">        <span class="keyword">object</span> oTestReflectionDLL = Activator.CreateInstance(testType);<span class="comment">//3 创建对象</span></span><br><span class="line">        IReflectionDLL iTestReflectionDLL = oTestReflectionDLL <span class="keyword">as</span> IReflectionDLL;<span class="comment">//4 类型转换</span></span><br><span class="line">        iTestReflectionDLL.TestShow1();<span class="comment">//5 方法调用</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> assemly.GetModules())</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(item.Name);<span class="comment">//打印结果 TestReflection.dll</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> type <span class="keyword">in</span> assemly.GetTypes())</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(type.Name);</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> type.GetMethods())</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.Log(item.Name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4.avatar如何换装？<br>5.啥子是Prefab，如何获取一个Prefab实例化的GameObject的类型？PrefabInstance和PrefabModelInstance有啥子区别（我都不知道他在问啥子）<br>6.获取一个Render的材质，然后设置流光shader的uniform/<br>7.地震了，狗跑了，房屋塌了，人慌了，这是哪个设计模式？写出伪代码或者画出流程图；要求可扩展<br>8.给你一个新项目，内存贼高，FPS贼低，咋优化，是Xlua和C#写的。<br>我答：<br>UI：用Profile抓GC，DrawCall，如果是Lua写的，抓函数逻辑占用的内存大小和GC<br>场景：检查面数，静态合批，<br>角色：<br>脚本：<br>预制体：检查是否有Miss Script，检查是否有太多的无用序列化逻辑<br>减少灯光的数量<br>9.说一哈AssetBundle的打包和加载</p><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>显示针对笔试题答得不好的问了几个，我没写设计模式那个，他问了问，还有换装那个我也不会他也问了一下。<br>问：你经过过啥子比较难忘的经历在项目上，或者遇到啥子困难，来扯会蛋。我实在不知道咋扯，就说了剧情编辑器的旋转bug和撤销重做bug。<br>还问了一个咋子判断线段和多边形是否相交？这个我做触发器写的，然鹅给忘了。。<br>正解：判断点（p）是否在多边形中，可以先以点p向左引一条射线（L），我们知道，从射线L左端的无穷远处开始一直到点P的过程中，当遇到多边形的第一个交点是L进入多边形，当遇到第二个交点时，L穿出了多边形。可知，规律如下，当在遇到P点之前L与多边形的交点为偶数个时，说明p点不在多边形内，当在遇到p点之前L与多边形交点为奇数个时，说明P点在多边形内。<br>但是，这个规律并不具有普遍性，还有几种特殊情况不满足此规律，需要额外考虑：<br>（1）当点P在多边形的某条边上，可以直接判断其在多边形中。<br>（2）对于多边形的水平边不做考虑</p><p>然后实在不想和我尬聊了吧，就说你对我们这块有想了解点啥。我寻思不用尬聊了，我就说我面试的太菜了，就啥也不问了。<br>再见。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【《Real-Time Rendering 3rd》 提炼总结】(二) 第二章 · 图形渲染管线 The Graphics Rendering Pipeline</title>
      <link href="/2018/03/13/Real-Time-Rendering-3rd-2/"/>
      <url>/2018/03/13/Real-Time-Rendering-3rd-2/</url>
      
        <content type="html"><![CDATA[<h1 id="一、全文内容思维导图"><a href="#一、全文内容思维导图" class="headerlink" title="一、全文内容思维导图"></a>一、全文内容思维导图</h1><h2 id="1-章节框架思维导图"><a href="#1-章节框架思维导图" class="headerlink" title="1.章节框架思维导图"></a>1.章节框架思维导图</h2><p><img src="http://oxcvfpext.bkt.clouddn.com/Real-Time-Rendering-3rd-2-1.png"></p><h2 id="2-知识结构思维导图"><a href="#2-知识结构思维导图" class="headerlink" title="2.知识结构思维导图"></a>2.知识结构思维导图</h2><p><img src="http://oxcvfpext.bkt.clouddn.com/Real-Time-Rendering-3rd-2-2.png"></p><h1 id="二、核心内容分节提炼"><a href="#二、核心内容分节提炼" class="headerlink" title="二、核心内容分节提炼"></a>二、核心内容分节提炼</h1><h2 id="2-1-图像渲染管线架构概述-Architecture"><a href="#2-1-图像渲染管线架构概述-Architecture" class="headerlink" title="2.1 图像渲染管线架构概述 Architecture"></a>2.1 图像渲染管线架构概述 Architecture</h2><p>渲染管线的主要功能就是决定再给虚拟相机、三维物体、光源、照明模式，以及纹理等诸多条件的情况下，生成或绘制一副二维图像的过程。<br>对于实时渲染来说，渲染管线就是基础。因此，我们可以说，渲染管线是实时渲染的底层工具。<br><img src="http://oxcvfpext.bkt.clouddn.com/Real-Time-Rendering-3rd-2-3.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Real-Time Rendering 3rd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性能优化，永无止境---CPU篇</title>
      <link href="/2018/03/05/optimzation-cpu/"/>
      <url>/2018/03/05/optimzation-cpu/</url>
      
        <content type="html"><![CDATA[<p>性能优化是游戏项目开发工程中一个永恒的话题。玩家的需求和项目的要求永远都在不停增长，同屏人数、屏幕特效和场景复杂度永远在向着”榨干“硬件的趋势毕竟。所以，无论硬件设备发展到何种成都，无论研发团队有多么丰富的经验积累，性能优化永远是一个非常棘手而又无法绕开的问题。</p><p>就当前游戏而言，性能优化主要是围着CPU、GPU和内存三大方面进行。下面，我们就这三方面说说当前移动游戏项目中存在的普遍问题的相应的解决方案。</p><h1 id="CPU方面"><a href="#CPU方面" class="headerlink" title="CPU方面"></a>CPU方面</h1><p>就目前的Unity移动游戏而言，CPU方面的性能开销主要可归结为两大类：引擎模块性能开销和自身代码性能开销。其中，引擎模块中又可细致划分为渲染模块、动画模块、物理模块、UI模块、粒子系统、加载模块和GC调用等等。正因如此，我们在UWA测评报告中，就这些模块进行详细的性能分析，以方便大家快速定位项目的性能瓶颈，同时，根据我们的分析和建议对问题进行迅速排查和解决。<br>通过大量的性能测评数据，我们发现渲染模块、UI模块和加载模块，往往占据了游戏CPU性能开销的Top3。</p><h2 id="一、渲染模块"><a href="#一、渲染模块" class="headerlink" title="一、渲染模块"></a>一、渲染模块</h2><p>渲染模块可以说是任何游戏中最为消耗CPU性能的引擎模块，因为几乎所有的游戏都离不开场景、物体和特效的渲染。对于渲染模块的优化，主要从以下两个方面入手：</p><h3 id="（1）降低Draw-Call"><a href="#（1）降低Draw-Call" class="headerlink" title="（1）降低Draw Call"></a>（1）降低Draw Call</h3><p>Draw Call是渲染模块优化方面的重中之重，一般来说，Draw Call越高，则渲染模块的CPU开销越大。究其原因，要从底层Driver和GPU的渲染流程讲起，限于篇幅我们不在这里做过的的介绍。<a href="https://stackoverflow.com/questions/4853856/why-are-draw-calls-expensive" target="_blank" rel="noopener">https://stackoverflow.com/questions/4853856/why-are-draw-calls-expensive</a><br>降低Draw Call的方法则主要是减少所渲染物体的材质种类，并通过Draw Call Batching来减少其数量。Unity文档对于Draw Call Batching的原理和注意事项有非常详细的讲解。</p><p>但是，需要主要的是，游戏性能并非Draw Call越小越好。这是因为，决定渲染模块性能的除了Draw Call之外，还有用于传输渲染数据的总线带宽。当我们使用Draw Call Batching将同种材质的网格模块拼合在一起，可能会造成同一时间需要传输的数据(Texture、VB/IB等)大大增加，以至于造成带宽”阻塞”，在资源无法及时传输过去的情况下，CPU只能等待，从而反倒降低了游戏的运行帧率。</p><p>Draw Call和总线带宽是天平的两端，我们需要做的是尽可能维持天平的平衡，任何一边过高或过低，对性能来说都是无益的。</p><h3 id="（2）简化资源"><a href="#（2）简化资源" class="headerlink" title="（2）简化资源"></a>（2）简化资源</h3><p>简化资源是非常行之有效的优化手段。在大量的移动中，其渲染资源其实是“过量”的，过量的网格资源、不合规的纹理资源等等。所以，我们在UWA测评报告中对资源的使用进行了详细的展示（每帧的三角形片数、网格和纹理资源的具体使用情况等），以帮助大家查找和完善存在问题的资源。</p><p>关于渲染模块在CPU方面的优化方法还有很多，比如LOD、Occlusion Culling和Culling Distance等等。我们会在后续的渲染模块技术专题中进行更为详细的讲解，敬请期待。</p><h2 id="二、UI模块"><a href="#二、UI模块" class="headerlink" title="二、UI模块"></a>二、UI模块</h2><p>UI模块同样也是几乎所有的游戏项目中必备的模块。一个性能优异的UI模块可以将用户体验在抬高一个档次。在目前国内的大量项目中，NGUI作为UI解决方案的占比仍然非常高。所以，UWA测评报告对NGUI的性能分析进行了极大的支持，我们会根据用户所使用的UI解决方案（UGUI或NGUI）的不同提供不同的性能分析和优化建议。</p><p>在NGUI的优化方面，UIPanel.LateUpdate为性能优化的重中之重，它是NGUI中CPU开销最大的函数，没有之一。UI模块制作的难点并不在于其表现上，因为UI界面的表现力是由设计师来决定的，但两套表现完全一直的UI系统，其底层的性能开销则可能千差万别。如何让UI系统使用尽可能小的CPU开销来达到设计师所设计的表现力，则足以考验每一位UI开发人员的制作功底。<br>对于UIPanel.LateUpdate的优化，主要着眼于UIPanel的布局，其原则如下：</p><ul><li>尽可能将动态UI元素和静态UI元素分离到不同的UIPanel中(UI的重建以UIPanel为单位)，从而尽可能将因为变动的UI模块引起的重构控制在较小的范围内；</li><li>尽可能让动态UI元素按照同步性进行划分，即运动频率不同的UI元素尽可能分离放在不同的UIPanel中；</li><li>控制同一个UIPanel中动态UI元素的数量，数量越多，所创建的Mesh越大，从而使得重构的开销显著增加，比如，战斗过程中的HUD运动血条可能会出现较多，此时，建议研发团队将运动血条分离成不同的UIPanel，每组UIPanel下5~10个动态UI为宜，其本质是从概率上尽可能降低单帧中UIPanel的重建开销。</li></ul><h2 id="三、加载模块"><a href="#三、加载模块" class="headerlink" title="三、加载模块"></a>三、加载模块</h2><p>加载模块同样也是任何游戏项目中所不可缺少的组成成分。与之前两个模块不同的是，加载模块的性能开销比较集中，主要出现于场景切换处，且CPU占用峰值均较高。</p><p>场景切换时的主要性能开销比较集中，主要出现于场景切换处，且CPU占用峰值均较高。</p><h3 id="1-场景卸载"><a href="#1-场景卸载" class="headerlink" title="1.场景卸载"></a>1.场景卸载</h3><p>对于Unity引擎而言，场景卸载是由引擎自动完成的，即当我们调用类似Application.LoadLevel的API时，引擎即会开始对上一场景进行处理，其性能开销主要被以下几个部分占据：</p><ul><li>Destroy<br>  引擎再切换场景时会收集未标识成”DontDestoryOnLoad”的GameObject及其Component，然后进行Destroy。同时，代码中的OnDestroy被触发执行，这里的性能开销主要取决于OnDestroy回调函数中的代码逻辑。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> uwa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六部分 GPU计算</title>
      <link href="/2018/03/03/note6/"/>
      <url>/2018/03/03/note6/</url>
      
        <content type="html"><![CDATA[<h1 id="第六部分-GPU计算"><a href="#第六部分-GPU计算" class="headerlink" title="第六部分 GPU计算"></a>第六部分 GPU计算</h1><h2 id="第三十五章-使用CPU进行病毒特征的快速匹配"><a href="#第三十五章-使用CPU进行病毒特征的快速匹配" class="headerlink" title="第三十五章 使用CPU进行病毒特征的快速匹配"></a>第三十五章 使用CPU进行病毒特征的快速匹配</h2><h3 id="35-1-介绍"><a href="#35-1-介绍" class="headerlink" title="35.1 介绍"></a>35.1 介绍</h3><h3 id="35-2-模式匹配"><a href="#35-2-模式匹配" class="headerlink" title="35.2 模式匹配"></a>35.2 模式匹配</h3><h3 id="35-3-GPU实现"><a href="#35-3-GPU实现" class="headerlink" title="35.3 GPU实现"></a>35.3 GPU实现</h3><h3 id="35-4-结果"><a href="#35-4-结果" class="headerlink" title="35.4 结果"></a>35.4 结果</h3><h3 id="35-5-结论和后续工作"><a href="#35-5-结论和后续工作" class="headerlink" title="35.5 结论和后续工作"></a>35.5 结论和后续工作</h3><h3 id="35-6-参考资料"><a href="#35-6-参考资料" class="headerlink" title="35.6 参考资料"></a>35.6 参考资料</h3><h2 id="第三十六章-用CPU进行AES加密和解密"><a href="#第三十六章-用CPU进行AES加密和解密" class="headerlink" title="第三十六章 用CPU进行AES加密和解密"></a>第三十六章 用CPU进行AES加密和解密</h2><h2 id="第三十七章-使用CUDA进行高效的随机数生成及应用"><a href="#第三十七章-使用CUDA进行高效的随机数生成及应用" class="headerlink" title="第三十七章 使用CUDA进行高效的随机数生成及应用"></a>第三十七章 使用CUDA进行高效的随机数生成及应用</h2><h2 id="第三十八章-使用CUDA进行地球内部成像"><a href="#第三十八章-使用CUDA进行地球内部成像" class="headerlink" title="第三十八章 使用CUDA进行地球内部成像"></a>第三十八章 使用CUDA进行地球内部成像</h2><h2 id="第三十九章-使用CUDA的并行前缀和（扫描方法）"><a href="#第三十九章-使用CUDA的并行前缀和（扫描方法）" class="headerlink" title="第三十九章 使用CUDA的并行前缀和（扫描方法）"></a>第三十九章 使用CUDA的并行前缀和（扫描方法）</h2><h2 id="第四十章-高斯函数的增量计算"><a href="#第四十章-高斯函数的增量计算" class="headerlink" title="第四十章 高斯函数的增量计算"></a>第四十章 高斯函数的增量计算</h2><h2 id="第四十一章-使用几何体着色器处理紧凑和可变长度的GPU反馈"><a href="#第四十一章-使用几何体着色器处理紧凑和可变长度的GPU反馈" class="headerlink" title="第四十一章 使用几何体着色器处理紧凑和可变长度的GPU反馈"></a>第四十一章 使用几何体着色器处理紧凑和可变长度的GPU反馈</h2>]]></content>
      
      
      
        <tags>
            
            <tag> GPU Gems[3] </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五部分 物理仿真</title>
      <link href="/2018/03/03/note5/"/>
      <url>/2018/03/03/note5/</url>
      
        <content type="html"><![CDATA[<h1 id="第五部分-物理仿真"><a href="#第五部分-物理仿真" class="headerlink" title="第五部分 物理仿真"></a>第五部分 物理仿真</h1><h2 id="第二十九章-CPU上实时刚体仿真"><a href="#第二十九章-CPU上实时刚体仿真" class="headerlink" title="第二十九章 CPU上实时刚体仿真"></a>第二十九章 CPU上实时刚体仿真</h2><h2 id="第三十章-实时仿真与3D流体渲染"><a href="#第三十章-实时仿真与3D流体渲染" class="headerlink" title="第三十章 实时仿真与3D流体渲染"></a>第三十章 实时仿真与3D流体渲染</h2><h2 id="第三十一章-使用CUDA进行快速N-body仿真"><a href="#第三十一章-使用CUDA进行快速N-body仿真" class="headerlink" title="第三十一章 使用CUDA进行快速N-body仿真"></a>第三十一章 使用CUDA进行快速N-body仿真</h2><h2 id="第三十二章-使用CUDA进行快速宽阶段碰撞检测"><a href="#第三十二章-使用CUDA进行快速宽阶段碰撞检测" class="headerlink" title="第三十二章 使用CUDA进行快速宽阶段碰撞检测"></a>第三十二章 使用CUDA进行快速宽阶段碰撞检测</h2><h2 id="第三十三章-用于碰撞检测的LCP算法的CUDA实现"><a href="#第三十三章-用于碰撞检测的LCP算法的CUDA实现" class="headerlink" title="第三十三章 用于碰撞检测的LCP算法的CUDA实现"></a>第三十三章 用于碰撞检测的LCP算法的CUDA实现</h2><h2 id="第三十四章-使用单过程的GPU扫描和四面体转换的有向距离场"><a href="#第三十四章-使用单过程的GPU扫描和四面体转换的有向距离场" class="headerlink" title="第三十四章 使用单过程的GPU扫描和四面体转换的有向距离场"></a>第三十四章 使用单过程的GPU扫描和四面体转换的有向距离场</h2>]]></content>
      
      
      
        <tags>
            
            <tag> GPU Gems[3] </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四部分 图像效果</title>
      <link href="/2018/03/03/note4/"/>
      <url>/2018/03/03/note4/</url>
      
        <content type="html"><![CDATA[<h1 id="第四部分-图像效果"><a href="#第四部分-图像效果" class="headerlink" title="第四部分 图像效果"></a>第四部分 图像效果</h1><h2 id="第二十一章-真正的Impostor"><a href="#第二十一章-真正的Impostor" class="headerlink" title="第二十一章 真正的Impostor"></a>第二十一章 真正的Impostor</h2><h2 id="第二十二章-在GPU上处理发现贴图"><a href="#第二十二章-在GPU上处理发现贴图" class="headerlink" title="第二十二章 在GPU上处理发现贴图"></a>第二十二章 在GPU上处理发现贴图</h2><h2 id="第二十三章-高速的离屏粒子"><a href="#第二十三章-高速的离屏粒子" class="headerlink" title="第二十三章 高速的离屏粒子"></a>第二十三章 高速的离屏粒子</h2><h2 id="第二十四章-保持线性的重要性"><a href="#第二十四章-保持线性的重要性" class="headerlink" title="第二十四章 保持线性的重要性"></a>第二十四章 保持线性的重要性</h2><h2 id="第二十五章-在CPU上渲染向量图"><a href="#第二十五章-在CPU上渲染向量图" class="headerlink" title="第二十五章 在CPU上渲染向量图"></a>第二十五章 在CPU上渲染向量图</h2><h2 id="第二十六章-通过颜色进行对象探测：使用CPU-进行实时视频图像处理"><a href="#第二十六章-通过颜色进行对象探测：使用CPU-进行实时视频图像处理" class="headerlink" title="第二十六章 通过颜色进行对象探测：使用CPU 进行实时视频图像处理"></a>第二十六章 通过颜色进行对象探测：使用CPU 进行实时视频图像处理</h2><h2 id="第二十七章-作为后置处理效果的运动模糊"><a href="#第二十七章-作为后置处理效果的运动模糊" class="headerlink" title="第二十七章 作为后置处理效果的运动模糊"></a>第二十七章 作为后置处理效果的运动模糊</h2><h2 id="第二十八章-使用景深后期处理"><a href="#第二十八章-使用景深后期处理" class="headerlink" title="第二十八章 使用景深后期处理"></a>第二十八章 使用景深后期处理</h2>]]></content>
      
      
      
        <tags>
            
            <tag> GPU Gems[3] </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三部分 渲染</title>
      <link href="/2018/03/03/note3/"/>
      <url>/2018/03/03/note3/</url>
      
        <content type="html"><![CDATA[<h1 id="第三部分-渲染"><a href="#第三部分-渲染" class="headerlink" title="第三部分 渲染"></a>第三部分 渲染</h1><h2 id="第十四章-用于真实感实时皮肤渲染的高级技术"><a href="#第十四章-用于真实感实时皮肤渲染的高级技术" class="headerlink" title="第十四章 用于真实感实时皮肤渲染的高级技术"></a>第十四章 用于真实感实时皮肤渲染的高级技术</h2><h2 id="第十五章-可播放的全方位捕捉"><a href="#第十五章-可播放的全方位捕捉" class="headerlink" title="第十五章 可播放的全方位捕捉"></a>第十五章 可播放的全方位捕捉</h2><h2 id="第十六章-Crysis-中植被的过程化动画和着色"><a href="#第十六章-Crysis-中植被的过程化动画和着色" class="headerlink" title="第十六章 Crysis 中植被的过程化动画和着色"></a>第十六章 Crysis 中植被的过程化动画和着色</h2><h2 id="第十七章-鲁棒的多镜面反射和折射"><a href="#第十七章-鲁棒的多镜面反射和折射" class="headerlink" title="第十七章 鲁棒的多镜面反射和折射"></a>第十七章 鲁棒的多镜面反射和折射</h2><h2 id="第十八章-用于浮雕映射的松散式锥形步进"><a href="#第十八章-用于浮雕映射的松散式锥形步进" class="headerlink" title="第十八章 用于浮雕映射的松散式锥形步进"></a>第十八章 用于浮雕映射的松散式锥形步进</h2><h2 id="第十九章-Tabula-Rasa中的延迟着色"><a href="#第十九章-Tabula-Rasa中的延迟着色" class="headerlink" title="第十九章 Tabula Rasa中的延迟着色"></a>第十九章 Tabula Rasa中的延迟着色</h2><h2 id="第二十章-基于GPU的重要性采样"><a href="#第二十章-基于GPU的重要性采样" class="headerlink" title="第二十章 基于GPU的重要性采样"></a>第二十章 基于GPU的重要性采样</h2>]]></content>
      
      
      
        <tags>
            
            <tag> GPU Gems[3] </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二部分 光照和阴影</title>
      <link href="/2018/03/03/note2/"/>
      <url>/2018/03/03/note2/</url>
      
        <content type="html"><![CDATA[<h1 id="第二部分-光照和阴影"><a href="#第二部分-光照和阴影" class="headerlink" title="第二部分 光照和阴影"></a>第二部分 光照和阴影</h1><h2 id="第八章-区域求和的差值阴影贴图"><a href="#第八章-区域求和的差值阴影贴图" class="headerlink" title="第八章 区域求和的差值阴影贴图"></a>第八章 区域求和的差值阴影贴图</h2><h3 id="8-1-介绍"><a href="#8-1-介绍" class="headerlink" title="8.1 介绍"></a>8.1 介绍</h3><h3 id="8-2-相关工作"><a href="#8-2-相关工作" class="headerlink" title="8.2 相关工作"></a>8.2 相关工作</h3><h3 id="8-3-percentage-closer-过滤"><a href="#8-3-percentage-closer-过滤" class="headerlink" title="8.3 percentage-closer 过滤"></a>8.3 percentage-closer 过滤</h3><h3 id="8-4-插值阴影贴图"><a href="#8-4-插值阴影贴图" class="headerlink" title="8.4 插值阴影贴图"></a>8.4 插值阴影贴图</h3><h3 id="8-5-区域求和插值阴影贴图"><a href="#8-5-区域求和插值阴影贴图" class="headerlink" title="8.5 区域求和插值阴影贴图"></a>8.5 区域求和插值阴影贴图</h3><h3 id="8-6-percentage-closer-软阴影"><a href="#8-6-percentage-closer-软阴影" class="headerlink" title="8.6 percentage-closer 软阴影"></a>8.6 percentage-closer 软阴影</h3><h3 id="8-7-结论"><a href="#8-7-结论" class="headerlink" title="8.7 结论"></a>8.7 结论</h3><h3 id="8-8-参考资料"><a href="#8-8-参考资料" class="headerlink" title="8.8 参考资料"></a>8.8 参考资料</h3><h2 id="第九章-使用全局照明实现互动的电影级重光照"><a href="#第九章-使用全局照明实现互动的电影级重光照" class="headerlink" title="第九章 使用全局照明实现互动的电影级重光照"></a>第九章 使用全局照明实现互动的电影级重光照</h2><h3 id="9-1-介绍"><a href="#9-1-介绍" class="headerlink" title="9.1 介绍"></a>9.1 介绍</h3><h3 id="9-2-算法总览"><a href="#9-2-算法总览" class="headerlink" title="9.2 算法总览"></a>9.2 算法总览</h3><h3 id="9-3-聚集样本"><a href="#9-3-聚集样本" class="headerlink" title="9.3 聚集样本"></a>9.3 聚集样本</h3><h3 id="9-4-一次反射的间接照明"><a href="#9-4-一次反射的间接照明" class="headerlink" title="9.4 一次反射的间接照明"></a>9.4 一次反射的间接照明</h3><h3 id="9-5-用于压缩的小波"><a href="#9-5-用于压缩的小波" class="headerlink" title="9.5 用于压缩的小波"></a>9.5 用于压缩的小波</h3><h3 id="9-6-增加多次反射"><a href="#9-6-增加多次反射" class="headerlink" title="9.6 增加多次反射"></a>9.6 增加多次反射</h3><h3 id="9-7-对稀疏矩阵进行压缩"><a href="#9-7-对稀疏矩阵进行压缩" class="headerlink" title="9.7 对稀疏矩阵进行压缩"></a>9.7 对稀疏矩阵进行压缩</h3><h3 id="9-8-基于GPU的重光照引擎"><a href="#9-8-基于GPU的重光照引擎" class="headerlink" title="9.8 基于GPU的重光照引擎"></a>9.8 基于GPU的重光照引擎</h3><h3 id="9-9-结果"><a href="#9-9-结果" class="headerlink" title="9.9 结果"></a>9.9 结果</h3><h3 id="9-10-结论"><a href="#9-10-结论" class="headerlink" title="9.10 结论"></a>9.10 结论</h3><h3 id="9-11-参考资料"><a href="#9-11-参考资料" class="headerlink" title="9.11 参考资料"></a>9.11 参考资料</h3><h2 id="第十章-在可编程的GPU中实现并行分割的阴影贴图"><a href="#第十章-在可编程的GPU中实现并行分割的阴影贴图" class="headerlink" title="第十章 在可编程的GPU中实现并行分割的阴影贴图"></a>第十章 在可编程的GPU中实现并行分割的阴影贴图</h2><h2 id="第十一章-使用层次化的遮挡剔除和几何体着色器得到高效鲁棒的阴影体"><a href="#第十一章-使用层次化的遮挡剔除和几何体着色器得到高效鲁棒的阴影体" class="headerlink" title="第十一章 使用层次化的遮挡剔除和几何体着色器得到高效鲁棒的阴影体"></a>第十一章 使用层次化的遮挡剔除和几何体着色器得到高效鲁棒的阴影体</h2><h2 id="第十二章-高质量的环境遮挡"><a href="#第十二章-高质量的环境遮挡" class="headerlink" title="第十二章 高质量的环境遮挡"></a>第十二章 高质量的环境遮挡</h2><h2 id="第十三章-作为后置处理的体积光照散射"><a href="#第十三章-作为后置处理的体积光照散射" class="headerlink" title="第十三章 作为后置处理的体积光照散射"></a>第十三章 作为后置处理的体积光照散射</h2>]]></content>
      
      
      
        <tags>
            
            <tag> GPU Gems[3] </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一部分 几何体</title>
      <link href="/2018/03/03/GPU-Gems-3-note/"/>
      <url>/2018/03/03/GPU-Gems-3-note/</url>
      
        <content type="html"><![CDATA[<h1 id="第一部分-几何体"><a href="#第一部分-几何体" class="headerlink" title="第一部分 几何体"></a>第一部分 几何体</h1><h2 id="第一章-使用CPU生成复杂的程序化地形"><a href="#第一章-使用CPU生成复杂的程序化地形" class="headerlink" title="第一章 使用CPU生成复杂的程序化地形"></a>第一章 使用CPU生成复杂的程序化地形</h2><h3 id="1-1介绍"><a href="#1-1介绍" class="headerlink" title="1.1介绍"></a>1.1介绍</h3><pre><code>传统上，程序化地形(procedural terrains)受限于CPU生成的并用GPU进行渲染的高度长(height fields)。然而，生成复杂的地形是一项高度并行化的任务，CPU的串行处理本质并不适合完成这项工作。此外，CPU生成高度场的方法也无法提供吸引人的地形特征（如凹洞和凸起物）。为了在交互级的帧速率下，生成高度复杂的程序化地形，我们转而使用GPU。通过使用DirectX 10的新特性，我们可以快速生成大块的复杂程序化地形。最终，这些块共同创建一个大型的、具有细节的多边形网格，以表示当前视锥观察到的地形。</code></pre><h3 id="1-2-Marching-Cubes算法和密度函数"><a href="#1-2-Marching-Cubes算法和密度函数" class="headerlink" title="1.2 Marching Cubes算法和密度函数"></a>1.2 Marching Cubes算法和密度函数</h3><pre><code>理论上，地形表面可以用单个函数完整的描述，这个函数被称为密度函数(density function)。对于3D空间的任意一点(x,y,z)，密度函数产生一个单精度浮点值。这些值</code></pre><h3 id="1-3-地形生成系统概述"><a href="#1-3-地形生成系统概述" class="headerlink" title="1.3 地形生成系统概述"></a>1.3 地形生成系统概述</h3><h3 id="1-4-在地形块中生成多边形"><a href="#1-4-在地形块中生成多边形" class="headerlink" title="1.4 在地形块中生成多边形"></a>1.4 在地形块中生成多边形</h3><h3 id="1-5-纹理和光影"><a href="#1-5-纹理和光影" class="headerlink" title="1.5 纹理和光影"></a>1.5 纹理和光影</h3><h3 id="1-6-对实际应用的考虑"><a href="#1-6-对实际应用的考虑" class="headerlink" title="1.6 对实际应用的考虑"></a>1.6 对实际应用的考虑</h3><h3 id="1-7-结论"><a href="#1-7-结论" class="headerlink" title="1.7 结论"></a>1.7 结论</h3><h3 id="1-8-参考资源"><a href="#1-8-参考资源" class="headerlink" title="1.8 参考资源"></a>1.8 参考资源</h3><h2 id="第二章-群体动画渲染"><a href="#第二章-群体动画渲染" class="headerlink" title="第二章 群体动画渲染"></a>第二章 群体动画渲染</h2><h3 id="2-1-目的"><a href="#2-1-目的" class="headerlink" title="2.1 目的"></a>2.1 目的</h3><h3 id="2-2-实例化的简单回顾"><a href="#2-2-实例化的简单回顾" class="headerlink" title="2.2 实例化的简单回顾"></a>2.2 实例化的简单回顾</h3><h3 id="2-3-技术细节"><a href="#2-3-技术细节" class="headerlink" title="2.3 技术细节"></a>2.3 技术细节</h3><h3 id="2-4-其它考虑因素"><a href="#2-4-其它考虑因素" class="headerlink" title="2.4 其它考虑因素"></a>2.4 其它考虑因素</h3><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><h2 id="第三章-DirectX-10-混合形状：打破限制"><a href="#第三章-DirectX-10-混合形状：打破限制" class="headerlink" title="第三章 DirectX 10 混合形状：打破限制"></a>第三章 DirectX 10 混合形状：打破限制</h2><h3 id="3-1-介绍"><a href="#3-1-介绍" class="headerlink" title="3.1 介绍"></a>3.1 介绍</h3><h3 id="Dawn例子的实现"><a href="#Dawn例子的实现" class="headerlink" title="Dawn例子的实现"></a>Dawn例子的实现</h3><h3 id="运行例子"><a href="#运行例子" class="headerlink" title="运行例子"></a>运行例子</h3><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><h3 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h3><h2 id="第四章-下一代SpeedTree-渲染"><a href="#第四章-下一代SpeedTree-渲染" class="headerlink" title="第四章 下一代SpeedTree 渲染"></a>第四章 下一代SpeedTree 渲染</h2><h3 id="4-1-介绍"><a href="#4-1-介绍" class="headerlink" title="4.1 介绍"></a>4.1 介绍</h3><h3 id="4-2-轮廓裁减"><a href="#4-2-轮廓裁减" class="headerlink" title="4.2 轮廓裁减"></a>4.2 轮廓裁减</h3><h3 id="4-3-阴影"><a href="#4-3-阴影" class="headerlink" title="4.3 阴影"></a>4.3 阴影</h3><h3 id="4-4-树叶光照"><a href="#4-4-树叶光照" class="headerlink" title="4.4 树叶光照"></a>4.4 树叶光照</h3><h3 id="4-5-高动态范围和反锯齿"><a href="#4-5-高动态范围和反锯齿" class="headerlink" title="4.5 高动态范围和反锯齿"></a>4.5 高动态范围和反锯齿</h3><h3 id="4-6-半透明覆盖"><a href="#4-6-半透明覆盖" class="headerlink" title="4.6 半透明覆盖"></a>4.6 半透明覆盖</h3><h3 id="4-7-结论"><a href="#4-7-结论" class="headerlink" title="4.7 结论"></a>4.7 结论</h3><h3 id="4-8-参考资料"><a href="#4-8-参考资料" class="headerlink" title="4.8 参考资料"></a>4.8 参考资料</h3><h2 id="第五章-普遍自适应的网格优化"><a href="#第五章-普遍自适应的网格优化" class="headerlink" title="第五章 普遍自适应的网格优化"></a>第五章 普遍自适应的网格优化</h2><h3 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h3><h3 id="5-2-总览"><a href="#5-2-总览" class="headerlink" title="5.2 总览"></a>5.2 总览</h3><h3 id="5-3-自适应优化模式"><a href="#5-3-自适应优化模式" class="headerlink" title="5.3 自适应优化模式"></a>5.3 自适应优化模式</h3><h3 id="5-4-渲染工作流"><a href="#5-4-渲染工作流" class="headerlink" title="5.4 渲染工作流"></a>5.4 渲染工作流</h3><h3 id="5-5-结果"><a href="#5-5-结果" class="headerlink" title="5.5 结果"></a>5.5 结果</h3><h3 id="5-6-结论和改进"><a href="#5-6-结论和改进" class="headerlink" title="5.6 结论和改进"></a>5.6 结论和改进</h3><h3 id="5-7-参考资料"><a href="#5-7-参考资料" class="headerlink" title="5.7 参考资料"></a>5.7 参考资料</h3><h2 id="第六章-GPU生成的树的过程式风动画"><a href="#第六章-GPU生成的树的过程式风动画" class="headerlink" title="第六章 GPU生成的树的过程式风动画"></a>第六章 GPU生成的树的过程式风动画</h2><h3 id="6-1-介绍"><a href="#6-1-介绍" class="headerlink" title="6.1 介绍"></a>6.1 介绍</h3><h3 id="6-2-GPU上的过程式动画"><a href="#6-2-GPU上的过程式动画" class="headerlink" title="6.2 GPU上的过程式动画"></a>6.2 GPU上的过程式动画</h3><h3 id="6-3-现象学方法"><a href="#6-3-现象学方法" class="headerlink" title="6.3 现象学方法"></a>6.3 现象学方法</h3><h3 id="6-4-模拟步骤"><a href="#6-4-模拟步骤" class="headerlink" title="6.4 模拟步骤"></a>6.4 模拟步骤</h3><h3 id="6-5-渲染树"><a href="#6-5-渲染树" class="headerlink" title="6.5 渲染树"></a>6.5 渲染树</h3><h3 id="6-6-分析和比较"><a href="#6-6-分析和比较" class="headerlink" title="6.6 分析和比较"></a>6.6 分析和比较</h3><h3 id="6-7-结论"><a href="#6-7-结论" class="headerlink" title="6.7 结论"></a>6.7 结论</h3><h3 id="6-8-参考资料"><a href="#6-8-参考资料" class="headerlink" title="6.8 参考资料"></a>6.8 参考资料</h3><h2 id="第七章-GPU上基于点的变形球可视化"><a href="#第七章-GPU上基于点的变形球可视化" class="headerlink" title="第七章 GPU上基于点的变形球可视化"></a>第七章 GPU上基于点的变形球可视化</h2><h3 id="7-1-变形球、光滑粒子流体力学和表面粒子"><a href="#7-1-变形球、光滑粒子流体力学和表面粒子" class="headerlink" title="7.1 变形球、光滑粒子流体力学和表面粒子"></a>7.1 变形球、光滑粒子流体力学和表面粒子</h3><h3 id="7-2-限制粒子"><a href="#7-2-限制粒子" class="headerlink" title="7.2 限制粒子"></a>7.2 限制粒子</h3><h3 id="7-3-局部粒子斥力"><a href="#7-3-局部粒子斥力" class="headerlink" title="7.3 局部粒子斥力"></a>7.3 局部粒子斥力</h3><h3 id="7-4-全局粒子传播"><a href="#7-4-全局粒子传播" class="headerlink" title="7.4 全局粒子传播"></a>7.4 全局粒子传播</h3><h3 id="7-5-性能"><a href="#7-5-性能" class="headerlink" title="7.5 性能"></a>7.5 性能</h3><h3 id="7-6-渲染"><a href="#7-6-渲染" class="headerlink" title="7.6 渲染"></a>7.6 渲染</h3><h3 id="7-7-结论"><a href="#7-7-结论" class="headerlink" title="7.7 结论"></a>7.7 结论</h3><h3 id="7-8-参考资料"><a href="#7-8-参考资料" class="headerlink" title="7.8 参考资料"></a>7.8 参考资料</h3>]]></content>
      
      
      
        <tags>
            
            <tag> GPU Gems[3] </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻引擎学习之路：渲染模块之光照系统</title>
      <link href="/2017/12/10/Study_unreal4_Rendering_1/"/>
      <url>/2017/12/10/Study_unreal4_Rendering_1/</url>
      
        <content type="html"><![CDATA[<p>我们准备从三方面来介绍Unreal 4引擎的渲染模块，主要包括：光照系统，材质系统喝图像后处理。本篇文章重点讲解第一部分：光照系统。<br>在对比Unreal 4与Unity两者引擎时，本文分别采用的版本是Unreal 4.18.1和Unity 5.3.8.f1。</p><p>本节将介绍Unreal 4引擎的光照系统。在介绍基础功能时，本文将分四块进行介绍，主要包括：光源、全局光照、阴影以及反射效果。同时，本文将与Unity引擎中的这些功能进行对比。另外，对于Unreal 4引擎中的特殊功能，本文将单独介绍。</p><h1 id="一、光源"><a href="#一、光源" class="headerlink" title="一、光源"></a>一、光源</h1><p>光源对于游戏引擎的光照系统来说时最为基础的功能模块。游戏渲染中光照计算的每一部分都离不开光源。<strong>通常游戏引擎通过三个重要属性对员光源进行了分类：光源类型、实时性以及渲染管线。</strong>对于不同属性的光源，其光照计算方式和复杂程度都有所不同。在接下来的内容中，本文将对Unreal 5和Unity引擎的光源在这三个方面进行比较。</p><h2 id="1、光源类型"><a href="#1、光源类型" class="headerlink" title="1、光源类型"></a>1、光源类型</h2><p>Unreal 4引擎中，可在场景中创建的光源类型有四种：<strong>方向光、点光源、聚光灯和天空光。</strong></p><p>创建方式跟Unity类似，只需通过在Unreal 4地图编辑器中点击左上角的”Modes”页面，选择”Lights”标签，即可在其子菜单选择需要的光源拖放的场景中，如下图所示：<br>Unreal 4引擎中的天空光其作用是：自动获取远处的入射光信息，然后用于场景中物体的光照计算。远处的入射光信息涵盖了”Sky Distance Threshold”设置的距离以外的所有入射光来源，包括远景=天空盒=云雾等。它的实现方式是先将远处的入射光信息渲染到Cube Map中，然后使用这张Cube Map来计算光照。在Unity中也可以在Lighting设置中采用Sky Box作为环境光的输入，但是Unity没有将其作为单独可放入场景的光源。</p><h2 id="2、实时性"><a href="#2、实时性" class="headerlink" title="2、实时性"></a>2、实时性</h2><p>在Unreal 4的光源属性中，有一项Mobility表示光源的可移动性以及光照计算实时性。它包含了三种类型：Static、Stationary以及Movable。它与Unity中光源类型的Static、Mixed、Realtime具有类似含义，如下图所示：</p>]]></content>
      
      
      
        <tags>
            
            <tag> Unreal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>世界boss设计</title>
      <link href="/2017/11/07/word-boss/"/>
      <url>/2017/11/07/word-boss/</url>
      
        <content type="html"><![CDATA[<h1 id="设计目的"><a href="#设计目的" class="headerlink" title="设计目的"></a>设计目的</h1><p>作为主要的金钱额外发放通道，驱动尽可能多的玩家参与。<br>将世界boss分为大小两个类型，阶梯性的学习，鼓励低级用户参与，降低挫折感<br>在世界boss和潜在的竞争对手的压力下，让玩家开始自发的组织，逐步形成社会关系。由于小boss需要的组织难度较低，玩家很容易形成组织。而大boss普通玩家只需要依托公会，而公会的组织主要来源于高端玩家，普通玩家只需要参与到这种社会关系中，而不需要耗费额外的精力去组织<br>同时，世界boss还是一个玩家印证自我价值（和其他玩家同比）的方式，通过PVE和pvp的比拼来作为成长压力的宣泄。</p><h1 id="大概描述"><a href="#大概描述" class="headerlink" title="大概描述"></a>大概描述</h1><p>世界上散落着很多个伏魔阵的阵眼<br>通过各种方式激活阵眼，并击破阵眼后，玩家就会被传入到封印世界boss的禁阵中<br>多个队伍（公会）攻击boss，当限时结束或者成功击杀后，伤害名列前茅的队伍获得额外奖励<br>每个被传入禁阵中的玩家，每对boss造成一次伤害，都会获得和伤害成正比的金钱数，同时在阵中的这段时间内，都会源源不断的获得经验</p><h1 id="基础原则"><a href="#基础原则" class="headerlink" title="基础原则"></a>基础原则</h1><p>世界boss分为大小两种<br>由于一个场景可能存在n条线并行的原因，而这个n并不确定，世界boss如果再单独刷在大世界的场中，则刷多少个boss完全无法确定，作为一个重要和敏感的发放渠道，这种方式将是完全不可接受的。因此需要更改世界boss的形式。<br>世界boss单独刷在一个特定场景（暂且称之为禁阵）中，该场景除了boss以外几乎没有其他NPC和其他逻辑，因此该场景可以容纳更多的玩家，缓解了服务器的逻辑压力<br>必须由击破阵眼来获得进入boss战场景的资格</p><h1 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h1><p>世界boss分为大小两种</p><h2 id="低级boss"><a href="#低级boss" class="headerlink" title="低级boss"></a>低级boss</h2><h3 id="设计基础思路"><a href="#设计基础思路" class="headerlink" title="设计基础思路"></a>设计基础思路</h3><ul><li>以小队为单位，强调队伍之间的对抗和博弈<br>过程分为【大世界击破阵眼】【禁阵内击杀boss】两个阶段。<br>在大世界上pvp模式不做更改，由玩家控制。默认为和平，玩家可以通过开红来发动pk<br>在禁阵内，是否pk仍然交给玩家决定，想主动发起pk的一方可以先开启【杀戮】和【公会杀戮模式】——【公会杀戮模式】现在还没实现，需要负责人苏博跟进实现<br>开启禁阵<br>无规定时间，无固定时间开启<br>玩家在世界探索中会获得【低级boss召唤符】，在伏魔阵的阵眼附近使用该道具，可以打开伏魔阵。<br>只要拥有道具【召唤符】，就可以随时（世界大boss活动时间内不允许）开启禁阵<br>召唤符有N种，一一对应N个世界小boss，例如：玄黄坤龙召唤符就只能召唤玄黄坤龙，姥姥召唤符就只能召唤姥姥。<br>每个召唤符只能在唯一对应的场景使用（道具tips上有说明，例如玄黄坤龙召唤符，tips上写着“该召唤符只能在海底的伏魔阵周围使用”）<br>有些场景有伏魔阵，有些场景没有。<br>拥有伏魔阵的场景都对应有5个阵眼，想要召唤的玩家必须走到一个阵眼附近使用道具。<br>召唤者身边一定会生成一个阵眼<br>地图上其他的4个阵眼位置会随机生成2个阵眼<br>阵眼生成的时间为30秒（期间会有阵眼逐渐生成的特效表现）<br>阵眼生成的阶段，会有跑马灯和世界聊天提升—-类似：玩家xxx正在【某个场景】打开伏魔阵阵眼。（方括号的为链接，点击后可以直接传送到该场景）<br>如果该召唤场景存在着多条分线，也只能在使用召唤符的本线打开阵眼，其他的分线无动静<br>阵眼持续2分钟，2分钟内每30秒通知一次全服，2分钟后阵眼消失。<br>阵眼生成和持续时间内，跑马灯和世界聊天通知全服，会有以下的处理<br>点击提示上的链接，会自动寻路走到阵眼所在的场景<br>如果和召唤者不在同一个场景，自动寻路到切场景时，自动进入阵眼所在的场景线（如果多线）<br>在同一个场景不在同一条线的，自动切线到阵眼所在线<br>到达召唤场景后，自动寻路中止，接下来需要玩家手动去寻找打开的阵眼<br>如何进入禁阵<br>每个阵眼被击破，都会传送一队人进入boss场景<br>阵眼击破后，都会在阵眼刷出的位置出现一个传送门，该门存在时间由策划填表调整控制<br>如何挑选进入boss场景的人<br>伤害最高的队伍进入boss场景<br>1.一个阵眼被攻击时候，记录对其造成的伤害，对应的玩家，并进行排名<br>2.每次记录的时候，是以队伍为基础单位进行记录，不记录玩家的个人伤害<br>3.攻击阵眼的过程中，会在客户端出现伤害排行榜<br>A.只有走到阵眼附近20米的范围内且当时正处于开启状态下，该排行榜才会在客户端上显示（为什么是20米，20米是玩家有可能对阵眼造成伤害的最大攻击距离）<br>B.该排行榜出现在任务栏的位置，临时顶替掉任务栏<br>C.该排行榜有且只有3行<br>D.如果自己的队伍排名第一，则在下方显示伤害最接近自己的两个组<br>E.如果不排名第一，则显示伤害排名比自己高一名和低一名的队伍<br>F.该排行榜每1秒动态更新一次<br>G.伤害排行的上仅仅显示名次和造成的伤害数值<br>H.自己队伍在排行榜上所在行会凸起显示，让人直观上一眼就能看出这行是自己队伍的数据<br>每个阵眼仅仅只挑选一个队伍进入<br>1.最大只开启3个阵眼，也就是说最多有3个队可以被传入boss场景<br>2.那些玩家可以进入？<br>A.当阵眼被击破的时候，系统才开始挑人<br>B.此时，先确定伤害最高的队伍<br>C.再确定当前队伍里的玩家，并记录这些玩家<br>D.把这些玩家都传入到boss场景里<br>阵眼存在2分钟，阵眼消失前如果阵眼没有被击破，该阵眼不会传送任何一个玩家进入boss场景<br>特别注意<br>1.当阵眼传送人之前，需要判断玩家是否在阵眼所在的场景，只有玩家处于阵眼所在的场景，才把玩家传送。<br>2.阵眼被击碎后的2分钟内（也就是传送门穿在的2分钟内），每秒都会检测拥有进入资格的玩家是否出现在阵眼附近20米区域，如果出现，则把玩家传送进入boss场景（预防阵眼开启前掉线，预防阵眼开启前切了场景）[后面会引用]<br>3.玩家如果死在附近，也可以被传送，传送后复活</li></ul><p>Boss战怎么玩<br>场景<br>1.使用天劫副本场景修改<br>A.该场景由中央的大圆形平台和周围的3个浮空阁楼组成<br>B.大平台和阁楼之间没有导航连接，没法通过走路互通<br>C.需要通过对话，触发飞行寻路飞到中间的战斗区域<br>D.该场景禁止玩家手动的飞行<br>2.出生点和复活点<br>A.出生点和复活点在3个小平台上<br>B.玩家随机出生和复活在3个点上<br>C.怎么从出生点到达战斗场景<br>对话，确定后随机选一条该出生点连接到boss平台的飞行路线进行自动寻路飞行<br>使用tx01-85帧的动画，大世界探索动画<br>策划在技能编辑调整为5秒，300帧<br>需要一个运气聚敛云朵的粒子效果<br>5秒后吟唱结束，脚底驾云<br>飞行路径相关<br>在每个复活点种多条飞行寻路路径，让一堆人一起飞出来的时候不重合，感觉更有仪式感<br>飞行寻路花费5-10秒飞到场景中央<br>飞行寻路过程中不能使用技能，不能驾云，坐骑等所有互动功能（最好客户端所有相关互动按钮都隐去）<br>状态处理<br>复活后无敌，初次传入时无敌，无敌时间无限长，跨场景删除，<br>飞行寻路完毕后，删除无敌<br>3.战斗场景<br>A.中间的大圆形区域为boss场景<br>B.战斗只能发生在这里<br>规则<br>1.场景内玩家关系<br>A.可以自由组队和退队<br>B.默认pk模式为善恶<br>C.可以开各种杀戮模式pk<br>2.特殊玩法（二期制作？？）<br>A.阶段性出现特殊玩法<br>B.特殊玩法1：PK鼓励向，boss血量到某个阶段后开启，该阶段一旦击杀了其他玩家，每杀一个玩家获得一层状态，提升攻击10%<br>3.战斗限时<br>A.3-4分钟的时间为宜（策划填表）<br>B.时间长了疲惫<br>C.时间短了拉不开差距<br>Boss战斗属性<br>1.每一个boss都有其固定的属性。<br>2.对应该boss刷出来的阵眼的属性也固订。也就是一个boss对应一个阵眼，boss的阵眼的属性都是固定不变的。比如：姥姥的属性就是npcgrowup里的1101，对应的阵眼cha_list id为11001，属性也对应为1102.<br>3.Boss的等级由玩家决定<br>A.Boss的等级取决由有资格传送进入boss战的玩家中等级最高的玩家，boss的等级等于该玩家的等级<br>B.玩家传送进入boss场景后，boss场景才刷出boss<br>4.Boss最初的1级属性确定，之后的每级属性有npc——growup决定（如果boss属性据此控制不力，则可以使用分段控制法，每个关键等级点单独取一条属性，该属性包括了boss的基础属性和成长属性，直到下一个等级关键点之前的所有等级都使用该属性，到达下个关键点后，取新的关键点的战斗属性匹配给boss（比如30-39使用npc成长表属性ID1000,40-45使用1001,45-50使用1002）<br>5.注意：阵眼的等级等于开启伏魔阵队伍里等级最高的玩家的等级，其属性由其等级匹配到相应的表得到）<br>奖励相关<br>首先需要伤害统计<br>Boss战的时候，类似阵眼击破，对所有对boss造成的伤害进行记录和统计<br>伤害统计栏还是出现在任务栏，隐去任务栏<br>还是只以队伍为单位进行排行和统计<br>参与就有奖励<br>只要进入战斗状态，每秒获得一定经验（策划填表），根据玩家等级获得经验<br>只要对boss造成伤害，就能获得金钱奖励<br>每个boss对应不同等级都有一个总金钱掉落书<br>每次造成的伤害对应boss总血量的必烈决定单次获得基础金钱数<br>1.Boss等级越高，总金钱数越多<br>2.玩家伤害越高，单次获得金钱越多<br>3.可能会一秒判定很多次，获得金钱的间隔就设定为一秒<br>如果有玩家完成了最终一击的击杀，则额外奖励该玩家3%boss掉落金钱的奖励<br>不同的职业在基础金钱数上还有个系数加成（系数策划填表），用来平衡不同职业定位下，职业之间的伤害有差距的问题<br>每个玩家造成的伤害都记录下来，到最后boss战结束的时候统一结算，通过邮件发放<br>额外的排名奖励<br>以队伍伤害排名为标杆<br>选择伤害最高的队伍发奖<br>发奖以道具为基础形式，通过邮件发送。<br>如何退出<br>副本战斗时间倒计时结束后进行结算。因此屏幕中央上方位置有本次挑战的限时倒计时显示，倒计时是从boss刷出开始计时。<br>结算时弹出结算界面（结算界面见界面设计）<br>界面上表明谁的队伍获得了额外奖励，并显示奖励礼包，点击礼包可以看到tips<br>显示自己获得的金钱和经验奖励<br>点击确定离开boss场景，该界面仅仅有确定按钮<br>Boss战结束后，会用跑马灯宣布【xxx（队长）和他的队友击败了xxboss，获取了丰厚的回报】<br>掉线问题的处理<br>大世界掉线<br>阵眼击破前就重新上线了<br>1.队伍还存在，无需特殊处理，因为记录的是队伍伤害和队伍信息<br>2.全队都掉线，队伍只要不删除，还记录有队伍信息即可<br>阵眼开启后才重新上线<br>1.参考【如何进入禁阵】里的【特别注意】第二条 ：链接在此<br>Boss挑战时掉线<br>战斗结束前就重新上线<br>1.单人掉线，队伍还在就出现在掉线前位置，伤害和队伍信息继承<br>2.队伍解散，上线还是出现在掉线前位置，但伤害信息清零<br>3.全队掉线，保留伤害统计和队伍信息，等上线后继续<br>战斗结束后才上线<br>1.结束前没有散队，奖励照发，从邮件获得<br>2.散队了，没有奖励</p><h2 id="高阶boss"><a href="#高阶boss" class="headerlink" title="高阶boss"></a>高阶boss</h2><p>玩的是什么<br>公会间的竞争，同时小队为基础的竞争单元<br>阵眼会开启多次，一个公会怎么保证自己的人尽可能多的在前两轮进入，是很重要的竞争和博弈<br>Boss战时候的竞争和博弈，主要体现在pve伤害的竞争，以及多个公会间因为PK策略的选择展开的博弈<br>Pk规则<br>大世界上默认组队前的pk模式，pk自由交给玩家，玩家可以手段选择开启。基本以公会杀戮为主，不排斥其他pvp模式<br>Boss场景的pk决定权同上，交给玩家<br>怎么开启<br>系统上指定时间点上自动打开地图上的大伏魔阵阵眼，需要打破阵眼，该阵眼才会挑选参与过击破自己的玩家，符合规则被选中的人才能被传送到世界boss身边<br>规定时间开启<br>每天都会开启<br>每天开启2次，分别是中午12:00-12:30,晚上20:00-20:30<br>开启时间内和开启前10分钟内，所有伏魔阵无法使用召唤符召唤小世界boss，（表现为这段时间内，伏魔阵的符咒纹理显示为红色，表明大伏魔阵激活，小伏魔阵无法开启—-小伏魔阵的纹理采用蓝色或者其他做区别）<br>开启时间策划填表决定，原则就是和其他活动不冲突，并安排在大部分玩家有闲的时间段。<br>指定地点开启<br>开启地点<br>1.只能在指定地点生成阵眼<br>2.指定点规则<br>A.要素1：不同boss对应的场景组不一样<br>例如场景ID有1到10<br>1号boss对应：1<em>3</em>5<br>2号boss对应：2<em>4</em>6<br>如果是打1号boss，则只会在1 3 5场景刷出阵眼<br>B.要素2：一个场景包含了5个阵眼<br>如果该场景可以召唤小boss，该场景的大小boss阵眼点相同<br>世界boss定时活动开启后，一定是5个阵眼一起打开<br>C.要素3：允许一个场景多条线：如果一个场景开了多条线，则每条线的指定点都会生成阵眼<br>D.要素4：PVE和PVP场景都会有指定点<br>PVE场景选择等级略高的地方<br>Pvp的场景也尽量选择等级比较高的地方，但考虑玩家参与情况，可以选择个别对应等级比较低的场景。<br>阵眼开启通知<br>1.阵眼开启前5分钟，每20秒跑马灯提醒一次全服玩家<br>2.阵眼开启后，跑马灯通知全服（完全和小boss相同）<br>A.点击跑马灯和世界聊天的链接，自动寻路走到阵眼所在的场景<br>B.。。。<br>怎么进入<br>每次阵眼被击破，都会传送一定数量的玩家进入boss场景<br>每个阵眼可以被击破3次，随着被击破的次数增加，阵眼扩大，下一次可以被传送的玩家数量随之增加<br>挑选进入boss场景的规则<br>阵眼每次被击碎后，挑选玩家进入boss禁阵<br>阵眼可以被击碎三次，三次后，阵眼不再生成<br>阵眼有存活时间，该时间策划填表决定，时间一到，该阵眼如果还未被击破，阵眼消失，本次不传送<br>攻击阵眼的过程中，会统计伤害并排行，并显示在客户端<br>1.该排行榜最多出现3行<br>2.完全类似小boss的大世界伤害统计（略过不表）<br>第一次传送<br>1.精英传送：只传最厉害的一组人进入<br>A.当阵眼被击破时，才开始挑人<br>B.确定伤害最高的队伍<br>C.确定当前这个队伍的玩家，记录<br>D.把这些玩家传入boss副本<br>E.如果有掉线，不在阵眼同一场景，参考特殊处理<br>2.传送完毕后，有个阵眼重新打开过程，该过程持续时间策划填表决定（改好等于boss场景中复活点到战斗场景时间或更大）<br>3.屏幕提示：阵眼被击碎后，显示【阵眼受到攻击，禁制松动，下一次阵眼会稍后打开】<br>第二次传送<br>1.高级传送：传送最厉害的1组人进入<br>A.类似第一次传送<br>B.这次仍然只传送1队人<br>2.传送完毕后，类似第一次传送，仍然有个阵眼重新打开过程该过程持续时间策划填表决定（改好等于boss场景中复活点到战斗场景时间或更大）<br>3.屏幕提示：阵眼被击碎后，显示【阵眼受到猛烈攻击，禁制受损严重，稍后将会打开最后一次阵眼】<br>第三次传送<br>1.普世传送：仍然只传送一队人<br>A.当阵眼被击碎，所有参与的有伤害的人都被传入<br>B.阵眼有个存活时间，时间到还没被击破，伏魔阵关闭，符文熄灭，阵眼消失，木有传送门<br>2.该次传送后，阵眼不再生成，但会 有传送门存在2分钟<br>初步计算和预估<br>一个boss对应3个场景<br>每个场景2条线<br>一个场景5阵眼<br>每个着眼前两轮传2只队<br>每队6个玩家<br>第一轮最多30个阵眼，可传180个玩家，实际普遍情况可能最多15个阵眼传入90个玩家（参考另个情况：一个大公会100人满员）<br>第二轮第三轮同理<br>一共540，其实最大估计270。<br>Boss战玩法<br>Boss战场景<br>场景内容完全继承小boss<br>出生点和复活点几乎等同于小boss，不同点在于：出生点和复活点随机在预设的3个点，3个点刚好平均分在3个小阁楼上。<br>战斗场景就是中间的大圆圈<br>Boss战规则<br>场景内可以自由组队和退队<br>默认pk模式为善恶，是否开红，自主权给玩家<br>阶段性玩法（二期）<br>1.例如小boss也有的阶段性强化pk玩法<br>战斗限时<br>1.策划填表决定限时。15-20分钟适宜<br>2.时间太长疲惫<br>3.时间短了拉不开伤害差距<br>4.如果需要进一步强化boss战的交互和互动，那可以适当增加写时间，反正由策划手动填表控制<br>Boss的战斗属性<br>Boss的属性是可以升级和降级的<br>世界boss的等级是固定的服务器玩家封顶等级（策划填表）<br>每一级的属性从表里匹配，匹配方式类似小boss<br>Boss如果当次被击杀，则boss会自动升一级，那么boss的属性也会升级<br>如果当次没有被击杀，则boss会自动降一级，那么boss的属性也会降低<br>动态的调整boss等级，等于动态的调整了boss的属性，保证了boss的属性总是趋向于贴合本服务器玩家的当前战斗力水平预期的<br>另外注意：阵眼的等级等于boss的等级，其属性也是动态升级和降级的（也由策划填表控制）<br>奖励发放<br>首先需要伤害统计为依据<br>Boss战的时候，类似阵眼，会对所有造成的伤害记性记录和统计<br>队伍伤害统计<br>1.隐去任务栏，在该处出现伤害统计<br>2.以队伍为单位进行统计和排行<br>公会伤害统计<br>1.在队伍伤害统计下方，客户单显示公会伤害统计<br>2.以公会为单位进行排行和统计<br>3.样式完全类似队伍的<br>4.该伤害统计和排行只能出现在boss战阶段<br>参与就发奖励<br>只要进入战斗状态，每秒获得一定经验（策划填表），根据玩家等级获得经验<br>只要对boss造成伤害，就能获得金钱奖励<br>1.每个boss对应不同等级都有一个总金钱掉落书<br>2.每次造成的伤害对应boss总血量的必烈决定单次获得基础金钱数<br>A.Boss等级越高，总金钱数越多<br>B.玩家伤害越高，单次获得金钱越多<br>C.可能会一秒判定很多次，获得金钱的间隔就设定为一秒<br>3.不同的职业在基础金钱数上还有个系数加成（系数策划填表），用来平衡不同职业定位下，职业之间的伤害有差距的问题<br>4.如果有玩家完成了最终一击的击杀，则额外奖励该玩家3%boss掉落金钱的奖励<br>5.每个玩家造成的伤害都单独记录，直到活动完毕时一并结算成金钱，并通过邮件发放给玩家<br>排名的额外奖励<br>分为队伍和公会两部分奖励<br>队伍<br>1.以队伍伤害为标杆<br>2.选择伤害最高的队伍发奖<br>公会<br>1.排名前3名的公会会的额外奖励，前几名可以获奖，奖励什么都由策划填表控制<br>2.前N名可以获得世界boss妖丹，该妖丹是个直接发放给公会仓库的道具（N暂时取5）<br>3.妖丹的道具只决定了召唤出来的boss的类型<br>4.妖丹的等级等于本次活动的世界boss的等级，不同等级的妖丹召唤出来的门派boss的等级也不相同<br>5.排名第一名的公会得到的妖丹等级等于世界boss的等级，而后的2-5名得到的妖丹都会有个等级修正（策划填表），他们得到的妖丹的等级需要用世界boss的等级减去修正值得到。<br>怎么退出<br>战斗过程中无法主动退出<br>活动倒计时为0时，结束战斗，开始结算<br>结算时弹出结算界面<br>表明那个公会拔得头筹（伤害最高的公会）<br>表明那只队伍贡献最大<br>表明本公会获得奖励<br>表明自己队伍获得的奖励<br>点击确定离开boss场景<br>Boss战结束后，会用跑马灯宣布【xxx公会是降伏世界boss xxx的中流砥柱，获取了丰厚的回报】</p><p>掉线处理<br>类似小boss<br>特别注意<br>当阵眼传送人之前，需要判断玩家是否在阵眼所在的场景，只有玩家处于阵眼所在的场景，才把玩家传送。<br>阵眼前两次被击碎后，会有1-2分钟聚力重塑的时间，（时间策划填表）该时间内每秒都会检测拥有进入资格的玩家是否出现在阵眼20米区域，如果出现，则把玩家传送进入boss场景（预防阵眼开启前掉线，预防阵眼开启前切了场景）<br>当第三次阵眼击碎后，阵眼位置生成一个缝隙，存在2分钟，2分钟内有资格进入的玩家走到缝隙附近20米，被传入<br>玩家如果死在附近，也可以被传送，传送后复活</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Shell</title>
      <link href="/2017/11/02/shell/"/>
      <url>/2017/11/02/shell/</url>
      
        <content type="html"><![CDATA[<p>${}用来做变量替换。<br>一般情况下，$var与${var}并没啥不一样<br>但是用${}会比较精确的界定变量名称的范围，比方说：<br>$ A=B<br>$ echo $AB<br>g++ -DLINUX -D_FILE_OFFSET_BITS=64 -D_LARGEFILE64_SOURCE -D_LARGEFILE_SOURCE -Wall -Wno-multichar -g -D_DEBUG -DPG_MEMORY_DISABLE_POOL -march=core2 -m32 -rdynamic -std=c++0x -o ../../bin/debug/xxsy/ScnSvr_AllInOne/ScnSvr_AllInOne_d ../../temp/debug/xxsy/ScnSvr_AllInOne/ScnSvr_AllInOne.o_d  /root/work_code/src/lib/libGSDB_Lib_d.a /root/work_code/src/lib/libScnSvr_d.a /root/work_code/src/lib/libGZSGamePlay_Lib_d.a /root/work_code/src/lib/libMCE4Chat_d.a /root/work_code/src/lib/libMCE_d.a /root/work_code/src/lib/libDIA4DBI_d.a /root/work_code/src/lib/libDIA_d.a /root/work_code/src/lib/libPNGS_d.a /root/work_code/src/lib/libWHNET_d.a /root/work_code/src/lib/libWHCMN_d.a /root/work_code/src/lib/libxxsy_cmn_d.a /root/work_code/src/lib/libpgcmn_d.a -lpathfind_d -lcJSON_d -lcryptlib_d -llua_d -lzlib_d -ltss_sdk_d  /root/work_code/3rd/lib/libqos_client.a -lz -ldl -lssl -lpthread -ldl -lrt -march=prescott  -L/root/work_code/3rd/lib -L/root/work_code/src/lib -pthread<br>/usr/bin/ld: skipping incompatible /usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../lib/libm.so when searching for -lm</p><pre><code>#0 这个是shell的执行名字#n 这个是shell的第n个参数值，n=1..9$* 这个是shell的所有参数$# 表示参数的个数$$ shell的PID$! 执行上一个的PID$? 执行上一个指令的返回值（显示最后的退出状态，0表示没有错误，其它任何值表明有错误）$- 显示shell使用的当前选项，与set命令功能相同$@ 跟$* 类似，但是可以当作数组用-eq 等于-ne 不等于-le 小于等于-ge 大于等于-lt 小于-gt 大于</code></pre><p>=     就是赋值运算<br>:=    就是当冒号前面的变量不存在或者值为空时，就把等号后的值赋值给变量</p><h1 id="删除十天前的文件lt"><a href="#删除十天前的文件lt" class="headerlink" title="删除十天前的文件lt"></a>删除十天前的文件lt</h1><pre><code>find ./ -mtime +10 -name &quot;*.*&quot; -exec rm -rf {} \;</code></pre><h1 id="文件传输（Windows向Linux传输）"><a href="#文件传输（Windows向Linux传输）" class="headerlink" title="文件传输（Windows向Linux传输）"></a>文件传输（Windows向Linux传输）</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>yum install openssh-clients -y</code></pre><h2 id="传输文件"><a href="#传输文件" class="headerlink" title="传输文件"></a>传输文件</h2><pre><code>scp -p ./file/yum.log root@192.168.199.150:/tmp/yum.log</code></pre><h2 id="传输目录"><a href="#传输目录" class="headerlink" title="传输目录"></a>传输目录</h2><pre><code>scp -rp ./file/ root@192.168.199.150:/tmp/</code></pre><p>查看那个共享内存被哪些进程使用着</p><pre><code>lsof | grep &quot;shmid&quot;</code></pre><p>将静态库文件解析成.o文件</p><pre><code>ar -x libexpat.a</code></pre><p>查看归档文件的函数名</p><pre><code>nm -s xmltok.o</code></pre><p>查看汇编代码</p><p>objdump -j .text -Sl tbus.o | more</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日记</title>
      <link href="/2017/10/30/zentia-note1/"/>
      <url>/2017/10/30/zentia-note1/</url>
      
        <content type="html"><![CDATA[<p>遇到问题：CLS起不来，自我感觉应该是SSH验证，因为XCLS2中的auth-info解析出来的地址是3.6，研究中。<br>线索：通过上传记录发现配置文件和openresty一块上传，认为配置文件是通过openresty生成的，故而研究openresty。<br>Message:<br>cls 加上认证，win32平台测试通过</p><hr><p>Modified : /trunk/server/src/engine/PNGS/inc/pngs_cls_i.h<br>Modified : /trunk/server/src/engine/PNGS/src/pngs_cls_i.cpp<br>Modified : /trunk/server/src/engine/PNGS/src/pngs_cls_i_Tick_DealTE.cpp</p><p>SetUseAuth<br>由于个人喜欢sublime也在使用，遇到不支持ANSI编码，特标注：ConvertToUtf8<br>    import urllib.request,os; pf = ‘Package Control.sublime-package’; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), ‘wb’).write(urllib.request.urlopen( ‘<a href="http://sublime.wbond.net/" target="_blank" rel="noopener">http://sublime.wbond.net/</a>‘ + pf.replace(‘ ‘,’%20’)).read())<br>上面的是安装package controls</p><pre><code>grep key1 * | grep key2 并所有文件find ./ -name &quot;*.ext&quot; | xargs -i rm -rf {} # 查询某个后缀名的所有文件，然后移除，-i表示对文件操作</code></pre><p>解决树冲突：</p><pre><code>svn resolve --accept working dir</code></pre><p><a href="https://github.com/Unity-Technologies/UnityCsReference" target="_blank" rel="noopener">https://github.com/Unity-Technologies/UnityCsReference</a></p><p>README.md<br>Unity 2018.1.0b12 C# reference source code</p><p>The C# part of the Unity engine and editor source code.May be used for reference purposes only.</p><p><a href="https://github.com/duanjiahao/UnityDecompiled" target="_blank" rel="noopener">https://github.com/duanjiahao/UnityDecompiled</a></p><p><a href="https://github.com/MattRix/UnityDecompiled" target="_blank" rel="noopener">https://github.com/MattRix/UnityDecompiled</a></p><p><a href="https://github.com/jameslinden/unity-decompiled" target="_blank" rel="noopener">https://github.com/jameslinden/unity-decompiled</a></p><div class="table-container"><table><thead><tr><th>IP</th><th>Username</th><th>Password</th><th>Environment</th></tr></thead><tbody><tr><td>192.168.0.171</td><td>liyanfeng</td><td>yanfeng</td><td>Intranet</td></tr><tr><td>192.168.0.171</td><td>maobakeji</td><td>maoba</td><td>Intranet</td></tr><tr><td>106.12.98.12</td><td>root</td><td>lyf8068353A@</td><td>Outter net</td></tr></tbody></table></div>]]></content>
      
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>port-security</title>
      <link href="/2017/10/30/port-security-1/"/>
      <url>/2017/10/30/port-security-1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>端口映射</title>
      <link href="/2017/10/30/port-security/"/>
      <url>/2017/10/30/port-security/</url>
      
        <content type="html"><![CDATA[<p>端口安全（Port Security），从基本原理上讲，Port Security特性会通过MAC地址表记录连接到交换机端口的以太网MAC地址（即网卡号），并只允许某个MAC地址通过本端口通信。其它MAC地址发送的数据包通过此端口是，端口安全特性会组织它。使用端口安全特性可以防止未经允许的设备访问网络，并增强安全性。</p>]]></content>
      
      
      
        <tags>
            
            <tag> server </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ps</title>
      <link href="/2017/10/30/ps/"/>
      <url>/2017/10/30/ps/</url>
      
        <content type="html"><![CDATA[<p>USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND<br>root      44936 99.1  1.4 148660 14340 ?        R    10月28 2004:47 ./XGMS_d gms_cfg.txt</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>poll</title>
      <link href="/2017/10/28/poll/"/>
      <url>/2017/10/28/poll/</url>
      
        <content type="html"><![CDATA[<p>Poll就是监控文件是否可读的一种机制，作用与select一样。<br>应用程序的调用如下：</p><pre><code>int poll(struct pollfd *fds, nfds_t nfds, int timeout)</code></pre><p>Poll机制会判断fds中的文件是否可读，如果可读则立即返回，返回的就是可读fd的数量，如果不可读，那么进程就会休眠。</p><h1 id="内核实现流程："><a href="#内核实现流程：" class="headerlink" title="内核实现流程："></a>内核实现流程：</h1><p>当应用程序调用poll函数的时候，系统会调用sys_poll函数，该函数最终调用do_poll函数，do_poll函数中有一个死循环，在里面又会利用</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XXSY服务器游戏架构</title>
      <link href="/2017/10/27/game-framework/"/>
      <url>/2017/10/27/game-framework/</url>
      
        <content type="html"><![CDATA[<h3 id="总体架构图"><a href="#总体架构图" class="headerlink" title="总体架构图"></a>总体架构图</h3><p><img src="http://oxcvfpext.bkt.clouddn.com/game-framework-1.png"></p><h3 id="大区架构图"><a href="#大区架构图" class="headerlink" title="大区架构图"></a>大区架构图</h3><p><img src="http://oxcvfpext.bkt.clouddn.com/game-framework-2.png"></p><h3 id="逻辑服务器架构图"><a href="#逻辑服务器架构图" class="headerlink" title="逻辑服务器架构图"></a>逻辑服务器架构图</h3><p><img src="http://oxcvfpext.bkt.clouddn.com/game-framework-3.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> server </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apache</title>
      <link href="/2017/10/27/Apache/"/>
      <url>/2017/10/27/Apache/</url>
      
        <content type="html"><![CDATA[<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">1</span>] 安装 httpd.</span><br><span class="line">[<span class="meta">root@linuxprobe ~</span>]<span class="meta"># yum -y install httpd</span></span><br><span class="line"><span class="meta"># 删除默认欢迎页面</span></span><br><span class="line">[<span class="meta">root@linuxprobe ~</span>]<span class="meta"># rm -f /etc/httpd/conf.d/welcome.conf</span></span><br><span class="line">[<span class="meta">2</span>] 配置httpd，将服务器名称替换为您自己的环境</span><br><span class="line">[<span class="meta">root@linuxprobe ~</span>]<span class="meta"># vim /etc/httpd/conf/httpd.conf</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">line</span> 86: 改变管理员的邮箱地址</span></span><br><span class="line">ServerAdmin root@linuxprobe.org</span><br><span class="line"><span class="meta"># <span class="meta-keyword">line</span> 95: 改变域名信息</span></span><br><span class="line">ServerName www.linuxprobe.org:<span class="number">80</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">line</span> 151: none变成All</span></span><br><span class="line">AllowOverride All</span><br><span class="line"><span class="meta"># <span class="meta-keyword">line</span> 164: 添加只能使用目录名称访问的文件名</span></span><br><span class="line">DirectoryIndex index.html index.cgi index.php</span><br><span class="line"><span class="meta"># add follows to the end</span></span><br><span class="line"><span class="meta"># server's response header（安全性）</span></span><br><span class="line">ServerTokens Prod</span><br><span class="line"><span class="meta"># keepalive is ON</span></span><br><span class="line">KeepAlive On</span><br><span class="line">[<span class="meta">root@linuxprobe ~</span>]<span class="meta"># systemctl start httpd</span></span><br><span class="line">[<span class="meta">root@linuxprobe ~</span>]<span class="meta"># systemctl enable httpd</span></span><br><span class="line">[<span class="meta">3</span>] 如果Firewalld正在运行，请允许HTTP服务。，HTTP使用<span class="number">80</span> / TCP</span><br><span class="line">[<span class="meta">root@linuxprobe ~</span>]<span class="meta"># firewall-cmd --add-service=http --permanent</span></span><br><span class="line">success</span><br><span class="line">[<span class="meta">root@linuxprobe ~</span>]<span class="meta"># firewall-cmd --reload</span></span><br><span class="line">success</span><br><span class="line">[<span class="meta">4</span>] 创建一个HTML测试页，并使用Web浏览器从客户端PC访问它。如果显示以下页面，是正确的</span><br><span class="line">[<span class="meta">root@linuxprobe ~</span>]<span class="meta"># vi /var/www/html/index.html</span></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div style=<span class="string">"width: 100%; font-size: 40px; font-weight: bold; text-align: center;"</span>&gt;</span><br><span class="line">Welcome access LinuxProbe.org,This <span class="keyword">is</span> Test Page!</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><a href="http://blog.csdn.net/wh211212/article/details/52982917" target="_blank" rel="noopener">http://blog.csdn.net/wh211212/article/details/52982917</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> server </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vs</title>
      <link href="/2017/10/26/vs/"/>
      <url>/2017/10/26/vs/</url>
      
        <content type="html"><![CDATA[<p>$(TargetDir)\XGZS_d.exe<br>../data/cfg/network/cfg_relation.txt</p>]]></content>
      
      
      
        <tags>
            
            <tag> server </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>netstat</title>
      <link href="/2017/10/26/netstat/"/>
      <url>/2017/10/26/netstat/</url>
      
        <content type="html"><![CDATA[<ol><li>netstat -tln 查看端口占用情况\<br>p 可以显示进程<br>每一列含义<br>协议类型  接受流量 发送流量 本机地址 目的地址 状态<br>自己的IP地址就是本地地址，需要连接的地址的就是目的地址</li></ol><p>nmap 127.0.0.1 查看本机开放的端口<br>0.0.0.0 表示网络的所有主机<br>[{“type”:0,”pid”:-1,”Attr1”:0,”id”:1,”Attr2”:0,”name”:”PC主支”,”tag”:0},{“type”:0,”pid”:1,”Attr1”:0,”id”:2,”Attr2”:0,”name”:”策划大区”,”tag”:1},{“type”:0,”pid”:1,”Attr1”:0,”id”:3,”Attr2”:0,”name”:”程序大区”,”tag”:1},{“type”:0,”pid”:1,”Attr1”:0,”id”:4,”Attr2”:0,”name”:”3.0.90.0”,”tag”:1},{“type”:0,”pid”:1,”Attr1”:0,”id”:22,”Attr2”:0,”name”:”4.0.30.0”,”tag”:1},{“type”:0,”pid”:1,”Attr1”:0,”id”:28,”Attr2”:0,”name”:”云服务器”,”tag”:1},{“type”:0,”pid”:1,”Attr1”:0,”id”:34,”Attr2”:0,”name”:”4.0.0.0”,”tag”:1},{“type”:0,”pid”:1,”Attr1”:0,”id”:35,”Attr2”:0,”name”:”3.0.60.0”,”tag”:1},{“type”:0,”pid”:1,”Attr1”:0,”id”:41,”Attr2”:0,”name”:”合服”,”tag”:1},{“type”:1,”pid”:2,”id”:381,”RoleCount”:0,”RoleInfos”:{},”name”:”[1]策划主支”,”Attr1”:4,”Flag”:64,”Url”:”192.168.3.6:16400”,”Attr2”:0,”tag”:3},{“type”:1,”pid”:2,”id”:382,”RoleCount”:0,”RoleInfos”:{},”name”:”[2]策划主支”,”Attr1”:3,”Flag”:64,”Url”:”192.168.6.113:16400”,”Attr2”:0,”tag”:1},{“type”:1,”pid”:3,”id”:256,”RoleCount”:0,”RoleInfos”:{},”name”:”[1]程序主支”,”Attr1”:2,”Flag”:64,”Url”:”192.168.3.6:26400”,”Attr2”:0,”tag”:3},{“type”:1,”pid”:3,”id”:257,”RoleCount”:0,”RoleInfos”:{},”name”:”[2]程序主支”,”Attr1”:1,”Flag”:64,”Url”:”192.168.6.113:26400”,”Attr2”:0,”tag”:1},<br>{“type”:1,”pid”:3,”id”:259,”RoleCount”:0,”RoleInfos”:{},”name”:”yhy-1”,”Attr1”:0,”Flag”:32,”Url”:”192.168.7.13:3100 192.168.7.13:3110”,”Attr2”:0,”tag”:1},<br>{“type”:1,”pid”:3,”id”:53,”RoleCount”:0,”RoleInfos”:{},”name”:”yhy-2”,”Attr1”:0,”Flag”:32,”Url”:”192.168.7.13:13100”,”Attr2”:0,”tag”:1},<br>{“type”:1,”pid”:3,”id”:19,”RoleCount”:0,”RoleInfos”:{},”name”:”218(zy)”,”Attr1”:0,”Flag”:32,”Url”:”192.168.5.106:3100”,”Attr2”:0,”tag”:1},<br>{“type”:1,”pid”:3,”id”:20,”RoleCount”:0,”RoleInfos”:{},”name”:”190(zmq)”,”Attr1”:0,”Flag”:32,”Url”:”192.168.5.228:26400”,”Attr2”:0,”tag”:1},<br>{“type”:1,”pid”:3,”id”:21,”RoleCount”:0,”RoleInfos”:{},”name”:”230(hjz)”,”Attr1”:0,”Flag”:32,”Url”:”10.96.205.230:26400”,”Attr2”:0,”tag”:1},<br>{“type”:1,”pid”:3,”id”:310,”RoleCount”:0,”RoleInfos”:{},”name”:”测试专服”,”Attr1”:0,”Flag”:64,”Url”:”192.168.6.113:7100”,”Attr2”:0,”tag”:1},<br>{“type”:1,”pid”:3,”id”:268,”RoleCount”:0,”RoleInfos”:{},”name”:”主支跨服大区”,”Attr1”:0,”Flag”:64,”Url”:”192.168.3.6:10010”,”Attr2”:0,”tag”:1},<br>{“type”:1,”pid”:4,”id”:93,”RoleCount”:0,”RoleInfos”:{},”name”:”[1]3.0.90.0”,”Attr1”:0,”Flag”:64,”Url”:”192.168.3.6:51100”,”Attr2”:0,”tag”:3},<br>{“type”:1,”pid”:4,”id”:94,”RoleCount”:0,”RoleInfos”:{},”name”:”[2]3.0.90.0”,”Attr1”:0,”Flag”:64,”Url”:”192.168.6.113:51100”,”Attr2”:0,”tag”:1},<br>{“type”:1,”pid”:22,”id”:95,”RoleCount”:0,”RoleInfos”:{},”name”:”[1]4.0.30.0”,”Attr1”:0,”Flag”:64,”Url”:”192.168.3.6:43100”,”Attr2”:0,”tag”:1},<br>{“type”:1,”pid”:22,”id”:96,”RoleCount”:0,”RoleInfos”:{},”name”:”[2]4.0.30.0”,”Attr1”:0,”Flag”:64,”Url”:”192.168.6.113:43100”,”Attr2”:0,”tag”:1},{“type”:1,”pid”:28,”id”:5999,”RoleCount”:0,”RoleInfos”:{},”name”:”IOS游客”,”Attr1”:0,”Flag”:64,”Url”:”139.199.37.182:48100”,”Attr2”:0,”tag”:1},{“type”:1,”pid”:28,”id”:4999,”RoleCount”:0,”RoleInfos”:{},”name”:”IOS微信”,”Attr1”:0,”Flag”:64,”Url”:”139.199.37.182:53100”,”Attr2”:0,”tag”:1},{“type”:1,”pid”:28,”id”:3999,”RoleCount”:0,”RoleInfos”:{},”name”:”IOS手Q”,”Attr1”:0,”Flag”:64,”Url”:”139.199.37.182:33100”,”Attr2”:0,”tag”:1},{“type”:1,”pid”:28,”id”:1999,”RoleCount”:0,”RoleInfos”:{},”name”:”安卓手Q”,”Attr1”:0,”Flag”:64,”Url”:”139.199.37.182:23100”,”Attr2”:0,”tag”:1},{“type”:1,”pid”:28,”id”:2999,”RoleCount”:0,”RoleInfos”:{},”name”:”安卓微信”,”Attr1”:0,”Flag”:64,”Url”:”139.199.37.182:28100”,”Attr2”:0,”tag”:1},{“type”:1,”pid”:34,”id”:97,”RoleCount”:0,”RoleInfos”:{},”name”:”[1]4.0.0.0”,”Attr1”:0,”Flag”:64,”Url”:”192.168.3.6:20400”,”Attr2”:0,”tag”:1},{“type”:1,”pid”:34,”id”:98,”RoleCount”:0,”RoleInfos”:{},”name”:”[2]4.0.0.0”,”Attr1”:0,”Flag”:64,”Url”:”1921.68.6.113:20400”,”Attr2”:0,”tag”:1},{“type”:1,”pid”:35,”id”:90,”RoleCount”:0,”RoleInfos”:{},”name”:”[1]3.0.60.0”,”Attr1”:6,”Flag”:64,”Url”:”192.168.3.6:6400”,”Attr2”:0,”tag”:1},{“type”:1,”pid”:35,”id”:91,”RoleCount”:0,”RoleInfos”:{},”name”:”[2]3.0.60.0”,”Attr1”:5,”Flag”:64,”Url”:”192.168.6.113:6400”,”Attr2”:0,”tag”:1},{“type”:1,”pid”:41,”id”:311,”RoleCount”:0,”RoleInfos”:{},”name”:”合服后(3014+3016)”,”Attr1”:0,”Flag”:64,”Url”:”192.168.6.113:7100”,”Attr2”:0,”tag”:9},{“type”:1,”pid”:41,”id”:312,”RoleCount”:0,”RoleInfos”:{},”name”:”3014”,”Attr1”:0,”Flag”:64,”Url”:”192.168.6.113:23100”,”Attr2”:0,”tag”:9},{“type”:1,”pid”:41,”id”:313,”RoleCount”:0,”RoleInfos”:{},”name”:”3016”,”Attr1”:0,”Flag”:64,”Url”:”192.168.6.113:37100”,”Attr2”:0,”tag”:9}]</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多语言规范</title>
      <link href="/2017/10/25/lang/"/>
      <url>/2017/10/25/lang/</url>
      
        <content type="html"><![CDATA[<h1 id="概述部分"><a href="#概述部分" class="headerlink" title="概述部分"></a>概述部分</h1><p>多语言资源，客户端和服务器放在不同目录里，公用的部分使用外链。</p><p>客户端多语言根目录：Assets\Art\lang<br>二级目录mb：存放mb的多语言数据<br>二级目录res: 存放界面文本，以及其它资源的多语言数据（比如图片和prefab等）<br>三级目录：用各种语言名字来命令的目录<br>config.txt：保存当前语言的名字</p><p>服务器多语言根目录：bin\data\lang<br>二级目录mb：存放mb的多语言数据（这个是上面的客户端二级mb的外链）<br>二级目录mbs：存放mbs多语言数据<br>三级目录：用各种语言名字来命名的目录<br>config.txt：保存当前语言的名字（服务器和客户端需要分别配置）</p><h2 id="程序需要做的事情-："><a href="#程序需要做的事情-：" class="headerlink" title="程序需要做的事情:："></a>程序需要做的事情:：</h2><ol><li>处理表格配置，合理设置翻译列；</li><li>在界面prefab里，给UILabel等控件填写langId，需要同时创建对应的文字资源文件；</li><li>界面用到的Lua/text里的json文件，需要转换成txt文件资源；</li><li>脚本里的中文，需要放到文本资源里；</li><li>图片文字，需要整理放到单独目录里，便于提供海外运营商；</li></ol><h1 id="res目录规范"><a href="#res目录规范" class="headerlink" title="res目录规范"></a>res目录规范</h1><p>此目录是界面文本资源表格，表格无标题行，分三列：名字，文本，英文长度，某些按钮类的空间，如果需要限制文本长度，那么需要填写英文长度列。<br>不要有任何子目录，子目录是无效的。<br>非翻译文本（比如目录配置文本），放到lua里就好，不要放在txt里。<br>此目录里的所有文件，都是用到的时候加载的<br>文本资源使用方式：</p><ul><li>C#代码访问方式：LangMgr.Find(“login.Username”),此函数无GC</li><li>prefab访问方式：填写UILabel的langId,格式同上，所有中文标签都要做修改。</li><li>lua脚本访问方式：lua_core.LoadLangFile(“login”).Username<br>目录file：<br>可替换掉相同路径的资源，比如字体替换，文字图片替换等，也可以直接用这个替换整个界面的prefab，但是轻易不要这样用。</li></ul><h2 id="Json转Text工具"><a href="#Json转Text工具" class="headerlink" title="Json转Text工具"></a>Json转Text工具</h2><p>在Unity里，选中Lua/text/目录里的某个文件<br>点击菜单项Pangmei/Translate/json转text，这样可以将原本的json文件转txt表格。<br>转换后的文件放在了Assets\Art\lang\res\zh_cn\text\temp里，需要重新命名后挪出来。<br>原本的子目录都不要有了，如果有重命名，就自己改个名字。<br>建议文件别太多，太小的文件自己合并一下，文件少会更容易管理。</p><h2 id="新文本merge方式"><a href="#新文本merge方式" class="headerlink" title="新文本merge方式"></a>新文本merge方式</h2><p>可以使用string.merge()来格式化字符串，这个是仿造C#的Format来设计功能。用{0}引用首个参数，其余参数类推。这个函数在客户端没有C#级别的GCAlloc，大量使用的时候推荐这个，不要用CSFormat系列了。<br>部分带%s的文本，建议都检查一下，多个%s的文本有可能会导致某些语言翻译错误（主谓宾和汉语次序不同导致）</p><h1 id="mb目录规范"><a href="#mb目录规范" class="headerlink" title="mb目录规范"></a>mb目录规范</h1><h2 id="翻译列配置"><a href="#翻译列配置" class="headerlink" title="翻译列配置"></a>翻译列配置</h2><p>表格的json配置文件，每列可以加防疫配置”translate”:true<br>指定翻译的列：会被翻译工具检索出来生成翻译词条。</p><h2 id="目录text"><a href="#目录text" class="headerlink" title="目录text"></a>目录text</h2><p>有工具生成的表格翻译文本，运行期动态替换掉中文表格文本。</p><h2 id="目录cell"><a href="#目录cell" class="headerlink" title="目录cell"></a>目录cell</h2><p>替换掉同名表格指定单元格的内容，不需要写子目录。<br>多个文件可以同名，以二级扩展名区分，比如：item_list.a.txt,item_list.b.txt<br>同名文件按照二级扩展名排序依次执行，重复配置的单元格，以最后的为准。<br>首行是标题，第二行是json配置里的表格列的名字，后续航是替换的内容。<br>第二行的名字，可以不填写，就表示忽略该列。此特性通常用于注释或者名字之类的。<br>空单元格表示不需要替换，如果需要替换为空，那么填写“##”</p><h2 id="目录file"><a href="#目录file" class="headerlink" title="目录file"></a>目录file</h2><p>整文件替换表格，对应的参照目录是mb目录。<br>这个功能尽量别用，使用cell来精确替换某个单元格更可控。</p><h1 id="mbs目录规范"><a href="#mbs目录规范" class="headerlink" title="mbs目录规范"></a>mbs目录规范</h1><h2 id="翻译列配置："><a href="#翻译列配置：" class="headerlink" title="翻译列配置："></a>翻译列配置：</h2><p>规则同mb</p><h2 id="目录text-1"><a href="#目录text-1" class="headerlink" title="目录text"></a>目录text</h2><p>规则同mb</p><h2 id="目录cell-1"><a href="#目录cell-1" class="headerlink" title="目录cell"></a>目录cell</h2><p>基本规则同mb<br>有子目录npc_refresh和flag，分别对应那两组表，目录内的规则也同mb</p><h2 id="目录file-1"><a href="#目录file-1" class="headerlink" title="目录file"></a>目录file</h2><p>规则同mb</p><h1 id="翻译工具"><a href="#翻译工具" class="headerlink" title="翻译工具"></a>翻译工具</h1><p>海外专员翻译工具路径：<br>svn://zentia/welcome/LangTool<br>海外专员一般是市场部同学。<br>负责将待翻译的文本到处，然后发给海外运营商翻译，并且将译文导入公用词条库里。</p><h2 id="项目分支翻译工具路径："><a href="#项目分支翻译工具路径：" class="headerlink" title="项目分支翻译工具路径："></a>项目分支翻译工具路径：</h2><p>svn://zentia/trunk/xxpub/LangTool（其余分支路径类似）<br>项目的导入职能由产品负责<br>需要在每个海外版本发布前，将特定分支生成海外文本资源并且上传。</p><h1 id="多语言名字参照"><a href="#多语言名字参照" class="headerlink" title="多语言名字参照"></a>多语言名字参照</h1><p>微软的多语言名称参考网站：<a href="https://www.microsoft.com/en-us/locale.aspx" target="_blank" rel="noopener">https://www.microsoft.com/en-us/locale.aspx</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> sy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fork</title>
      <link href="/2017/10/25/fork/"/>
      <url>/2017/10/25/fork/</url>
      
        <content type="html"><![CDATA[<p>通过系统调用创建一个与原来进程几乎完全相同的进程，也就是说两个进程可以做完全相同的事情，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。<br>一个进程调用fork()函数之后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后吧原来的进程的所有值都复制到新的进程中，只有少数值与原来进程的值不同。相当于克隆了一个自己。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">whdaemon_init</span><span class="params">(<span class="keyword">bool</span> bAutoCloseFD)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Transform to daemon ... "</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( (pid=fork()) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed!%s"</span>, WHINEED);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid !=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//parent goes bye-bye</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"SUCCESS, pid might be:%d!%s"</span>, pid+<span class="number">1</span>, WHLINEEND);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭所有句柄</span></span><br><span class="line">    <span class="keyword">if</span> (bAutoCloseFD)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; MAXFD; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            close(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 否则至少关闭标准的输入输出</span></span><br><span class="line">        close(<span class="number">0</span>);</span><br><span class="line">        close(<span class="number">1</span>);</span><br><span class="line">        close(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 变成seeion leader</span></span><br><span class="line">    setsid();</span><br><span class="line"></span><br><span class="line">    signal(SIGHUP, SIG_IGN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结束第一个紫禁城</span></span><br><span class="line">    <span class="keyword">if</span> ((pid=<span class="keyword">for</span>() != <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> gcc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>time</title>
      <link href="/2017/10/24/time/"/>
      <url>/2017/10/24/time/</url>
      
        <content type="html"><![CDATA[<p>设置时间同步<br>timedatectl set-ntp yes</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>systemctl</title>
      <link href="/2017/10/24/systemctl/"/>
      <url>/2017/10/24/systemctl/</url>
      
        <content type="html"><![CDATA[<p>显示防火墙状态：systemctl status firewalld.service<br>关闭防火墙：systemctl stop firewalld.service<br>开启防火墙：systemctl start firewalld.service<br>上面的firewalld的，不过我后来安装了iptables换一下就好了</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器搭建和日常维护</title>
      <link href="/2017/10/24/server-set/"/>
      <url>/2017/10/24/server-set/</url>
      
        <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><h1 id="2-系统软硬件要求"><a href="#2-系统软硬件要求" class="headerlink" title="2 系统软硬件要求"></a>2 系统软硬件要求</h1><p>软件：<br>所有的服务器程序都可以在linux和windows系统上。推荐使用linux系统。<br>我们一般使用的系统是suse10.1，不过按要求，我们在tlinux的服务器上实验编译并运行了我们的所有服务器成。<br>Gcc版本：gcc(GCC)4.8.5<br>数据库使用MYSQL。版本：5.6.38<br>硬件：<br>参考先前提供的硬件配置资料<br>另外，请在启动文件/etc/rc.d/rc.local中设置共享内存、网络参数以及core文件模式<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#increase Linux SHM max</span></span><br><span class="line">echo <span class="number">300000000</span> &gt; <span class="meta-keyword">/proc/</span>sys<span class="meta-keyword">/kernel/</span>shmmax</span><br><span class="line"></span><br><span class="line"><span class="meta">#increase Linux TCP buffer limits</span></span><br><span class="line">echo <span class="number">8388608</span>&gt;<span class="meta-keyword">/proc/</span>sys<span class="meta-keyword">/net/</span>core/rmem_max</span><br><span class="line">echo <span class="number">8388608</span>&gt;<span class="meta-keyword">/proc/</span>sys<span class="meta-keyword">/net/</span>core/wmem_max</span><br><span class="line">echo <span class="number">262114</span>&gt;<span class="meta-keyword">/proc/</span>sys<span class="meta-keyword">/net/</span>core/rmem_default</span><br><span class="line">echo <span class="number">262114</span>&gt;<span class="meta-keyword">/proc/</span>sys<span class="meta-keyword">/net/</span>core/wmem_default</span><br><span class="line"></span><br><span class="line"><span class="meta">#increase Linux autotruning TCP buffer limits</span></span><br><span class="line">echo <span class="string">"4096 87380 8388608"</span>&gt;<span class="meta-keyword">/proc/</span>sys<span class="meta-keyword">/net/</span>ipv4/tcp_rmem</span><br><span class="line">echo <span class="string">"4096 65536 8388608"</span>&gt;<span class="meta-keyword">/proc/</span>sys<span class="meta-keyword">/net/</span>ipv4/tcp_wmem</span><br><span class="line">echo <span class="string">"8388608 8388608 8388608"</span>&gt;<span class="meta-keyword">/proc/</span>sys<span class="meta-keyword">/net/</span>ipv4/tcp_mem</span><br><span class="line">echo <span class="string">"840"</span>&gt;<span class="meta-keyword">/proc/</span>sys<span class="meta-keyword">/net/</span>ipv4/</span><br><span class="line">echo <span class="string">"core-%e-%p-%s"</span>&gt;<span class="meta-keyword">/proc/</span>sys<span class="meta-keyword">/kernel/</span>core_pattern</span><br></pre></td></tr></table></figure></p><h1 id="3-维护人员账号配置"><a href="#3-维护人员账号配置" class="headerlink" title="3 维护人员账号配置"></a>3 维护人员账号配置</h1><p>为了安全的原因，请不要使用root账号进行服务器的维护工作。</p><h1 id="4-MySQL的配置"><a href="#4-MySQL的配置" class="headerlink" title="4 MySQL的配置"></a>4 MySQL的配置</h1><h1 id="5-服务程序简介"><a href="#5-服务程序简介" class="headerlink" title="5 服务程序简介"></a>5 服务程序简介</h1><h1 id="6-服务程序的版本辨认"><a href="#6-服务程序的版本辨认" class="headerlink" title="6 服务程序的版本辨认"></a>6 服务程序的版本辨认</h1><h1 id="7-日志服务程序启动过程"><a href="#7-日志服务程序启动过程" class="headerlink" title="7 日志服务程序启动过程"></a>7 日志服务程序启动过程</h1><h2 id="7-1-启动日志服务"><a href="#7-1-启动日志服务" class="headerlink" title="7.1 启动日志服务"></a>7.1 启动日志服务</h2><h2 id="7-2-检查"><a href="#7-2-检查" class="headerlink" title="7.2 检查"></a>7.2 检查</h2><h1 id="8-游戏服务器启动过程"><a href="#8-游戏服务器启动过程" class="headerlink" title="8 游戏服务器启动过程"></a>8 游戏服务器启动过程</h1><h2 id="8-1-启动日志服务"><a href="#8-1-启动日志服务" class="headerlink" title="8.1 启动日志服务"></a>8.1 启动日志服务</h2><h2 id="8-2-启动游戏总控框架"><a href="#8-2-启动游戏总控框架" class="headerlink" title="8.2 启动游戏总控框架"></a>8.2 启动游戏总控框架</h2><h2 id="8-3-启动游戏场景线"><a href="#8-3-启动游戏场景线" class="headerlink" title="8.3 启动游戏场景线"></a>8.3 启动游戏场景线</h2><h2 id="8-4-检查"><a href="#8-4-检查" class="headerlink" title="8.4 检查"></a>8.4 检查</h2><h1 id="9-服务组关闭过程"><a href="#9-服务组关闭过程" class="headerlink" title="9 服务组关闭过程"></a>9 服务组关闭过程</h1><h1 id="10-YYCGZS的维护"><a href="#10-YYCGZS的维护" class="headerlink" title="10 YYCGZS的维护"></a>10 YYCGZS的维护</h1>]]></content>
      
      
      
        <tags>
            
            <tag> server </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器安装说明</title>
      <link href="/2017/10/24/server-install/"/>
      <url>/2017/10/24/server-install/</url>
      
        <content type="html"><![CDATA[<ol><li>解压服务器执行文件xx_svr_binfull_XXXX.tgz到指定文件夹。</li><li>解压配置文件xx_svr_cfgfull_XXXX.tgz到相同的文件夹。</li><li>解压配置文件xx_svr_resfull_XXXX.tgz到相同的文件夹。</li><li>将我们提供的key文件修改文件名为auth-info.key放在XCAAFS和XCLS文件夹下</li><li>XGMS目录下创建filecache目录，并给予执行服务器帐号写权限。</li><li>XLBA目录下创建siglog目录，并给予执行服务器帐号写权限。</li><li>确认pid文件目录/tmp有写权限，确认/data日志目录有写权限。</li><li>创建数据库，执行SQL下ca.sh，命令为：<br>./ca.sh 版本后缀 地址<br>如：<br>./ca.sh sy xxsy.cxebfhyvgemb.us-east-2.rds.amazonaws.com</li><li>修改配置文件cmncfg.txt，主要修改如下：<br>SVRGRPID    大区ID，如果需要在一个集群建立多个大区，则大区ID不可重复<br>VER_EXT        版本后缀，同一台机器配置多组大区的时候必须不同<br>ONEOUTERIP    对外IP，客户端主要从此IP连接服务器<br>ONEINNERIP    服务器组内部IP，服务器间通信通过此IP<br>MYSQLIP        数据库IP<br>GDB_PORT    数据库端口<br>DB_USER        数据库帐号<br>DB_PASSWORD    数据库密码<br>PORTSHIFT    同一台机器上启动多组服务器必须不同<br>SHMSHIFT    同上<br>注：如分开多台服务器架设还需要修改指定服务器地址</li><li>按照《服务器搭建和日常维护》文档第2节修改共享内存限制和tcp相关配置。</li><li>runGlog.sh启动日志服务器，一共15个进程。</li><li>执行run.sh启动服务器组。</li></ol><p>共有IP:18.219.246.109<br>私有IP:172.31.29.118</p>]]></content>
      
      
      
        <tags>
            
            <tag> server </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uwa</title>
      <link href="/2017/10/23/uwa/"/>
      <url>/2017/10/23/uwa/</url>
      
        <content type="html"><![CDATA[<h1 id="AssetBundle-lockpersistentmanager开销"><a href="#AssetBundle-lockpersistentmanager开销" class="headerlink" title="AssetBundle lockpersistentmanager开销"></a>AssetBundle lockpersistentmanager开销</h1><p>观察性能曲线，发现某一帧AssetBundle加载中，lockpersistentmanager耗时比较大。请问这块是否能够优化？<br>这说明当前帧或前几帧中存在较大量的资源在通过LoadAsync来进行加载，其本质是所加载的资源过大所致，对自身资源进行合理优化可降低Loading.LockPersistentManager的开销。另外，将异步加载换成同步加载，LockPersistentManager就不会出现了，但其总加载耗时是没有变化的，因为总加载量没变。<br>关于主要资源的加载优化，可参考如下链接：<br><a href="https://blog.uwa4d.com/archives/LoadingPerformance_Texture.html" target="_blank" rel="noopener">https://blog.uwa4d.com/archives/LoadingPerformance_Texture.html</a><br><a href="https://blog.uwa4d.com/archives/LoadingPerformance_Mesh.html" target="_blank" rel="noopener">https://blog.uwa4d.com/archives/LoadingPerformance_Mesh.html</a><br><a href="https://blog.uwa4d.com/archives/LoadingPerformance_Shader.html" target="_blank" rel="noopener">https://blog.uwa4d.com/archives/LoadingPerformance_Shader.html</a><br><a href="https://blog.uwa4d.com/archives/Loading_AnimationClip.html" target="_blank" rel="noopener">https://blog.uwa4d.com/archives/Loading_AnimationClip.html</a><br><a href="https://blog.uwa4d.com/archives/livebroadcast6-8.html" target="_blank" rel="noopener">https://blog.uwa4d.com/archives/livebroadcast6-8.html</a></p><pre><code>** IN DIR:3rd, make dep with Makefile_debug.mk dep **   make[1]: 进入目录“/root/work_code/3rd”   ** IN DIR:cryptlib, make dep with Makefile_debug.mk dep **   make[2]: 进入目录“/root/work_code/3rd/cryptlib”g++ -DLINUX -D_FILE_OFFSET_BITS=64 -D_LARGEFILE64_SOURCE -D_LARGEFILE_SOURCE -march=core2 -m32 -MM -MT &quot;../temp/debug/cryptlib/cpu.o_d&quot; -MF ../temp/debug/cryptlib/cpu.d_d cpu.cpp -I/usr/include/mysql  -I/root/work_code/3rd -I/root/work_code/3rd/freetype221 -I/root/work_code/src/engine -I/root/work_code/src/svr -I/root/work_code/src/xxsy -I/root/work_code/src/svr/glogger/tlog/linux   &lt;built-in&gt;:0:0: 致命错误：打开依赖文件 ../temp/debug/cryptlib/cpu.d_d：没有那个文件或目录-DLINUX                 #define LINUX-D_FILE_OFFSET_BITS     #define _FILE_OFFSET_BITS</code></pre><p>-D_LARGFEFILE64_SOURCE<br>march指定的是当前cpu的架构，而mtune是真正作用于某一型号cpu的选项。<br>    -M 生成文件关联的信息。<br>    -MM 忽略由#include造成的依赖关系<br>    -MF 指一个文件用于存放生成文件的关联信息，这些信息与-M或-MM是一样的，<br>    -MT 指定目标文件名</p><h1 id="Camera-Render里面Animation-RebuildInternalState耗时较多"><a href="#Camera-Render里面Animation-RebuildInternalState耗时较多" class="headerlink" title="Camera.Render里面Animation.RebuildInternalState耗时较多"></a>Camera.Render里面Animation.RebuildInternalState耗时较多</h1><p>之所以出现这一项，主要可以说以下两点：<br>（1）项目用的是Animation老版动画系统；<br>（2）对含有Animation组件的GameObject进行了大量频繁的Active或者Instantiate操作，一般这种情况比较常见于特效、UI HUD、角色/怪物等。</p><h1 id="是否可以针对特定GameObject提升它的物理模拟次数"><a href="#是否可以针对特定GameObject提升它的物理模拟次数" class="headerlink" title="是否可以针对特定GameObject提升它的物理模拟次数"></a>是否可以针对特定GameObject提升它的物理模拟次数</h1><p>我们在做一个尽速项目，发现有时候物理的计算并不是非常准确，在运动速度较快时，依然会和墙体造成部分穿插，这给我们的游戏带来了很不好的体验，我知道可以通过Fixed TimeStep来提升物理系统的每帧的计算速度，目前该值为0.02，也就是1秒计算50次，Edit&gt;Project Settings&gt;Time&gt;Fixed TimeStep=0.02。我们曾将其设置为0.005，穿插问题明显好转，但是看上去该值是对所有GameObject均使用的，所以我想问问能否仅针对某一个GameObject来进行提升它的物理计算频率？<br>这是不行的，因为Fixed TimeStep是Unity引擎物理模块的全局参数。建议题主可以考虑将碰撞检测的模式改为”Continuous Dynamic”，看看是否满足需求。但是，需要说明的是，如果物体的速度确实非常快，那么任何一种碰撞模式都不能100%达到不穿插的效果。建议题主可以考虑增大碰撞体的Size或者通过射线求交的方式来将出现穿插问题的概率降到最低。</p><h1 id="请教AssetBundle-Diff-Patch-方案是否可行"><a href="#请教AssetBundle-Diff-Patch-方案是否可行" class="headerlink" title="请教AssetBundle Diff Patch 方案是否可行"></a>请教AssetBundle Diff Patch 方案是否可行</h1><h2 id="我原先的更新方案是比对AssetBundle文件的hash值直接替换整个AssetBundle和manifest来达到更新效果的，有没有其它方案类似diff-patch-可以减少更新包体，如果可以做diff-patch，资源颗粒度是不是九可以忽略了"><a href="#我原先的更新方案是比对AssetBundle文件的hash值直接替换整个AssetBundle和manifest来达到更新效果的，有没有其它方案类似diff-patch-可以减少更新包体，如果可以做diff-patch，资源颗粒度是不是九可以忽略了" class="headerlink" title="我原先的更新方案是比对AssetBundle文件的hash值直接替换整个AssetBundle和manifest来达到更新效果的，有没有其它方案类似diff patch,可以减少更新包体，如果可以做diff patch，资源颗粒度是不是九可以忽略了"></a>我原先的更新方案是比对AssetBundle文件的hash值直接替换整个AssetBundle和manifest来达到更新效果的，有没有其它方案类似diff patch,可以减少更新包体，如果可以做diff patch，资源颗粒度是不是九可以忽略了</h2><p>基于AB的直接Diff更新目前没有成熟的方案，不过只把完整的Resources库中的部分资源更新的项目，已经做了2个了。<br>思路其实很简单：<br>1、出整包的时候，用ScriptableObject记录下AssetsDataBase中所有被发布资源的MD5码（不能用Unity自己的hash码）。<br>2、用工具调出哪些assets是代码动态Load的，分一个Res包中；找出这些资源的依赖资源，分入一个Share包中，并记录每个Asset所属的AB包。<br>3、出补丁时，对比当前AssetsDataBase中哪些代码中动态Load的资源出现了增加和改动（删除可以无视），包括他们依赖的资源。仍然把代码中动态Load的资源ResPatch中，依赖放入SharePatch中。对于没有变化的资源，仍然维持原来AB名字。<br>4、记录下次补丁之后，更新每个Asset所属的AB包。<br>5、下一次补丁时的Res和Share可能会依赖上一次的补丁的Share。<br>6、运行时，对所有补丁入的Res建立一个字典索引。Load的时候，有限判断这个Asset是否在补丁的Res包中，如果是则读补丁的AB包，并按套路处理依赖包。否则就用二进制版本内建的包</p><p>这种做法的好处是：<br>1、充分利用版本中的已经发布的资源，以减小补丁包的体积<br>2、补丁包的打包规则可以几乎无视完整包的分包规则，方便后续折腾</p><p>当然缺点也是很严重的：</p><ul><li>Reserved Total                 - Unity引擎在内存方面的总体分配量。Unity引擎的内存并不是随用随取，而是预先从操作系统中申请一块，然后再进行使用。</li><li>Uesd Total                     - Unity引擎再内存方面的总体使用量。</li><li>Reserved Unity &amp; Used Unity     - Unity引擎自身各个模块内部的内存分配，宝库偶各个Manager的内存占用、序列化信息的内存站哟个，WebStream/SerializedFile内存占用和部分资源的内存暂用等等。 </li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gcc</title>
      <link href="/2017/10/23/gcc/"/>
      <url>/2017/10/23/gcc/</url>
      
        <content type="html"><![CDATA[<h1 id="extern-static"><a href="#extern-static" class="headerlink" title="extern static"></a>extern static</h1><p>extern 指为导出到其它文件所使用的非statice变量<br>static是当前文件的静态变量<br>二者不能同时定义<br>setarch i386 ./config -m32<br>编译32位的openssh<br>缺少 gnu/stubs-32.h</p><pre><code>yum install glibc-devel.i686</code></pre><p>gcc没有找到</p><pre><code>yum install libstdc++-devel.i686yum install -y gcc gcc+ gcc-c++</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> gcc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity Shader PBR</title>
      <link href="/2017/10/23/ShaderLab/"/>
      <url>/2017/10/23/ShaderLab/</url>
      
        <content type="html"><![CDATA[<h1 id="观察两个空间"><a href="#观察两个空间" class="headerlink" title="观察两个空间"></a>观察两个空间</h1><p>阴影映射(Shadow Mapping)牵涉到两个空间的Z深度比较,一个是灯光空间,一个是相机空间,首先打开ShadowMapping_2下的场景,场景是默认的相机视角,单击下面的Light View按钮,可以切换到灯光视角,<br>13.1.2 两个视角的Z深度<br>分别单机LightView Depth和CamView Depth,然后到Shadow/ShadowMapping工程文件夹下面找到_CamViewZDepth和_LightViewZDepth两张Render Texture,查看一下渲染输出的ZDepth<br>13.1.3 渲染Z深度的材质<br>这两张ZDepth是分别在灯光视角和相机使用Replacement Shader 渲染出来的<br>在vertex函数vert中,主要操作除了对物体形体的必要输出外,就是UNITY_TRANSFERDEPTH(o.depth),打开UnityCG.cginc文件,会发现它一般情况下的操作就是o.depth = o.pos.zw,把物体在投影空间做的zw值赋给o.depth,再将它的值输出到一张Render Texture 之前,通过Linear01Depth(d)函数把Z的值变换到01空间,这样我们可以看到一张对比度更强的Z深度图,就像在上面所看到的那样,而不是一张大多数情况下都朦朦胧胧的Z深度图<br>13.2 投射Z深度<br>13.2.1 准备灯光视角的投影矩阵<br> 在进行映射阴影经典的Z深度比较之前,我们需要把灯光视角ZDepth深度图投射到相机视角.打开ShadowMapping_3下的场景.和上一个场景系相比,附加在Main Camera物体上的ShadowMapping_3.cs<br>13.3.4 对Z值进行偏移<br>显然,Z的精度是个问题,而且通过上述编码操作我们已经解决了Shadow ance的问题,但是主要问题依然,这个现象叫Peter Panning,源自迪尼斯的一部动画主角Peter Pan,他的影子可以脱离自身活动起来,打开</p><ol><li>分开处理反射面的绝缘体特性和金属属性，最后光照应该是Diffuse+Specular</li><li>纯金属没有Diffuse，非金属主要是Diffuse，有一点反射</li><li>光部分主要有3个东西影响：微表面的法线分布（NDF），微表面的入射和反射遮挡（Geometry Function），反射率和入射角的关系（Fresnel反射）。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua中元方法_newindex详解</title>
      <link href="/2017/10/23/newindex/"/>
      <url>/2017/10/23/newindex/</url>
      
        <content type="html"><![CDATA[<p>__index元方法用于处理调用table中不存在的字段和查询<br>__newindex用于更新</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> smartMan = &#123;</span><br><span class="line">    name = <span class="string">"lyf"</span>,</span><br><span class="line">    money = <span class="number">900</span>,</span><br><span class="line"></span><br><span class="line">    sayHello = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"hello,I’m lyf"</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> t1 = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> mt = &#123;</span><br><span class="line">    <span class="built_in">__index</span> = smartMan,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setmetatable</span>(t1, mt);</span><br><span class="line"></span><br><span class="line">t1.sayHello = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"en"</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">t1.sayHello()</span><br></pre></td></tr></table></figure><p>这是一个模仿继承结构的例子<br>mt作为t1的元表,设置__index为smartMan<br>于是,当我们调用t1中不存在的字段时,就会自动去smartMan中查找<br>比如我们调用了t1.sayHello(),自然就能找到对应的函数</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="keyword">local</span> smartMan = &#123;</span><br><span class="line">        name = <span class="string">"none"</span>,</span><br><span class="line">        money = <span class="number">9000000</span>,</span><br><span class="line"></span><br><span class="line">        sayHello = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Hello world!"</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">local</span> t1 = &#123;&#125;;</span><br><span class="line">    <span class="keyword">local</span> mt = &#123;</span><br><span class="line">        <span class="built_in">__index</span> = smartMan,</span><br><span class="line"></span><br><span class="line">        <span class="built_in">__newindex</span> = <span class="function"><span class="keyword">function</span><span class="params">(table, key, value)</span></span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(key .. <span class="string">"字段是不存在的，不要试图给它赋值！"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setmetatable</span>(t1, mt);</span><br><span class="line"></span><br><span class="line">    t1.sayHello = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"en"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    t1.sayHello()</span><br></pre></td></tr></table></figure><p>留意mt元表,我们给他加了一个<strong>newindex<br>导致sayHello字段赋值失败,因为给sayHello字段赋值的时候,调用了</strong>index元方法,代替了赋值操作<br>和<strong>index一样,</strong>newindex元方法也可以赋值一个table<br>__newindex规则</p><ol><li>如果__newindex是一个函数,则在给table不存在的字段赋值时,会调用这个函数</li><li>如果<strong>newindex是一个table,则在给table不存在的字段赋值时,会直接给</strong>newindex的table赋值</li></ol><h1 id="Lua类和继承实现"><a href="#Lua类和继承实现" class="headerlink" title="Lua类和继承实现"></a>Lua类和继承实现</h1><p>Lua本身不能像C++那样直接实现继承，但是可以用table来实现<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object = &#123;class_id = <span class="number">0</span>&#125;</span><br><span class="line">funtion Object:New(o)</span><br><span class="line">    o = o <span class="keyword">or</span> &#123;&#125;</span><br><span class="line">    <span class="built_in">setmetatable</span>(o, self) <span class="comment">-- 对象o调用不存在的成员时会去self中查找，而这里的self指的就是Object</span></span><br><span class="line">    self.<span class="built_in">__index</span> = self</span><br><span class="line">    <span class="keyword">return</span> o</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c</title>
      <link href="/2017/10/22/c/"/>
      <url>/2017/10/22/c/</url>
      
        <content type="html"><![CDATA[<h1 id="先被声明为‘extern’后又被声明为‘static’"><a href="#先被声明为‘extern’后又被声明为‘static’" class="headerlink" title="先被声明为‘extern’后又被声明为‘static’"></a>先被声明为‘extern’后又被声明为‘static’</h1><p>In file included from src/mt_mysql_connector.cpp:14:0:<br>/usr/include/mysql/my_global.h: 在函数‘double log2(double)’中:<br>/usr/include/mysql/my_global.h:823:35: 错误：‘double log2(double)’先被声明为‘extern’后又被声明为‘static’ [-fpermissive]<br> static inline double log2(double x)<br>static 声明的全局变量只能在当前源文件中使用。<br>extern不是定义，是引入（声明）在其它源文件中定义的非static全局变量</p>]]></content>
      
      
      
        <tags>
            
            <tag> c </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lua-select</title>
      <link href="/2017/10/20/lua-select/"/>
      <url>/2017/10/20/lua-select/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>lua</title>
      <link href="/2017/10/20/lua/"/>
      <url>/2017/10/20/lua/</url>
      
        <content type="html"><![CDATA[<h1 id="让lua编译时计算"><a href="#让lua编译时计算" class="headerlink" title="让lua编译时计算"></a>让lua编译时计算</h1><p>由于lua的编译速度相当快，而且这种迭代编译的过程仅仅在程序加载的时候进行一次，故而可以带来性能的提高；一些在系统初始化可以决定的参数（比如从配置文件中读出来的数据直接编译为常量置入程序中。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">select</span> = <span class="built_in">select</span></span><br><span class="line"><span class="keyword">local</span> <span class="built_in">setmetatable</span> = <span class="built_in">setmetatable</span></span><br><span class="line"><span class="keyword">local</span> <span class="built_in">getfenv</span> = <span class="built_in">getfenv</span></span><br><span class="line"><span class="keyword">local</span> setfenc = <span class="built_in">setfenv</span></span><br><span class="line"><span class="keyword">local</span> loadstring = loadstring</span><br><span class="line"><span class="keyword">local</span> <span class="built_in">type</span> = <span class="built_in">type</span></span><br><span class="line"><span class="keyword">local</span> <span class="built_in">tostring</span> = <span class="built_in">tostring</span></span><br><span class="line"><span class="keyword">local</span> <span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"><span class="keyword">local</span> <span class="built_in">unpack</span> = <span class="built_in">unpack</span></span><br><span class="line"><span class="keyword">local</span> <span class="built_in">assert</span> = <span class="built_in">assert</span></span><br><span class="line"><span class="keyword">local</span> <span class="built_in">string</span> = <span class="built_in">string</span></span><br><span class="line"><span class="keyword">local</span> <span class="built_in">table</span> = <span class="built_in">table</span></span><br><span class="line"><span class="keyword">local</span> <span class="built_in">io</span> = <span class="built_in">io</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">result</span><span class="params">(...)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">select</span>(<span class="string">"#"</span>, ...), <span class="built_in">select</span>(<span class="number">1</span>, ...) <span class="comment">-- 参数的个数，第一个参数</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="Lua的upvalue和闭包"><a href="#Lua的upvalue和闭包" class="headerlink" title="Lua的upvalue和闭包"></a>Lua的upvalue和闭包</h1><p>Lua函数可以被当成参数传递，也可以被当成结果返回，在函数体中仍然可以定义内嵌函数，Lua闭包是Lua函数生成的数据对象。每个闭包可以有一个upvalue值，或者多个闭包共享一个upvalue值。</p><h2 id="1-upvalue"><a href="#1-upvalue" class="headerlink" title="1.upvalue"></a>1.upvalue</h2><p>如果函数f2定义在函数f1中，那么f2为f1的内嵌函数，f1</p><h1 id="什么是JIT"><a href="#什么是JIT" class="headerlink" title="什么是JIT"></a>什么是JIT</h1><p>JIT=Just In Time即时编译，是动态编译的一种形式，是一种优化虚拟机运行的技术。<br>程序运行通常有两种方式，一种是静态编译，一种是动态编译，即使编译混合了这二者。Java和.Net/mono中都使用了这种技术。<br>然而IOS中禁止使用（不是针对JIT，而是所有的动态编译都不支持）</p><h1 id="为什么要使用JIT"><a href="#为什么要使用JIT" class="headerlink" title="为什么要使用JIT"></a>为什么要使用JIT</h1><p>解释执行：</p><ul><li>效率低</li><li>代码暴露</li></ul><p>静态编译：</p><ul><li>不够灵活，无法热更新</li><li>平台兼容性差。</li></ul><p>JIT：</p><ul><li>效率：高于解释执行，低于静态编译。</li><li>安全性：一般都会先转换成字节码。</li><li>热更新：无论源码还是字节码本质都是资源文件。</li><li>兼容性：虚拟机会处理平台差异，对用户透明。</li></ul><h1 id="JIT是如何实现的"><a href="#JIT是如何实现的" class="headerlink" title="JIT是如何实现的"></a>JIT是如何实现的</h1><p>这里讲的实际上是JIT的一个变种：自适应动态编译(adaptive dynamic compilation)。它分为两种：Method JIT和Trace JIT。<br>如图所示，这是jvmjit的流程：<br><img src="http://oxcvfpext.bkt.clouddn.com/lua-1.png"><br>简单来讲：<br>1.跟踪热点函数或trace，编译成机器码执行，并缓存起来供以后使用。<br>2.非热点函数解释执行。</p><p>为什么只编译热点函数？<br>对只执行一次的代码而言，解释执行其实总是比JIT编译要快。对这些代码做JIT编译在执行，可以说是得补偿式。而对于只执行少量次数的代码，JIT编译带来的执行速度的提升也未必必能抵消掉最初编译带来的开销。只有对频繁执行的代码，JIT编译才能保证有正面的收益。</p><h1 id="Lua元素-Metatable"><a href="#Lua元素-Metatable" class="headerlink" title="Lua元素(Metatable)"></a>Lua元素(Metatable)</h1><p>1.定义算术操作符和关系操作符的行为</p><pre><code>+ __add* __mul- __sub/ __div- __unm(for negation) 自减% __mod^ __pow</code></pre><p>关系操作符</p><pre><code>== __eq&lt;  __lt&lt;= __le</code></pre><h1 id="元方法-index"><a href="#元方法-index" class="headerlink" title="元方法__index"></a>元方法__index</h1><p>当我们访问某个不存在的字段的时候，就会调用__index元方法。</p><h3 id="1-1-源文件划分"><a href="#1-1-源文件划分" class="headerlink" title="1.1 源文件划分"></a>1.1 源文件划分</h3><p>1.虚拟机运转核心功能<br>|源文件名        |功能                            |前缀|<br>|———————:|———————————————:|—-:|<br>|lapi.c         |C语言接口                        |luaC|<br>|lctype.c         |C标准库中ctype相关实现            ||<br>|ldebug.c         |Debug 接口                        ||<br>|ldo.c             |函数调用以及栈管理                |luaD|<br>|lfunc.c         |函数原型及闭包管理                ||<br>|lgc.c             |垃圾回收                        ||<br>|lmem.c         |内存管理接口                    ||<br>|lobject.c         |对象操作的一些函数                ||<br>|lopcodes.c     |虚拟机的字节码定义                ||<br>|lstate.c         |全局状态机                        ||<br>|lstring.c         |字符串池                        ||<br>|ltable.c         |表类型的相关操作                |luaH|<br>|ltm.c             |元方法                            ||<br>|lvm.c             |虚拟机                            ||<br>|lzio.c         |输入流接口                        |luaZ|</p><p>2.源代码解析以及预编译字节码<br>|源文件名        |功能                            |前缀|<br>|———————:|———————————————:|—-:|<br>|lcode.c     |代码生成器||<br>|ldump.c     |序列化预编译的Lua字节码||<br>|llex.c         |词法分析器||<br>|lparser.c     |解析器||<br>|lundump.c     |还原预编译的字节码||</p><p>3.内嵌库<br>|源文件名        |功能                            |前缀|<br>|———————:|———————————————:|—-:|<br>|lauxlib.c     |库编写用到的辅助函数库||<br>|lbaselib.c     |基础库||<br>|lbitlib.c     |位操作库||<br>|ldblib.c     |Debug库||<br>|lini.c     |    内嵌库的初始化||<br>|liolib.c     |IO库||<br>|lstrlib.c     |字符串库||<br>|ltablib.c     |表处理库||</p><p>4.可执行的解析器，字节码编译器<br>|源文件名        |功能                            |前缀|<br>|———————:|———————————————:|—-:|<br>|lua.c         |解释器||<br>|luac.c         |字节码编译器||</p><h3 id="1-3-Lua核心"><a href="#1-3-Lua核心" class="headerlink" title="1.3 Lua核心"></a>1.3 Lua核心</h3><pre><code>Lua核心部分仅包括Lua虚拟机的运转。Lua虚拟机的行为是由一组组opcode控制的。这些opcode定义在lopcodes.h及lopcodes.c中。而虚拟机对opcode的解析和运作在lvm.c中，其API以luaV为前缀。Lua虚拟机的外在数据形式是一个lua_State结构体，取名State大概意为Lua虚拟机的当前状态。全局State引用了整个虚拟机的所有数据。这个全局State的相关代码放在lstate.c中，API使用luaE为前缀。函数的运行流程：函数调用及返回则放在ldo.c中，相关API以luaD为前缀。Lua中最复杂和重要的三种数据类型function、table、string的实现分属在lfunc.c、ltable.c、lstring.c中。这三组内部API分别以luaF、luaH、luaS为前缀命名。不同的数据类型最终呗统一定义为LuaObject，相关操作在lobject.c中，API以luaO为前缀。Lua从第五版后增加了元表，元表的处理在ltm.c中，API以luaT为前缀。另外，核心系统还用到两个基础设施：内存管理lmem.c，API以luaM为前缀；带缓存的流处理lzio.c，API以luaZ为前缀。最后是核心系统里最为复杂的部分，垃圾回收部分，在lgc.c中实现，API以luaC为前缀。Lua设计的初衷之一就为了最好的和宿主系统相结合。它是一门嵌入式语言，所以必须提供和宿主系统交互API。这些API以C函数的形式提供，大多数实现在lapi.c中。API直接以lua为前缀，可供C编写的程序库直接调用。</code></pre><h3 id="1-4-代码翻译及预编译字节码"><a href="#1-4-代码翻译及预编译字节码" class="headerlink" title="1.4 代码翻译及预编译字节码"></a>1.4 代码翻译及预编译字节码</h3><pre><code>光有核心代码和一个虚拟机还无法让Lua程序运行起来。因为必须从外部输入将Lua运行起来。Lua的脚本需要经过解析得到内部的数据结构（常量和opcode的集合）。这个是用parser:lparser.c （luaY:语法解析)及词法分析llex.c(luaX)解析完脚本代码，还需要最终生成code码，在lcode.c中实现。luaK为了满足某些需求，加快代码翻译的流程。还可以采用预编译的过程。把运行时编译的结果，生成为字节码。这个过程以及逆过程由ldump.c和lundump.c实现。luaU</code></pre><h3 id="1-5-内嵌库"><a href="#1-5-内嵌库" class="headerlink" title="1.5 内嵌库"></a>1.5 内嵌库</h3><pre><code>作为嵌入式语言，其实完全可以不提供任何库及函数。全部由宿主系统注入到State中即可。也的确有许多系统是这么用的。但Lua的官方版本还是提供了少量必要的库。尤其是一些基础函数paris、error、setmetatable、type等等，完成了语言的一些基本特性，几乎很难不使用。而coroutine、string、table、math等等库，也很常用。Lua提供了一套简洁的方案，允许你自由加载你需要的部分，以控制最终执行文件的体积和内存的占用量。主动加载这些内建库进入lua_State，是由在lualib.h中的API实现的。</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> TValue *<span class="title">index2addr</span> <span class="params">(lua_State *L, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">    CallInfo *ci = L-&gt;ci;</span><br><span class="line">    <span class="keyword">if</span> (idx &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        TValue *o = ci-&gt;func + idx;</span><br><span class="line">        api_check(L, idx &lt;= ci-&gt;top - (ci-&gt;func + <span class="number">1</span>), <span class="string">"unacceptable index"</span>);</span><br><span class="line">        <span class="keyword">if</span> (o &gt;= L-&gt;top) <span class="keyword">return</span> NONVALIDVALUE;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!ispseudo(idx)) &#123; <span class="comment">/* nagative index */</span></span><br><span class="line">        api_check(L, idx != <span class="number">0</span> &amp;&amp; -idx &lt;= L-&gt;top - (ci-&gt;func + <span class="number">1</span>), <span class="string">"invalid index"</span>);</span><br><span class="line">        <span class="keyword">return</span> L-&gt;top + idx;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LuaMgr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Module <span class="title">GetModule</span>(<span class="params"><span class="keyword">string</span> name</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        Module m = m_modules.PG_TryGetValue(name);</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// repeat</span></span><br><span class="line">        <span class="keyword">if</span> (m.m_state != Module.State.None)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.m_state == Module.State.Failed) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> L = m_L;<span class="comment">//lua_State</span></span><br><span class="line">        <span class="keyword">string</span>[] names = name.Split(m_dotSep); <span class="comment">// mulit file</span></span><br><span class="line">        LuaDLL.lua_pushvalue(L, LuaIndexes.LUA_GLOBALSINDEX); <span class="comment">// 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; names.Length; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            LuaDLL.lua_pushstring(L, names[i]);</span><br><span class="line">            LuaDLL.lua_rawget(L, <span class="number">-2</span>); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> t = LuaDLL.lua_type(L, <span class="number">-1</span>); <span class="comment">// 1</span></span><br><span class="line">            <span class="keyword">switch</span> (t)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> LuaTypes.LUA_TNIL:</span><br><span class="line">                    LuaDLL.lua_pop(L, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                    luaDLL.lua_newtable(L);</span><br><span class="line">                    luaDLL.lua_pushstring(L, names[i]);</span><br><span class="line">                    luaDLL.lua_pushvalue(L, <span class="number">-2</span>);</span><br><span class="line">                    LuaDLL.lua_rawset(L, <span class="number">-4</span>); <span class="comment">// _G.name = module</span></span><br><span class="line"></span><br><span class="line">                    LuaDLL.lua_rawgeti(L, LuaIndexes.LUA_REGISTRYINDEX, m_ref_globalMeta);</span><br><span class="line">                    LuaDLL.lua_setmetatable(L, <span class="number">-2</span>);</span><br><span class="line">                    LuaDLL.lua_pushvalue(L, <span class="number">-1</span>);</span><br><span class="line">                    LuaDLL.lua_setfield(L, <span class="number">-2</span>, <span class="string">"_M"</span>); <span class="comment">// module._M = module</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> LuaTypes.LUA_TTABLE:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    m.m_state = Module.State.Failed;</span><br><span class="line">                    LuaDLL.lua_pop(L, <span class="number">2</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            LuaDLL.lua_remove(L, <span class="number">-2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m.m_index = ++m_moduleIndex;</span><br><span class="line">        m.m_ref_module = LuaDLL.luaL_ref(L, luaIndexes.LUA_REGISTRYINDEX);</span><br><span class="line">        ReloadModule(m);</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">LoadModule</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> L = LuaMgr.m_L;</span><br><span class="line">    <span class="keyword">string</span> name = LuaDLL.lua_tosting(L, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> m = LuaMgr.GetModule(name);</span><br><span class="line">    LuaDLL.lua_pushboolean(L, m != <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-7-阅读源代码的次序"><a href="#1-7-阅读源代码的次序" class="headerlink" title="1.7 阅读源代码的次序"></a>1.7 阅读源代码的次序</h3><p>首先、阅读外围的库是如何实现功能扩展的，这样可以熟悉Lua公开API，不必陷入功能细节。<br>然后、阅读API的具体实现。Lua对外暴露的API可以说是一个对内部模块的一层封装，这个层次尚未触及核心，但可以对核心代码有个初步的了解。<br>之后、可以开始了解Lua VM的实现。<br>接下来就是分别理解函数调用、返回，string,table,metatable等如何实现。<br>debug模块是一个额外的设施，但可以帮助你理解Lua内部细节。<br>最后是parser等编译相关的部分。<br>垃圾回收是最难的部分，可能会花掉最多的时间去理解细节。</p>]]></content>
      
      
      
        <tags>
            
            <tag> lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>expect</title>
      <link href="/2017/10/19/expect/"/>
      <url>/2017/10/19/expect/</url>
      
        <content type="html"><![CDATA[<ol><li>安装<br> yum install -y tcl tclx tcl-devel<br>Expect是一个免费的免费的编程工具语言，用来实现自动和交互任务进行通信，而无需人的干预。<br>expect是交互性很强的脚本语言，可以帮助运维人员实现批量管理成千上百台服务器操作，是一款很实用的批量部署工具！<br>下载：expect-5.43.0.tar和tcl8.4.11-src.tar</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作记录</title>
      <link href="/2017/10/19/server/"/>
      <url>/2017/10/19/server/</url>
      
        <content type="html"><![CDATA[<p>pwd: ~/work_code<br>mkdbg_all<br>vim src/ini/Jenkins_Script/compile.sh<br> <strong> IN DIR:BNMSGamePlay, make all with Makefile_debug.mk all </strong><br>115 make[3]: 进入目录“/root/work_code/src/svr/BNMSGamePlay”<br>116 ==== making DLL file … ====<br>117 g++ -DLINUX -D_FILE_OFFSET_BITS=64 -D_LARGEFILE64_SOURCE -D_LARGEFILE_SOURCE -Wall -Wno-multichar -g -D_DEBUG -DPG_MEMORY_DISABLE_POOL -march=core2 -m32 -rdynamic -std=c++0x -o ../../bin/debug/svr/BNMSGamePlay/BNMSGamePlay_d.so ../../temp/debug/svr/BNMSGamePlay/BNMSGamePlay.s.o_d  /root/work_code/src/lib/libBNMSGamePlay_Lib_d.s.a /root/work_code/src/lib/lib    PNGS_d.s.a /root/work_code/src/lib/libWHNET_d.s.a /root/work_code/src/lib/libWHCMN_d.s.a   -lpthread -ldl -lrt -march=prescott -shared  -L/root/work_code/3rd/lib -L/root/work_code/src/lib<br>118 /usr/bin/ld: skipping incompatible /usr/lib/gcc/x86_64-redhat-linux/4.8.5/libstdc++.so when searching for -lstdc++<br>119 /usr/bin/ld: cannot find -lstdc++<br>120 /usr/bin/ld: skipping incompatible /usr/lib/gcc/x86_64-redhat-linux/4.8.5/libgcc_s.so when searching for -lgcc_s<br>121 /usr/bin/ld: cannot find -lgcc_s<br>122 collect2: 错误：ld 返回 1<br>123 make[3]: <em>*</em> [../../bin/debug/svr/BNMSGamePlay/BNMSGamePlay_d.so] 错误 1<br>124 make[3]: 离开目录“/root/work_code/src/svr/BNMSGamePlay”</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldconfig #更新缓冲</span><br></pre></td></tr></table></figure><p> g++ -DLINUX -D_FILE_OFFSET_BITS=64 -D_LARGEFILE64_SOURCE -D_LARGEFILE_SOURCE -Wall -Wno-multichar -g -D_DEBUG -DPG_MEMORY_DISABLE_POOL -march=core2 -m32 -rdynamic -std=c++0x -o ../../bin/debug/xxsy/ScnSvr_AllInOne/ScnSvr_AllInOne_d ../../temp/debug/xxsy/ScnSvr_AllInOne/ScnSvr_AllInOne.o_d  /root/work_code/src/lib/libGSDB_Lib_d.a /root/work_code/src/lib/li      bScnSvr_d.a /root/work_code/src/lib/libGZSGamePlay_Lib_d.a /root/work_code/src/lib/libMCE4Chat_d.a /root/work_code/src/lib/libMCE_d.a /root/work_code/src/lib/libDIA4DBI_d.a /root/work_code/src/lib/libDIA_d.a /root/work_code/src/lib/libPNGS_d.a /root/work_code/src/lib/libWHNET_d.a /root/work_code/src/lib/libWHCMN_d.a /root/work_code/src/lib/libxxsy_cmn_d.a       /root/work_code/src/lib/libpgcmn_d.a -lpathfind_d -lcJSON_d -lcryptlib_d -llua_d -lzlib_d -ltss_sdk_d  -lz -ldl -lssl -lpthread -ldl -lrt -march=prescott  -L/root/work_code/3rd/lib -L/root/work_code/src/lib<br>g++ -DLINUX -D_FILE_OFFSET_BITS=64 -D_LARGEFILE64_SOURCE -D_LARGEFILE_SOURCE -Wall -Wno-multichar -g -D_DEBUG -DPG_MEMORY_DISABLE_POOL -march=core2 -m32 -rdynamic -std=c++0x -o ../../bin/debug/xxsy/ScnSvr_AllInOne/ScnSvr_AllInOne_d ../../temp/debug/xxsy/ScnSvr_AllInOne/ScnSvr_AllInOne.o_d  /root/work_code/src/lib/libGSDB_Lib_d.a /root/work_code/src/lib/libScnSvr_d.a /root/work_code/src/lib/libGZSGamePlay_Lib_d.a /root/work_code/src/lib/libMCE4Chat_d.a /root/work_code/src/lib/libMCE_d.a /root/work_code/src/lib/libDIA4DBI_d.a /root/work_code/src/lib/libDIA_d.a /root/work_code/src/lib/libPNGS_d.a /root/work_code/src/lib/libWHNET_d.a /root/work_code/src/lib/libWHCMN_d.a /root/work_code/src/lib/libxxsy_cmn_d.a /root/work_code/src/lib/libpgcmn_d.a -lpathfind_d -lcJSON_d -lcryptlib_d -llua_d -lzlib_d -ltss_sdk_d  -lz -ldl -lssl -lpthread -ldl -lrt -march=prescott  -L/root/work_code/3rd/lib -L/root/work_code/src/lib -pthread<br>/root/work_code/3rd/lib/liblua_d.a(core_profiler.o_d)：在函数‘lprofP_init_core_profiler’中：<br>/root/work_code/3rd/lua/profiler/core_profiler.c:154: 警告：the use of <code>tmpnam&#39; is dangerous, better use</code>mkstemp’<br>/usr/bin/ld: /root/work_code/src/lib/libScnSvr_d.a(RegScn.o_d): undefined reference to symbol ‘EVP_sha256@@libcrypto.so.10’<br>/lib/libcrypto.so.10: error adding symbols: DSO missing from command line</p>]]></content>
      
      
      
        <tags>
            
            <tag> server </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMware12中CentOS7网络设置</title>
      <link href="/2017/10/18/Vm/"/>
      <url>/2017/10/18/Vm/</url>
      
        <content type="html"><![CDATA[<p>VMware提供了三种将虚拟网卡和物理网卡捆绑起来的方式，即桥接(Bridge）模式，网络地址转换(Network Address Transformation, NAT)模式和主机(Host Only)模式。<br>三种模式区别，参见<br>关于三种模式的区别，简单而言，Bridge模式直接将虚拟机添加到局域网中，使虚拟机看起来像网内的一台真实计算机，虚拟网卡和宿主物理网卡之间不存在名义上的从属关系，因而需要局域网内具有多余的IP地址能够提供给虚拟机网卡，如果局域网内严格给每台计算机分配固定的IP，那这种Bridge模式就基本失效。在Bridge模式下虚拟机既可以访问到Internet也可以同局域网内的其他真实计算机通信；NAT模式下宿主的物理网卡就充当了路由器或交换机的角色，这时VMware会根据宿主的真实IP提供很多Subset IP供虚拟机使用，这样所有的虚拟机都是通过宿主的网络端口进行对Internet的访问，但看起来这些虚拟计算机都合法地访问到了局域网或者Internet，因为他们的IP地址通过NAT技术之后看起来是合法的。Host Only模式下虚拟机之间可以相互通信，但虚拟机并不能同局域网内的其他真实计算机直接通信，但该模式下通过宿主访问Internet还是可以的。<br><img src="http://oxcvfpext.bkt.clouddn.com/vm1.gif"><br><img src="http://oxcvfpext.bkt.clouddn.com/vm2.gif"><br><img src="http://oxcvfpext.bkt.clouddn.com/vm3.gif"><br>VM的虚拟网卡可以被设置成上述的三种网络连接模式，默认情况下，VMnet0被设置成为Bridge模式，VMnet1被设置为Host Only模式，而VMnet8的默认连接方式为NAT模式。VMnet2-VMnet7和VMnet9这七块虚拟网卡用户可以自定义，但是在所有的虚拟网卡中仅有一块能被设置为NAT模式，默认情况就是VMnet8。用户可以在VMware workstation-&gt;编辑-&gt;虚拟网络编辑器 中查看这些信息。<br><img src="http://oxcvfpext.bkt.clouddn.com/vm4.png"><br><img src="http://oxcvfpext.bkt.clouddn.com/vm5.png"><br>这里已NAT模式配置</p><ol><li>打开“网络和共享中心”选择“VMware Virtual Ethernet Adapter for VMnet8”网卡右键属性，选择VMware Bridge Protocol,同时设置ip自动获取<br><img src="http://oxcvfpext.bkt.clouddn.com/vm6.png"><br><img src="http://oxcvfpext.bkt.clouddn.com/vm7.png"></li><li>将物理网卡网络分享给VMware Virtual Ethernet Adapter for VMnet8<br><img src="http://oxcvfpext.bkt.clouddn.com/vm8.png"></li><li>虚拟机网络连接设置为NAT模式，选择虚拟机，右键》设置》网络适配器》NAT 模式<br><img src="http://oxcvfpext.bkt.clouddn.com/vm9.png"><br><img src="http://oxcvfpext.bkt.clouddn.com/vm10.png"></li><li>检验网络是否正常，不正常，检测ifcfg-e<em>**</em>(每台可能不一样)中的bootproto是不是dhcp，如果不是则修改为dhcp，此外还需要设置onboot = yes; 然后用命令service network restart重启网络连接，就可以连上网络了<br><img src="http://oxcvfpext.bkt.clouddn.com/vm11.png"></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> VMware </tag>
            
            <tag> CentOS7 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>www</title>
      <link href="/2017/10/16/www/"/>
      <url>/2017/10/16/www/</url>
      
        <content type="html"><![CDATA[<p>StartCoroutine开启一个协程，yield return是迭代器返回调用迭代的地方。<br>协程至少产生十几还是多少B的GC具体是多少我忘记了，至少在5.3.8f2之前的版本是，未来如果有时间和有机会我会讲解一个可以避免掉GC的办法。CoroutineTool，本篇不再介绍范围内。<br>一个协程的执行可以在任何地方用yield语句来暂停，yield return的值决定了什么时候协程恢复执行。<br>WWW的加载方式，本身会增加FileSystem的崩溃率，然后还增加显存占用提高了Present的崩溃率。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins</title>
      <link href="/2017/10/16/Jenkins/"/>
      <url>/2017/10/16/Jenkins/</url>
      
        <content type="html"><![CDATA[<ol><li>添加Jenkins的源（repository）<br> sudo wget -O /etc/yum.repos.d/jenkins.repo <a href="http://jenkins-ci.org/redhat/jenkins.repo" target="_blank" rel="noopener">http://jenkins-ci.org/redhat/jenkins.repo</a><br> sudo rpm —import <a href="http://pkg.jenkins-ci.org/redhat/jenkins-ci.org.key" target="_blank" rel="noopener">http://pkg.jenkins-ci.org/redhat/jenkins-ci.org.key</a></li><li>安装/检查JDK<br> java —version # 这个必须安装成功<br> sudo yum install java-1.6.0-openjdk # 我用的1.8</li><li>安装Jenkins:<br> sudo yum install jenkins</li></ol><p>安装完成后，有如下相关目录：<br>/usr/lib/jenkins/ :jenkins安装目录，WAR包会放在这里。<br>    cd /usr/lib/jenkins<br>    ll</p><ol><li>启动Jenkins<br> echo &amp;JAVA_HOME<br> /usr/java/…(懒的复制了)<br>昨天还好好的，今天不知道为什么访问不了，各种查最后通过<br> service jenkins start<br>搞定了，但是昨天一直没关，ps -aux | grep “jenkins” 也能找到。奇怪。<br>不过使用service jenkins start之后多了一个。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>makefile</title>
      <link href="/2017/10/15/makefile/"/>
      <url>/2017/10/15/makefile/</url>
      
        <content type="html"><![CDATA[<h1 id="make-Nothing-to-be-done-for-xxxx"><a href="#make-Nothing-to-be-done-for-xxxx" class="headerlink" title="make: Nothing to be done for xxxx"></a>make: Nothing to be done for xxxx</h1><h1 id="中间文件、链接文件"><a href="#中间文件、链接文件" class="headerlink" title="中间文件、链接文件"></a>中间文件、链接文件</h1><p>C、C++要把源文件编译成中间代码文件，在Windows是.obj文件，在Linux是.o文件，即Object File，这一步叫做编译。然后把这些Object File合成可执行文件，这一步叫做链接(link)。<br>编译时，编译器需要的是语法正确，函数和变量声明正确，然后编译中中间目标文件。一般来说每个源文件都对应一个中间目标文件（O文件或者OBJ文件）。链接主要是链接函数和全局变量，所以我们可以使用这些中间目标文件来链接我们的可执行文件。链接器并不考虑源文件，只考虑中间目标文件（OBJ文件），大点的项目文件成千上百，导致会变成生成太多的中间文件，而链接时需要明确指出中间目标文件名，这对于编译很不方便，所以出现了库文件来合并这些目标文件windows下“库文件”（Library File）.lib文件，在Liunx下叫Archive File（.a）文件，所以一般包Link 错误就是指没有找到这个中间文件，即没有找到该声明的实现（一般情况下）。</p><h1 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h1><p>make命令执行时，需要一个Makefile（一般是.mk 缺省Makefile或者makefile，作者习惯Makefile.mk）文件，告诉make命令如何编译和链接程序。<br>规则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target ... : prerequisites ...</span><br><span class="line">    command</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p><p>target也就是一个目标文件，可是是Object File，也可以是执行文件。还可以是一个标签（Label）。<br>prerequisites就是，要生成那个target所需要的文件或目标。<br>command是make需要执行的命令。（Shell命令）<br>这是一个依赖关系，就是说，target这一个或多个目标文件依赖于prerequisties中的文件，而规则是由command决定的。也就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。这就是Makefile的规则。</p><ol><li>ifeq的用法<br> ifeq($(SRCFILE),)<br> else ifeq()<br> endif<br>如果没有变量值，则判断是否定义，有则判断是否相等<br>./test.sh -f config.conf -v —prefix=/home<br>我们称-f为选项，它需要一个参数，即config.conf，-v也是一个选项，但它不需要参数。<br>—prefix我们称之为长选项，即选项本身多余一个字符，它也需要一个参数，用等号连接，当然等号不是必须的，/home可以直接卸载—prefix后面，即—prefix/home。<h1 id="伪目标、虚目标"><a href="#伪目标、虚目标" class="headerlink" title="伪目标、虚目标"></a>伪目标、虚目标</h1>伪目标不是一个真正的文件名，在执行make时可以指定这个目标执行</li><li><p>如果我们需要书写这样一个规则：规则所定义的命令不是去创建目标文件，而是使用make指定具体的目标来执行一些特定的命令。像下边那样：<br> clean:<br> rm <em>.o temp<br>规则中”rm”不是创建文件”clean”的命令，只是删除当前目录下的所有.O文件和temp文件。在工作目录下不存在”clean”这个文件时，我们输入”make clean”后，”rm </em>.o temp”总会被执行。这是我们的初衷。<br>但当前工作目录下存在”clean”时情况就不一样了，在我们输入”make clean”时。规则没有依赖文件，所以目标被认为是最新的而不去执行规则所定义的命令，命令”rm”将不会被执行。这并不是我们的初衷。为了避免这个问题，我们可以将目标”clean”明确声明为伪目标。讲一个目标声明为伪目标需要将它作为特殊目标.PHONY的依赖。如下：<br> .PHONY: dummy_help all dep obj cleanobj cleanint cleanout clean veryclean verycleanint install dirint dirout dirs pch cleanpch<br>这样dummy_help等就是一些伪目标或者说是虚目标，无论当前目录下是否存在”clean”这个文件。我们输入”make clean”之后，”rm”命令都会被执行。而且当一个目标被声明为伪目标后，make在执行规则时不会试图去查找隐含规则来创建这个目标。这样也提高了make的执行效率，同时我们也不用担心由于目标和文件名重名而使我们的期望失败。在书写伪目标规则时，首先需要声明目标是一个伪目标，之后才是伪目标的规则定义。目标”clean”书写格式应该如下：<br> .PHONY: clean<br> cleanint: cleanobj</p><h1 id="移除所有临时文件-目标文件、依赖文件"><a href="#移除所有临时文件-目标文件、依赖文件" class="headerlink" title="移除所有临时文件(目标文件、依赖文件)"></a>移除所有临时文件(目标文件、依赖文件)</h1><pre><code> $(RM) -f $(DEPFILE_TO_DEL)</code></pre><p> cleanout:<br> ifeq ($(ISWHAT),LIB)</p><h1 id="库"><a href="#库" class="headerlink" title="库"></a>库</h1><pre><code>     $(RM) -f $(TargetOutFile).*</code></pre><p> else<br> ifeq ($(ISWHAT),EXE)</p><h1 id="EXE文件"><a href="#EXE文件" class="headerlink" title="EXE文件"></a>EXE文件</h1><pre><code>     $(RM) -f $(TargetOutFile)</code></pre><p> else</p><h1 id="DLL或其他"><a href="#DLL或其他" class="headerlink" title="DLL或其他"></a>DLL或其他</h1><pre><code>     $(RM) -f $(TargetOutFile).*</code></pre><p> ifneq ($(OutDirLib),)</p><pre><code>     $(RM) -f $(TargetOutFileLib).*</code></pre><p> endif<br> endif<br> endif</p><p> cleanpch:</p><pre><code>     $(RM) -f $(PchFile)</code></pre><p> clean: cleanint cleanout cleanpch</p><pre><code>     @echo ==== clean now ====</code></pre></li></ol><h1 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h1><p>通配符是一种特殊语句，主要有星号(*)和问号(?)，用来模糊搜索文件</p><h1 id="Makefile中的wildcard用法"><a href="#Makefile中的wildcard用法" class="headerlink" title="Makefile中的wildcard用法"></a>Makefile中的wildcard用法</h1><p>在Makefile规则中，通配符会被自动展开。但在变量的定义和函数引用时，通配符将失效。这种情况下如果需要通配符有效，就需要使用函数”wildcard”，它的用法是：$(wildcard PATTERN…)。在Makefile中，它被展开为已经存在的、使用空格分开的、匹配此模式的所有文件列表。如果不存在任何符合此模式的文件，函数会忽略模式字符并返回空。需要</p><h1 id="Linux-make-保存错误日志"><a href="#Linux-make-保存错误日志" class="headerlink" title="Linux make 保存错误日志"></a>Linux make 保存错误日志</h1><p>$mkdbg all 2&gt;&amp;1|tee xxx.log<br>这条命令是编译并保存打印信息。在Linux Shell的设备定义中，“0”表示标准输入，“1”表示标准输出，“2”表示标准出错信息输出。2&gt;&amp;1表示把2设备的信息重定向到1设 备；“|”是管道符号，把标准输出的信息直接传递给后面的命令；tee是创建文件并保存信息的工具；xxx.log是文件名。<br>这种管道的用法在Linux Shell命令中使用非常普遍。编译过程中都可以使用这个方法，生成日志文件，保存到buildlogs目录下。<br>  1 # 编译模式名<br>  2 ConfigurationName               := debug<br>  3 # 用于体现该编译模式的文件标记<br>  4 # (对于debug版来说，比如目标文件后缀就会变成._do)<br>  5 CfgFileTag                              := _d<br>  6 # 编译选项<br>  7 #CCFlag                                 := -Wall -g -D_DEBUG -march=native<br>  8 CFlag                                   := -Wall -Wno-multichar -g -D_DEBUG -DPG_MEMORY_DISABLE_POOL -march=core2 -m32 -rdynamic<br>  9 CCFlag                                  := $(CFlag) -std=c++0x<br> 10<br> 11 #CCFlag                                 := -finput-charset=gb2312 -Wall -g -D_DEBUG<br> 12 # 连接选项<br> 13 #LNFlag                                 := -lpthread -march=native<br> 14 LNFlag                                  := -lpthread -ldl -lrt -march=prescott</p>]]></content>
      
      
      
        <tags>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gdb</title>
      <link href="/2017/10/15/gdb/"/>
      <url>/2017/10/15/gdb/</url>
      
        <content type="html"><![CDATA[<h1 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h1><ul><li>break filename:linenum 在源文件filename的linenum行处停住。<br>d 清除所有断点<br>|—|—|<br>|step(s)|执行下一句，如果有函数则进入函数里面执行|<br>set follow-fork-mode parent<br>glibc-2.17-196.el7.i686 libgcc-4.8.5-16.el7.i686 libstdc++-4.8.5-16.el7.i686<br>gdb debugme pid<br>clear 删除所在行的所有断点<br>clear 12 //删除12行的所有断点<br>clear list.c:12 //删除该文件该行号的所有断点<br>b list.c:12 // 在该文件该行号添加断点<br>backtrace\bt 打印全部栈帧的简要信息，按Ctrl-c可终止打印。<br>finish 跳出当前函数。</li></ul><h1 id="调试守护进程"><a href="#调试守护进程" class="headerlink" title="调试守护进程"></a>调试守护进程</h1><p>如果需要调试子进程，在启动gbd后：<br>set follow-fork-mode child<br>并在子进程代码设置断点<br>此外还有detach-on-fork参数，只是gdb在fork之后是否断开(detach)某个进程的调试，或者都交由GDB控制。</p><h1 id="观察点-WatchPoint"><a href="#观察点-WatchPoint" class="headerlink" title="观察点(WatchPoint)"></a>观察点(WatchPoint)</h1><p>在变量读、写或变化时中断，这类方式常用来定位bug。</p><ul><li>watch <expr> 变量发生变化时中断</expr></li><li>rwatch <expr> 变量被读时中断</expr></li><li>awatch <expr> 变量值被读或写时中断</expr></li></ul><h1 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h1><p>(gdb) b 13 if i == 8</p><h1 id="程序运行参数"><a href="#程序运行参数" class="headerlink" title="程序运行参数"></a>程序运行参数</h1><p>set args 可指定运行时的参数。(如：set args 10 20 30 40 50<br>show args 命令可以查看设置好的运行参数</p><h1 id="打印堆栈"><a href="#打印堆栈" class="headerlink" title="打印堆栈"></a>打印堆栈</h1><p>bt<br>显示所有的函数调用的栈帧信息，每个帧一行。</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux</title>
      <link href="/2017/10/15/linux/"/>
      <url>/2017/10/15/linux/</url>
      
        <content type="html"><![CDATA[<p>例子：将目录A重命名为B</p><p>mv A B</p><p>例子：将/a目录移动到/b下，并重命名为c</p><p>mv /a /b/c</p><ol><li>yum install wget</li><li>yum install gcc</li><li>yum install gcc-c++</li><li>wget <a href="http://ftp.gnu.org/pub/gnu/ncurses/ncurses-5.6.tar.gz" target="_blank" rel="noopener">http://ftp.gnu.org/pub/gnu/ncurses/ncurses-5.6.tar.gz</a></li><li>tar -zxvf </li><li>./configure -prefix=/usr/local -with-shared-without-debug</li><li>make &gt; t.log</li><li>make install</li></ol><ul><li>no termcap library found<br>wget <a href="http://ftp.gnu.org/gnu/termcap/termcap-1.3.1.tar.gz" target="_blank" rel="noopener">http://ftp.gnu.org/gnu/termcap/termcap-1.3.1.tar.gz</a><br>tar -zxvf termcap-1.3.1.tar.gz<br>cd termcap<br>./configure —help<br>set t.log<br>vim t.log<br>/MACHTYPE<br>=x86_64-redhat-linux-gnu<br>yum install gdb (这尼玛坑爹呀)</li></ul><h1 id="du查看某个文件或目录占空间大小"><a href="#du查看某个文件或目录占空间大小" class="headerlink" title="du查看某个文件或目录占空间大小"></a>du查看某个文件或目录占空间大小</h1><pre><code>du -ahdu -sh</code></pre><h1 id="linux下修改-bash-profile立即生效的方法"><a href="#linux下修改-bash-profile立即生效的方法" class="headerlink" title="linux下修改.bash_profile立即生效的方法"></a>linux下修改.bash_profile立即生效的方法</h1><ol><li>source .bash_profile</li><li>exec bash —login</li></ol><h1 id="linux中文乱码"><a href="#linux中文乱码" class="headerlink" title="linux中文乱码"></a>linux中文乱码</h1><p>查看当前系统默认的字符集<br>locale<br>安装中文包<br>yum -y groupinstall chinese-support</p><p>生效<br>export LANG=”zh_CN.UTF-8”<br>重新载入<br>. /etc/profile</p><h1 id="解决中文乱码"><a href="#解决中文乱码" class="headerlink" title="解决中文乱码"></a>解决中文乱码</h1><p>export LC_ALL=”zh_CN.utf8”</p><h1 id="Linux中安装gcc-g-yum方式"><a href="#Linux中安装gcc-g-yum方式" class="headerlink" title="Linux中安装gcc g++ yum方式"></a>Linux中安装gcc g++ yum方式</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc</span><br><span class="line">yum -y install gcc-c++</span><br><span class="line">yum intall make</span><br></pre></td></tr></table></figure><h1 id="Linux注销用户"><a href="#Linux注销用户" class="headerlink" title="Linux注销用户"></a>Linux注销用户</h1><p>who 列出登陆的用户列表<br> who<br>root@localhost:~/work_code/src/svr&gt; who<br>root     pts/0        2017-10-20 06:33 (192.168.171.1)<br>root@localhost:~/work_code/src/svr&gt; pkill -kill -t pts/0</p><h1 id="cannot-find-lgcc-s"><a href="#cannot-find-lgcc-s" class="headerlink" title="cannot find -lgcc_s"></a>cannot find -lgcc_s</h1><p>在64位Centos7上编译32位C程序，因为是编译32位的目标程序，所以使用gcc编译的时候需要加上-m32选项，但是编译的话会报错，如下：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@<span class="symbol">localhost:</span>~<span class="regexp">/work_code&gt; gcc -g -m32 -o hello hello.c</span></span><br><span class="line"><span class="regexp">/usr</span><span class="regexp">/bin/ld</span>: skipping incompatible /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">gcc</span>/<span class="title">x86_64</span>-<span class="title">redhat</span>-<span class="title">linux</span>/4.8.5/<span class="title">libgcc_s</span>.<span class="title">so</span> <span class="title">when</span> <span class="title">searching</span> <span class="title">for</span> -<span class="title">lgcc_s</span></span></span><br><span class="line">/usr/bin/<span class="symbol">ld:</span> cannot find -lgcc_s</span><br><span class="line"><span class="symbol">collect2:</span> 错误：ld 返回 <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>getconf LONG_BIT #查看自己版本是32位还是64位<br>32位的库<br>yum install glibc-devel.i686<br>yum install libstdc++-devel.i686</p><h1 id="kill-2-和-kill-9的区别"><a href="#kill-2-和-kill-9的区别" class="headerlink" title="kill -2 和 kill -9的区别"></a>kill -2 和 kill -9的区别</h1><p>-2类似Ctrl + C 是程序在结束之前，能够保存相关数据，然后在退出。<br>-9直接强制结束程序。</p><h1 id="硬链接-hard-link-和软链接-符号链接，fsoft-link或symbolic-link"><a href="#硬链接-hard-link-和软链接-符号链接，fsoft-link或symbolic-link" class="headerlink" title="硬链接(hard link)和软链接(符号链接，fsoft link或symbolic link)"></a>硬链接(hard link)和软链接(符号链接，fsoft link或symbolic link)</h1><p>我们知道文件都有文件名和数据，在Linux上被分成两个部分：用户数据(user data)和元数据(metadata)。用户数据，即文件数据块(data block)，数据块时记录文件真实内容的地方；而元数据则是文件的附加属性，如文件大小、创建时间、所有者等信息。在Linux中，元数据中的inode号(inode是文件元数据的一部分但其并不包含文件名，inode号即索引节点号)才是文件的唯一标识而非文件名。文件名仅是为了方便人们的记忆和使用，系统或程序通过inode号寻找正确的文件数据块。<br>若一个inode号对应多个文件名，则称这些文件为硬链接。换言之，硬链接就是同一个文件使用了多个别名。硬链接可由命令link或ln创建。<br>    link oldfile newfile<br>    ln oldfile newfile<br>由于硬链接有着相同inode号仅文件名不同的文件，因此硬链接存在以下几点特性：</p><ul><li>文件有相同的inode及data block；</li><li>只能对已存在的文件进行创建；</li><li>不能交叉文件系统进行硬链接的创建；</li><li>不能对目录进行创建，只可对文件创建；</li><li>删除一个硬链接文件并不影响其它有相同inode号的文件。<br>软连接与硬链接不同，若文件用户数据块存放的内容是另一文件的路径名的指向，则该文件就是软连接。软链接就是普通文件，只是数据块内容有点特殊。软链接有着自己的inode号以及用户数据块<br>usage: ln -s 源文件 目标文件</li></ul><h1 id="ssh登录方法"><a href="#ssh登录方法" class="headerlink" title="ssh登录方法"></a>ssh登录方法</h1><pre><code>ssh -l username ip</code></pre><h1 id="永久性获取ROOT权限"><a href="#永久性获取ROOT权限" class="headerlink" title="永久性获取ROOT权限"></a>永久性获取ROOT权限</h1><pre><code>sudo passwdsu</code></pre><h1 id="64位linux机器上编译32位openssl库"><a href="#64位linux机器上编译32位openssl库" class="headerlink" title="64位linux机器上编译32位openssl库"></a>64位linux机器上编译32位openssl库</h1><pre><code>setarch i386 ./config -m32wget http://zlib.net/zlib-1.2.11.tar.gztar -zxvf zlib-1.2.111.tar.gzcd zlib-1.2.11./configure --prefix=/usr/localmake &amp;&amp; make installfind ./ -name &quot;*.o&quot; -exec rm {} \;make: ***[install_docs] Error 1vim /usr/bin/pod2man 注释69行#</code></pre><p>i386 几乎所有的X86平台<br>i686 只是i386的一个子集</p><h1 id="在EC2上创建root用户，并使用root用户登录"><a href="#在EC2上创建root用户，并使用root用户登录" class="headerlink" title="在EC2上创建root用户，并使用root用户登录"></a>在EC2上创建root用户，并使用root用户登录</h1><pre><code>suvim /etc/ssh/sshd_config找到PasswordAuthentication no，把no改成yesPermitRootLogin yessudo /sbin/service sshd restartsu root</code></pre><h1 id="Linux内存管理"><a href="#Linux内存管理" class="headerlink" title="Linux内存管理"></a>Linux内存管理</h1><p>&lt;% img asset_img Linux1.webp %&gt;<br>在linux中，每一个进程都被抽象为task_struct结构体中，成为进程描述符，存储着进程各方面的信息；例如打开的文件，信号以及内存等等；然后task_struct中的一个属性mm_struct管理着进程的所有虚拟内存，成为内存描述符。在mm_struct结构体中，存储着进程各个内存段的开始以及结尾，如上图所示；进程使用的物理内存，即常驻内存RSS页数，这个内存使用的虚拟地址空间VSZ页数，还有进程虚拟内存区域集合和页表。<br>从上图可以看出，进程有代码段Text segment,数据段（已初始化的全局，静态变量），BSS段（未初始化的全局，静态变量），堆，内存映射区以及栈；<br>每一块虚拟内存区（VMA）都是由一块连续的虚拟地址组成，这些地址从不覆盖。一个vm_area_struct实例描述了一块内存区域，包括这块内存区域开始以及结尾地址；flags标志决定了这块内存的访问权限和行为；vm_file决定这块内存是由哪个文件映射的，如果没有文件映射，则这块内存为匿名的(anonymous)。上图中提到的每个内存段，都对应一个vm_area_struct结构。如下图所示<br>&lt;% asset_img Linux2.webp %&gt;<br>上图即为/bin/gonzo进程的内存布局。程序的二进制文件映射到代码段和数据段，代码段为只读只执行，不可更改；全局以及静态的未初始化的变量映射到BSS段，为匿名映射，堆和栈也是匿名映射，因为没有相对应的文件映射；内存映射区可以映射共享库，映射文件以及匿名映射，所以这块内存段可以使文件映射也可以是匿名映射。而且不同的文件，映射到不同的vm_area_struct区。<br>这些vm_area_struct集合存储在mm_struct中的一个单向链表和红黑树中；当输出/proc/pid/maps文件时，只需要遍历这个链表即可。红黑树主要是为了快速定位到某一个内存块，红黑树的跟存储在mm_rb域。<br>线性地址需要通过页表才能转换为物理地址。每个进程的内存描述符也保存了这个进程页表指针pgd,每一块虚拟内存页都和页表的某一项对应。<br>虚拟内存是不存储任何数据的，它只是将地址空间映射到物理内存。物理内存有内核伙伴系统分配，如果一块物理内存没有被映射，就可以被伙伴系统分配给虚拟内存。刚分配的物理内存可能是匿名的，存储进程数据，也可能是缓存，存储文件或块设备的数据。一块虚拟内存vm_area_struct块是由连续的虚拟内存也组成的，而这些虚拟内存块映射的物理内存却不一定连续，如下图所示：<br>&lt;% asset_img Linux3.webp  %&gt;</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>svn</title>
      <link href="/2017/10/15/svn/"/>
      <url>/2017/10/15/svn/</url>
      
        <content type="html"><![CDATA[<h1 id="svn-E200002-line-19-Option-expected错误解决"><a href="#svn-E200002-line-19-Option-expected错误解决" class="headerlink" title="svn: E200002: line 19: Option expected错误解决"></a>svn: E200002: line 19: Option expected错误解决</h1><p>这是因为修改svnserve.conf时，打开注释时，配置的前面有空格，应该顶格写。<br>修改后即可。</p><h1 id="解决svn-Authorization-failed错误"><a href="#解决svn-Authorization-failed错误" class="headerlink" title="解决svn Authorization failed错误"></a>解决svn Authorization failed错误</h1><p>出现该问题基本都是三个配置文件的问题，下面把这个文件列出来<br>svnserve.conf:<br>[general]<br>anon-access = read<br>auth-access = write<br>password-db = passwd<br>authz-db = authz<br>passwd:<br>[users]<br>admin=123<br>authz:<br>[groups]<br>[/]<br>admin= rw<br>出现authorization failed异常，一般都是authz文件里，用户组或者用户权限没有配置好，只要设置[/]就可以，代表根目录下所有的资源，如果要限定资源，可以加上 子目录即可。</p><h1 id="checkout"><a href="#checkout" class="headerlink" title="checkout"></a>checkout</h1><p>svn checkout path（path是服务器上的目录）<br>   例如：svn checkout svn://192.168.171.128/zentia/trunk/xxprj/server</p><h1 id="revert"><a href="#revert" class="headerlink" title="revert"></a>revert</h1><pre><code>svn revert [-R] dir</code></pre><h1 id="CentOS下svn迁移备份的三种方法"><a href="#CentOS下svn迁移备份的三种方法" class="headerlink" title="CentOS下svn迁移备份的三种方法"></a>CentOS下svn迁移备份的三种方法</h1><p>一般采用三种方式：</p><ol><li>svnadmin dump</li><li>svnadmin hotcopy</li><li>svnsync<br>注意，svn备份不宜采用普通的文件拷贝方式（除非你很懂svn，并且将库暂停），如copy、rsync命令。<br>svnadmin dump是官方推荐的备份方式，优点是比较灵活，可以全量备份也可以增量备份，并提供了版本恢复机制。<br>缺点：如果版本比较大，如版本数增长到数万、数十万，那么dump的过程将非常慢；备份耗时，恢复更耗时；不利于快速进行灾难恢复。<br>个人建议在版本数比较小的情况下使用这种备份方式。<br>svnadmin hotcopy原设计目的估计不是用来备份的，只能进行全量拷贝，不能进行增量备份；<br>优点是：备份过程较快，灾难恢复也很快；如果备份机上已经搭建了svn服务，甚至不需要恢复，只需要进行简单配置即可切换到备份库上工作。<br>缺点是：比较消耗硬盘，需要有较大的硬盘支持。<br>svnsync实际上是<h1 id="CentOS下SVN服务的启动语关闭"><a href="#CentOS下SVN服务的启动语关闭" class="headerlink" title="CentOS下SVN服务的启动语关闭"></a>CentOS下SVN服务的启动语关闭</h1>svnserve -d -r /home/svn<br>/home/svn 为版本的根目录<br>关闭SVN服务：<br>ps aux | grep svn<br>kill -s 9 64434<br>64434为进程ID</li></ol><p>或者 killall svnserve</p><h1 id="linux下SVN中改变执行权限"><a href="#linux下SVN中改变执行权限" class="headerlink" title="linux下SVN中改变执行权限"></a>linux下SVN中改变执行权限</h1><p>本地文件在commit到仓库之前若没有chmod+x权限的话，拿在svn仓库里的文件将会保持当前无可执行属性状态，我们可以做svn命令修改。<br>SVN中，如果我们在linux下提交权限为755文件，就会在svn的属性中存在一个svn:executable。<br>只在本地chmod 644 ，是不能造成修改的。<br>svn propset svn:executable on * （注意，如果包含目录会执行失败）<br>svn commit</p><h1 id="前一个操作被卡住的问题"><a href="#前一个操作被卡住的问题" class="headerlink" title="前一个操作被卡住的问题"></a>前一个操作被卡住的问题</h1><p>去官网下载win32那个包就可以了。<br>sqlite3.exe .svn/wc.db “delete from wc_lock”<br>sqlite3.exe .svn/wc.db “delete from work_queue”<br>/OUT:”F:\zentia\server\bin\vc120debugs\glogger_d.exe” /MANIFEST /NXCOMPAT /PDB:”F:\zentia\server\bin\vc120debugs\glogger_d.pdb” /DYNAMICBASE:NO “WHCMN_d.lib” “WHNET_d.lib” “PNGS_d.lib” “cryptlib_d.lib” “zlib_d.lib” “kernel32.lib” “user32.lib” “gdi32.lib” “winspool.lib” “comdlg32.lib” “advapi32.lib” “shell32.lib” “ole32.lib” “oleaut32.lib” “uuid.lib” “odbc32.lib” “odbccp32.lib” /FIXED /LARGEADDRESSAWARE /IMPLIB:”F:\zentia\server\bin\vc120debugs\glogger_d.lib” /DEBUG /MACHINE:X86 /OPT:NOREF /SAFESEH:NO /INCREMENTAL /PGD:”F:\zentia\server\bin\vc120debugs\glogger_d.pgd” /SUBSYSTEM:CONSOLE”,5.01” /MANIFESTUAC:”level=’asInvoker’ uiAccess=’false’” /ManifestFile:”F:\zentia\server\temp\vc120\glogger2010\debug\glogger_d.exe.intermediate.manifest” /OPT:NOICF /ERRORREPORT:PROMPT /NOLOGO /LIBPATH:”F:\zentia\server\src\svr\glogger\/lib/win32” /LIBPATH:”F:\zentia\server\lib\vc120lib\” /LIBPATH:”F:\zentia\server\3rd\lib\vc120\” /LIBPATH:”F:\zentia\server\3rd\lib” /LIBPATH:”%(AdditionalLibraryDirectories)” /TLBID:1<br>g++ -DLINUX -D_FILE_OFFSET_BITS=64 -D_LARGEFILE64_SOURCE -D_LARGEFILE_SOURCE -Wall -Wno-multichar -g -D_DEBUG -DPG_MEMORY_DISABLE_POOL -march=core2 -m32 -rdynamic -std=c++0x -o ../../bin/debug/svr/GBNMS/GBNMS_d.so ../../temp/debug/svr/GBNMS/GBNMS.s.o_d  /root/work_code/src/lib/libGBNMS_Lib_d.s.a /root/work_code/src/lib/libDIA_d.s.a /root/work_code/src/lib/libPNGS_d.s.a /root/work_code/src/lib/lib    WHNET_d.s.a /root/work_code/src/lib/libWHCMN_d.s.a  /usr/lib64/mysql/libmysqlclient_r.a -lz -lpthread -ldl -lrt -march=prescott -shared  -L/root/work_code/3rd/lib -L/root/work_code/src/lib</p><h1 id="拉分支"><a href="#拉分支" class="headerlink" title="拉分支"></a>拉分支</h1><p>svnserve -d -r /var/svn<br>启动svn服务器，但是客户端还是一直连接不上</p><p>svn info 查看库版本路径</p><p>客户端一直连接不上服务器，最后发现是防火墙的问题，最暴力直接关掉防火墙就好啦。</p><p>post-commit.tmpl<br>它在事务外城后运行，创建一个新的修订版本。大多数人用这个钩子来发送关于提交的描述性邮件，或者作为版本库的备份。版本库传给程序两个参数：到版本库的路径和被创建的新的修订版本号。退出程序时被忽略。</p><p>关闭防火墙<br>重启后生效<br>开启: chkconfig iptables on<br>关闭: chkconfig iptables off<br>即时生效，重启后失效<br>开启：service iptables start<br>关闭：service iptables stop</p><p>查看磁盘空间<br>df -h</p><h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mkdir /var/svn</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入svn目录</span></span><br><span class="line">cd /var/svn  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 用svn管理员创建bigsvr</span></span><br><span class="line">svnadmin create /var/svn/bigsvr</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入库</span></span><br><span class="line">cd bigsvr</span><br></pre></td></tr></table></figure><p>subversion目录说明<br>db        所有版本控制的数据存放目录<br>hooks    放置hook脚本<br>locks     用户操作的锁文件<br>format    记录当前文件库的版本号<br>conf    配置文件</p><h1 id="Svn命令行总结"><a href="#Svn命令行总结" class="headerlink" title="Svn命令行总结"></a>Svn命令行总结</h1><ol><li><p>上传项目到SVN服务器上</p><p> svn import project_dir(本地项目全路径)</p></li><li><p>下载checkout svn项目到本地</p><p> svn checkout 简写：svn co</p></li><li><p>添加新文件</p><p> svn add file(文件名)<br> svn add *.php(添加当前目录下所有的php文件)</p></li><li><p>提交到版本库</p><p> svn commit -m “LogMessage” [-N] [—no-unlock] PATH(如果选择了保持锁，就使用—no-unlock开关)</p></li><li><p>更新文件</p><p> svn update<br> svn update -r 修正版本 文件名<br> svn update (后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本)<br> svn update -r 200 test.cpp (将版本库中的文件test.cpp还原到修正版本(revision)200)<br> svn update test.php (更新于版本库同步)</p></li><li><p>设置忽略</p><p> svn propset svn:ignore Temp .</p></li><li><p>relocate</p><p> svn switch —relocate svn://18.223.184.177/project/ss/ss/bin/data svn://18.223.184.177/project/ss/ss/bin/data</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> svn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos7下 vim</title>
      <link href="/2017/10/14/vi/"/>
      <url>/2017/10/14/vi/</url>
      
        <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install vim</span><br></pre></td></tr></table></figure><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><ol><li>/etc/vimrc 全局</li><li>vim ~/.vimrc 新建<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> nu // 行号</span><br><span class="line"><span class="keyword">set</span> showmode //显示当前模式</span><br><span class="line"><span class="keyword">set</span> ruler //显示行数信息</span><br><span class="line"><span class="keyword">set</span> autoindent //回车对齐</span><br><span class="line">syntax on //语法检测</span><br><span class="line"><span class="keyword">set</span> encoding=urf-8 fileencodings=ucs-born,utf-8,cp936 //自动识别编码，如果没有找到，用latin-1(ASCII)编码打开(解决乱码问题)</span><br><span class="line"><span class="keyword">set</span> ts=4 //四个空格</span><br></pre></td></tr></table></figure></li></ol><p>vi查看文件编码格式<br>    :set fileencoding<br>:edit ++enc=utf-8</p><p>最后来看看处理中文文档最典型的几种情况和设置方式：</p><p>1，系统locale是utf-8（很多linux系统默认的locale形式），编辑的文档是GB2312或GBK形式的（Windows记事本 默认保存形式，大部分编辑器也默认保存为这个形式，所以最常见），终端类型utf-8（也就是假定客户端是putty类的unicode软件）</p><p>则vim打开文档后，encoding=utf-8（locale决定的），fileencoding=latin1（自动编码判断机制不准导致的），termencoding=空（默认无需转换term编码），显示文件为乱码。</p><p>解决方案1：首先要修正fileencoding为cp936或者euc-cn（二者一样的，只不过叫法不同），注意修正的方法不是:set fileencoding=cp936，这只是将文件保存为cp936，正确的方法是重新以cp936的编码方式加载文件为:edit ++enc=cp936，可以简写为:e ++enc=cp936。</p><p>解决方案2：临时改变vim运行的locale环境，方法是以LANG=zh_CN vim abc.txt的方式来启动vim，则此时encoding=euc-cn（locale决定的），fileencoding=空（此locale下文件 编码自动判别功能不启用，所以fileencoding为文件本身编码方式不变，也就是euc-cn），termencoding=空（默认值，为空则等 于encoding）此时还是乱码的，因为我们的ssh终端认为接受的数据为utf-8，但vim发送数据为euc-cn，所以还是不对。此时再用命令: set termencoding=utf-8将终端数据输出为utf-8，则显示正常。</p><p>2，情况与1基本相同，只是使用的ssh软件为secure CRT类ansi类软件。</p><p>vim打开文档后，encoding=utf-8（locale决定的），fileencoding=latin1（自动编码判断机制不准导致的），termencoding=空（默认无需转换term编码），显示文件为乱码。</p><p>解决方案1：首先要保证运行secure CRT的windows机器的默认代码页为CP936，这一点中文windows已经是默认设置了。其他的与上面方案1相同，只是要增加一步，:set termencoding=cp936</p><p>解决方案2：与上面方案2类似，不过最后一步修改termencoding省略即可，在此情况下需要的修改最少，只要以locale为zh_CN开 启vim，则encoding=euc-cn，fileencoding和termencoding都为空即为encoding的值，是最理想的一种情 况。</p><p>可见理解这3个关键点和3个参数的意义，对于编码问题有很大助力，以后就可以随心所欲的处理文档了，同时不仅仅是应用于vim，在其他需要编码转换的环境里，都可以应用类似的思路来处理问题解决问题。</p><h1 id="行跳转"><a href="#行跳转" class="headerlink" title="行跳转"></a>行跳转</h1><ol><li>12gg / 12G</li><li>:12</li><li>打开文件时输入vim +12 filename</li></ol><h1 id="vim-精确匹配查找单词"><a href="#vim-精确匹配查找单词" class="headerlink" title="vim 精确匹配查找单词"></a>vim 精确匹配查找单词</h1><p>精确匹配查找单词<br>如果你输入 “/the”，你也可能找到”there”。要找到以”the”结尾的单次，可以用: /the> “>“是一个特殊的记号，表示只匹配单词末尾。类似的，”\&lt;” 只匹配单词的开头。<br>这样要匹配一个完整的单词”the”，只需要: /\<the\></the\></p><p>:e 刷新文件内容</p>]]></content>
      
      
      
        <tags>
            
            <tag> vi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql</title>
      <link href="/2017/10/14/mysql/"/>
      <url>/2017/10/14/mysql/</url>
      
        <content type="html"><![CDATA[<h1 id="修改mysql密码"><a href="#修改mysql密码" class="headerlink" title="修改mysql密码"></a>修改mysql密码</h1><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p</span><br><span class="line">use mysql;</span><br><span class="line">UPDATE<span class="built_in"> user </span><span class="builtin-name">SET</span> <span class="attribute">password</span>=password("123456") WHERE <span class="attribute">user</span>=<span class="string">'root'</span>; </span><br><span class="line">flush privileges;</span><br><span class="line">exit;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">DATABASES</span>;</span><br></pre></td></tr></table></figure><p>首先CentOS7 已经不支持mysql，因为收费了你懂得，所以内部集成了mariadb，而安装mysql的话会和mariadb的文件冲突，所以需要先卸载掉mariadb，以下为卸载mariadb，安装mysql的步骤。</p><h1 id="列出所有被安装的rpm-package"><a href="#列出所有被安装的rpm-package" class="headerlink" title="列出所有被安装的rpm package"></a>列出所有被安装的rpm package</h1><p>rpm -qa | grep mariadb</p><h1 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h1><p>rpm -e mariadb-libs-5.5.37-1.el7_0.x86_64<br>错误：依赖检测失败：<br>libmysqlclient.so.18()(64bit) 被 (已安裝) postfix-2:2.10.1-6.el7.x86_64 需要<br>libmysqlclient.so.18(libmysqlclient_18)(64bit) 被 (已安裝) postfix-2:2.10.1-6.el7.x86_64 需要</p><h1 id="强制卸载，因为没有—nodeps"><a href="#强制卸载，因为没有—nodeps" class="headerlink" title="强制卸载，因为没有—nodeps"></a>强制卸载，因为没有—nodeps</h1><p>rpm -e —nodeps mariadb-libs-5.5.37-1.el7_0.x86_64</p><h1 id="安装mysql依赖"><a href="#安装mysql依赖" class="headerlink" title="安装mysql依赖"></a>安装mysql依赖</h1><p>yum install vim libaio net-tools</p><p>其他情况：</p><p>1、centos下yum暂时没有mysql-server直接安装包；<br>MariaDB是MySQL社区开发的分支，也是一个增强型的替代品;</p><p>2、安装MariaDB（目前还是先不要安装了）<br>yum -y install mariadb-server mariadb mariadb-devel<br>systemctl start mariadb<br>systemctl enable mariadb<br>mysql_secure_installation<br>firewall-cmd —permanent —add-service mysql<br>systemctl restart firewalld.service<br>iptables -L -n|grep 3306</p><p>CentOS7的yum源中默认好像是没有mysql的。为了解决这个问题，我们要先下载mysql的repo源。</p><ol><li>下载mysql的repo源</li></ol><p>$ wget <a href="http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm" target="_blank" rel="noopener">http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm</a></p><ol><li>安装mysql-community-release-el7-5.noarch.rpm包</li></ol><p>$ sudo rpm -ivh mysql-community-release-el7-5.noarch.rpm</p><p>安装这个包后，会获得两个mysql的yum repo源：/etc/yum.repos.d/mysql-community.repo，/etc/yum.repos.d/mysql-community-source.repo。</p><ol><li>安装mysql</li></ol><p>$ sudo yum install mysql-server<br>根据步骤安装就可以了，不过安装完成后，没有密码，需要重置密码。</p><ol><li><p>重置密码<br>重置密码前，首先要登录<br>$ mysql -u root<br>登录时有可能报这样的错：ERROR 2002 (HY000): Can‘t connect to local MySQL server through socket ‘/var/lib/mysql/mysql.sock‘ (2)，原因是/var/lib/mysql的访问权限问题。下面的命令把/var/lib/mysql的拥有者改为当前用户：<br>$ sudo chown -R openscanner:openscanner /var/lib/mysql<br>然后，重启服务：<br>$ service mysqld restart</p></li><li><p>开放3306端口<br>$ sudo vim /etc/sysconfig/iptables<br>添加以下内容：<br>-A INPUT -p tcp -m state —state NEW -m tcp —dport 3306 -j ACCEPT<br>保存后重启防火墙：<br>$ sudo service iptables restart<br>这样从其它客户机也可以连接上mysql服务了。<br>MYSQL启动后报：ERROR! The server quit without updating PID file错误的问题解决<br>MYSQL日志：Can’t find file: ‘./mysql/plugin.frm’ (errno: 13 - Permission denied)</p></li><li><p>权限不够：chown -R mysql:mysql /home/mysql/data”  chmod -R 755 /home/mysql/data</p></li><li>centos7的selinux问题：打开/etc/selinux/config，把SELINUX=enforcing改为SELINUX=disabled后存盘退出重启机器。<br>查看存储过程的创建代码<br>show create procedure proc_name;</li></ol><h1 id="ERROR-1728-HY000-Cannot-load-from-mysql-proc-The-table-is-probably-corrupted"><a href="#ERROR-1728-HY000-Cannot-load-from-mysql-proc-The-table-is-probably-corrupted" class="headerlink" title="ERROR 1728 (HY000): Cannot load from mysql.proc. The table is probably corrupted"></a>ERROR 1728 (HY000): Cannot load from mysql.proc. The table is probably corrupted</h1><p>【错误过程】：MySQL从5.1升级至5.5后在调用存储过程时报出“Cannot load from mysql.proc. The table is probably corrupted。”<br>【造成原因】：MySQL升级完成后未对相关数据库执行升级.<br>【解决办法】：在命令行中执行mysql_upgrade -uroot -p 即可~</p><h1 id="查看Mysql端口"><a href="#查看Mysql端口" class="headerlink" title="查看Mysql端口"></a>查看Mysql端口</h1><pre><code>show global variables like &#39;port&#39;;</code></pre><h1 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h1><h2 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h2><ul><li>character_set_server          默认的内部操作字符集</li><li>character_set_client          客户端来源数据使用的字符集</li><li>character_set_connection      连接层字符集</li><li>character_set_results         查询结果字符集</li><li>character_set_database        当前选中数据库的默认字符集</li><li>character_set_system          系统元数据（字段名等）字符集</li></ul><h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><pre><code>show variables like &#39;character_set_database&#39;;show variables like &#39;%character%&#39;;show variables like &#39;collation%&#39;;</code></pre><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><h3 id="临时修改"><a href="#临时修改" class="headerlink" title="临时修改"></a>临时修改</h3><pre><code>alter database xxx CHARACTER SET gb2312; // 修改库的字符集SET character_set_client = utf8;</code></pre><h3 id="永久修改"><a href="#永久修改" class="headerlink" title="永久修改"></a>永久修改</h3><p>修改my.cnf 位置在/etc/my.cnf<br>在[mysqld]上面加下面两句话</p><pre><code>[client]default-character-set=utf8</code></pre><p>在[mysqld]最下面加入下面几句话</p><pre><code>default-storage-engine=INNODBcharacter-set-server=utf8collation-server=utf8_general_ci</code></pre><p>然后保存</p><p>重启Mysql</p><pre><code>service mysqld restart</code></pre><h2 id="查看MYSQL所支持的字符集"><a href="#查看MYSQL所支持的字符集" class="headerlink" title="查看MYSQL所支持的字符集"></a>查看MYSQL所支持的字符集</h2><pre><code>show charset;</code></pre><h2 id="查看库的字符集"><a href="#查看库的字符集" class="headerlink" title="查看库的字符集"></a>查看库的字符集</h2><pre><code>show create database db_xxsy_game_1004\G;</code></pre><h2 id="查看表的字符集"><a href="#查看表的字符集" class="headerlink" title="查看表的字符集"></a>查看表的字符集</h2><pre><code>show table status from db_xxsy_game_1004 like &#39;common_accounts&#39;;</code></pre><h1 id="CentOS7-开放3306端口访问"><a href="#CentOS7-开放3306端口访问" class="headerlink" title="CentOS7 开放3306端口访问"></a>CentOS7 开放3306端口访问</h1><p>CentOS 7.0默认使用的是firewall作为防火墙，这里改为iptables防火墙。<br>1、关闭firewall：<br>systemctl stop firewalld.service<br>systemctl disable firewalld.service<br>systemctl mask firewalld.service</p><p>2、安装iptables防火墙<br>yum install iptables-services -y</p><p>3.启动设置防火墙</p><pre><code># systemctl enable iptables# systemctl start iptables</code></pre><p>4.查看防火墙状态</p><p>systemctl status iptables</p><p>5编辑防火墙，增加端口<br>vi /etc/sysconfig/iptables #编辑防火墙配置文件<br>-A INPUT -m state —state NEW -m tcp -p tcp —dport 22 -j ACCEPT<br>-A INPUT -m state —state NEW -m tcp -p tcp —dport 80 -j ACCEPT<br>-A INPUT -m state —state NEW -m tcp -p tcp —dport 3306 -j ACCEPT<br>:wq! #保存退出</p><p>3.重启配置，重启系统<br>systemctl restart iptables.service #重启防火墙使配置生效<br>systemctl enable iptables.service #设置防火墙开机启动</p><h1 id="Host-‘192-168-171-128’-is-not-allowed-to-connect-to-this-MySQL-server"><a href="#Host-‘192-168-171-128’-is-not-allowed-to-connect-to-this-MySQL-server" class="headerlink" title="Host ‘192.168.171.128’ is not allowed to connect to this MySQL server"></a>Host ‘192.168.171.128’ is not allowed to connect to this MySQL server</h1><h1 id="ERROR-1044-42000-Access-denied-for-user-‘’-’localhost’-to-database-‘mysql’"><a href="#ERROR-1044-42000-Access-denied-for-user-‘’-’localhost’-to-database-‘mysql’" class="headerlink" title="ERROR 1044 (42000):Access denied for user ‘’@’localhost’ to database ‘mysql’"></a>ERROR 1044 (42000):Access denied for user ‘’@’localhost’ to database ‘mysql’</h1><p>在mysql数据库的user表里，存在用户名为空的账户即为匿名账户，导致登陆的时候虽然用的时root，但实际时匿名登陆的。<br>解决办法：</p><ol><li>关闭mysql<br>service mysqld stop</li><li>屏蔽权限<br>mysqld_safe —skip-grant-table</li><li>新开一个终端<br>mysql -u root mysql<br>delete from user where user=’’;<br>flush privileges;</li></ol><h1 id="mysql-h-no-found-file-or-directory"><a href="#mysql-h-no-found-file-or-directory" class="headerlink" title="mysql.h no found file or directory"></a>mysql.h no found file or directory</h1><p>yum install mysql-devel</p><div class="table-container"><table><thead><tr><th style="text-align:left">数据类型</th><th style="text-align:left">解释</th><th style="text-align:left">存储范围</th><th style="text-align:left">字节</th></tr></thead><tbody><tr><td style="text-align:left">TINYINT</td><td style="text-align:left">有符号值:-128到127<br>unsigned : [0 255]</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">SMALLINT</td><td style="text-align:left">signed[-32768,32767]<br>unsigned [0,65535]</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">BINARY</td><td style="text-align:left">用来表示二进制数据</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">VARBINARY</td></tr></tbody></table></div><p>大小写忽略</p><h3 id="CHAR和VARCHAR类型"><a href="#CHAR和VARCHAR类型" class="headerlink" title="CHAR和VARCHAR类型"></a>CHAR和VARCHAR类型</h3><p>都用来存储字符串<br>VARCHAR 可以存储可变长度的字符串<br>CHAR    存储定长字符串<br>定义如下<br>CHAR(M)或者VARCHAR(M)<br>M指的是字符串的最大长度<br>比如<br>插入值’ab’<br>CHAR(4) 需要4个字节<br>VARCHAR(4) 需要3个字节<br>当数据为CHAR(M)类型时，不管插入值的长度是多少，所占用的存储空间都是M个字节。<br>当为VARCHAR(M)类型时，所占用的字节数为实际长度加1。</p><h3 id="BINARY和VARBINARY类型"><a href="#BINARY和VARBINARY类型" class="headerlink" title="BINARY和VARBINARY类型"></a>BINARY和VARBINARY类型</h3><p>类似于CHAR和VARCHAR<br>用来表示二进制数据<br>定义如下<br>BINARY(M)或者VARBINARY(M)<br>M指的是二进制数据的最大字节长度<br>注意<br>BINARY类型的长度是固定的，如果数据的长度不足最大长度，在后面用”\0”补齐。<br>比如，数据类型为BINARY(3)，当插入a时，实际存储的时”a\0\0”</p><h1 id="Centos7安装Mysql"><a href="#Centos7安装Mysql" class="headerlink" title="Centos7安装Mysql"></a>Centos7安装Mysql</h1><pre><code>yum install mysqlyum install mysql-develyum install mariadb-server mariadbsystemctl start mariadb</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云主机CentOS7.2密钥丢失重新注入密钥方法</title>
      <link href="/2017/10/13/centos/"/>
      <url>/2017/10/13/centos/</url>
      
        <content type="html"><![CDATA[<h1 id="一、单用户模式重置ROOT密码（如有root密码，则跳过该步骤）"><a href="#一、单用户模式重置ROOT密码（如有root密码，则跳过该步骤）" class="headerlink" title="一、单用户模式重置ROOT密码（如有root密码，则跳过该步骤）"></a>一、单用户模式重置ROOT密码（如有root密码，则跳过该步骤）</h1><ol><li><p>登录控制台，输入VNC密码并回车</p></li><li><p>点击【Send CtrlAltDel】重启linux系统；</p></li><li>在弹出界面，按键盘‘e’；<br>4、如图修改前/修改后，将ro修改成rw init=/sysroot/bin/sh  去除console=ttyS0 115200，确认修改完成后，键盘输入Ctrl加x。</li></ol><p>5、依次输入如下命令：chroot /sysroot/   passwd root  touch /.autorelabel进行root密码修改<br>6、返回云主机侧点击【重启】使得密码修改生效<br>7、待云主机重启完成后，进入VNC输入用户名root，修改后的密码进入系统</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 服务器搭建</title>
      <link href="/2017/10/13/git-server/"/>
      <url>/2017/10/13/git-server/</url>
      
        <content type="html"><![CDATA[<p>首先要明确现在代码的分布情况，开发者电脑上的本地仓库，git服务器上的远端仓库，web服务器上的另一个本地仓库，我们浏览器访问的就是这里的代码。其实自动部署就是要当开发者本地仓库提交代码到远端仓库的时候，自动把代码部署到web服务器的本地仓库，实现开发着本地仓库和web服务器的本地仓库同步。（即通过GitHook中的post-receive脚本文件）</p><h1 id="1、安装Git"><a href="#1、安装Git" class="headerlink" title="1、安装Git"></a>1、安装Git</h1><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel</span><br><span class="line">yum <span class="keyword">install</span> git</span><br></pre></td></tr></table></figure><p>接下来我们创建一个git用户组和用户，用来运行git服务：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">groupadd</span> git</span><br><span class="line"><span class="keyword">adduser </span>git -g git</span><br></pre></td></tr></table></figure></p><h1 id="3、初始化Git仓库"><a href="#3、初始化Git仓库" class="headerlink" title="3、初始化Git仓库"></a>3、初始化Git仓库</h1><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git init <span class="comment">--bare runoob.git</span></span><br><span class="line">Initialized <span class="literal">empty</span> Git repository <span class="keyword">in</span> /home/gitrepo/</span><br></pre></td></tr></table></figure><p>git init 使用当前目录作为Git仓库,该命令执行完后回生成一个.git目录<br>git init zentia 指定目录创建Git仓库</p><p>修改/etc/ssh/sshd_config文件，将其中的PermitRootLogin no修改为yes,PublicAuthentication yes修改为no,AuthorizedKeysFile .ssh/authorized_keys前面加上的#屏蔽掉,PasswordAuthentication no修改为yes就可以了<br>ssh -l username hostname</p><p>在服务器checkout出一份代码<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># In remote server</span></span><br><span class="line">cd ~</span><br><span class="line">git <span class="keyword">clone</span> <span class="title">sample</span>.git/ my_repo</span><br></pre></td></tr></table></figure></p><p>这个时候就会出现my_repo文件夹，里面就会有你的代码。同时，这个代码文件夹的默认origin远端（remote）就会变成my_repo文件夹。当你做git fetch git pull等动作的时候就会从my_repo取信息。<br>3.配置Git Hook<br>进入到/home/gitrepo/sample.git文件夹，使用vi post-receive创建一个脚本，当你在本地仓库执行git push后就会触发post-receive。</p><p>/usr/games/project.git/<br>git clone git@ec2-18-191-158-223.us-east-2.compute.amazonaws.com:/usr/games/project.git/<br>添加到本地仓库</p><pre><code>git add .</code></pre><p>添加提交描述</p><pre><code>git commit -m ‘内容’</code></pre><p>提交前先从远程仓库🐖分支中拉取请求</p><pre><code>git pull origin master</code></pre><p>把本地仓库代码提交</p><pre><code>git push -u origin master</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git clone 命令</title>
      <link href="/2017/10/13/git-clone/"/>
      <url>/2017/10/13/git-clone/</url>
      
        <content type="html"><![CDATA[<p>git clone 命令将存储库克隆到新目录中。</p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh</title>
      <link href="/2017/10/13/ssh-key/"/>
      <url>/2017/10/13/ssh-key/</url>
      
        <content type="html"><![CDATA[<p>ssh中，有两个钥匙：<strong><em>公钥、私钥</em></strong>，公钥主要是用于对一些敏感信息进行加密，私钥适用于解密。<br>ssh的文件都存在于机器~/.ssh中。</p><ul><li>客户端：id_rsa(私钥)、id_rsa.pub(公钥)、known_hosts(已知远程主机)</li><li>服务端: authorized_keys(验证过的公钥列表)、sshd_config(ssh配置文件)</li></ul><h1 id="设置ssh连接不断开"><a href="#设置ssh连接不断开" class="headerlink" title="设置ssh连接不断开"></a>设置ssh连接不断开</h1><pre><code>vim /etc/ssh/sshd_config# 客户端每隔多少秒向服务器发送一个心跳数据ClientAliveInterval 30# 客户端多少秒没有响应，服务器自动断掉连接ClientAliveCountMax 1800service sshd restart</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网站部署规则</title>
      <link href="/2017/10/13/site-dealy-role/"/>
      <url>/2017/10/13/site-dealy-role/</url>
      
        <content type="html"><![CDATA[<p>网站发布只在自己笔记本电脑发布，公司电脑只能hexo s —debug,不能 hexo d -g<br>本地内容修改完成之后记得<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add . </span><br><span class="line">git commit -am <span class="string">"m"</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>fatal:remote error You can&#39;t push to git 的解决办法</title>
      <link href="/2017/10/13/github-remote-error/"/>
      <url>/2017/10/13/github-remote-error/</url>
      
        <content type="html"><![CDATA[<p>branch正确的情况下，不知为什么，在push的时候出现:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fatal: remote error:</span><br><span class="line">You can<span class="string">'t push to git://github.com/zentia/hexo.git</span></span><br><span class="line"><span class="string">Use git@github.com:zentia/hexo.git</span></span><br></pre></td></tr></table></figure></p><p>解决办法:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br><span class="line">git remote add origin git@github.com:zentia/hexo.git</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wm</title>
      <link href="/2017/10/13/wm/"/>
      <url>/2017/10/13/wm/</url>
      
        <content type="html"><![CDATA[<p>第一个问题：昨天一直提示hexo command no found，然后本地的hexo/node_module下找到一个.bin目录，里面还有hexo的执行文件，天真的以为这个就是执行路径，然后搞了一天，无果。今天去program files(x86)找到全局的npm下的hexo然后修改环境变量解决。<br>第二个问题：hexo new _post 文章的时候提示fatal：admin-hey（一个管理员控制的）module no found ，以前配置这个过，后来感觉没啥用，就不用了，开始下载这个module，但是可能是今天的网络问题还是怎么回事，github一直很慢，然后去node_module里面看的时候发现有hexo-hey，但是发现里面文件目录结构不对，然后删掉就好了。<br>本来想做一个单纯的技术博客，但是王苗喜欢这个视频，就放上去吧。</p><video width="480" height="320" controls><source src="http://oxcvfpext.bkt.clouddn.com/wm%20_%20zentia%27blog.mp4"></video>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity Shader</title>
      <link href="/2017/10/12/shader/"/>
      <url>/2017/10/12/shader/</url>
      
        <content type="html"><![CDATA[<p>CGPROGRAM和ENDCG包裹的部分就是CG\HLSL语言部分。</p><ol><li><p>Vertex &amp; Fragment Shader: 顶点/片元着色器。它是最基本，也是非常强大的着色器类型。一般用于2D场景、特效之类的。Unlit Shader(无光照着色器，不包含无效)<br>在世界三维空间中，一开始传入Shader处理的数据其实就是网格数据(Mesh Data)<br>但是一般情况下，光是网格数据不能满足我们处理画面的需求，这时就需要引入一些常数属性数据(Properties)<br>属性的声明规则如下：</p><p> _Name(“Display Name”, type)=defaultValue[{options}]</p><ul><li>_Name是属性的名字，也就是变量名，在之后整个Shader代码中将使用这个名字来获取该属性的内容，切记要添加下划线。</li><li>Displayer Name 这个字符串将显示在Unity的Inspector中作为Shader的使用者可读的内容，即显示的名称。</li><li>type属性的类型。常用的有几种：Color颜色，一般为RGBA的数组；2D纹理，宽高为2的幂次尺寸；Rect纹理，对应非2的幂次尺寸；Cube立方体，即6张2D纹理组成；Float和Range，都是浮点数，但是Range要求定义最小值和最大值，以Range(min,max)形式显示；Vector四位数。</li><li>defauleValue默认值，与类型直接挂钩。一开始赋予该属性的初始值，但是在检视窗口调整过属性值之后，不再有效。Color以0~1定义rgba颜色，比如(1,1,1,1)；2D/Rect/Cube，对于纹理来说，默认可以为一个代表默认tint颜色字符串，可以使空字符串或者”white”，”black”等中的一个；Float和Range为某个指定的浮点数；同样，Vector的是一个四维数值，(x,y,z,w)的形式。</li><li>Options可选项，它只对2D，Rect或者Cube纹理有关，一般填入OpenGL中TexGen的模式。<br>这样我们可以尝试解读上图中的那些属性声明的是声明了。比如_MainTex(“A Texture”, 2D)=””{},就是声明了一个变量名为_MainTex的2次幂尺寸纹理，它在检视窗口中显示的名称是A Texture，默认是空的。</li></ul></li><li><p>语义<br>语义（Semantics）是附加到着色器输入或输出的字符串，其传达关于参数的预期使用的信息。对于在着色器级之间传递的所有变量都需要语义，通常，在流水线级之间传递的数据是完全通用的，并且不被系统唯一地解释；允许任意语义没有特殊意义。</p></li><li>Surface Shader: 表面着色器。它拥有更多的光照运算，其实在系统内部它会被编译成一个比较复杂的顶点/片元着色器。Standard Surface Shader(标准光照模型表面着色器)</li><li>Standard Shader: 标准着色。它是表面着色器升级版，因为它使用了Physically Based Rendering（简称PBR）技术，即基于物理的渲染技术。所以在这个着色器中开放了更多处理光照与材质的参数。</li></ol><h3 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h3><p>表面着色器可以被若干的标签(tags)所修饰，而硬件将通过判定这些标签来决定什么时候调用该着色器。比如我们的粒子中SubShader的第一句<br>Tags{“RenderType”=”Opaque”}<br>告诉了系统应该在渲染非透明物体的时调用我们。Unity定义了一系列这样的渲染过程，与RenderType是Opaque相对应的显而易见的是”RenderType”=”Transparent”，表明渲染含有透明效果的物体时调用它。在这里Tags其实暗示了你的Shader输出的是什么，如果是渲染非透明物体，那添加”Queue”=”Opaque”标签；如果渲染透明或者半透明的像素，那添加”Queue”=”Transparent”。<br>另外比较有用的标签”IgnoreProject”=”True”(不背Projectors影响)，”ForceNoShadowCasting”=”True”(从不产生阴影)以及”Queue”=”xxx”(指定渲染顺序队列)。这里想要赵忠说一下的是Queue这个标签，如果你使用Unity做过一些透明和不透明物体的混合的话，很可能已经遇到过不透明物体无法呈现在透明物体之后的情况。这种情况很可能是由于Shader的渲染顺序不正确导致的。Queue指定了物体的渲染顺序，预定义的Queue有：</p><ul><li>Background     - 最早被调用的渲染，用来渲染天空盒或者背景</li><li>Geometry         - 这是默认值，用来渲染非透明的物体（普通情况下，场景中的绝大多数物体应该是非透明的）</li><li>AlphaTest     - 用来渲染经过Alpha Test的像素，单独为AlphaTest设定一个Queue是出于对效率的考虑</li><li>Overlay         - 用来渲染效果的叠加，是渲染的最后阶段（比如镜头光晕等效果）</li></ul><p>这些预设值本质是一组整数，Background = 1000(背景), Geometry = 2000(几何体), AlphaTest = 2450(alpha测试), Transparent = 3000(透明),最后Overlay = 4000。在我们实际设置Queue值时，不仅能使用上面的几个预定义值，我们也可以指定自己的Queue值，写成类似这样：”Queue”=”Transparent+100”,表示一个在Transparent之后100的Queue上进行调用。通过调整Queue值，我们可以确保某些物体一定在另一些物体之前或者之后渲染。</p><h2 id="LOD"><a href="#LOD" class="headerlink" title="LOD"></a>LOD</h2><p>LOD很简单，它是Level of Detail的缩写，在这里例子里我们指定了其为200（其实这是Unity的内建Diffuse着色器的设定值）。这个数值决定了我们能用上面样的Shader。在Unity的Quality Settings中我们可以设定允许最大LOD，当设定的LOD小于SubShader所指定的LOD时，这个SubShader将不可用。Unity内建Shader定义了一组LOD的数值，我们在实现自己的Shader的时候可以将其作为参考来设定自己的LOD数值，这样在之后调整根据设备图形性能来调整画质时可以紧急性比较精确的控制。</p><ul><li>VertexLit及其系列 = 100</li><li>Decal,Reflective VertexLit = 150</li><li>Diffuse = 200</li><li>Diffuse Detail,Reflective Bumped Unlit,Reflective Bumped VertexLit = 250</li><li>Bumped,Specular = 300</li><li>Bumped Specular = 400</li><li>Parallax = 500</li><li>Parallax Specular = 600</li></ul><h2 id="Shader本体"><a href="#Shader本体" class="headerlink" title="Shader本体"></a>Shader本体</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CGPROGRAM</span><br><span class="line">#pragma surface surf Lambert</span><br><span class="line"></span><br><span class="line">sampler2D _MainTex;</span><br><span class="line"></span><br><span class="line">struct Input &#123;</span><br><span class="line">    float2 uv_MainTex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void surf(Input IN, inout SurfaceOutput o)&#123;</span><br><span class="line">    half4 c = tex2D(_MainTex, IN.uv_MainTex);</span><br><span class="line">    o.Albedo = c.rgb;</span><br><span class="line">    o.Alpha = c.a;</span><br><span class="line">&#125;</span><br><span class="line">ENDCG</span><br></pre></td></tr></table></figure><p>还是逐行来看，首先是CGPROGRAM。这是一个开始标记，表明从这里开始是一段CG程序（我们在写Unity的Shader时用的是Cg/HLSL语言）。最后一行的ENDCG与CGPROGRAM是对应的，表明CG程序到此结束。<br>接下来是一个编译指令：#program surface surf Lambert,它表明了我们要写一个表面Shader，并指明了光照模型。它的写法是这样的</p><pre><code>#pragma surface surfaceFunction lightModel [optionalparams]</code></pre><ul><li>surface -表明的是一个表明着色器</li><li>surfaceFunction -着色器代码的方法的名字</li><li>lightModel -使用的光照模型<br>我们声明了一个表面着色器，实际的代码在surf函数，使用Lambert(也就是普通的diffuse)作为光照模型。<br>接下来一句sampler2D MainTex,sampler2D是个啥？其实在CG中，sampler2D就是和Texture所绑定的一个数据容器接口。等等..这个说法还是太复杂了，简单理解的话，所谓加载以后的texture(贴图)说白了不过是一块内存存储的，使用了RGB(也许还有A)通道，且每个通道8bits的数据。而具体想知道像素与坐标的对应关系，以及获取这些数据，我们总不能一次次去自己计算内存地址或者偏移，因此可能通过sampler2D来对贴图进行操作。更简单理解，sampler2D就是GLSL中的2D贴图类型，相应的，还有smapler1D,sampler2D,samplerCube等等格式。<br>解释通了sampler2D是什么之后，还需要解释下为什么在这里需要一句对_MainTex的声明，之前我们不是已经在Properties里声明过它是贴图了么。答案是我们用来实力的这个shader其实是由两个相对独立的块组成的，外层的属性声明，回滚等等是Unity可以直接使用和编译的ShaderLab;而现在我们是CGPROGRAM..ENDCG这样一个代码块中，这是一段CG程序。对于这段CG程序，要想访问在Properties中所定义的变量的话，必须使用和之前变量形同的名字进行声明。于是其实sampler2D _MainTex;做的事情就是再次声明并链接了_MainTex,使接下来的CG程序能够使用这个变量。<br>解释通了sampler2D是什么之后，还需要解释为什么在这里需要一句对_MainTex的声明，之前我们不是已经在Properties里声明过它是贴图了吗。答案是我们用来实力的这个shader其实是由两个独立的快组成的，外层的属性声明，会。<br>-</li></ul><p>在CG中，函数就像C中那样声明。你可以随意的指定传递给函数的参数，以及将被函数啊发你会的值。下面是一个简单的函数声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">float getX(float3 v)</span><br><span class="line">&#123;</span><br><span class="line">    return v.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个函数采用了一个三元向量v作为一个参数，并且将v的x分量作为返回值，其类型为float。关键字return被用来返回函数的结果。你可以像调用任何其它Cg函数那样调用getX函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//声明一个临时使用的向量</span><br><span class="line">float3 myVector = float3(0.5,1.0,-1.0);</span><br><span class="line"></span><br><span class="line">//取得myVector的x分量</span><br><span class="line">float x = getX(myVector);</span><br><span class="line">//现在 x=0.5</span><br></pre></td></tr></table></figure></p><p>有些时候，你想要一个函数返回几个结果而不仅仅是一个结果。在这种情况下，你能够使用out修饰符来指定一个程序的某个特定的参数只用于输出。下面的例子用一个向量作为输入，然后返回它的x、y和z分量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void getComponents(float3 vector, out float x, out float y, out float z)</span><br><span class="line">&#123;</span><br><span class="line">    x = vector.x;</span><br><span class="line">    y = vector.y;</span><br><span class="line">    z = vector.z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意这个函数被声明为void类型，因为它通过参数来返回所有的值。下面的代码示例显示了getComponents是如何被使用的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//声明一个临时使用的向量</span><br><span class="line">float3 myVector = float3(0.5,1.0,-1.0);</span><br><span class="line"></span><br><span class="line">//声明一个临时使用的变量</span><br><span class="line">flaot x,y,z;</span><br><span class="line">//获得myVector的x、y和z分量</span><br><span class="line">getComponents(myVector, x,y,z);</span><br><span class="line">//现在x=0.5,y=1.0,z=-1.0</span><br></pre></td></tr></table></figure></p><h2 id="一个光照函数"><a href="#一个光照函数" class="headerlink" title="一个光照函数"></a>一个光照函数</h2><p>因为光照是一个复杂的过程，你能够编写许多不同类型的光照函数，每个函数都能接受不同的参数。现在，你只需要采用你实现的简单模型，并为它创建一个函数。下面是这个函数的最基本的样子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">float3 lighting(float Ke, float3 Ka, float3 Kd,float3 Ks,float shininess,float3 lightPosition,float3 lightColor,float3 globalAmbient,float3 P,float3 N,float3 eyePosition)</span><br><span class="line">&#123;</span><br><span class="line">    //在这里计算光照</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法的一个主要问题是这个函数需要很多参数。把这些参数组成“材质参数”和“光参数”，然后把每个参数集当成一个单独变量来传递，这将使得整个函数整洁许多。幸运的是Cg支持这种结构，恰好能够提供这种功能。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>Cg的结构使用与C和C++同样的方法来声明。struct关键字被用来声明结构，它后面跟随的是结构的成员。下面是一个结构的例子，它分封装了基于基本光照模型的某个材质的所有性质：</p><h3 id="Fog"><a href="#Fog" class="headerlink" title="Fog"></a>Fog</h3><p>语法:</p><ol><li>Fog {Fog Commands}</li><li>Mode Off | Global | Linear | Exp | Exp2(雾的模式，缺省值是Global)</li><li>Color ColorValue(雾的颜色)</li><li>Density FloatValue(雾的浓度，影响Exp/Exp2)</li><li>Range FloatValue,FloatValue(雾的开始和结束距离，影响Linear)</li></ol><p>注意如果使用了片段着色器的话，着色器种的雾设定仍然是有效的。另外可以通过菜单Edit-&gt;Render Settings可以打开渲染设置</p><h3 id="Alpha-Test和Alpha-Blending"><a href="#Alpha-Test和Alpha-Blending" class="headerlink" title="Alpha Test和Alpha Blending"></a>Alpha Test和Alpha Blending</h3><p>Alpha Test是不需要关闭ZWrite的。Alpha Test要么完全透明，要么完全不透明</p><p>Alpha Blending 需要关闭ZWrite，如果不关闭ZWrite，那么在进行深度检测的时候，它背后的物体本来可以被外面看到的，但由于深度检测时大于它的深度就被剔除了，从而我们就看不到它后面的物体了。因此，我们需要保证物体的渲染顺序是从后往前，并且关闭该半透明对象的ZWrite。</p><p>Appha Blending 只是关闭ZWrite，但是不会关闭ZTest。这意味着，在输出一个Alpha Blending的fragment时，它还是会判断和当前Color Buffer种的fragment的深度关闭，如果它比当前的fragement深度更远，那么它就不会再做后续的混合操作了；</p><h3 id="ColorMask"><a href="#ColorMask" class="headerlink" title="ColorMask"></a>ColorMask</h3><p>ColorMask可让我们指定渲染结果的输出通道，而不是通常情况下的RGBA这4个通道皆会被写入。可选参数是RGBA的任意组合以及0，这将意味着不会写入到任何通道，可以用来单独做一次Z Test，而不将结果写入颜色通道。</p><h3 id="Time"><a href="#Time" class="headerlink" title="_Time"></a>_Time</h3><p>_Time是个4维向量，跟Unity3D中的deltaTime（这个是一维的，数值）不同。</p><div class="table-container"><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">类型</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">_Time</td><td style="text-align:left">float4</td><td style="text-align:left">t是自该场景加载开始所经过的时间，4个分量分别是(t/20,t,t<em>2,t</em>3)</td></tr><tr><td style="text-align:left">_SinTime</td><td style="text-align:left">float4</td><td style="text-align:left">t是时间的正弦值，4个分量分别是(t/8,t/4,t/2,t)</td></tr><tr><td style="text-align:left">_CosTime</td><td style="text-align:left">float4</td><td style="text-align:left">t是时间的余弦值，4个分量分别是(t/8,t/4,t/2,t)</td></tr><tr><td style="text-align:left">unity_DeltaTime</td><td style="text-align:left">float4</td><td style="text-align:left">dt是时间增量，4个分量分别是(dt,1/dt,smoothDt,1/smoothDt)</td></tr></tbody></table></div><p>上述表格中t表示当前时间，并且只有当游戏运行的时候才要有效，但是不知道如何支持在编辑器有效，懒得研究了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器配置文件说明</title>
      <link href="/2017/10/12/servercfg/"/>
      <url>/2017/10/12/servercfg/</url>
      
        <content type="html"><![CDATA[<p><strong><em>摘要：</em></strong>本文档描述手游服务器的各个配置文件的使用和配置参数说明。<br>关键字：服务器 维护 配置</p><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><p>请先参考《游戏系统架构》以了解手游的服务器架构状况。<br>手游的所有配置文件都采用相同的格式。运维人员会经常用到的配置文件特性有：注释，文件包含include、宏定义、条件读取。</p><h1 id="2-各个服务器主要配置参数说明"><a href="#2-各个服务器主要配置参数说明" class="headerlink" title="2.各个服务器主要配置参数说明"></a>2.各个服务器主要配置参数说明</h1><h2 id="2-1-公共配置文件"><a href="#2-1-公共配置文件" class="headerlink" title="2.1 公共配置文件"></a>2.1 公共配置文件</h2><p>文件名：cmncfg.txt<br>该文件主要用来被所有的配置文件包含，可以定义一些全局性的信息（比如在不同的服务器配置信息不同的地方就可以放在这个文件里，这样不同的服务器只要修改这一个文件即可。）<br>它一般放在所有服务器程序目录的上层目录，命名为cmncfg.txt<br>典型内容如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 经常要变的部分</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 大区的ID（这个配置很重要，如果配置错误会导致所有的角色和物品ID错误，影响合服）</span></span><br><span class="line">#defene SVRGRPID 2</span><br><span class="line"><span class="comment">// 代表版本字串</span></span><br><span class="line">#define VERMAIN 0.7100</span><br><span class="line"><span class="comment">// 各类服务器IP定义</span></span><br><span class="line"><span class="comment">// 日志服务器的地址</span></span><br><span class="line">#define LOGSVR 192.168.0.49</span><br><span class="line"><span class="comment">// GMS4Chat</span></span><br><span class="line">#define GMS4CHATINNERIP 192.168.0.49</span><br><span class="line"><span class="comment">// CAAFS4CHAT</span></span><br><span class="line">#define CAAFS4CHATOUTTERIP 192.168.0.49</span><br><span class="line"><span class="comment">// GMS4Game</span></span><br><span class="line">#define GMS4GAMEINNERIP 192.168.0.49</span><br><span class="line"><span class="comment">// DBS</span></span><br><span class="line">#define DBSINNERIP 192.168.0.49</span><br><span class="line"><span class="comment">// P2PSERVER</span></span><br><span class="line">#define P2POUTTERIP 192.168.0.49</span><br><span class="line"><span class="comment">// XGMS</span></span><br><span class="line">#define XGMSINNERIP 192.168.0.49</span><br><span class="line"><span class="comment">// TTYGZS</span></span><br><span class="line">#define TTYGZSINNERIP 192.168.0.49</span><br><span class="line"><span class="comment">// XCAAFS</span></span><br><span class="line">#define XCAAFSOUTTERIP 192.168.0.49</span><br><span class="line"><span class="comment">// XCLS</span></span><br><span class="line">#define XCLSOUTERIP 192.168.0.49</span><br><span class="line"><span class="comment">// 本组配置的端口增量（主要用于在同一台机器上启动多组服务器）</span></span><br><span class="line">#define PORTSHIEF 0</span><br><span class="line"><span class="comment">// 共享内存增量</span></span><br><span class="line">#define SHMSHIFT 0</span><br><span class="line"><span class="comment">// 日志的跟路径（注意这个配置，如果在后面加上了"/"则会导致目录创建失败，因为字串中后来形成的//会被当成注释）</span></span><br><span class="line">#define LOGPATH /ITC/LOG</span><br><span class="line"><span class="comment">// 数据库相关的定义</span></span><br><span class="line">#define DB_HOST localhost</span><br><span class="line"><span class="comment">// 如果DB_HOST是localhost则需要填写这个，默认值是/tmp/mysql.sock</span></span><br><span class="line">#define DB_SOCKET /TMP/mysql.sock</span><br><span class="line">#define DB__USER root</span><br><span class="line">#define DB_PASSWORD zentiadb2017</span><br><span class="line">#define DB_CHARSET utf8</span><br><span class="line"><span class="comment">// 用户数据库</span></span><br><span class="line">#define PLAYERDB zentia0</span><br><span class="line"><span class="comment">// 全局总控相关数据库（GMS4Game使用的）</span></span><br><span class="line">#define IMSDB ims0</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 不经常变的部分</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 表面这是debug版本</span></span><br><span class="line">#define DEBUG</span><br><span class="line"><span class="comment">// 表明这是内部调试用的，可以放宽一些限制（正常运营时应该注视掉）</span></span><br><span class="line"><span class="comment">// #define INNERDEBUG</span></span><br><span class="line"><span class="comment">// 表明客户端超时不要太长（在内部测试的时候可能有用，因为有时候需要长时间不断，有时候需要正常超时断）</span></span><br><span class="line"><span class="comment">// define QUICKDROP</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 日志服务定义</span></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 日志服务的描述串（根据各个服务器需求的不同分为下面三个等级）</span></span><br><span class="line">#define LOGADDRSTR_0 0,$(LOGSVR):2000+$(PORTSHIFT), 1,$(LOGSVR):2001+$(PORTSHIFT),2,$(LOGSVR):2002+$(PORTSHIFT)</span><br><span class="line">#define LOGADDRSTR_10,$(LOGSVR):2000+$(PORTSHIFT),1,$(LOGSVR):2001+$(PORTSHIFT),2,$(LOGSVR):2002+$(PORTSHIFT),3,$(LOGSVR):2003+$(PORTSHIFT),4,$(LOGSVR):2004+$(PORTSHIFT),5.$(LOGSVR):2005+$(PORTSHIFT),6,$(LOGSVR):2006+$(PORTSHIFT)</span><br><span class="line">#define LOGADDRSTR_10,$(LOGSVR):2000+$(PORTSHIFT),1,$(LOGSVR):2001+$(PORTSHIFT),2,$(LOGSVR):2002+$(PORTSHIFT),3,$(LOGSVR):2003+$(PORTSHIFT),4,$(LOGSVR):2004+$(PORTSHIFT),5.$(LOGSVR):2005+$(PORTSHIFT),6,$(LOGSVR):2006+$(PORTSHIFT),7,$(LOGSVR):2007+$(PORTSHIFT),8,$(LOGSVR):2008+$(PORTSHIFT),9,$(LOGSVR):2009+$(PORTSHIFT),10,$(LOGSVR):2010+$(PORTSHIFT),11,$(LOGSVR):2011+$(PORTSHIFT),12.$(LOGSVR):2012+$(PORTSHIFT),13,$(LOGSVR):2013$(PORTSHIFT),14,$(LOGSVR):2014$(PORTSHIFT)</span><br><span class="line"><span class="comment">// 本大区最多支持的同时在线用户数量</span></span><br><span class="line">#define MAXPLAYER 16000</span><br><span class="line"><span class="comment">// 服务器间tcp通讯的消息缓冲设置</span></span><br><span class="line">#define MSGBUFFLEN 10*1024*1024</span><br><span class="line"><span class="comment">// debug版的文件后缀</span></span><br><span class="line">#ifdef DEBUG</span><br><span class="line">#define CFGEXT</span><br><span class="line">#else</span><br><span class="line">#define CFGEXT</span><br><span class="line">#endif</span><br><span class="line"><span class="comment">// 这个只有配置caafs4chat的时候才需要，正常的配置不需要，这个一般不变的，因为CAAFS4Chat一般就起一个即可</span></span><br><span class="line">#define CAAFS4CHATID 1</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否在GSZ宕掉之后重新拉起自动载入用户</span></span><br><span class="line">#define GZSDOWNRESTOREPLAYER true</span><br><span class="line"></span><br><span class="line"><span class="comment">// CNL网络超时（和客户端的断线超时）</span></span><br><span class="line">#ifdef INNERDEBUG</span><br><span class="line">#define DROPTIMEOUT 2000000</span><br><span class="line">#else</span><br><span class="line">#define DROPTIMEOUT 100000</span><br><span class="line">#endif</span><br><span class="line">#ifdef QUICKDROP</span><br><span class="line">#define DROPTIMEOUT 600000</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><h2 id="2-2-GMS4Game"><a href="#2-2-GMS4Game" class="headerlink" title="2.2 GMS4Game"></a>2.2 GMS4Game</h2><p>配置文件：gms4game_cfg.txt<br>典型内容如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include ../cmncfg.txt</span><br><span class="line"></span><br><span class="line">CMN</span><br><span class="line">&#123;</span><br><span class="line">    stream_size= $(MSGBUFFLEN)</span><br><span class="line">    <span class="comment">// 本地监听的地址和端口（供其他服务器连接）</span></span><br><span class="line">    tcp_listen_host = $(MYOUTERIP):<span class="number">5000</span>+$(PORTSHIFT)</span><br><span class="line">    <span class="comment">// 和其他服务器TCP连接的超时设置</span></span><br><span class="line">    keepalive_idle= <span class="number">60000</span></span><br><span class="line">    keepalive_interval= <span class="number">2000</span></span><br><span class="line">    <span class="comment">// MySQL配置</span></span><br><span class="line">    db_host = $(DB_HOST)</span><br><span class="line">    db_user = $(DB_USER)</span><br><span class="line">    db_password = $(DB_PASSWORD)</span><br><span class="line">    db_database = $(IMSDB)</span><br><span class="line">    db_charset = $(DB_CHARSET)</span><br><span class="line">    db_socket = $(DB_SOCKET)</span><br><span class="line">    <span class="comment">// 日志服务（这个只需要比较少的日志种类）</span></span><br><span class="line">    logger_addr = $(LOGADDRSTR_0)</span><br><span class="line">    <span class="comment">// szPIDFile = /tmp/GMS4Game-$(SVRGRPID).pid</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="2-3-XLBA"><a href="#2-3-XLBA" class="headerlink" title="2.3 XLBA"></a>2.3 XLBA</h1><p>配置文件：lba_cfg.txt<br>典型内容如下（基于XCMNSVR的配置）:<br>gzs_cfg1.txt<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="附录1-基于XCMNSVR的配置"><a href="#附录1-基于XCMNSVR的配置" class="headerlink" title="附录1.基于XCMNSVR的配置"></a>附录1.基于XCMNSVR的配置</h1><p>  XCMNSVR是PNGS框架中的一种标准服务器程序结构。<br>  通过该结构配置的服务器由一个主程序框架：XCMNSVR和一系列的动态连接库插件构成。<br>  其配置文件一般都是下面的样子：<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CMN</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">//</span> 用于记录日志中表示程序名和在windows下显示窗口标题栏上</span><br><span class="line">    szSvrName= 服务器名</span><br><span class="line">    <span class="string">//</span> 是否运行为后台守护进程（这个选项一般在GDB启动程序进行调试比较有用）</span><br><span class="line">    bDaemon= <span class="literal">true</span></span><br><span class="line">    <span class="string">//</span> 日志服务地址</span><br><span class="line">    szLoggerAddr= $<span class="params">(LOGADDRSTR)</span></span><br><span class="line">    <span class="string">//</span> 每个逻辑循环的最大时间（其大小会影响服务器在没有网络输入输出的情况下的逻辑tick精度）</span><br><span class="line">    nSelectInterval = 50</span><br><span class="line">&#125;</span><br><span class="line">PlugIn</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">//</span> 各个插件的载入和创建参数</span><br><span class="line">    <span class="string">//</span> 注意：插件的文件名必须是带路径的。即便是当前路径下也需要写<span class="string">"./"</span>前缀</span><br><span class="line">    DLL= 0,<span class="string">/TCPReceiver</span>$<span class="params">(CFGEXT)</span><span class="string">.so</span>,TCPReceiver_Create</span><br><span class="line">    DLL= 0,<span class="string">/TCPReceiver</span>$<span class="params">(CFGEXT)</span><span class="string">.so</span>,LBACDTest_Create</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">//</span> 后面跟着各个插件自己需要的参数配置</span><br></pre></td></tr></table></figure></p><h1 id="附录2-CNTRSVR的配置"><a href="#附录2-CNTRSVR的配置" class="headerlink" title="附录2.CNTRSVR的配置"></a>附录2.CNTRSVR的配置</h1><h1 id="附录3-GSMEM的配置"><a href="#附录3-GSMEM的配置" class="headerlink" title="附录3.GSMEM的配置"></a>附录3.GSMEM的配置</h1><h1 id="附录4-IP的允许禁止文件的配置"><a href="#附录4-IP的允许禁止文件的配置" class="headerlink" title="附录4.IP的允许禁止文件的配置"></a>附录4.IP的允许禁止文件的配置</h1>]]></content>
      
      
      
        <tags>
            
            <tag> server </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Manual</title>
      <link href="/2017/10/12/hexo/"/>
      <url>/2017/10/12/hexo/</url>
      
        <content type="html"><![CDATA[<h1 id="关闭背景动画"><a href="#关闭背景动画" class="headerlink" title="关闭背景动画"></a>关闭背景动画</h1><p>背景动画基于canvas，个人感觉比较耗，毕竟i3，所以关闭，在\themes\next_config.yml中修改字段<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">three_waves: <span class="literal">false</span></span><br></pre></td></tr></table></figure></p><h1 id="嵌入PDF"><a href="#嵌入PDF" class="headerlink" title="嵌入PDF"></a>嵌入PDF</h1><p>npm install —save hexo-pdf<br>添加</p><pre><code>hexo deploy -- 发布</code></pre><p>编辑主题的 source/css/_variables/custom.styl 文件，新增变量：<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改成你期望的宽度</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$content</span>-desktop = 700px</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当视窗超过 1600px 后的宽度</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$content</span>-desktop-large = 900px</span></span><br></pre></td></tr></table></figure></p><p>发布：</p><pre><code>hexo d -g</code></pre><h1 id="Insert-Image"><a href="#Insert-Image" class="headerlink" title="Insert Image"></a>Insert Image</h1><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="symbol">%</span> asset_img <span class="built_in">example</span>.jpg This <span class="built_in">is</span> an <span class="built_in">example</span> <span class="built_in">image</span> <span class="symbol">%</span>&#125;</span><br></pre></td></tr></table></figure><h1 id="Font"><a href="#Font" class="headerlink" title="Font"></a>Font</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">4</span> <span class="attr">color</span>=<span class="string">red</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span> # 字体大小颜色设置</span><br></pre></td></tr></table></figure><ul><li><strong>列表嵌套</strong><ul><li>上一级和下一级之间敲三个空格即可</li></ul></li></ul><p>用pass-by-refrence-to-const替换pass-by-value<br>内置类型，STL迭代器，和函数对象采用pass-by-value<br>不要返回pointer或者reference指向一个on stack对象（被析构）<br>不要返回pointer或者reference指向一个on heap对象（需要用户delete）<br>不要返回pointer或者reference指向local static对象<br>切记将成员变量声明为private<br>protected并不比public更有封装性（其实我不是很喜欢封装这个东西）<br>多一个成员函数，就多一分破坏封装性<br>若所有参数都需要类型转换，采用non-member函数（member类型转换不行吗？）</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git笔记</title>
      <link href="/2017/10/12/git-question/"/>
      <url>/2017/10/12/git-question/</url>
      
        <content type="html"><![CDATA[<h1 id="warning-LF-will-be-replaced-by-CRLF问题解决方法"><a href="#warning-LF-will-be-replaced-by-CRLF问题解决方法" class="headerlink" title="warning:LF will be replaced by CRLF问题解决方法"></a>warning:LF will be replaced by CRLF问题解决方法</h1><p>CRLF — Carriage-Return Line-Feed回车(ASCLL 13, \r)换行(LF, ASCLL 10, \n)。<br>解决方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.autocrlf <span class="literal">false</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The following untracked working tree files would be overwritten by merge</title>
      <link href="/2017/10/12/The-following-untracked/"/>
      <url>/2017/10/12/The-following-untracked/</url>
      
        <content type="html"><![CDATA[<p>git pull的时候遇到的问题。<br>解决办法：<br>git clean -d -fx<br>note:会删除没有add到仓库的文件，操作记得慎重，以免改动文件的丢失。</p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初始化云服务器</title>
      <link href="/2017/10/11/init-server/"/>
      <url>/2017/10/11/init-server/</url>
      
        <content type="html"><![CDATA[<h1 id="注册网易云"><a href="#注册网易云" class="headerlink" title="注册网易云"></a>注册网易云</h1><h1 id="创建网易云服务器"><a href="#创建网易云服务器" class="headerlink" title="创建网易云服务器"></a>创建网易云服务器</h1><h1 id="搭建git服务器"><a href="#搭建git服务器" class="headerlink" title="搭建git服务器"></a>搭建git服务器</h1><p>yum install -y git<br>adduser git //创建用户git<br>git clone git@10.173.32.7:/home/git/sample.git //克隆远程仓库</p><h1 id="clone-git仓库"><a href="#clone-git仓库" class="headerlink" title="clone git仓库"></a>clone git仓库</h1><h1 id="上传代码"><a href="#上传代码" class="headerlink" title="上传代码"></a>上传代码</h1><p>git commit -am “<message>“, 将所有修改，但未进stage的改动加入stage,并记录commit信息（某种程度上相当于git add 和 git commit -m的组合,前提是被改动文件已经是tracked)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ./ -type d -name <span class="string">"del_dir"</span> -exec rm -r &#123;&#125; \;</span><br></pre></td></tr></table></figure></message></p><p>注意中间的空格</p>]]></content>
      
      
      
        <tags>
            
            <tag> server </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity 2D描边实现介绍</title>
      <link href="/2017/10/05/2d-outline/"/>
      <url>/2017/10/05/2d-outline/</url>
      
        <content type="html"><![CDATA[<h1 id="像素着色器描边："><a href="#像素着色器描边：" class="headerlink" title="像素着色器描边："></a>像素着色器描边：</h1><p>　　首先最直观的想法，就是使用fragment shader找出2D角色贴图透明像素和非透明像素的边界，然后通过边界周边Alpha值Blur的方式，给边界上描边色。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Hidden/NewImageEffectShader&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Offset (&quot;Offset&quot;, Range(0,1)) = 0.1 // 偏移</span><br><span class="line">        _Color (&quot;Color&quot;, Color) = (1,0,0,1) // 边缘色</span><br><span class="line">        _AlphaThreshold(&quot;Alpha Threshold&quot;, Range(0,1)) = 0.5</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot;&#125;</span><br><span class="line">        Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            </span><br><span class="line">            #include &quot;UnityCG.cginc&quot;</span><br><span class="line"></span><br><span class="line">            struct appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float2 uv[5] : TEXCOORD0;</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed _Offset; // 偏移</span><br><span class="line">            fixed4 _Color; // 边缘色</span><br><span class="line">            fixed _AlphaThreshold; // Alpha 阀值</span><br><span class="line"></span><br><span class="line">            v2f vert (appdata v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv[0] = v.uv;</span><br><span class="line">                o.uv[1] = v.uv + float2(0, _Offset);// 上</span><br><span class="line">                o.uv[2] = v.uv + float2(0, -_Offset); // 下</span><br><span class="line">                o.uv[3] = v.uv + float2(-_Offset, 0); // 左</span><br><span class="line">                o.uv[4] = v.uv + float2(_Offset, 0); // 右</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                fixed4 col = tex2D(_MainTex, i.uv[0]);</span><br><span class="line">                fixed alpha = col.a;</span><br><span class="line">                fixed p1 = tex2D(_MainTex, i.uv[1]).a;</span><br><span class="line">                fixed p2 = tex2D(_MainTex, i.uv[2]).a;</span><br><span class="line">                fixed p3 = tex2D(_MainTex, i.uv[3]).a;</span><br><span class="line">                fixed p4 = tex2D(_MainTex, i.uv[4]).a;</span><br><span class="line">                alpha = (alpha + p1 + p2 + p3 + p4) / 5;</span><br><span class="line">                fixed ret = step(alpha, _AlphaThreshold);</span><br><span class="line">                col.rgb = ret * _Color.rgb + col.rgb * (1-ret);</span><br><span class="line">                return col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">"Hidden/NewImageEffectShader"</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">_Edge</span> (<span class="string">"Edge"</span>, Range(<span class="number">0</span>,<span class="number">0.5</span>)) = <span class="number">0.1</span> <span class="comment">// 边缘</span></span><br><span class="line">        <span class="variable">_EdgeColor</span> (<span class="string">"Edge Color"</span>, Color) = (<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>) <span class="comment">// 边缘色</span></span><br><span class="line">        <span class="variable">_FlowColor</span> (<span class="string">"Flow Color"</span>, Color) = (<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>) <span class="comment">// 流动色</span></span><br><span class="line">        <span class="variable">_Speed</span> (<span class="string">"Speed"</span>, Range(<span class="number">0</span>, <span class="number">2</span>)) = <span class="number">1</span> <span class="comment">// 旋转速度</span></span><br><span class="line">        <span class="variable">_MainTex</span>(<span class="string">"MainTex"</span>, <span class="number">2</span>D) = <span class="string">"white"</span> &#123;&#125; <span class="comment">// 主纹理</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123;<span class="string">"Queue"</span> = <span class="string">"Transparent"</span>&#125;</span><br><span class="line">        Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"UnityCG.cginc"</span></span></span><br><span class="line"></span><br><span class="line">            struct appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : <span class="built_in">POSITION</span>;</span><br><span class="line">                float2 uv : TEXCOORD0; <span class="comment">// 纹理uv坐标</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            sampler2D <span class="variable">_MainTex</span>;</span><br><span class="line">            float4 <span class="variable">_MainTex_ST</span>;</span><br><span class="line">            fixed <span class="variable">_Edge</span>; <span class="comment">// 边缘阀值</span></span><br><span class="line">            fixed4 <span class="variable">_EdgeColor</span>; <span class="comment">// 边缘色</span></span><br><span class="line">            fixed4 <span class="variable">_FlowColor</span>; <span class="comment">// 流动色</span></span><br><span class="line">            fixed <span class="variable">_Speed</span>; <span class="comment">// 旋转速度</span></span><br><span class="line"></span><br><span class="line">            v2f vert (appdata v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = v.uv;</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                fixed x = i.uv.x;</span><br><span class="line">                fixed y = i.uv.y;</span><br><span class="line">                <span class="keyword">if</span> (x &lt; <span class="variable">_Edge</span> || <span class="built_in">abs</span>(<span class="number">1</span> - x) &lt; <span class="variable">_Edge</span> || y &lt; <span class="variable">_Edge</span> || <span class="built_in">abs</span>(<span class="number">1</span> - y) &lt; <span class="variable">_Edge</span>) <span class="comment">// 求边缘</span></span><br><span class="line">                &#123;</span><br><span class="line">                    x -= <span class="number">0.5</span>;</span><br><span class="line">                    y -= <span class="number">0.5</span>;</span><br><span class="line">                    fixed w = <span class="variable">_Speed</span> * <span class="variable">_Time</span>.y;</span><br><span class="line">                    fixed temp = saturate(x* <span class="built_in">cos</span>(w) - y* <span class="built_in">sin</span>(w));</span><br><span class="line">                    return (temp )* <span class="variable">_EdgeColor</span> + (<span class="number">1</span>-temp)*<span class="variable">_FlowColor</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                return tex2D(<span class="variable">_MainTex</span>, i.uv);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后处理-像素着色器描边："><a href="#后处理-像素着色器描边：" class="headerlink" title="后处理+像素着色器描边："></a>后处理+像素着色器描边：</h1><p>　　于是，很自然的想到，使用Postprocessing 的方式来处理屏幕最终渲染出来的仅包含有需要描边的角色的图片，然后进行上述的fragment描边处理。<br>　　首先，在场景中添加一个专用的描边相机，Depth设为比默认相机高一级，视口大小、位置全部和默认相机一致。另外给场景物体添加一个”Outline1”layer，设置到专用相机的cullingmask，需要描边的角色的layer都设置为”Outline1”。</p><p>　　这个时候专用相机只渲染描边物体，然后给相机添加Monobehavior脚本，在OnRenderImage里对相机渲染的图像进行像素着色器的描边处理，得到如下效果：<br>　　描边效果的确是预期的效果，但是还是有两个问题：<br>　　一个是：由于我们游戏UI是使用Screen space - camera的方式，它和游戏中对象都是在默认相机渲染的，专用相机的depth比默认相机高一级，所以所有渲染内容都会在UI层次之上，这显然也不是我们想要的。<br>　　另一个是：角色的不同行动状态需要用不同的描边颜色来区分，上述方式只支持一种描边颜色。</p><h1 id="三、RenderTarget-像素着色器描边："><a href="#三、RenderTarget-像素着色器描边：" class="headerlink" title="三、RenderTarget + 像素着色器描边："></a>三、RenderTarget + 像素着色器描边：</h1><p>　　现在我们着重来解决上述两个问题：<br>第一个遮挡UI的问题：<br>　　描边效果需要在默认相机中进行z轴排序，让其渲染在UI之后，所以，我们需要让描边效果作为一个默认相机渲染的常规游戏对象放到游戏中。于是，我想到的是给它创建一个和屏幕尺寸同大小的Mesh，再将描边渲染的图片放到Mesh上，所以，做法是给专用相机分配一个屏幕尺寸同大小的RenderTarget，然后将RenderTarget渲染到创建的Mesh上。如下图所示，该Mesh在骨骼动画和相机之间创建。</p><p>第二个颜色区分的问题：<br>　　查询Unity Camera的API有两个回调接口可以用：<br>　　OnPreRender 在相机渲染场景之前被调用。<br>　　OnPostRender 在相机完成场景渲染之后被调用。<br>　　我们给专用相机添加这两个回调，<br>在OnPreRender里：<br>　　给所有需要描边的物体更换Material，该Material负责绘制该物体的状态纯颜色到RenderTarget上，并保存原有Material。<br>在OnPostRender里：<br>　　将原有Material又置换回来供默认相机正常渲染。得到的RenderTarget如下，<br>　　这个时候，再用像素着色器对应用了RenderTarget的Mesh进行描边，得到如下效果</p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pixel-and-voxel</title>
      <link href="/2017/10/05/pixel-and-voxel/"/>
      <url>/2017/10/05/pixel-and-voxel/</url>
      
        <content type="html"><![CDATA[<p>原文地址: <a href="https://medium.com/retronator-magazine/pixels-and-voxels-the-long-answer-5889ecc18190#.8gf6zy8mc" target="_blank" rel="noopener">https://medium.com/retronator-magazine/pixels-and-voxels-the-long-answer-5889ecc18190#.8gf6zy8mc</a></p><p>伪3D等轴游戏 赛达尔, Sir Carma, 2016</p><p>像素和体素，一个详细的答案<br>Retronator Stray Pixels</p><p>像素和体素的区别是什么？</p><p>我很清楚他的问题。你会在生活中看到类似像素大战电影海报这样的东西，而你会对此产生困惑。它是像素吗？还是体素？它是一只鸟？还是一架飞机？这个东西一定不简单。<br>不必害怕，我来解释这个问题。当你阅读完这篇文章后你会知道所有关于像素和体素的知识以及它们之间的联系。</p><p>首先我先介绍一点背景知识以便你更好的了解该领域的全貌。在计算机中有两种表示图像的方法：向量和栅格（raster）。</p><p>向量图像（左）的数学准确性和栅格图像（右）的离散性<br>向量图像使用各种表示直线，曲线和不同形状的数学方程描述图像。相反，栅格图像将图像描述为一个含有颜色值的数组，该数组中的颜色值依次被放置在一个网格系统中。</p><p>计算机图像学中的第二个区别在于2D和3D空间之间的差别。算上向量/栅格的区别总共有四种情况：</p><p>大家都喜欢象限！<br>向量图像<br>在2D向量图像中，直线或不同形状上的每个点都由具有两个分量（x和y）的向量来表示。这就是它被称为2D的原因（两个分量——两个维度）。</p><p>2D向量是这样表示2D向量图像中每个点的<br>以下是一张所谓的低多边形2D向量图像</p><p>伟大梦想着乌鲁鲁（Uluru the Mighty Dreamer）, Anh Tran, 2015<br>它完全使用了2D多边形（在这个情况中为三角形）。低多边形这个术语意味着制成图像所需的多边形数量相对较少。这使得三角形容易被识别出来。<br>我们加入一个维度。在3D向量图像中情况相同，但是每个向量使用了三个分量（x，y，z）。三个分量——三个维度。<br>我们看一张3D低多边形的作品。</p><p>iOS概念游戏 赛道, Timothy J. Reynolds, 2013</p><p>之前的Ayers Rock的2D图像和这里的3D跑道之间的区别在于我们可以在我们想要的任意位置看这个跑道。</p><p>iOS概念游戏 赛道 (另外视角), Timothy J. Reynolds, 2013<br>为了在你的屏幕（一个2D平面）上显示跑道，我们需要一个特定的视点（viewpoint）然后从那一点将3D几何体投影到2D中。</p><p>从3D向2D的变换叫做投影<br>这是我们得到一个特定2D图片的方法。</p><p>但是我们可以使用一个小技巧来在2D中显示3D几何体的体积特征——我们可以制作一个动画，将我们的视点设置为绕物体旋转（或者固定视点，旋转物体，如下图所示）</p><p>旅行车, Timothy J. Reynolds, 2013<br>耶！我们真的看到了3D，不需要3D眼镜！</p><p>栅格图像<br>这只是热身。向量暂告一段落，我们继续看看栅格图像如何处理2D和3D。<br>在2D栅格图像中，图片被分为若干行列的小方格，这些小方格大小相等。</p><p>Turbo Esprit Sprite, Matej ‘Retro’ Jan, 2014<br>每个单元被称作一个像素（来自图片的元素）。除了网格中的2D坐标（x，y）它的主要性质还有那个坐标的颜色。</p><p>我们已经见过低多边形向量方法如何使用易于辨认的大多边形。如果我们在栅格图像中也这样做（使用明显的大像素）我们得到了像素艺术。</p><p>Tribute (修正版), Matej ‘Retro’ Jan, 2005, 2012<br>对于2D像素图片来说，尽管它们想要表示三维物体（一个Lotus Esprit 或者一个X-wing），但是它们被直接画到了2D像素网格上。你不能像前面旋转3D向量小汽车那样旋转这张图片。同样，文章开始的那张Ayers Rock图片也不能被旋转。尽管是由多边形构成的，它们没有被放置在3D空间内，而是直接被放在2D中。</p><p>目前我们已经介绍完了2D和3D向量图像以及2D栅格图像。最后我们介绍3D栅格图像。</p><p>即将介绍激动人心的东西！<br>在3D栅格图像中，体积被均匀分到行和列中，覆盖了全部三个不同的方向（上下，左右，里外）。这样3D空间被分为许多小立方体，称为体素（体积元素或者体积像素）。每个体素由一个3D坐标和位于该坐标的颜色定义。</p><p>和像素艺术（指的是精心安排像素位置的艺术）一样，我们现在有了体素艺术，其中每个小方块都需仔细安排。</p><p>星球大战场景, Sir Carma, 2015<br>太像乐高了，你不这么认为吗？<br>注意由于我们在3D场景中，我们可以从各种方向观察体素。这是从另一个角度看Tatooine的体素。</p><p>星球大战场景 (从另一视点观测), Sir Carma, 2015</p><p>我们甚至可以做动画！这是Sir Carma的动画体素角色中的一个例子：</p><p>骑士快跑（Knight Run）, Sir Carma, 2015<br>将它和2D像素艺术角色作比较：</p><p>最后元素（Last Element）中的精灵, Glauber Kotaki, 2015<br>你可以看出在体素艺术中，动画是如何改变小方块——也就是体素——的外表（颜色）的，以及在像素艺术中颜色的改变是如何发生在小方块——像素上的。<br>现在你知道了像素和体素之间的差别（以及更多……哈哈，对于这一点很抱歉）。<br>但是还没完。瞧，我之所以解释向量/栅格，以及2D/3D是因为在现代显示设备上，每种图像类型最后都会被显示为2D栅格图片。</p><p>我们在一本像素艺术杂志中提及这个的原因是我们可以使用这类变换来创造出现代像素艺术的风格，此风格使用非像素艺术象限中的艺术资源。<br>“我可以使用体素或3D模型制作像素图像？”你觉得呢？没错就是这样！巧妙地运用着色和渲染技术可以使我们创造出独特的视觉风格，将像素艺术带入到未来。<br>向量的显示和投影<br>上面的图示并不全部正确。有一种直接显示2D向量图像的方法，它使用了一个小技巧。</p><p>一张2D向量图像只能直接显示在一个向量显示器上，和Atari的街机游戏太空射击使用的那些一样。</p><p>太空射击, Atari, 1979<br>这是它实际看上去的样子（示波器上显示的是一款类似于太空射击的游戏）</p><p>太空岩石(游戏), Autopilot, 见 Wikimedia Commons [CC BY-SA 3.0]<br>我们还可以这样显示3D向量图像（通常被称为3D模型）。<br>与之前提到的一样，3D模型首先需要被投影到两个维度上，产生一张可以显示在向量显示器上的2D向量图像。</p><p>VEC9, Andrew Reitano &amp; Todd Bailey, 2013<br>我极度推荐观看VEC9宣传片以及80年代的硬汉片：<br><a href="https://youtu.be/rSPixmsLfn4" target="_blank" rel="noopener">https://youtu.be/rSPixmsLfn4</a></p><p>VEC9, Andrew Reitano &amp; Todd Bailey, 2013</p><p>栅格化处理<br>如今你很难在博物馆以外的地方找到一个向量显示器。相反，我们使用像素进行显示！</p><p>RGB LCD, Luís Flávio Loureiro dos Santos, 见 Wikimedia Commons [CC BY 3.0]<br>一个现代LCD显示器通过开启和关闭（或半开半关）小的红绿蓝LCD（液晶显示器）创造出不同的颜色。以免你有疑问，CRT（阴极射线管）原理类似，只不过它们使用三种荧光体进行搭配以便电子束撞击的时候产生红绿蓝三种颜色。</p><p>CRT 荧光点, 见 Wikipedia [CC-SA]</p><p>那么我们该如何将一张向量图片显示在一个栅格显示器上呢？嗯，从2D向量图片到2D栅格图片，图片需要被渲染或者被栅格化处理。每个多边形（通常一个三角形）被渲染为网格中的一个像素。</p><p>使用抽样法进行栅格化处理, Making WebGL Dance的一张幻灯片, Steven Wittens, 2013</p><p>这可以被拓展到在栅格显示器上渲染3D模型。首先，3D三角形被投影为2D三角形。然后2D向量三角形被栅格化处理为像素。</p><p>星际火狐, Nintendo, 1993</p><p>三角化<br>那么体素呢？现在体素艺术使用的最常见方法是将每个体素表示为一个3D向量方块，为此我们可以创建一个沿体素方块边缘摆放三角形的3D模型</p><p>世界上最激动人心的3D模型, Matej ‘Retro’ Jan, 2016</p><p>和之前一样，3D三角形接着被投影到2D图像空间中最后被栅格化处理来显示一张2D栅格图像。</p><p>旋转的方块 (技术演示), Matej ‘Retro’ Jan, 2016<br>这是我们现在得到最常见的体素艺术风格的方法，几乎完全使用免费建模工具MagicaVoxel完成。</p><p>长发公主的塔（Rapunzel tower）, Thibault Simar, 2016</p><p>无题, Argo San, 2016</p><p>口袋妖怪的体素, Playiku, 2016</p><p>猫咪 vs 体素, Stefan Smiljkovic, 2016</p><p>战壕奔跑（Trench Run）, Gabriel de Laubier, 2015</p><p>体素气球, Gabriel de Laubier, 2015</p><p>空中追击, Sir Carma, 2015</p><p>塔拉克村庄（Talaak village）, Sir Carma, 2016</p><p>Latica悬崖, Sir Carma, 2015</p><p>光线投射<br>其实我们可以不采用立方体方法。每个体素都可以被认为是3D空间中的一个点，那个位置的一个blob（二进制大对象）体积。你可以通过在2D空间中的一个位置放置一个（或多个）像素来直接在2D空间中画出每个体素。或者相反——你可以选择屏幕中的一个像素然后找出场景中出现在那个位置的体素。</p><p>该逆向方法被称为光线投射。你可以从视点向场景内投射一束光线然后找出击中的体素。事实上，你可以射出多个射线来扫过全部的视界。</p><p>使用鱼眼矫正的简单光线投射, Kieff, 见 Wikimedia Commons [public domain]</p><p>这个技巧被首次使用在德军司令部中，其中它的体素全部是房间中的小方块，所以这只是另一种将体素作为小方块进行渲染的方法。不过它的速度很快，因为你只需将一整列的像素投射到屏幕中。这本质上是一个2D过程，也就是为什么我们有时将这类3D图像称为2.5D（某种程度上讲第三个维度是假的，因为它是沿着突出的2D平面的）。</p><p>德军司令部, id Software, 1992</p><p>不过通常我们不认为Wolfenstein使用了体素。我们必须让单元足够小并让它们有不同的高度。于是到了90年代我们有了经典体素图像引擎。</p><p>超级科曼奇, NovaLogic, 1992</p><p>一开始体素只被用于地形制作。它们必须简化物体使得全部的体积信息只有存储在2D图像（又被称为高度贴图）中的地形高度。</p><p>一个高度贴图（左）告诉我们体素的垂直高度有多少（黑代表低，白代表高）</p><p>将体素信息限制在高度贴图中意味着不能有类似于突出的悬崖的东西。但是已经很好了，地形含有的的细节数量是所有之前游戏不能企及的。</p><p>三角洲特种部队, NovaLogic, 1998</p><p>时空英豪, Appeal, 1999</p><p>体素的结束<br>光线投影不是90年代的游戏渲染体素信息所用的唯一方法。其它的方法各有优势，例如支持可以毁坏的地形或者可以渲染汽车或者人物。这些在当时都是最先进的方法了！讽刺的是，这种富有创造的多样性也预示着这项技术迎来迟暮。</p><p>万杰赛车, K-D Lab, 1998<br>问题是，直到2000年底图形加速卡诞生了。这些硬件专门处理投影和栅格化3D多边形（现在我们管这些芯片叫做图像处理单元或GPU）。它们渲染三角形的速度飞快，不过这也是它们所能做的全部工作了。自定义体素渲染算法，包括光线投射，在它们的能力之外。</p><p>Hexplore, Doki Denki Studio, 1998<br>体素引擎继续在CPU（中央处理单元）上实现，但是CPU另外还要接管剩余的工作，包括物理模拟，游戏流程和人工智能。在GPU上处理图像的主要原因是将渲染放在一张单独的芯片上完成，提高渲染速度的同时还给予了CPU更多的空间做更复杂的模拟。体素引擎跟不上多边形图像的性能所以死翘翘了……</p><p>……直到大约十年后有一款游戏将它们带到了一个新的受欢迎程度。它摒弃了旧的方法，为“将体素作为小方块”方法铺平了道路。现在这可以有效地使用GPU进行渲染而其它的皆成为历史。</p><p>我的世界, Mojang, 2009–今</p><p>定义<br>我们总结一下我们学到的内容，然后使用一点数学知识回答一开始的关于什么是像素和体素的问题。</p><p>一个像素是将2D空间分割为离散的，均匀的（大小相同的）区域时得到的最小单位。</p><p>每个像素可以使用一个两个分量均为整数的向量来表示。这是为什么像素空间是离散的，而不是像连续的向量图像那样每个坐标都是一个实数（使用浮点数表示）。</p><p>相似地，一个体素是将3D空间分割为离散的，均匀的区域时得到的最小单位。<br>这下你明白了。</p><p>我说完了吗？还没有，我还没说完。</p><p>被定义得如此宽泛，像素和体素可以以许多不同的方式出现，而我们可以创造性地将概念以各种形式表达出来。尤其，我们考虑综合了4象限的栅格/向量，2D/3D。</p><p>纯2D图像</p><p>在早些时候如果你想将2D 精灵（sprite）画到屏幕上你必须将一块储存精灵颜色的内存直接复制到另一块储存屏幕显示颜色的内存中（这个复制过程也被称为位块转换，或者叫bit BLT）。如今几乎没人单纯使用这种方法进行2D渲染了。幻想主机PICO-8作为现代的范本向过去那个位块转移作为唯一方法的时代致敬。</p><p>PICO-8, Lexallofle Games (以及各自特征小车的作者), 2014–今</p><p>3D图像中的纹理</p><p>如今大多图像引擎在基础层次使用向量，因为GPU就是这样工作的。在这个系统中使2D图像出现在屏幕上的主要方法是使用一种叫做纹理映射的方法将它们画在多边形上。</p><p>纹理是2D栅格图片，可以被放置在（或被映射到）3D多边形上。</p><p>这是大多数3D视频游戏（广泛上讲还有3D图像）在制作中所采用的最简单的方法。</p><p>例如，这是一个高多边形的3D模型，我们加入一张高分辨率的纹理：</p><p>镜之边缘：催化剂  Keyart, Per Haagensen, 2016</p><p>由于我们使用平滑的多边形着色和纹理映射我们甚至不需要那么多的三角形来创造出人物好看的外表。这是一个低多边形3D模型外加一个高分辨率的纹理。</p><p>低多边形的工匠, Mark Henriksen, 2015<br>当我们也将高分辨率纹理转换为低分辨率时，我们得到了类似于下面这个低多边形3D模型和一个像素艺术纹理：</p><p>漂移阶段, 2014–今 (正在制作中)<br>这个情况最出色的例子当然是我的世界了。尽管我的世界的块根据定义是体素（它们是游戏中最小的离散体积单位），但是它们以各种低多边形模型和像素艺术纹理代表的类型出现。尽管它们是一个个的小块，它们中的许多都不是简单的立方体。</p><p>我的世界, Mojang, 2009–今</p><p>这样所有的3D模型情况就都讲完了（高多边形3D模型和低分辨率纹理的组合并不是很常见，但是如果错了请纠正我）</p><p>镜之边缘(左上), 马克思佩恩(左下) 和我的世界 (右下)</p><p>2D图像中的纹理</p><p>回到2D！当我们将纹理投影应用到2D矩形上时，我们得到了现在常见的2D游戏。使用当今的硬件，每张2D图像（在这种情况下常被称为精灵）被放在一个由两个三角形组成的矩形中进行显示。两个三角形（加起来也被称为一个四边形）通过映射到它们上面的精灵进行渲染，使得图像出现在正确的位置。</p><p>人物图像的一部分(左) 被纹理映射到动画四边形中(右)。羽毛球, Matej ‘Retro’ Jan, 2006</p><p>高分辨率图像就很直接了……</p><p>时空幻境, Number None, 2008</p><p>地狱边境, Playdead, 2010<br>……但是低分辨率，像素艺术纹理就稍微复杂一些了。它完全取决于我们采用什么显示分辨率来渲染精灵。</p><p>时空幻境(左上), 通往天空的路(右上), 王国(右下)</p><p>我们已经见识到了可以将像素艺术纹理应用到一个低多边形3D模型上，但是仍使用高分辨率进行渲染。考虑一下我的世界。低多边形模型，低分辨率16x16像素纹理，放在一个显示分辨率为1920x1080的场景中。</p><p>我的世界, Mojang, 2009–今</p><p>同样2D多边形也可以这样做。我们使用一张像素艺术图片，将它放在一个2D四边形上，然后将它渲染到高分辨率屏幕上，这样一来源图像中的每个像素都包含了显示中的多个像素。</p><p>迈阿密热线, Dennaton Games, 2012</p><p>我们将此风格称为大像素艺术风格。每个精灵像素按照大于显示像素进行渲染，以便它在图像中作为一个大方块出现。</p><p>每个源精灵像素被渲染为3x3显示像素， 登月者, Ben Porter, 2011–今 （正在制作中)</p><p>大像素风格在精灵被旋转或倾斜时变得明显：</p><p>通往天空的路, Johannes ‘Dek’ Märtterer, 2011–今 (正在制作中)</p><p>看看上图中的树叶，然后将它和低分辨率渲染下的旋转精灵进行对比。</p><p>王国, Noio &amp; Licorice, 2015</p><p>你看到水轮的像素是如何水平/垂直排列开来的，而在通往天空的路中树叶，小鸟，和桥梁的大像素都被调整了角度和做了变换吗？</p><p>王国在低分辨率下渲染整个游戏然后只将结果图像放大（调大尺度）到显示分辨率。另一方面，通往天空的路，迈阿密热线和登月者直接将精灵渲染到高分辨率显示。</p><p>回到3D<br>王国是一款2D游戏，但是它所采用的方法也能放到3D中。</p><p>我们可以使用像素艺术纹理的3D模型，但是在低分辨率中渲染它们，我们得到如下：</p><p>像素艺术学院技术演示, Matej ‘Retro’ Jan, 2016<br>你会发现我们正确地得到了带有投射阴影的3D着色。尽管结果看上去像2D像素艺术，但它实际上是一个使用像素艺术纹理在低分辨率下进行渲染得到的3D场景。</p><p>像素艺术学院技术演示 (场景视觉), Matej ‘Retro’ Jan, 2016</p><p>基于向量（使用骨骼绑定）的动画也可以利用这个优势。这是它们在大像素风格中的样子：</p><p>动画绑定, Matej ‘Retro’ Jan, 2016</p><p>但是当在低分辨率下渲染时，它们显得更像像素艺术，排成一列的像素和上面的王国相似。</p><p>像素艺术学院动画测试, Matej ‘Retro’ Jan, 2016</p><p>这和手绘的、一帧一帧的动画相差甚远，但是具有一定的美感，让人想起了90年代的rotoscope（动态遮罩）动画。</p><p>波斯王子, Jordan Mechner, 1989</p><p>3D效果<br>回到高分辨率，一个充分利用3D优势的游戏是Odd Tales的Last Night</p><p>最后一夜（The Last Night）, Odd Tales, 2014–今 (正在制作中)</p><p>它们的美术资源本质上是2D的，但是采用所有你能想象到的现代图像效果（动态光照，全屏泛光（bloom），景深，电影级别的相机角度，反射……）展开到3D世界中。</p><p>最后一夜中的WIP场景, Tim Soret, 2016</p><p>这样他们构建了一个可以从不同角度观察的三维世界。</p><p>最后一夜中的3D场景构建, Tim Soret, 2016</p><p>另一个动态3D光照的例子是拥有优秀场景但是命运不佳的游戏致命快递。</p><p>致命快递, Maksym Pashanin, 2013–2014 (未发布)</p><p>虽然美术资源仍是2D的，但是它们还包括了从多个方向的着色的图片。这些是使用类似于Sprite Lamp这样的工具进行处理的，并且任何位置的光源都会产生精灵的平滑照明。</p><p>来自于体素的像素艺术<br>以上方法的问题在于只有精灵的着色可以准确完成，而它们投射的阴影缺少所需的3D几何因此不能正确生成。为此你还是需要体积信息。又到体素了！</p><p>这种方法一个很棒的例子是最近宣布的Pathway：</p><p>道路（Pathway）, Robotality, 2016 (正在制作中)</p><p>图像看上去完全像是在使用像素艺术精灵，但是其背后的信息却是体积的。和90年代试图看上去更现代和更现实的体素引擎不同，Robotality的开发者最多只将体素和显示像素的大小相匹配。这制造了一个巧妙的伪装，使它看上去像像素艺术，但是实际上它们拥有所有的3D信息来创造出完全正确的动态光照。</p><p>不过使用体素几何产生像素艺术并不完全是个新方法。之前FEZ使用了被其称之为三像素（3d 像素）的方法。三像素就是被综合为16x16x16方格（3d方格）的体素。</p><p>FEZ的游戏开发截图, Polytron, 2007</p><p>当一个FEZ场景在游戏中被渲染时我们基本上看到的是一个2D正交投影，这样他们既达到了传统像素艺术的外观又加入了FEZ标志性的视角旋转功能。</p><p>FEZ GDC ’09年宣传片, Polytron Corporation, 2009</p><p>FEZ, Polytron Corporation, 2012</p><p>纯体素<br>最终，由于我们绕了一大圈终于回到了体素几何上，我们可以完全不管像素，仅在3D空间中渲染纯离散体素（使用不带任何纹理的立方体方法）。</p><p>Lexallofle’s Voxatron 是这个空间内的游戏名字.</p><p>Voxatron, Lexallofle Games, 2010–今(正在制作中)</p><p>你注意到Lexallofle虚拟主机中的一个主题了吗？Pico-8有一个纯2D图像引擎而Voxatron则有一个3D体素的。它们是完美的搭档。</p><p>Voxatron, Lexallofle Games, 2010–今 (正在制作中)<br>Voxatron是少数几个（如果不是唯一的话）真正使用3D空间的纯离散分割的游戏。但是与之相似的大像素风格却应用于许多游戏中，尤其在移动设备中。</p><p>天天过马路, Hipster Whale, 2014</p><p>Shooty Skies, Mighty Games, 2016</p><p>吃豆人256, Hipster Whale, 2015<br>我们绕了一整圈回到了Sir Carma。在成为最著名的体素艺术师后，他现在在使用Unity将仅含体素的美学推向更高的高度，得到各种视觉效果，和Odd Tales对于像素艺术做出的贡献一样。</p><p>返回之路, Sir Carma, 2016 (正在制作中)</p><p>返回之路, Sir Carma, 2016 (正在制作中)<br>有人知道Voxel Zelda/Atic Atac吗?</p><p>返回之路, Sir Carma, 2016 (正在制作中)<br>好了，我们介绍了2D/3D/栅格/向量/低分辨率/高分辨所有我能想到的组合。我确定我忘记了一些内容，但是我更确定未来会有更多有趣的方法，但是目前这样就不错了。</p><p>我希望你们阅读愉快——为我们一路到尾欢呼！我希望你更深刻地了解了像素和体素图像，以及对它们下一步如何发展有了一些创造性的想法。想要更多有关像素艺术特征的信息你可以在Tumblr，Twitter，和Facebook上关注Retronator。每天都有新发现哦！<br>—Retro</p>]]></content>
      
      
      
        <tags>
            
            <tag> 渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大规模场景的资源拆分合动态加载</title>
      <link href="/2017/10/04/assetSplit-dynamicLoad/"/>
      <url>/2017/10/04/assetSplit-dynamicLoad/</url>
      
        <content type="html"><![CDATA[<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><ul><li><strong><em>资源拆分</em></strong>    <ul><li>地形，地表</li></ul></li><li><strong><em>动态加载/卸载</em></strong></li><li><strong><em>打包策略</em></strong><h1 id="资源拆分"><a href="#资源拆分" class="headerlink" title="资源拆分"></a>资源拆分</h1></li><li>地形资源拆分<ul><li>Unity原始地形有网格尺寸的限制（4096）</li><li>Mesh地形有面片数限制</li><li>降低内存占用，仅需载入部分地形数据</li><li>降低渲染面片数，视域体剔除</li><li>制作大规模地形<ul><li>Terrain Composer 2</li><li>T4M</li><li>建模软件…</li></ul></li><li>拆分现有地形<ul><li>Terrain Slicing &amp; Dynamic Loading Kit</li><li>地形数据</li></ul></li></ul></li></ul><hr><div class="table-container"><table><thead><tr><th>filed</th><th style="text-align:center">meaning</th></tr></thead><tbody><tr><td>basemapDistance</td><td style="text-align:center">Heightmap patches beyond basemap distance will use a preomputed low res basemap.</td></tr><tr><td>castShadows</td><td style="text-align:center">Should terrain cast shadows?</td></tr><tr><td>ollectDetailPatches</td><td style="text-align:center">Collect Detail patches from memory.</td></tr><tr><td>detailObjectDensity</td><td style="text-align:center">Density of detail objects.</td></tr><tr><td>detailObjectDistance</td><td style="text-align:center">Detail objets will be displayed up to this distance.</td></tr><tr><td>heightmapMaxmumLOD</td><td style="text-align:center">Lets you essentially lower the heightmap resolution used for rendering.</td></tr><tr><td>heightmapPixelError</td><td style="text-align:center">An approximation of how many pixels the terrain will pop in the worst case when switching lod.</td></tr><tr><td>lightmapindex</td><td style="text-align:center">The index of the lightmap applied to this renderer.</td></tr><tr><td>terrainData</td><td style="text-align:center">The Terrain Data that stres htightmaps,terrain textures,detail meshes and trees.</td></tr><tr><td>treeBillboardDistance</td><td style="text-align:center">Distance from the camera where trees will be rendered as billboards only.</td></tr><tr><td>terrCrossFadeLength</td><td style="text-align:center">Total distance delta that trees will use to transition from billboard orientation to to mesh orientation.</td></tr><tr><td>treeDistance</td><td style="text-align:center">The maximum distance at which trees are rendered.</td></tr><tr><td>treeMaximumFullLODCount</td><td style="text-align:center">Maximum number of trees rendered at full LOD.</td></tr></tbody></table></div><ul><li>Lightmap<ul><li>拆分后重新烘培</li><li>切分烘培好的Lightmap<ul><li>exr 格式，FreeImage</li></ul></li></ul></li><li>切割跨地形的大模型</li><li>按地形块分组<h1 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h1></li><li><p>关键在于：流畅</p><ul><li>卡顿分析</li><li>Instantiate 前自动加载未加载的引用资源<ul><li>Shader(Fallback)</li><li>Texture</li><li>Mesh</li><li>AnimationClip</li></ul></li><li>预加载资源<ul><li>Shader(Fallback)</li><li>Texture</li></ul></li><li>预加载资源异步加载<ul><li>Resources.LoadAsync</li><li>AssetBundle.LoadAsync</li></ul></li><li>实例化引起的序列化操作(Loading.LoadFileHeaders)<ul><li>避免一次性实例化过多的粒子系统（预加载）</li><li>避免层级复杂，组件Awake过多</li><li>尝试拆分Prefab，流失Instantiate</li></ul></li><li>加载策略(Assetbundle)<ul><li>Shared包常驻内存<ul><li>大纹理等资源采用LoadFromCacheOrDownload</li><li>Material/Mesh等可采用new WWW</li></ul></li></ul></li><li>卸载策略（AssetBundle）<ul><li>Prefab 包<ul><li>GameObject可通过Destroy来销毁</li><li>TerrainData,Object等可通过Resources.UnloadAsset来进行卸载</li></ul></li><li>Shared包<ul><li>建议在确认不适用或切换场景时进行卸载</li><li>切换场景时调用UnloadUnusedAssets来卸载Texture，Mesh等加载的共享资源</li></ul></li></ul></li><li>注意事项<ul><li>加载方式<ul><li>九宫格<ul><li>适用于非自由视角</li></ul></li><li>建立缓冲池，防止反复实例化。</li><li>Load vs LoadAsync</li><li>进场景预加载，推荐Load</li><li>游戏中，推荐LoadAsync</li></ul></li><li>Lightmap动态加载<ul><li>LightmapSettings</li><li>lightmapindex/lightmapScaleOffset</li><li>Shader Stripping</li></ul></li><li>Terrain动态加载<ul><li>Lightmapld</li><li>Terrain.SetNeighbors</li></ul></li><li>动态 Static Batching (StaticBatchingUtility)<ul><li>运行时CPU/堆内存开销较大</li><li>优先推荐手动拼合</li><li>推荐分组拼合</li></ul></li><li>防止资源泄露<ul><li>运行时创建<ul><li>new Material,Mesh</li><li>Material set</li></ul></li><li>AssetBundle重复加载<ul><li>共享资源<ul><li>Texture,Mesh,Font</li><li>Prefab</li></ul></li></ul></li><li>隐形资源<ul><li>TerrainData/AlphaMap<h1 id="打包策略"><a href="#打包策略" class="headerlink" title="打包策略"></a>打包策略</h1></li></ul></li></ul></li></ul></li><li><p>地形资源</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="built_in">Object</span>&gt; groundObjs = <span class="keyword">new</span> List&lt;<span class="built_in">Object</span>&gt;();</span><br><span class="line">groundObjs.AddRange(Resources.LoadAll(BundleConfig.GroundObjectsPath, <span class="keyword">typeof</span>(Texture2D)));</span><br><span class="line">groundObjs.AddRange(Resources.LoadAll(BundleConfig.GroundObjectsPath, <span class="keyword">typeof</span>(GameObject)));</span><br><span class="line"></span><br><span class="line">BuildPipeline.PushAssetDependencies();</span><br></pre></td></tr></table></figure></li><li><p>地表资源</p><ul><li>复杂资源拆分<ul><li>“流失”实例化</li></ul></li><li>按地形块分组打包</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity5.x场景优化之动态设置光照贴图lightmap</title>
      <link href="/2017/10/03/lightmap/"/>
      <url>/2017/10/03/lightmap/</url>
      
        <content type="html"><![CDATA[<p>在很多情况下，我们为了提高渲染效率，一般都会让美术同学在制作场景时，设置场景相关节点的lightmap static属性，提前给整个场景烘培出静态的光照贴图lightmap，烘培的数据保存在场景目录下的LightmapSnapshot文件中，主要包括的数据有：<br>lightmaps：烘培出的光照贴图数组；<br>gameobject uid：被烘焙的gameobject的唯一标识；<br>renderer的lightmapIndex：</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AssetBundle管理机制</title>
      <link href="/2017/10/02/ABTheory/"/>
      <url>/2017/10/02/ABTheory/</url>
      
        <content type="html"><![CDATA[<p>接上期AssetBundle打包的讲解，我们今天为大家继续探秘AssetBundle,从管理机制的角度出发，谈谈其资源加载和卸载的原理。</p><h1 id="AssetBundle加载基础"><a href="#AssetBundle加载基础" class="headerlink" title="AssetBundle加载基础"></a>AssetBundle加载基础</h1><p>通过AssetBundle加载资源，分为两步，第一步获取AssetBundle对象，第二步是通过该对象加载需要的资源。而第一步又分为两种方式，下文中将结合常用的API进行详细的描述。</p><h2 id="一-获取AssetBundle对象常用的API"><a href="#一-获取AssetBundle对象常用的API" class="headerlink" title="一 获取AssetBundle对象常用的API"></a>一 获取AssetBundle对象常用的API</h2><h3 id="（1）先获取WWW对象，在通过WWW-assetBundle获取AssetBundle对象："><a href="#（1）先获取WWW对象，在通过WWW-assetBundle获取AssetBundle对象：" class="headerlink" title="（1）先获取WWW对象，在通过WWW.assetBundle获取AssetBundle对象："></a>（1）先获取WWW对象，在通过WWW.assetBundle获取AssetBundle对象：</h3><ul><li>public WWW(string url);<br>加载Bundle文件并获取WWW对象，完成后会在内存中创建较大的WebStream(解压后的内容，通常为原Bundle文件的4~5倍大小，纹理资源比例可能更大),因此后续的AssetBundle.Load可以直接在内存中惊醒。</li><li>public static WWW LoadFromCacheOrDownload(string url, int version, uint crc = 0);<br>加载Bundle文件获取WWW对象，同时将解压形式的Bundle内容存入磁盘中作为缓存(如果该Bundle已在缓存中，则省去这一步),完成后只会在内存中创建较小的SerializedFile,而后续的AssetBundle.Load需要通过IO从磁盘中的缓存获取。</li><li>public AssetBundle assetBundle;<br>通过之前的两个接口获取WWW对象后，即可通过WWW.assetBundle获取AssetBundle对象。</li></ul><h3 id="（2）直接获取AssetBundle"><a href="#（2）直接获取AssetBundle" class="headerlink" title="（2）直接获取AssetBundle:"></a>（2）直接获取AssetBundle:</h3><ul><li>public static AssetBundle CreateFromFile(string path);<br>通过未压缩的Bundle文件，同步创建AssetBundle对象，这是最快的创建方式。创建完成后只会在内存中创建较小的SerializedFile，而后续的AssetBundle.Load需要通过IO从磁盘中过去。</li><li>public static AssetBundleCreateRequest CreateFromMemory(byte[] binary);<br>通过Bundle的二进制数据，异步创建AssetBundle对象。完成后会在内存中创建较大的WebStream。调用时，Bundle的解压时异步进行的，因此对于未压缩的Bundle文件，该接口与CreateFromMemoryImmediate等价。</li><li>public static AssetBundle CreateFromMemoryImmediate(byte[] binary);<br>该接口是CreateFromMemory的同步版本。</li><li>注：5.3下分别改名为LoadFromFile,LoadFromMemory,LoadFromMemoryAsync并增加了LoadFromFileAsync，且机制也有一定的变化，可详见Unity官方文档。</li></ul><h2 id="二·从AssetBundle加载资源的常用API"><a href="#二·从AssetBundle加载资源的常用API" class="headerlink" title="二·从AssetBundle加载资源的常用API"></a>二·从AssetBundle加载资源的常用API</h2><ul><li>public ObjectLoad(string name, Type type);<br>通过给定的名字和资源类型，加载资源。加载时会自动在家其依赖的资源，即Load一个Prefab时，会自动Load其引用的Texture资源。</li><li>public Object[] LoadAll(Type type);<br>一次性加载Bundle中给定资源类型的所有资源。</li><li><p>public AssetBundleRequest LoadAsync(string name, Type type);该接口是Load的异步版本。</p></li><li><p>注：5.x下分别改名为LoadAsset,LoadAllAssets,LoadAssetAsync，并增加了LoadAllAssetsAsync。</p></li></ul><h1 id="AssetBundle加载进阶"><a href="#AssetBundle加载进阶" class="headerlink" title="AssetBundle加载进阶"></a>AssetBundle加载进阶</h1><h2 id="一·接口对比：new-WWW与WWW-LoadFromCacheOrDownload"><a href="#一·接口对比：new-WWW与WWW-LoadFromCacheOrDownload" class="headerlink" title="一·接口对比：new WWW与WWW.LoadFromCacheOrDownload"></a>一·接口对比：new WWW与WWW.LoadFromCacheOrDownload</h2><h3 id="1-前者的优势"><a href="#1-前者的优势" class="headerlink" title="(1)前者的优势"></a>(1)前者的优势</h3><ul><li>后续的Load操作在内存中进行，相比后者的IO操作开销更小；</li><li>不形成缓存文件，而后者则需要额外的磁盘空间存放缓存；</li><li>能通过WWW.texture,WWWW.bytes,WWW.audioClip等接口直接加载外部资源，而后者只能用于加载AssetBundle</li></ul><h3 id="2-前者的劣势"><a href="#2-前者的劣势" class="headerlink" title="(2)前者的劣势"></a>(2)前者的劣势</h3><ul><li>每次加载涉及到解压操作，而后者在第二次加载时就省去了解压的开销；</li><li>在内存中会有较大的WebStream,而后者在内存中只有通常较小的SerializedFile。（此项为一般情况，但并不绝对，对于序列化信息较多的Prefab,很可能出现SerializedFile比WebStream更大的情况）</li></ul><h2 id="二·内存分析"><a href="#二·内存分析" class="headerlink" title="二·内存分析"></a>二·内存分析</h2><p><img src="/2017/10/02/ABTheory/memoryprofile.png"></p><p>在管理AssetBundle时，了解其加载过程中对内存的影响意义重大。在上图中，我们在中间列出了AssetBundle加载资源后，内存中各类物件的分布图，在左侧则列出了每一类内存的产生所涉及到的加载API:</p><ul><li>WWW对象：在第一步的方式1中产生，内存开销小；</li><li>WebStream:在使用new WWW或CreateFromMemory时产生内存开销通常较大；</li><li>SerializedFile:在第一步中两种方式都会产生，内存开销通常较小；</li><li>AssetBundle对象：在第一步中两种方式都会产生，内存开销小；</li><li>资源（包括Prefab）：在第二步中通过Instantiate产生，内存开销通常较小。</li><li>场景物件（GameObject):在第二步中通过Instantiate产生，内存开销通常较小。<br>在后续的章节中，我们还将针对该图中各类内存物件分析其卸载方式，从而避免内存残留甚至泄露。</li></ul><h2 id="三·注意点"><a href="#三·注意点" class="headerlink" title="三·注意点"></a>三·注意点</h2><ul><li>CreateFromFile只能适用于未压缩的AssetBundle,而Android系统下StreamingAssets是在压缩目录(.jar)中，因此需要先将未压缩的AssetBundle放到SD卡中国才能对其使用CreateFromFile。</li><li>iOS系统有256个开启文件的上限，因此，内存中通过CreateFromFile或WWW.LoadFromCacheOrDownload加载的AssetBundle对象也会低于该值，在较新的版本中，如果LoadFromCacheOrDownload超过上限，则会自动改为new WWW的形式加载，而焦躁的版本中则会加载失败。</li><li>CreateFromFile和WWW.LoadFromCacheOrDownload的调用会增加ResistenManager.Remapper的大小，而PersistentManager负责维护资源的持久化存储，Remapper保存的是加载到内存的资源HeapID与源数据FileID的映射关系，它是一个MemoryPool,其行为类似Mono堆内存，只增不减，因此需要对两个接口的使用做合理的规划。</li><li>对于存在依赖关系的Bundle包，在加载时主要注意顺序，举例来说，假设CanvasA在BundleA中，所依赖的AtlasB在BundleB中，为了确保资源正确引用，那么最晚创建BundleB的AssetBundle对象的时间点是在实例化CanvasA之前，即，创建BundleA的AssetBundle对象时，Load(“CanvasA”)时，BundleB的AssetBundle对象都可以不在内存中。<br><img src="/2017/10/02/ABTheory/dependbundle.png"></li><li>根据经验，建议AssetBundle文件的大小不超过1MB，因为在普遍情况下Bundle的加载时间与其大小并非呈线性关系，过大的Bundle可能引起较大的加载开销。</li><li>由于WWW对象的加载是异步的，因此逐个加载容易出现下图中CPU空间的情况（选中帧处Vsync占了大部分）此时建议适当的同时加载多个对象，以增加CPU的使用率，同时加快加载的完成。<br><img src="/2017/10/02/ABTheory/dependbundle.png"></li></ul><h1 id="AssetBundle卸载"><a href="#AssetBundle卸载" class="headerlink" title="AssetBundle卸载"></a>AssetBundle卸载</h1><p>前文提到了通过AssetBundle加载资源时的内存分配情况，下面，我们结合常用的API介绍如何将已分配的内存进行卸载，最终达到清空所有相关内存的目的。</p><h2 id="一·内存分析"><a href="#一·内存分析" class="headerlink" title="一·内存分析"></a>一·内存分析</h2><p><img src="/2017/10/02/ABTheory/dependbundle.png"></p><p>在上图中的右侧，我们列出了各种内存物件的卸载方式：</p><ul><li>场景物件(GameObject):这类物件可通过Destroy函数进行卸载；</li><li>资源(包括Prefab):除了Prefab以外，资源文件可以通过三种方式来卸载<br>1）通过Resources.UnloadAsset卸载指定的资源，CPU开销小；<br>2）通过Resources.UnloadUnusedAssets一次性卸载所有未被引用的资源，CPU开销大；<br>3）通过Resources.Unload(true)在卸载AssetBundle对象时，将加载出来的资源一起卸载。<br>而对于Prefab,目前仅能通过DestroyImmediate来卸载，且卸载后，必须重新加载AssetBundle才能重新加载该Prefab。由于内存开销较小，通常不建议进行针对性的卸载。</li><li>WWW对象：调用对象的Dispose函数或将其置为null即可；</li><li>WebStream:在卸载WWW对象以及对应的AssetBundle对象后，这部分内存即会被引擎自动卸载；</li><li>SerializedFile:卸载AssetBundle后，这部分内存会被引擎自动卸载;</li><li>AssetBundle对象：AssetBundle的卸载方式有两种：<br>1）通过AssetBundle.Unload(false),卸载AssetBundle对象时保留内存中已加载的资源；<br>2)通过AssetBundle.Unload(true),卸载AssetBundle对象时卸载内存中已加载的资源，由于该方法容易引起资源引用丢失，因此并不建议经常使用；<h2 id="二·注意点"><a href="#二·注意点" class="headerlink" title="二·注意点"></a>二·注意点</h2>在通过AssetBundle.Unload(false)卸载AssetBundle对象后，如果重新创建该对象并加载之前加载过的资源的时候，会出现冗余，即两份相同的资源。</li></ul><p>被脚本静态变量引用的资源，在调用Resources.UnloadUnusedAssets时，并不会被卸载，在Profiler中能够看到其引用情况。</p><h1 id="UWA推荐方案"><a href="#UWA推荐方案" class="headerlink" title="UWA推荐方案"></a>UWA推荐方案</h1><p>通过以上的讲解，相信您对AssetBundle的加载和卸载有了明确的了解。下面，我们简单地做一下API选择上的推荐：</p><ul><li>对于需要常驻内存的Bundle文件来说，优先考虑减少内存占用，因此对于存放非Prefab资源（特别是纹理）的Bundle文件，可以考虑使用WWW.LoadFromCacheOrDownload或AssetBundle.CreateFromFile加载，从而避免WebStream常驻内存；而对于存放较多Prefab资源的Bundle，则考虑使用new WWW加载，因为这类Bundle用WWWW.LoadFromCacheOrDownload加载时产生的SerializedFile可能会比new WWW产生的WebStream更大。</li><li>对于加载完后即卸载的Bundle文件，则分两种情况：优先考虑速度（加载场景时）和优先考虑流畅度（游戏进行时）。<br>1）加载场景的情况下，需要注意的是避免WWW对象的逐个加载导致的CPU空间，可以考虑使用加载速度较快的WWW.LoadFromCacheOrDownload或AssetBundle.CreateFromFile，但需要避免后续大量地进行Load资源的操作，引起IO开销（可以尝试直接LoadAll）。<br>2）游戏进行的情况下，则需要避免使用同步操作引起卡顿，因此可以考虑使用new WWW配合AssetBundle.LoadAsync来进行平滑的资源加载，但需要注意的是，对于Shader，较大的Texture等资源，其初始化操作通常很耗时，容易引起卡顿，因此建议将这类资源在加载场景时进行预加载。</li><li>只在Bundle需要加密的情况下，考虑使用CreateFromMemory，因为该接口加载速度较慢。</li><li>尽量避免在游戏进行中调用Resources.UnloadUnusedAssets(),因为该接口开销较大，容易引起卡顿，可尝试使用Resources.Unload(obj)来逐个进行卸载，以保证游戏的流畅度。</li></ul><p><strong>需要说明的是，以上内存管理交适合于Unity5.3之前的版本。Unity引擎在5.3中对AssetBundle的内存占用进行了一定的调整，目前我们也在进一步的学习和研究中。</strong></p><p>以上即为我们这次为您带来的AssetBundle管理机制，希望对您的项目研发有所帮助。我们会在后续技术文章通过大量的案例来进一步解释AssetBundle的管理机制，敬请关注。</p><p>原文链接：<a href="https://blog.uwa4d.com/archives/ABTheory.html" target="_blank" rel="noopener">https://blog.uwa4d.com/archives/ABTheory.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AI</title>
      <link href="/2017/09/29/AI/"/>
      <url>/2017/09/29/AI/</url>
      
        <content type="html"><![CDATA[<p>Unity正朝着AI的方向潜心探索着。本文是Unity发布的首篇AI相关文章，为大家介绍AI的一些概念及术语，详细介绍机器学习相关理论与方法，并讲解在使用Unity开发游戏的过程中如何应用AI。未来我们还将为大家分享更多AI的内容。</p><h1 id="ML（机器学习）与AI-人工智能）"><a href="#ML（机器学习）与AI-人工智能）" class="headerlink" title="ML（机器学习）与AI(人工智能）"></a>ML（机器学习）与AI(人工智能）</h1><p>首先来介绍下Machine Learning(机器学习，下文简称ML）和游戏Artificial Intelligence(人工智能，下文简称AI）间的关系。现存的大部分游戏AI都是手工源码，由大量决策树组成，有时会包含多达数千条规则。而且必须由手工维护和测试。而ML所依赖的算法可以自动从原始数据寻找规律，无需专家预先定义数据的解读方式。</p><p>以图片内容分类这个计算机视觉问题为例。直到几年前，专家们仍然通过手工编写过滤器，提取图像的有用特征，用于分辨某个图像中包含的是猫还是狗。而ML，特别是i最新的深度学习方法，仅需图像和类型标签，就可以自动学习有用的特征。我们相信这种自动化学习不仅可以扩展Unity平台的应用范围，例如用于ML场景模拟，还可以帮助所有开发者简化和加速游戏的开发过程。</p><p>这种自动化学习尤其可以应用于游戏代理（即NPC）的行为方面。我们可以使用Reinforcement Learning(增强学习，简称RL）来训练代理，预估某一环境中施行特定行为的价值。一旦训练完成，代理即可以最佳行为模式做出反应，无需通过程序对行为进行显示的编码。</p><h1 id="采用老虎机算法的增强学习"><a href="#采用老虎机算法的增强学习" class="headerlink" title="采用老虎机算法的增强学习"></a>采用老虎机算法的增强学习</h1><p>RL背后的一个核心概念是价值估计，并据此进行相应动作。在继续深入之前，最好先了解一些术语。</p><p>在RL中，实施动作的个体被称为agent(代理),它使用policy(策略)进行动作决策。一个代理通常嵌入一个environment中，并在任意给定的时刻都处于某个特定的state(状态).从哪个状态，它可以进行一系列actions(动作）。某个给定状态的value(值)指的是处于该状态的最终回报价值。在某个状态的value(值)指的是处于该状态的最终回报值。在某个状态执行一个动作可以让代理进入另一个新的状态，获得一个reward(回报),或者同事拥有两者。所有的RL代理都在尽可能最大化累计回报。</p><p>&lt;img = /2017/09/30/AI/“&gt;</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Real-Time Rendering 3rd</title>
      <link href="/2017/09/29/Real-Time-Rendering-3rd/"/>
      <url>/2017/09/29/Real-Time-Rendering-3rd/</url>
      
        <content type="html"><![CDATA[<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p><img src="/2017/09/29/Real-Time-Rendering-3rd/overview.png" alt="overview"><br>url: www.realtimerendering.com</p><h1 id="The-Graphics-Rendering-Pipeline"><a href="#The-Graphics-Rendering-Pipeline" class="headerlink" title="The Graphics Rendering Pipeline"></a>The Graphics Rendering Pipeline</h1><p><img src="/2017/09/29/Real-Time-Rendering-3rd/tgrp.png"></p><h2 id="核心内容分节提炼"><a href="#核心内容分节提炼" class="headerlink" title="核心内容分节提炼"></a>核心内容分节提炼</h2><h3 id="图像渲染管线架构概述-Architecture"><a href="#图像渲染管线架构概述-Architecture" class="headerlink" title="图像渲染管线架构概述 Architecture"></a>图像渲染管线架构概述 Architecture</h3><p>渲染管线的主要功能就是决定在给虚拟相机，三维物体，光源，照明模式，以及纹理等诸多条件的情况下，生成或绘制一幅二维图像的过程。对于实时渲染来说，渲染管线就是基础。因此，我们可以说，渲染管线是实时渲染的底层工具。</p><p><img src="/2017/09/29/Real-Time-Rendering-3rd/viewport.png"><br>上图，相机放在棱锥的顶端（四条线段的交汇点），只有可视体内部的图元会被渲染。<br>在概念上可以将图形渲染管线分为三个阶段：</p><ul><li>应用程序阶段（The Application Stage)</li><li>几何阶段(The Geometry Stage)</li><li>光栅化阶段(The Rasterizer Stage)<br>如下图：<br><img src="/2017/09/29/Real-Time-Rendering-3rd/pipeline.png"><br>原书图2.2绘制管线的基本结构包括3个阶段：应用程序，几何，光栅化。</li></ul><p>几个要点：<br>-每个阶段本身也可能是一条管线，如图中的几何阶段所示。此外，还可以对有的阶段进行全部或者部分的并行化处理，如图中的光栅化阶段。应用程序阶段虽然是一个单独的过程，但是依然可以对之进行管线化或者并行化处理。<br>-最慢的管线阶段决定绘制速度，即图像的更新速度，这种速度一般用FPS表示，也就是帧率。</p><h3 id="应用程序阶段The-Application-Stage"><a href="#应用程序阶段The-Application-Stage" class="headerlink" title="应用程序阶段The Application Stage"></a>应用程序阶段The Application Stage</h3><p>-应用程序阶段一般是图形渲染管线概念上的第一个阶段。应用程序阶段是通过软件方式来实现的阶段，开发者能够对该阶段发生的情况进行完全控制，可以通过改变实现方法来改变实际性能。其他阶段，他们全部或者部分建立在硬件的基础上，因此要改变实现过程会非常困难。<br>-正因应用程序阶段是软件方式实现，因此不能像集合和光栅化阶段那样继续分为诺干个子阶段。但为了提高性能，该阶段还是可以在几个并行处理器上同时执行。在CPU设计商，称这种形式为超标量体系(superscalar)结构，因为它可以在同一个阶段同一个时间做不同的几件事情。<br>-应用程序阶段通常实现的方法有碰撞检测，加速算法，输入检测，动画，力反馈以及纹理动画，变化仿真，几何变形，以及一些不在其他阶段执行的计算，如层次堆裁剪等加速算法就可以在这里实现。<br>-应用程序阶段的主要任务：在应用程序阶段的末端，将需要在屏幕(具体形式取决于具体输入设备)显示出来绘制的几何体(也就是绘制图元,rendering primitives,如点，线，矩形等)输入到绘制管线的下一个阶段。<br>-对于被渲染的每一帧，应用程序阶段将摄像机位置，光照和模型的图元输出到管线的下一个主要阶段-几何阶段。</p><h3 id="几何阶段-The-Geometry-Stage"><a href="#几何阶段-The-Geometry-Stage" class="headerlink" title="几何阶段 The Geometry Stage"></a>几何阶段 The Geometry Stage</h3><p>几何阶段主要负责大部分多边形操作和顶点操作。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity-Weather</title>
      <link href="/2017/09/26/Unity-Weather/"/>
      <url>/2017/09/26/Unity-Weather/</url>
      
        <content type="html"><![CDATA[<p>抄：<a href="https://zhuanlan.zhihu.com/p/29668925" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29668925</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>UE3的3D渲染流水线处理流程</title>
      <link href="/2017/09/24/3%E7%9A%843D%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/"/>
      <url>/2017/09/24/3%E7%9A%843D%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>本文要给大家讲述的是UE3的3D渲染流水线的处理流程，让开发者知道UE3引擎在3D流水线各个阶段的工作内容，这样在开发的过程中才能更好的去使用3D渲染流水线。</p><h1 id="什么是渲染-Rendering"><a href="#什么是渲染-Rendering" class="headerlink" title="什么是渲染(Rendering)"></a>什么是渲染(Rendering)</h1><p>渲染简单的理解可能这样：就是将三维物体或三维场景的描述转化为一张2D图像,生成的2D图像能很好展示3D对象或场景。</p><h1 id="什么是流水线？"><a href="#什么是流水线？" class="headerlink" title="什么是流水线？"></a>什么是流水线？</h1><p>3D渲染流水线也类似一个工厂的流水线，它的原材料是一系列的3D网格数据，最终产品就是显示在2D屏幕的3D场景。<br>3D渲染流水线的处理和照相机的原理很像，它们都同样是通过将3D世界的内容放置到2D平面上，通过2D的方式来展示3D世界，<br>顶点管线中有这么几个坐标空间：局部空间-&gt;世界空间-&gt;相机空间-&gt;投影空间-&gt;屏幕空间(视口空间),初始的网格数据是在局部空间中的，顶点管线将其从局部空间变换到屏幕空间作为输入供”像素管线”处理。比如局部空间内，一个人物的骨骼模型，它的中心点就是根骨骼的位置，在进行骨骼层次计算的时候，根谷歌放在中心位置是易于计算的，如果将其放置到世界空间中进行骨骼计算，那么根骨骼的位置不在原点且朝向也不为0，计算起来相当复杂。而世界空间中，易于描述场景中各个物体间的关系，易于作碰撞处理，伤害计算，顶点光照计算等。在相机空间中，容易描述被观察物体与观察者之间的关系，利用相机视锥体对物体进行裁剪，把观察不到的物体剔除掉。</p><p>坐标空间转换及推倒这种内容涉及到相当多的几何学，线性代数等内容。</p><p>VertexShader—顶点着色器是用来替换这个阶段中固定管线的定点变换及光照计算的，传统管线处理顶点及光照的方式都是固定流程的，所以固定管线下的3D程序特效都有很大的局限性，引入顶点着色器之后，顶点在空间中的变换以及光照处理都可以可编程化了。顶点着色器主要是用来改变顶点固定流程中的变换过程，所以使用顶点着色器表现出来的大多是几何外形的变化以及顶点的光照，纹理等数据的变化。</p><p>在UE3中，是不能直接编写Shader语言的，UE3中把所有的Shader特效都绑定到材质中，只能通过材质编辑器来间接的编辑顶点着色器和像素着色器内容。UE3中修改顶点着色器的方式也是在材质编辑器中进行的，其中比较典型的一个输入节点叫做WorldPositionOffset，它就是在顶点管道阶段对材质对应的网络物体顶点进行编辑的一个节点，对应到底层是修改了该材质对应的顶点着色器代码(通过HLSL按钮能够看到该材质对应的Shader代码</p><h2 id="8-9-10步骤"><a href="#8-9-10步骤" class="headerlink" title="8,9,10步骤"></a>8,9,10步骤</h2><p>这三个步骤统称为像素管道，主要是对步骤7输入的光栅化像素进行操作的阶段。</p><p>这个阶段会逐像素地处理该像素的纹理映射，光照颜色，alpha融合，深度测试，模板测试等，并且根据该像素的距离信息进行雾化公式的应用，所以，顾名思义，像素管道主要处理的是像素信息，最终输出像素最终的颜色。</p><p>传统的3D管线只能通过有限几个图形API接口来操作像素，比如DX中设置多纹理的一些接口以及Alpha融合的接口，能够操作的范围很有限。</p><p>像素着色器所替换固定流水线的功能就是在这个阶段，在引入像素着色器之后，就可以根据需要对像素做许多自由的处理，因为帧缓存内的像素信息不止包含该像素的颜色、Alpha值、深度信息和模版信息，还可以包含该像素对应的法线贴图信息、高光贴图信息、凹凸贴图信息等（这些贴图实际上保存的是一系列向量信息），通过传入一定的参数，比如时间信息、物理量等，就能制作出各种贴近现实的精美特效。</p><p>UE3中的像素着色器也是通过材质编辑器中的表达式来处理的，UE3材质编辑器中的大部分输入节点都是用于处理像素着色的，如图所示</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>UGUI vs NGUI</title>
      <link href="/2017/09/24/UGUIvsNGUI/"/>
      <url>/2017/09/24/UGUIvsNGUI/</url>
      
        <content type="html"><![CDATA[<div class="table-container"><table><thead><tr><th>Tables</th><th style="text-align:center">NGUI</th><th style="text-align:right">UGUI</th></tr></thead><tbody><tr><td>锚点</td><td style="text-align:center">Anchor</td><td style="text-align:right">RectTransform Anchor</td></tr><tr><td>图片</td><td style="text-align:center">Sprite</td><td style="text-align:right">Image</td></tr><tr><td>文字</td><td style="text-align:center">Label</td><td style="text-align:right">Text</td></tr><tr><td>根节点</td><td style="text-align:center">UIRoot</td><td style="text-align:right">Canvas</td></tr><tr><td>UI面板</td><td style="text-align:center">Panel</td><td style="text-align:right">Canvas</td></tr><tr><td>UI容器</td><td style="text-align:center">Lets you essentially lower the heightmap resolution used for rendering.</td></tr><tr><td>heightmapPixelError</td><td style="text-align:center">An approximation of how many pixels the terrain will pop in the worst case when switching lod.</td></tr><tr><td>lightmapindex</td><td style="text-align:center">The index of the lightmap applied to this renderer.</td></tr><tr><td>terrainData</td><td style="text-align:center">The Terrain Data that stres htightmaps,terrain textures,detail meshes and trees.</td></tr><tr><td>treeBillboardDistance</td><td style="text-align:center">Distance from the camera where trees will be rendered as billboards only.</td></tr><tr><td>terrCrossFadeLength</td><td style="text-align:center">Total distance delta that trees will use to transition from billboard orientation to to mesh orientation.</td></tr><tr><td>treeDistance</td><td style="text-align:center">The maximum distance at which trees are rendered.</td></tr><tr><td>treeMaximumFullLODCount</td><td style="text-align:center">Maximum number of trees rendered at full LOD.</td></tr></tbody></table></div><h1 id="UGUI"><a href="#UGUI" class="headerlink" title="UGUI"></a>UGUI</h1><img src="/2017/09/24/UGUIvsNGUI/1.jpg"><p>上图是UIWidget，UIGeometry和UIDrawCall的关系图<br>UIPanel用来收集和管理它下面所有的widget的组件。通过widget的geometry创建实际的draw call。没有panel所有东西都不能被渲染出来。可以把UIPanel当作Renderer。</p><p>每一个UIWidget都有一个UIGeometry，但是并不都有一个UIDrawCall，而是要通过Batch合并达到减少DrawCall的数量。<br>所有Panel都有一个Depth值，会影响所有它包含的widget。Panel的depth权重要高于widget的depth权重，但是低于render queue。</p><p>当勾选static的时候，该panel下面所有的widget都不会被移动，这样可以提高性能。此时，NGUI会忽略所有的position/rotation/scale改变。所以在运行时移动widget不会有效。</p><h3 id="UIDrawCall"><a href="#UIDrawCall" class="headerlink" title="UIDrawCall"></a>UIDrawCall</h3><p>1.成员变量<br>a) List<uidrawcall> mActiveList和mInactiveList，mActiveList保持当前激活的UIDrawCall，mInactiveList主要是用于回收UIDrawCall.Destroy()的UIDrawCall，以达到循环利用避免内存的反复申请和释放，减少GC的次数。<br>b) Material mMaterial和mDynamicMat，mMaterial是图集的Material，mDynamicMat是实际采用的Material，因为UIPanel的Clipping有AlphaClip和SoftClip这两个是要通过切换Shader实现的，所以需要对应动态创建一个Material，这个就是mDynamicMat的存在。<br>c) bool mRebuildMat和isDirty，这两者表示UIDrawCall所处的状态，当改变UIDrawCall的Material和Shader，mRebuildMat就变成true，就会引起RebuildMaterial()的调用。isDirty若为true，表示UIDrawCall要进行重写“填充”，调用Set函数。</uidrawcall></p><p>负责将uv、顶点、color等信息输入到mesh中，继而绘制图形。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpdateGeometry</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mFilter == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mFilter = gameObject.AddComponent&lt;MeshFilter&gt;();</span><br><span class="line">        mMesh = <span class="keyword">new</span> Mesh();</span><br><span class="line">        mTriangles = (verts.size &gt;&gt; <span class="number">2</span>);</span><br><span class="line">        mMesh.verticess = verts.buffer;</span><br><span class="line">        mMesh.uv = uvs.buffer;</span><br><span class="line">        mFilter.mesh = mMesh;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mRenderer == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mRenderer = gameObject.AddComponent&lt;MeshRenderer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    UpdateMaterial();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上所有的buffer都是用BetterList来存储的。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpdateMaterial</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDynamicMat == <span class="literal">null</span> || mRebuildMat || mClipCount != panel.clipCount)</span><br><span class="line">    &#123;</span><br><span class="line">        RebuildMaterial();</span><br><span class="line">        mRebuildMat = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mSharedMat != mDynamicMat)</span><br><span class="line">    &#123;</span><br><span class="line">        mSharedMaterials = <span class="keyword">new</span> Material[]&#123;mDynamicMat&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RebuildMaterial</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CreateMaterial();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化DrawCall<br>使用相同material的连续UIWidget(UILbale,UISprite)共用一个UIDrawCall。对UIWidget.list进行排序，使得相同的material的UIWidget在UIWidget.list相连，而UIWidget.list是根据UIWidget的depth进行排序。（但是这样不会改变渲染顺序吗？）<br>1) 修改UIWidget(UILabel,UISprite)的depth，限定好UIWidget.list的排序<br>2) 重写UIWidget的CompareFunc方法。<br>夹层问题</p><h3 id="UIRoot"><a href="#UIRoot" class="headerlink" title="UIRoot"></a>UIRoot</h3><p>UIRoot的作用是缩放UI</p><p>PixelPerfect        保持原分辨率<br>FiexedSize          根据比例缩放<br>FixedSizeOnMobile   PC保持原分辨率，Mobile缩放</p><h3 id="UICamera"><a href="#UICamera" class="headerlink" title="UICamera"></a>UICamera</h3><p> 带有这个组件渲染出来的物体可以接受NGUI事件</p><h3 id="UIPanel"><a href="#UIPanel" class="headerlink" title="UIPanel"></a>UIPanel</h3><p>Panel的集合，一个Panel中包含多个Widget，负责更新会决定何时绘制Widget。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">public</span> List&lt;UIPanel&gt; list = <span class="keyword">new</span> List&lt;UIPanel&gt;();</span><br><span class="line"><span class="keyword">public</span> RenderQueue renderQueue = RenderQueue.Automatic; <span class="comment">//渲染次序类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> startingRenderQueue = <span class="number">3000</span>;</span><br><span class="line"><span class="keyword">public</span> List&lt;UIWidget&gt; widgets = <span class="keyword">new</span> List&lt;UIWidget&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;UIDrawCall&gt; drawcalls = <span class="keyword">new</span> List&lt;UIDrawCall&gt;();</span><br><span class="line"><span class="keyword">int</span> mDepth = <span class="number">0</span>; <span class="comment">// 深度</span></span><br><span class="line"><span class="keyword">int</span> mSortingOrder; <span class="comment">// 队列排序值</span></span><br><span class="line"><span class="keyword">bool</span> mRebuild = <span class="literal">false</span>;<span class="comment">//如果为true，需要重构所有的Drawcall，Panel中的OnEnable、RemoveWidget、AddWidget等和改变depth会将该值设置为true。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LateUpdate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mUpdateFrame != Time.frameCount)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2017/09/24/UGUIvsNGUI/2.jpg" title="LateUpdate调用图">]]></content>
      
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏对象和脚本</title>
      <link href="/2017/09/20/%E6%B8%B8%E6%88%8F%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%84%9A%E6%9C%AC/"/>
      <url>/2017/09/20/%E6%B8%B8%E6%88%8F%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p>原文：<a href="http://catlikecoding.com/unity/tutorials/basics/game-objects-and-scripts/" target="_blank" rel="noopener">http://catlikecoding.com/unity/tutorials/basics/game-objects-and-scripts/</a></p><ul><li>用简单的脚本构建一个时钟</li><li>用C#写脚本</li><li>让时钟转动起来</li><li>完成</li></ul><p>这边文章通过创建简单的组件脚本来实现一个时钟。您仅需几分钟来熟悉Unity编辑器，如果您已经熟悉此部分，可以跳过本篇文章。<br><img src="/2017/09/20/游戏对象和脚本/tutorial-image.jpg" alt="是时候创建一个时钟啦"></p><h1 id="构建一个简单的时钟"><a href="#构建一个简单的时钟" class="headerlink" title="构建一个简单的时钟"></a>构建一个简单的时钟</h1><p>打开Unity创建一个3D对象，你不需要任何额外的资源包.<br><img src="/2017/09/20/游戏对象和脚本/default-layout.png" alt="默认的窗口布局"></p><h2 id="1-1-创建一个游戏对象"><a href="#1-1-创建一个游戏对象" class="headerlink" title="1.1 创建一个游戏对象"></a>1.1 创建一个游戏对象</h2><p>默认的场景包含两个游戏对象，他们在层次窗口中而且你能看到他们的图标在场景窗口中，第一个是主相机，它是用来渲染的，第二个是方向光，照明场景的。<br>使用GameObject-&gt;Create Empty 选项，也可以选择层级窗口添加一个新的对象在scene上。</p><p><img src="/2017/09/20/游戏对象和脚本/hierarchy.png" alt="层次窗口的时钟对象"></p><p>监视窗口(Inspector window)展示游戏对象的细节，当选择时钟对象的时候，Inspector会展示他的name和一些额外的属性,默认为可用，非静态，没有标签属于一个默认的层。并且展示了所有的组件，transform组件是一定有的。</p><p><img src="/2017/09/20/游戏对象和脚本/inspector.png" alt="clock对象的Inspector"><br>transform组件包括位置，旋转和缩放在3D空间，确保position和rotation是0，scale是1（这里指的都是本地坐标)</p><h2 id="1-2-创建一个时钟"><a href="#1-2-创建一个时钟" class="headerlink" title="1.2 创建一个时钟"></a>1.2 创建一个时钟</h2><p>虽然我们有了clock object,但是我们什么也做不了,我们还得创建3D模型来渲染，Unity包含一些原始的对象，用这些我们能构建一个简单的时钟，s首先添加一个cylinder(圆柱Gameobject-&gt;3D Object-&gt;Cylinder)<br><img src="/2017/09/20/游戏对象和脚本/cylinder.png" alt><br><img src="/2017/09/20/游戏对象和脚本/cylinder-inspector.png" alt></p><p>圆柱体有一个Mesh Filter包含一个圆柱体的mesh，第二个是Capsule Collider(胶囊碰撞体)用来搞物理的，第三是Mesh Renderer确保可以得到渲染的，也用来控制用那个材质来渲染，最后一个就是材质(Material).</p><p>虽然对象是一个圆柱体，但是它用了capsule collider,因为unity没有原生的cylinder collider,我们不需要它，干掉！如果你不需要物理的话，你可以选择Mesh Collider 组件,组件能被干掉。</p><p>为了搞一个时钟的脸，我们必须把这玩意搞平，缩减scale的y值，</p><p><img src="/2017/09/20/游戏对象和脚本/cylinder-scaled-scene.png" alt></p><p>将圆柱体的名字改为Face,表示clock的脸,<br><img src="/2017/09/20/游戏对象和脚本/child-object.png" alt></p><h2 id="1-3-创建时钟刻度"><a href="#1-3-创建时钟刻度" class="headerlink" title="1.3 创建时钟刻度"></a>1.3 创建时钟刻度</h2><p>时钟有一圈刻度来告诉你现在几点了。<br>添加一个立方体对象通过Gameobject-&gt;3D Object-&gt;Cube,改变缩放(0.5,0.2,1)<br>刻度是难以看到的，因为他和表盘的颜色相同，让我们通过材质来区分吧，Assets-&gt;Create-&gt;Material，或者Proect Window都可以的，这个材质是复制默认的材质的，</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity渲染1 材质</title>
      <link href="/2017/09/20/Unity%E6%B8%B2%E6%9F%931-%E6%9D%90%E8%B4%A8/"/>
      <url>/2017/09/20/Unity%E6%B8%B2%E6%9F%931-%E6%9D%90%E8%B4%A8/</url>
      
        <content type="html"><![CDATA[<p>PS：翻译Catlike的文章</p><ul><li>创建一个立方体格子</li><li>支持缩放，位移，旋转</li><li>创建简单的相机投影</li></ul><p>这是关于渲染的第一篇文章，</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>scene和prefab的区别</title>
      <link href="/2017/09/17/article-title/"/>
      <url>/2017/09/17/article-title/</url>
      
        <content type="html"><![CDATA[<p>如果一个场景有多个相同的pfb(指引用相同的pfb，具体每个pfb可能有参数不同），那么Scene里每个pfb都是独立的对象，加载时每个对象都要走全套的流程: 文件I/O -&gt;反序列化 (解析，new obj + ctor) -&gt; awake -&gt; shader\texture\vbo create\upload，如果走pfb+Instantiate，那么前面的流程(文件I/O，反序列化）只用走一遍，直接Instantiate复制内存中现有的对象就行.<br>另外pfb可以在合适的时候提前异步预加载，这样切场景的时候就更快了（场景也可以异步预加载，不过awake\upload to gpu这些必须在主线程做，所以会卡一下），pfb也便于做细粒度的热更. 但pfb对美术日常调整场景不友好，除非有个一键生成场景+一键存pfb.<br>单论切换速度，什么都比不过预加载 + 大内存永驻</p><h1 id="网易云搭建云服务器"><a href="#网易云搭建云服务器" class="headerlink" title="网易云搭建云服务器"></a>网易云搭建云服务器</h1><p>ssh -i zentia -l root 10.173.32.4<br>例子: ssh -l sy 192.168.3.6<br>Password:(QQ微云中保存)<br>-i 表示私钥<br>-l 表示登录帐号后跟着内网IP<br>连内网IP需要配置OpenVPN，网上可以下载<br><a href="https://www.163yun.com/help/documents/56817419033956352" target="_blank" rel="noopener">https://www.163yun.com/help/documents/56817419033956352</a> 这是网易的文档，都有</p><h1 id="SVN服务器搭建"><a href="#SVN服务器搭建" class="headerlink" title="SVN服务器搭建"></a>SVN服务器搭建</h1><p>项目研发期间暂时用SVN管理服务器，等上线之后在考虑其它的思路。<br>CentOS<br>1.yum install subversion<br>2.创建svn版本目录: mkdir -p /var/svn/svnrepos<br>3.创建版本库: svnadmin create /var/svn/svnrepos<br>4.cd /var/svn/svnrepos/conf (authz文件是权限控制文件;passwd是帐号密码文件;svnserve.conf SVN服务器配置文件)<br>5.设置帐号密码<br>    vi passwd<br>    在[users]块中添加用户和密码，格式：帐号=密码，如zentia=zentia<br>6.设置权限<br>vi authz<br>在末尾添加如下代码<br>[/]<br>zentia=rw<br>liyanfeng=r<br>意思是版本库的根目录zentia对其有读写权限，liyanfeng只有读权限。<br>7.修改svnserve.conf文件<br>打开下面几个注释：<br>anon-access=read #匿名用户可读<br>auth-access = write #授权用户可写<br>password-db = passwd #使用哪个文件作为帐号文件<br>authz-db = authz #使用哪个文件作为权限文件<br>realm = /var/svn/svnrepos #认证空间名，版本库所在目录<br>8.启动svn版本库<br>svnserve -d -r /var/svn/svnrepos<br>ps aux | grep svnserve #查看服务是否启动</p><h1 id="SVN客户端搭建"><a href="#SVN客户端搭建" class="headerlink" title="SVN客户端搭建"></a>SVN客户端搭建</h1><p>1.修改host文件<br>    10.173.32.4 zentiasvr</p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
